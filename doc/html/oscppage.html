<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OSCLib: Open Surgical Communication Protocol</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OSCLib
   &#160;<span id="projectnumber">2.0 beta</span>
   </div>
   <div id="projectbrief">Open Surgical Communication Library (OR.NET prototype)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('oscppage.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Open Surgical Communication Protocol </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#oscpstartup">Framework startup and shutdown</a></li>
<li class="level1"><a href="#oscpoverview">Overview</a><ul><li class="level2"><a href="#oscp_mbid">The MDIB structure</a></li>
</ul>
</li>
<li class="level1"><a href="#oscp_provider">The EndoTAIX OSCP Provider example</a><ul><li class="level2"><a href="#oscp_provider_basics_descriptive">Implementation - The descriptive part</a></li>
<li class="level2"><a href="#oscp_provider_basics_dynamic">Implementation - The dynamic part</a></li>
<li class="level2"><a href="#oscp_provider_start">Implementation - Start the provider</a></li>
</ul>
</li>
<li class="level1"><a href="#oscp_consumer">The EndoTAIX OSCP Consumer example</a><ul><li class="level2"><a href="#oscp_consumer_servicemanager">Discovery using the ServiceManager</a></li>
<li class="level2"><a href="#oscp_consumer_events">Using the consumer - reception of events</a></li>
<li class="level2"><a href="#oscp_consumer_request_commit">Using the consumer - Request and commit states</a><ul><li class="level3"><a href="#oscp_consumer_request_commit_async">Handling async commits</a></li>
</ul>
</li>
<li class="level2"><a href="#oscp_consumer_close">Disconnecting the consumer</a></li>
</ul>
</li>
<li class="level1"><a href="#oscp_alarm_system">The alarm system</a><ul><li class="level2"><a href="#oscp_alarm_system_provide">The provider</a></li>
<li class="level2"><a href="#oscp_alarm_system_consumer">The consumer</a></li>
</ul>
</li>
<li class="level1"><a href="#oscp_code_snippets">Useful code snippets and recipes</a><ul><li class="level2"><a href="#oscp_streaming">Streaming</a></li>
<li class="level2"><a href="#oscp_activation">Custom commands using activations</a></li>
<li class="level2"><a href="#oscp_contexts">Using contexts</a></li>
<li class="level2"><a href="#oscp_stringenums">Using string enums</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="oscpstartup"></a>
Framework startup and shutdown</h1>
<p>On both consumer and provider side, the library needs to be initialized before use: </p><div class="fragment"><div class="line"><span class="comment">// Include common library headers</span></div><div class="line"><span class="preprocessor">#include &quot;OSCL.h&quot;</span></div><div class="line"><span class="comment">// Start framework</span></div><div class="line">OSCLibrary::getInstance().startup();</div><div class="line"><span class="comment">// Optional (override ip autobinding): choose a network adapter by providing an IP address for new socket connections</span></div><div class="line">OSCLibrary::getInstance().setBindInterface(<span class="stringliteral">&quot;192.168.1.1&quot;</span>);</div><div class="line"><span class="comment">// Optional (override default port start): choose a global port start number used for bindings</span></div><div class="line">OSCLibrary::getInstance().setPortStart(<span class="stringliteral">&quot;2011&quot;</span>);</div><div class="line"><span class="comment">// Do something</span></div><div class="line">...</div><div class="line"></div><div class="line">OSCLibrary::getInstance()-&gt;shutdown();</div></div><!-- fragment --><p>Please make sure to explicitly shutdown the library and all high level object such as consumers and providers. When calling the <b>OSCLibrary::getInstance()-&gt;shutdown()</b> all internal memory of the library is freed completely and immediately. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Startup library and init consumer and provider</span></div><div class="line">  OSCLibrary::getInstance().startup();</div><div class="line"></div><div class="line">  <span class="comment">// Do something</span></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="comment">// Shutdown library</span></div><div class="line">  OSCLibrary::getInstance().shutdown();</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="oscpoverview"></a>
Overview</h1>
<p>The API for the Open Surgical Communication Protocol (OSCP-API) is set on top of DPWS. It was created by the OR.NET data model working group and is based on the DIN EN ISO 11073-10201 information model. The resulting OR.NET data model is called CDM (Communication Data Model).</p>
<p>There are two main instances used for communication:</p>
<ul>
<li>
<b><a class="el" href="class_o_s_c_lib_1_1_data_1_1_o_s_c_p_1_1_o_s_c_p_provider.html">OSCLib::Data::OSCP::OSCPProvider</a></b>: describes the device, and converts OSCP-conform requests into (proprietary) device commands </li>
<li>
<b><a class="el" href="class_o_s_c_lib_1_1_data_1_1_o_s_c_p_1_1_o_s_c_p_consumer.html">OSCLib::Data::OSCP::OSCPConsumer</a></b>: a client tool used to establish communication with an OSCPProvider </li>
</ul>
<p>Both instances implement a base set of methods defined by a common interface. This interface allows transparent access to the medical device information base (MDIB) which can be regarded as the database that contains the values defined by the CDM. </p>
<p>In order to integrate a medical device (or a medical information service) into an OSCP Network (i.e. writing an <b>OSCP-Connector</b>), you'll first have to implement an instance of OSCPProvider. The following sections describe this process using a simple example of implementing an OSCP-Connector for the EndoTAIX holding device system, a camera holding device for endoscopy.</p>
<p>Working examples similar to this one can be found in the "Examples" folder, especially in <b>ExampleProject.cpp</b>. The unit tests <b>TestSimpleOSCP.cpp</b> and <b>TestStreamOSCP.cpp</b> might also help to illustrate the OSCP API.</p>
<h2><a class="anchor" id="oscp_mbid"></a>
The MDIB structure</h2>
<p>The MDIB structure is used to exchange information between the OSCPProvider and OSCPConsumer instances. The class structure behind it can be used to describe a medical device or a medical service statically and dynamically. The following (simplified) structure is used for the MDIB:</p>
<ul>
<li>
<b>MDIB</b>: the information base holding all static and dynamic sub-structures. Class-name: <a class="el" href="class_o_s_c_lib_1_1_data_1_1_o_s_c_p_1_1_m_d_i_b_container.html">OSCLib::Data::OSCP::MDIBContainer</a> <ul>
<li>
<b>Medical Device Description</b>: Describes the static part. Class-name: <a class="el" href="class_o_s_c_lib_1_1_data_1_1_o_s_c_p_1_1_m_d_description.html">OSCLib::Data::OSCP::MDDescription</a> <ul>
<li>
<b>Hydra Medical Device System</b>: Describes the complete device or service. Class-name: <a class="el" href="class_o_s_c_lib_1_1_data_1_1_o_s_c_p_1_1_hydra_m_d_s_descriptor.html">OSCLib::Data::OSCP::HydraMDSDescriptor</a> <ul>
<li>
<b>Virtual Medical Device</b>: Describes a subsystem (e.g. a hardware- or software-modul). Class-name: <a class="el" href="class_o_s_c_lib_1_1_data_1_1_o_s_c_p_1_1_v_m_d_descriptor.html">OSCLib::Data::OSCP::VMDDescriptor</a> <ul>
<li>
<b>Channel</b>: Describes a group of metrics. Class-name: <a class="el" href="class_o_s_c_lib_1_1_data_1_1_o_s_c_p_1_1_channel_descriptor.html">OSCLib::Data::OSCP::ChannelDescriptor</a> <ul>
<li>
<b>Metric</b>: Describes a primitive or complex data object (e.g. heart rate measurement). Sub-classes of: OSCLib::Data::OSCP::AbstractMetricDescriptor </li>
<li>
<b>Context</b>: Describes a specifix context (e.g. location of patient demographics). Sub-classes of: OSCLib::Data::OSCP::AbstractContextDescriptor </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<b>Medical Devices States</b>: Containes the dynamic part. Class-name: <a class="el" href="class_o_s_c_lib_1_1_data_1_1_o_s_c_p_1_1_m_d_state.html">OSCLib::Data::OSCP::MDState</a> <ul>
<li>
<b>Metric State</b>: Describes the state of a references metric (e.g. current heart rate value). Sub-classes of: OSCLib::Data::OSCP::AbstractMetricState (e.g. NumericMetricState, StringMetricState, etc.) </li>
<li>
<b>Context State</b>: Describes the state of a specific context (e.g. patient demographics data). Sub-classes of: OSCLib::Data::OSCP::AbstractContextState </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Alert systems can be inserted at the level of the hydra MDS, the VMD or channel. They will be described later in detail.</p>
<h1><a class="anchor" id="oscp_provider"></a>
The EndoTAIX OSCP Provider example</h1>
<p>This section provides a simplified example for an OSCPProvider instance for the EndoTAIX holding device system. The <b>OSCPHoldingDeviceProvider</b> class extends the <b><a class="el" href="class_o_s_c_lib_1_1_data_1_1_o_s_c_p_1_1_o_s_c_p_provider.html">OSCLib::Data::OSCP::OSCPProvider</a></b> class. However, it is not required to subclass OSCPProvider. Instead, you can also use an instance as a member variable in another class. </p>
<p>Using <b>OSCProvider::addMDStateHandler</b> is a comfortable way to provide separate handlers for each state. This has the advantage, that code concerning devices's data will be encapsulated elsewhere. This will keep our class (OSCPHoldingDeviceProvider) short.</p>
<p>In this example, the provider contains two metrics, which describe their purpose and properties: One for current weight (currentWeightMetric, read-only), which is measured using a force-torque-sensor attached to the arm. The other one defines the maximum weight limit (maxWeightMetric, read-write). Each metric also needs a corresponding <b>metric state</b> which contains the actual value.</p>
<p>Each metric state will be represented by a separate handler, which subclasses <b>OSCPProviderMDStateHandler</b>.</p>
<h2><a class="anchor" id="oscp_provider_basics_descriptive"></a>
Implementation - The descriptive part</h2>
<p>The implementation of the provider's descriptive part can be structured as followed.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>OSCPHoldingDeviceProvider : <span class="keyword">public</span> OSCPProvider {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  OSCPHoldingDeviceProvider() { ... }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> ~OSCPHoldingDeviceProvider() { }</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">private:</div><div class="line">  <span class="comment">// The current weight</span></div><div class="line">  NumericMetricDescriptor currentWeightMetric;</div><div class="line">  </div><div class="line">  <span class="comment">// Maximum weight</span></div><div class="line">  NumericMetricDescriptor maxWeightMetric;</div><div class="line">  </div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>First, the descriptors have to be filled with proper definitions for our example device. For convenience, we do this in the constructor of our OSCPHoldingDeviceProvider. However this is not a strict requirement.</p>
<p>The most important thing about initializing the metrics is that each metric needs a unique string identifier called "handle", which we define here. You are totally free to chose the handles, as long as they are unique within your device. It is also valid to generate them randomly.</p>
<div class="fragment"><div class="line">OSCPHoldingDeviceProvider() {</div><div class="line">  setEndpointReference(<span class="stringliteral">&quot;EPR_12345&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Define semantic meaning of weight unit &quot;kg&quot;, which will be used for defining the</span></div><div class="line">  <span class="comment">// current weight and the max weight below.</span></div><div class="line">  CodedValue unit;</div><div class="line">  unit.setCodeId(<span class="stringliteral">&quot;MDCX_CODE_ID_KG&quot;</span>)</div><div class="line">    .setCodingSystemId(<span class="stringliteral">&quot;OR.NET.Codings&quot;</span>)</div><div class="line">    .addConceptDescription(LocalizedText().<span class="keyword">set</span>(<span class="stringliteral">&quot;Weight in kg&quot;</span>));</div><div class="line"></div><div class="line">  <span class="comment">// Setup metric descriptors</span></div><div class="line">  <span class="comment">// define properties of current weight metric</span></div><div class="line">  currentWeightMetric</div><div class="line">    .setMetricCategory(MetricCategory::MEASUREMENT)</div><div class="line">    .setAvailability(MetricAvailability::CONTINUOUS)</div><div class="line">    .setUnit(unit)</div><div class="line">    .setType(</div><div class="line">      CodedValue()</div><div class="line">        .setCodeId(<span class="stringliteral">&quot;MDCX_CODE_ID_WEIGHT&quot;</span>)</div><div class="line">        .addConceptDescription(LocalizedText().<span class="keyword">set</span>(<span class="stringliteral">&quot;Current weight&quot;</span>)))</div><div class="line">     .setHandle(<span class="stringliteral">&quot;handle_cur&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Define properties of max weight metric</span></div><div class="line">  maxWeightMetric</div><div class="line">    .setMetricCategory(MetricCategory::SETTING)</div><div class="line">    .setAvailability(MetricAvailability::CONTINUOUS)</div><div class="line">    .setUnit(unit)</div><div class="line">    .setType(</div><div class="line">      CodedValue()</div><div class="line">        .addConceptDescription(LocalizedText().<span class="keyword">set</span>(<span class="stringliteral">&quot;Maximum weight&quot;</span>)))</div><div class="line">    .setHandle(<span class="stringliteral">&quot;handle_max&quot;</span>);</div><div class="line"></div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>The above code shows the usage of <b>method chaining</b>, which eases the definitions of descriptors.</p>
<p>The description (containing the hydra MDS) will be constructed <b>bottom-up</b>. It describes the structure of our device and uses the definitions of our metrics: Each metric must be added to a channel instance, the channel instance to the virtual medical device instance and that one finally to the medical device system instance.</p>
<p><b>Important:</b> To make the maximum value state writeable (<b>onStateChangeRequest</b> implemented), a set operation descriptor must be added using <b>createSetOperationForDescriptor</b>!</p>
<div class="fragment"><div class="line">OSCPHoldingDeviceProvider() {</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="comment">// Channel</span></div><div class="line">  ChannelDescriptor holdingDeviceChannel;</div><div class="line">  holdingDeviceChannel</div><div class="line">    <span class="comment">// Add metrics to channel</span></div><div class="line">    .addMetric(currentWeightMetric)</div><div class="line">    .addMetric(maxWeightMetric)</div><div class="line">        .setIntendedUse(IntendedUse::MEDICAL_A);</div><div class="line"></div><div class="line">  <span class="comment">// VMD</span></div><div class="line">  VMDDescriptor holdingDeviceModule;</div><div class="line">  holdingDeviceModule.addChannel(holdingDeviceChannel);</div><div class="line"></div><div class="line">  <span class="comment">// Hydra MDS</span></div><div class="line">  HydraMDSDescriptor holdingDeviceSystem;</div><div class="line">  holdingDeviceSystem</div><div class="line">    .setHandle(MDS_HANDLE)</div><div class="line">    .setMetaData(</div><div class="line">      SystemMetaData()</div><div class="line">        .setUDI(<span class="stringliteral">&quot;UDI_12345&quot;</span>)</div><div class="line">        .addManufacturer(</div><div class="line">          LocalizedText()</div><div class="line">          .<span class="keyword">set</span>(<span class="stringliteral">&quot;SurgiTAIX AG&quot;</span>))</div><div class="line">        .addModelName(</div><div class="line">          LocalizedText()</div><div class="line">          .<span class="keyword">set</span>(<span class="stringliteral">&quot;EndoTAIX&quot;</span>))</div><div class="line">        .addModelNumber(<span class="stringliteral">&quot;1&quot;</span>)</div><div class="line">        .addSerialNumber(<span class="stringliteral">&quot;1234&quot;</span>)</div><div class="line">      )</div><div class="line">    <span class="comment">// Add VMD to MDS</span></div><div class="line">    .addVMD(holdingDeviceModule)</div><div class="line">    .setType(</div><div class="line">      CodedValue()</div><div class="line">        .setCodingSystemId(<span class="stringliteral">&quot;OR.NET.Codings&quot;</span>)</div><div class="line">            .setCodeId(<span class="stringliteral">&quot;MDCX_CODE_ID_MDS&quot;</span>));</div><div class="line"></div><div class="line">  <span class="comment">// Create SET operation for max value</span></div><div class="line">  createSetOperationForDescriptor(maxWeightMetric, holdingDeviceSystem);</div><div class="line">  </div><div class="line">  <span class="comment">// Add MDS to provider</span></div><div class="line">  addHydraMDS(holdingDeviceSystem);</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="oscp_provider_basics_dynamic"></a>
Implementation - The dynamic part</h2>
<p>For the dynamic part, we have to implement handlers of a subtype of <b>OSCPProviderMDStateHandler</b> (e.g. <b>OSCPProviderNumericMetricStateHandler</b>) where each handler takes care of a single state, as already mentioned before. It defines the initial state at startup. The handler may then call the <b>updateState</b> method at any time to tell the framework about a state (value) change (e.g. if the real devices state changes). The internal MDIB will then be updated.</p>
<p>If the state is writable (SETTING), the handler has to provide at least a type-specific implementation of <b>onStateChangeRequest</b> for a specific type (e.g. NumericMetricState or StringMetricState) which processes incoming change requests for our metric state.</p>
<p>Each state must refer to the descriptor's state handle. If multiple states refer to the same descriptor, each state must furthermore have its own state handle. Otherwise this is optional.</p>
<div class="fragment"><div class="line"><span class="comment">// READ-ONLY state handler</span></div><div class="line"><span class="keyword">class </span>CurValueStateHandler : <span class="keyword">public</span> OSCPProviderNumericMetricStateHandler {</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  CurValueStateHandler() {</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// onStateChangeRequest not implemented (state is read-only - MEASUREMENT)</span></div><div class="line"></div><div class="line">  <span class="comment">// Helper method</span></div><div class="line">  NumericMetricState createState(<span class="keywordtype">float</span> value) {</div><div class="line">    NumericMetricState result;</div><div class="line">    result</div><div class="line">     .setObservedValue(NumericMetricValue().setValue(value))</div><div class="line">     .setComponentActivationState(ComponentActivation::ON)</div><div class="line">     .setDescriptorHandle(<span class="stringliteral">&quot;handle_cur&quot;</span>);</div><div class="line">    <span class="keywordflow">return</span> result;</div><div class="line">  }</div><div class="line"></div><div class="line">  NumericMetricState getInitialState()<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordflow">return</span> createState(0);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setNumericValue(<span class="keywordtype">float</span> value) {</div><div class="line">    NumericMetricState currentWeightState = createState(value);</div><div class="line">    <span class="comment">// Call update function (this will update internal MDIB and increase MDIB version number)</span></div><div class="line">    updateState(currentWeightState);</div><div class="line">  }</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>The handler for the max value state:</p>
<div class="fragment"><div class="line"><span class="comment">// READ-WRITE state handler</span></div><div class="line"><span class="keyword">class </span>MaxValueStateHandler : <span class="keyword">public</span> OSCPProviderNumericMetricStateHandler {</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  MaxValueStateHandler() {</div><div class="line">  }</div><div class="line"></div><div class="line">  InvocationState onStateChangeRequest(<span class="keyword">const</span> NumericMetricState &amp; state, <span class="keyword">const</span> OperationInvocationContext &amp; oic)<span class="keyword"> override </span>{</div><div class="line">    <span class="comment">// Invocation has been fired as WAITING when entering this method</span></div><div class="line">        DebugOut(DebugOut::Default, <span class="stringliteral">&quot;SimpleOSCP&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;Provider: MaxValueStateHandler received state change request&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        notifyOperationInvoked(oic, InvocationState::STARTED);</div><div class="line"></div><div class="line">    <span class="comment">// we can update here, but if we return FINISHED, the framework will also update</span></div><div class="line">    <span class="comment">//updateState(state);</span></div><div class="line"></div><div class="line">    <span class="comment">// Usually, update the real device&#39;s state here.</span></div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> InvocationState::FINISHED;  <span class="comment">// Framework will update internal MDIB with the state&#39;s value and increase MDIB version</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Helper method</span></div><div class="line">  NumericMetricState createState() {</div><div class="line">    NumericMetricState result;</div><div class="line">    result</div><div class="line">      .setObservedValue(NumericMetricValue().setValue(2.0))</div><div class="line">      .setComponentActivationState(ComponentActivation::ON)</div><div class="line">      .setDescriptorHandle(<span class="stringliteral">&quot;handle_max&quot;</span>)</div><div class="line">      .setHandle(<span class="stringliteral">&quot;handle_max_state&quot;</span>);</div><div class="line">      <span class="keywordflow">return</span> result;</div><div class="line">    }</div><div class="line"></div><div class="line">    NumericMetricState getInitialState()<span class="keyword"> override </span>{</div><div class="line">      NumericMetricState result = createState();</div><div class="line">      <span class="keywordflow">return</span> result;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Convenience value getter</span></div><div class="line">    <span class="keywordtype">float</span> getMaxWeight() {</div><div class="line">      NumericMetricState result;</div><div class="line">      <span class="comment">// TODO: in real applications, check if findState returns true!</span></div><div class="line">      getParentProvider().getMDState().findState(<span class="stringliteral">&quot;handle_max&quot;</span>, result);</div><div class="line">      <span class="comment">// TODO: in real applications, check if state has an observed value and if the observed value has a value!</span></div><div class="line">      <span class="keywordflow">return</span> (<span class="keywordtype">float</span>)result.getObservedValue().getValue();</div><div class="line">    }</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>We extend the constructor's code to add the handlers, which we define as members of the holding device provider class.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>OSCPHoldingDeviceProvider : <span class="keyword">public</span> OSCPProvider {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  OSCPHoldingDeviceProvider() {</div><div class="line">  </div><div class="line">    ...</div><div class="line">  </div><div class="line">    <span class="comment">// Add state handler&#39;s</span></div><div class="line">    addMDStateHandler(&amp;maxValueState);</div><div class="line">    addMDStateHandler(&amp;curValueState);</div><div class="line">  </div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="comment">// Current weight</span></div><div class="line">  NumericMetricDescriptor currentWeightMetric;</div><div class="line">  <span class="comment">// State handler</span></div><div class="line">  CurValueStateHandler curValueState;</div><div class="line">  </div><div class="line">  <span class="comment">// Maximum weight</span></div><div class="line">  NumericMetricDescriptor maxWeightMetric;</div><div class="line">  <span class="comment">// State handler</span></div><div class="line">  MaxValueStateHandler maxValueState;</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="oscp_provider_start"></a>
Implementation - Start the provider</h2>
<p>Starting the provider can be done by calling the method <b>startup</b>. The periodic update thread can be launched by calling <b>start</b>. The provider can be stopped by calling shutdown: </p><div class="fragment"><div class="line"><span class="comment">// Start framework</span></div><div class="line">OSCLibrary::getInstance()-&gt;startup();</div><div class="line"></div><div class="line"><span class="comment">// The OSCP Provider instance</span></div><div class="line">{ </div><div class="line">  OSCPHoldingDeviceProvider provider;</div><div class="line">  <span class="comment">// Start provider</span></div><div class="line">  provider.startup();  </div><div class="line">  ...</div><div class="line"></div><div class="line">  provider.shutdown();</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="oscp_consumer"></a>
The EndoTAIX OSCP Consumer example</h1>
<p>An OSCPConsumer instance is always connected to exactly one OSCPProvider instance. OSCPConsumer instances can be retrieved via the ServiceManager by using its connection and discovery methods.</p>
<h2><a class="anchor" id="oscp_consumer_servicemanager"></a>
Discovery using the ServiceManager</h2>
<p>An OSCPConsumer instance cannot be instantiated directly. The only component that can produce these instances is the ServiceManager (<b>OSCLib::Data::OSCP::OSCPServiceManager</b>). The ServiceManager is resposibe for the discovery of OSCPProvider instances. We will now discover the provider using the ServiceManager:</p>
<div class="fragment"><div class="line">OSCPServiceManager oscpsm;</div><div class="line">unique_ptr&lt;OSCPConsumer&gt; consumer = oscpsm.discoverEndpointReference(<span class="stringliteral">&quot;EPR_1234&quot;</span>);</div><div class="line"><span class="keywordflow">if</span> (consumer != <span class="keyword">nullptr</span>) {</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>It's also possible to directly connect using a known transport address:</p>
<div class="fragment"><div class="line">OSCPServiceManager oscpsm;</div><div class="line">unique_ptr&lt;OSCPConsumer&gt; consumer = oscpsm.connect(<span class="stringliteral">&quot;http://192.168.1.32:1234/UDI_1234&quot;</span>);</div></div><!-- fragment --><h2><a class="anchor" id="oscp_consumer_events"></a>
Using the consumer - reception of events</h2>
<p>If we like to process events (in this case, the ones containing states for the current weight metric), we'll have to provide an event handler of a subtype of <b>OSCPConsumerEventHandler</b> (e.g. <b>OSCPConsumerNumericMetricStateHandler</b>), implement the <b>onStateChanged</b> (if the metric is writable!) and override the <b>getHandle</b> method. The <b>onStateChanged</b> method will be entered whenever the framework or the user code notify about a metric change (updateState). Optionally, the method <b>onOperationInvoked</b> can be overwritten to receive detailed notification about invocation states.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ExampleConsumerEventHandler : <span class="keyword">public</span> OSCPConsumerNumericMetricStateHandler</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  ExampleConsumerEventHandler(<span class="keyword">const</span> std::string &amp; handle) {</div><div class="line">    currentWeight = 0;</div><div class="line">    this-&gt;handle = handle;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> ~ExampleConsumerEventHandler(<span class="keyword">const</span> std::string &amp; handle) { }</div><div class="line"></div><div class="line">  <span class="comment">// Overrides base</span></div><div class="line">  <span class="keywordtype">void</span> onStateChanged(<span class="keyword">const</span> NumericMetricState &amp; state)<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordtype">double</span> val = state.getObservedValue().getValue();</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Received current weight value changed: &quot;</span> &lt;&lt; val &lt;&lt; endl;</div><div class="line">    Poco::Mutex::ScopedLock lock(mutex);  <span class="comment">// Pay attention to concurrency</span></div><div class="line">    <span class="keywordtype">double</span> val = state.getObservedValue().getValue();</div><div class="line">    this-&gt;currentWeight = val;</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="comment">// Overrides base</span></div><div class="line">  <span class="keywordtype">void</span> onOperationInvoked(<span class="keyword">const</span> OperationInvocationContext &amp; oic, InvocationState is)<span class="keyword"> override </span>{</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Received operation invoked (ID, STATE): &quot;</span> &lt;&lt; oic.transactionId &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; EnumToString::convert(is) &lt;&lt; endl;</div><div class="line">  }  </div><div class="line"></div><div class="line">  <span class="comment">// Overrides base</span></div><div class="line">  std::string getHandle()<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordflow">return</span> handle;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> getWeight() {</div><div class="line">    Poco::Mutex::ScopedLock lock(mutex);  <span class="comment">// Pay attention to concurrency</span></div><div class="line">    <span class="keywordflow">return</span> this-&gt;weight;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  Poco::Mutex mutex;</div><div class="line">  <span class="keywordtype">double</span> weight;</div><div class="line">  std::string handle;</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>You can then register for the events using the following code:</p>
<div class="fragment"><div class="line">ExampleConsumerEventHandler * handler1 = <span class="keyword">new</span> ExampleConsumerEventHandler(<span class="stringliteral">&quot;handle_cur&quot;</span>);</div><div class="line">ExampleConsumerEventHandler * handler2 = <span class="keyword">new</span> ExampleConsumerEventHandler(<span class="stringliteral">&quot;handle_max&quot;</span>);</div><div class="line">consumer.registerStateEventHandler(handler1);</div><div class="line">consumer.registerStateEventHandler(handler2);</div></div><!-- fragment --><h2><a class="anchor" id="oscp_consumer_request_commit"></a>
Using the consumer - Request and commit states</h2>
<p>The currentweight metric state can also be requested directly using <b>requestState</b>:</p>
<div class="fragment"><div class="line">NumericMetricState currentWeightState;</div><div class="line"><span class="keywordflow">if</span> (consumer.requestState(<span class="stringliteral">&quot;handle_cur&quot;</span>, currentWeightState)) {</div><div class="line">  <span class="comment">// Note: the following pre-check is very important - if the observed value is missing, the code will result in undefined behavior!</span></div><div class="line">  <span class="keywordflow">if</span> (currentWeightState.hasObservedValue()) {</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Current weight value is: &quot;</span> &lt;&lt; currentWeightState.getObservedValue().getValue() &lt;&lt; endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><b>Important:</b> The handle provided to the function can either be the descriptor's handle or the state's handle (if there is any). In cases when multiple states refer to the same descriptor, the state's handle must be used! the same thing applies to commiting states (see below).</p>
<h3><a class="anchor" id="oscp_consumer_request_commit_async"></a>
Handling async commits</h3>
<p>Committing states takes place <b>asynchronously</b>, which means the method always returns at once, independently from how long the actual change process takes to complete on the Provider's side. The default return value for a change process that has preliminary been accepted, is InvocationState::WAITING.</p>
<p>However, in some cases like the currentweight metric, the invocation state will indicate a failure because this metric is read-only:</p>
<div class="fragment"><div class="line">NumericMetricState currentWeightStateResult;</div><div class="line">InvocationState::Value is = consumer.commitState(currentWeightState);</div><div class="line"><span class="comment">// is == InvocationState::FAILED</span></div></div><!-- fragment --><p>Please note that in this case the framework itself makes this determination and returns this value in the response. If for example InvocationState::FAILED is returned by the provider handler's user code, it can only be detected by evaluating the results later, because the immediate return value will still be InvocationState::WAITING (remember that the user code on the provider's side will be executed asynchronously).</p>
<p>There are two possibilities of how to handle results of asynchronously committed states:</p>
<ul>
<li>
Synchronously wait for received invocation state(s) by using a <b>FutureInvocationState</b> object provided to the <b>commit</b> function. Then call <b>waitReceived</b> after the commit. </li>
<li>
Handle operation invoked reports and episodic metric / alert / context reports in a user-defined subclass of subtypes of OSCPConsumerEventHandler (<b>onOperationInvoked</b> and <b>onStateChanged</b>) like shown before. The <b>FutureInvocationState</b> object can be used to get the right transaction ID which must somehow be taken into account by the handler. </li>
</ul>
<p>So in each case, a <b>FutureInvocationState</b> object is needed, either to use its methods to actively wait for an event to occur or to get the transaction ID and compare it with events received elsewhere. The first case is very easy to implement:</p>
<div class="fragment"><div class="line">NumericMetricState maxWeightState;</div><div class="line">maxWeightState.setDescriptorHandle(<span class="stringliteral">&quot;handle_max&quot;</span>);</div><div class="line">maxWeightState.setObservedValue(NumericMetricValue(3.0));</div><div class="line">FutureInvocationState fis;</div><div class="line"><span class="keywordflow">if</span> (consumer.commitState(maxWeightState, fis) == InvocationState::WAITING) {</div><div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Commit in progress...&quot;</span> &lt;&lt; endl;</div><div class="line">  <span class="comment">// Wait FINISHED to be signaled in the next 1000 milliseconds</span></div><div class="line">  <span class="keywordflow">if</span> (fis.waitReceived(InvocationState::FINISHED, 1000)) {</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Commit succeeded within expected time!&quot;</span> &lt;&lt; endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The second case would be more complicated because the chronology of messages sent from the server is not deterministic. Operation invoked reports can be received by the consumer event handler before the commit function actually returns. At this point, the transaction ID (created by the provider) is not yet known on the consumer's side. One way to address this problem would be to maintain a history of received events in the consumer event handler.</p>
<h2><a class="anchor" id="oscp_consumer_close"></a>
Disconnecting the consumer</h2>
<p>If the consumer is not needed any more, it should be disconnected (it MUST be disconnected before deletion). Handlers may be unregistered before that (if not, on the provider side the event subscription will time out):</p>
<div class="fragment"><div class="line">consumer.unregisterStateEventHandler(handler1);</div><div class="line">consumer.unregisterStateEventHandler(handler2);</div><div class="line">consumer.disconnect();</div><div class="line"><span class="comment">// shared_ptr will delete consumer when leaving scope</span></div></div><!-- fragment --><h1><a class="anchor" id="oscp_alarm_system"></a>
The alarm system</h1>
<p>The structures and methods of the alarm system can be used to implement alarm situations using mostly <b>conditions</b> and <b>signals</b>. Descriptors and states exist for each of the latter. This section describes an extension of the previous example to produce and consume an alarm, if the current weight value exceeds the maximum value. A real implementation of this example can be found in the unit test <b>TestSimpleOSCP.cpp</b></p>
<p>An alert condition holds the information about an actual alarm situation, while an alert signal's purpose is to define, how exactly the condition should be reported. In general, multiple signals can reference the same condition. We start again with the descriptive part.</p>
<h2><a class="anchor" id="oscp_alarm_system_provide"></a>
The provider</h2>
<p>We'd like to create an alert for the <b>limit condition</b> when the current weight value exceeds the maximum value and extend the holding device's provider with the following code.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>OSCPHoldingDeviceProvider : <span class="keyword">public</span> OSCPProvider {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  OSCPHoldingDeviceProvider() {</div><div class="line">  </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// Setup alert system</span></div><div class="line">    AlertSystemDescriptor alertSystem;</div><div class="line">    alertSystem</div><div class="line">        .addAlertSignal(alertSignal)</div><div class="line">        .addAlertCondition(alertCondition)</div><div class="line">        .setHandle(<span class="stringliteral">&quot;handle_alert_system&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Add to channel (VMD or MDS is also possible)</span></div><div class="line">    holdingDeviceChannel.setAlertSystem(alertSystem);</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// Create SET operation descriptor</span></div><div class="line">    createSetOperationForDescriptor(alertSignal, holdingDeviceSystem);</div><div class="line">  </div><div class="line">    <span class="comment">// Setup alert descriptors</span></div><div class="line"></div><div class="line">    <span class="comment">// Alert condition</span></div><div class="line">    alertCondition</div><div class="line">        .addSource(<span class="stringliteral">&quot;handle_cur&quot;</span>)</div><div class="line">        .setType(</div><div class="line">            CodedValue()</div><div class="line">            .setCodeId(<span class="stringliteral">&quot;MDCX_CODE_ID_ALERT_WEIGHT_CONDITION&quot;</span>)</div><div class="line">            .setCodingSystemId(<span class="stringliteral">&quot;OR.NET.Codings&quot;</span>))</div><div class="line">        .setKind(AlertConditionKind::TECHNICAL)</div><div class="line">        .setPriority(AlertConditionPriority::MEDIUM)</div><div class="line">        .setHandle(<span class="stringliteral">&quot;handle_alert_condition&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Create signal for condition</span></div><div class="line">    alertSignal</div><div class="line">        .setConditionSignaled(<span class="stringliteral">&quot;handle_alert_condition&quot;</span>)</div><div class="line">        .setManifestation(AlertSignalManifestation::VISIBLE)</div><div class="line">        .setLatching(<span class="keyword">false</span>)</div><div class="line">        .setHandle(<span class="stringliteral">&quot;handle_alert_signal&quot;</span>);</div><div class="line">        </div><div class="line">    <span class="comment">// Add alert state handlers</span></div><div class="line">    addMDStateHandler(&amp;alertCondHandler);</div><div class="line">    addMDStateHandler(&amp;alertSigHandler);</div><div class="line">    addMDStateHandler(&amp;alertSysHandler);</div><div class="line">  }</div><div class="line">  </div><div class="line"><span class="keyword">private</span>:</div><div class="line">  ...</div><div class="line">  </div><div class="line">  <span class="comment">// Alert descriptors</span></div><div class="line">  AlertSignalDescriptor alertSignal;</div><div class="line">  AlertConditionDescriptor alertCondition;</div><div class="line">  </div><div class="line">  <span class="comment">// Alert states</span></div><div class="line">  LimitAlertConditionStateHandler alertCondHandler;  <span class="comment">// See implementation details below</span></div><div class="line">  AlertSignalStateHandler alertSigHandler;  <span class="comment">// See implementation details below</span></div><div class="line">  AlertSystemStateHandler alertSysHandler;  <span class="comment">// See implementation details below</span></div><div class="line">}</div></div><!-- fragment --><p>The <b>LimitAlertConditionStateHandler</b> and <b>AlertSignalStateHandler</b> classes extend the OSCPProviderAlertConditionStateHandler and the OSCPProviderAlertSignalStateHandler, resp. The method <b>sourceHasChanged</b> will be called whenever the referenced source state changed (e.g. updateState was called). The behavior of the method call to <b>setAlertConditionPresence</b> will be explained later.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>LimitAlertConditionStateHandler : <span class="keyword">public</span> OSCPProviderLimitAlertConditionStateHandler {</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  LimitAlertConditionStateHandler() {</div><div class="line">  }</div><div class="line"></div><div class="line">  InvocationState onStateChangeRequest(<span class="keyword">const</span> LimitAlertConditionState &amp; state, <span class="keyword">const</span> OperationInvocationContext &amp; )<span class="keyword"> override </span>{</div><div class="line">    <span class="comment">// Invocation has been fired as WAITING when entering this method</span></div><div class="line">    LimitAlertConditionState currentState;</div><div class="line">    getParentProvider().getMDState().findState(state.getDescriptorHandle(), currentState);</div><div class="line"></div><div class="line">        DebugOut(DebugOut::Default, <span class="stringliteral">&quot;SimpleOSCP&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;Provider: LimitAlertConditionStateHandler received state change, presence = &quot;</span> &lt;&lt; state.getPresence() &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">if</span> (state.getPresence() != currentState.getPresence()) {</div><div class="line">      DebugOut(DebugOut::Default, <span class="stringliteral">&quot;SimpleOSCP&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;Provider: LimitAlertConditionStateHandler detected presence change to: &quot;</span> &lt;&lt; state.getPresence() &lt;&lt; std::endl;</div><div class="line">      <span class="comment">// do something...</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// we can update here, but if we return FINISHED, the framework will also notify</span></div><div class="line">    <span class="comment">//updateState(limitAlertConditionState);</span></div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> InvocationState::FINISHED;  <span class="comment">// Framework will update internal MDIB with the state&#39;s value and increase MDIB version</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> sourceHasChanged(<span class="keyword">const</span> std::string &amp; sourceHandle)<span class="keyword"> override </span>{</div><div class="line">    DebugOut(DebugOut::Default, <span class="stringliteral">&quot;SimpleOSCP&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;Provider: LimitAlertConditionStateHandler monitored source state changed.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Check limit and trigger alarm condition, if needed (this method will then take care of handling all signal states)</span></div><div class="line">    NumericMetricState sourceState;</div><div class="line">    getParentProvider().getMDState().findState(sourceHandle, sourceState);</div><div class="line">    LimitAlertConditionState limitAlertConditionState;</div><div class="line">    getParentProvider().getMDState().findState(<span class="stringliteral">&quot;handle_alert_condition&quot;</span>, limitAlertConditionState);</div><div class="line">    <span class="keywordflow">if</span> (sourceState.getDescriptorHandle() != sourceHandle) {</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!sourceState.hasObservedValue()) {</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> sourceValue(sourceState.getObservedValue());</div><div class="line">    <span class="keywordflow">if</span> (!sourceValue.hasValue()) {</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!limitAlertConditionState.hasLimits()) {</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> limits(limitAlertConditionState.getLimits());</div><div class="line">    <span class="keywordflow">if</span> (!limits.hasUpper()) {</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!limits.hasLower()) {</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Check value and set presence</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> triggerAlarm(sourceValue.getValue() &gt; limits.getUpper() || sourceValue.getValue() &lt; limits.getLower());</div><div class="line">        setAlertConditionPresence(limitAlertConditionState.getDescriptorHandle(), triggerAlarm, OperationInvocationContext::none());</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Can be used to switch condition on and off (e.g. propagate input from real device). Currently not used in this test.</span></div><div class="line">  <span class="keywordtype">void</span> setPresence(<span class="keywordtype">bool</span> presence) {</div><div class="line">    <span class="comment">// We do not need to update our state here, this will be done in onStateChangeRequest (will be called by the method we invoke next)</span></div><div class="line">    setAlertConditionPresence(getDescriptorHandle(), presence, OperationInvocationContext::none());</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Helper method</span></div><div class="line">  LimitAlertConditionState createState() {</div><div class="line">    LimitAlertConditionState result;</div><div class="line">    result</div><div class="line">      .setDescriptorHandle(<span class="stringliteral">&quot;handle_alert_condition&quot;</span>)  <span class="comment">// Reference alert signal descriptor&#39;s handle</span></div><div class="line">      .setActivationState(PausableActivation::ON)  <span class="comment">// Component is working</span></div><div class="line">      .setPresence(<span class="keyword">false</span>)</div><div class="line">      .setMonitoredAlertLimits(MonitoredAlertLimits::ALL)</div><div class="line">      .setLimits(Range().setLower(0.0).setUpper(2.0));</div><div class="line">    <span class="keywordflow">return</span> result;</div><div class="line">  }</div><div class="line"></div><div class="line">  LimitAlertConditionState getInitialState()<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordflow">return</span> createState();</div><div class="line">  }</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>Changing the condition's presence will trigger all alert signals which are referenced. The implementation of the signal's state handler follows next.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>AlertSignalStateHandler : <span class="keyword">public</span> OSCPProviderAlertSignalStateHandler {</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  AlertSignalStateHandler() {</div><div class="line">  }</div><div class="line"></div><div class="line">  InvocationState onStateChangeRequest(<span class="keyword">const</span> AlertSignalState &amp; state, <span class="keyword">const</span> OperationInvocationContext &amp; oic)<span class="keyword"> override </span>{</div><div class="line">    <span class="comment">// Invocation has been fired as WAITING when entering this method</span></div><div class="line">    DebugOut(DebugOut::Default, <span class="stringliteral">&quot;SimpleOSCP&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;Provider: AlertSignalStateHandler received state change: &quot;</span> &lt;&lt; EnumToString::convert(state.getPresence()) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    notifyOperationInvoked(oic, InvocationState::STARTED);</div><div class="line"></div><div class="line">    <span class="comment">// Update the real device&#39;s state here (update device alarms)! Check state&#39;s presence and alertSignalState&#39;s presence values!</span></div><div class="line"></div><div class="line">        <span class="comment">// we can update here, but if we return FINISHED, the framework will also notify</span></div><div class="line">        <span class="comment">//updateState(alertSignalState);</span></div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> InvocationState::FINISHED;  <span class="comment">// Framework will update internal MDIB with the state&#39;s value and increase MDIB version</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Helper method</span></div><div class="line">  AlertSignalState createState() {</div><div class="line">    AlertSignalState result;</div><div class="line">    result</div><div class="line">      .setDescriptorHandle(<span class="stringliteral">&quot;handle_alert_signal&quot;</span>)  <span class="comment">// Reference alert signal descriptor&#39;s handle</span></div><div class="line">      .setActivationState(PausableActivation::ON)  <span class="comment">// Component is working</span></div><div class="line">      .setPresence(SignalPresence::Off);  <span class="comment">// No alarm signal</span></div><div class="line">    <span class="keywordflow">return</span> result;</div><div class="line">  }</div><div class="line"></div><div class="line">  AlertSignalState getInitialState()<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordflow">return</span> createState();</div><div class="line">  }</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>Finally, the alarm system's state handler.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>AlertSystemStateHandler : <span class="keyword">public</span> OSCPProviderAlertSystemStateHandler {</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  AlertSystemStateHandler() {</div><div class="line">  }</div><div class="line"></div><div class="line">  AlertSystemState getInitialState()<span class="keyword"> override </span>{</div><div class="line">    AlertSystemState alertSystemState;</div><div class="line">    <span class="comment">// reference alert system descriptor&#39;s handle</span></div><div class="line">    alertSystemState</div><div class="line">      .setActivationState(PausableActivation::ON)</div><div class="line">      .setDescriptorHandle(<span class="stringliteral">&quot;handle_alert_system&quot;</span>);</div><div class="line">    <span class="keywordflow">return</span> alertSystemState;</div><div class="line">  }</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>Calling the method <b>setAlertConditionPresence</b> will handle all alert signals which reference a condition automatically. Depending on the condition's presence parameter (true or false), alert signals will be handled as follows.</p>
<ol>
<li>
True: the alert signal's presence state will be set ON (no matter what the previous value was). </li>
<li>
False: if an alert signal's presence state is currently set to ON, it will be set to LATCHED. </li>
</ol>
<p>However, it will never be set OFF or ACK (automatically). The logic behind this will be left to the user code.</p>
<h2><a class="anchor" id="oscp_alarm_system_consumer"></a>
The consumer</h2>
<p>The consumer can be extended by a new state handler, to handle alert state events fired by the provider. Like the <b>ExampleConsumerEventHandler</b> described before, a similar subclass of <b>OSCPConsumerAlertSignalStateHandler</b> will be used. The new handler will be called <b>ExampleConsumerAlertEventHandler</b>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ExampleConsumerAlertEventHandler : <span class="keyword">public</span> OSCPConsumerAlertSignalStateHandler {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ExampleConsumerAlertEventHandler(<span class="keyword">const</span> <span class="keywordtype">string</span> &amp; handle) :</div><div class="line">    handle(handle) {</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> ~ExampleConsumerAlertEventHandler() {</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> onStateChanged(<span class="keyword">const</span> AlertSignalState &amp; state)<span class="keyword"> override </span>{</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Consumer: Received alert signal changed of &quot;</span> &lt;&lt; handle &lt;&lt; <span class="stringliteral">&quot;, presence = &quot;</span> &lt;&lt; EnumToString::convert(state.getPresence()) &lt;&lt; endl;</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="keywordtype">void</span> onOperationInvoked(<span class="keyword">const</span> OperationInvocationContext &amp; oic, InvocationState is) {</div><div class="line">    <span class="comment">// Implement, if needed...</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">string</span> getHandle() {</div><div class="line">    <span class="keywordflow">return</span> handle;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  Poco::Mutex mutex;</div><div class="line">  <span class="keywordtype">string</span> handle;</div><div class="line">};</div></div><!-- fragment --><p>An instance of the handler can be added to the consumer using the Consumer's method <b>registerStateEventHandler</b>. Events will be fired when using the method <b>setAlertConditionPresence</b> on the provider's side.</p>
<p>Using the following code shows how to change an alert signal's activation state (in this case, switch the alarm OFF).</p>
<div class="fragment"><div class="line">AlertSignalState alertSignal;</div><div class="line"><span class="comment">// First request state (this way, we do not have to populate the structure manually)</span></div><div class="line"><span class="keywordflow">if</span> (consumer.requestState(<span class="stringliteral">&quot;handle_alert_signal&quot;</span>, alertSignal)) {</div><div class="line">  <span class="comment">// Switch alert signal off</span></div><div class="line">  alertSignal.setPresence(SignalPresence::Off);</div><div class="line">  FutureInvocationState fis;</div><div class="line">  <span class="keywordflow">if</span> (consumer.commitState(alertSignal) == InvocationState::WAITING &amp;&amp; fis.waitReceived(InvocationState::FINISHED, 1000)) {</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Success! Alarm has been switched off.&quot;</span> &lt;&lt; endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="oscp_code_snippets"></a>
Useful code snippets and recipes</h1>
<h2><a class="anchor" id="oscp_streaming"></a>
Streaming</h2>
<p>In order to provide streaming, the first thing to do is to define one or more streaming metrics members inside an OSCPProvider instance. </p><ul>
<li>
Create a member <b>RealTimeSampleArrayMetricDescriptor</b> and configure it in the constructor similar as shown before (define a unique handle for the descriptor). </li>
<li>
Create a provider state handler subclassing <b>OSCPProviderRealTimeSampleArrayMetricStateHandler</b> (see example below). </li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>StreamProviderStateHandler : <span class="keyword">public</span> OSCPProviderRealTimeSampleArrayMetricStateHandler {</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  StreamProviderStateHandler(std::string descriptorHandle) : descriptorHandle(descriptorHandle) {</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> ~StreamProviderStateHandler() { }</div><div class="line"></div><div class="line">  <span class="comment">// Helper method</span></div><div class="line">  RealTimeSampleArrayMetricState createState() {</div><div class="line">    RealTimeSampleArrayMetricState realTimeSampleArrayState;</div><div class="line">    realTimeSampleArrayState</div><div class="line">      .setComponentActivationState(ComponentActivation::ON)</div><div class="line">      .setDescriptorHandle(descriptorHandle)</div><div class="line">      .setHandle(descriptorHandle + <span class="stringliteral">&quot;_state&quot;</span>);</div><div class="line">    <span class="keywordflow">return</span> realTimeSampleArrayState;</div><div class="line">  }</div><div class="line"></div><div class="line">  RealTimeSampleArrayMetricState getInitialState()<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordflow">return</span> createState();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Called by user code (see next code example)</span></div><div class="line">  <span class="keywordtype">void</span> updateStateValue(<span class="keyword">const</span> RealTimeSampleArrayValue &amp; rtsav) {</div><div class="line">    RealTimeSampleArrayMetricState realTimeSampleArrayState = createState();</div><div class="line">    realTimeSampleArrayState</div><div class="line">      .setObservedValue(rtsav);</div><div class="line">    updateState(realTimeSampleArrayState);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::string descriptorHandle;</div><div class="line">};</div></div><!-- fragment --><p>Produce next block of stream values using this code:</p>
<div class="fragment"><div class="line">RTValueType values;</div><div class="line">std::vector&lt;double&gt; samples;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {</div><div class="line">   samples.push_back(i);</div><div class="line">}</div><div class="line">values.setValues(samples);</div><div class="line">RealTimeSampleArrayValue value;</div><div class="line">value.setSamples(values);</div><div class="line"><span class="comment">// Produce next stream chunk</span></div><div class="line">stateHandler.updateStateValue(value);</div></div><!-- fragment --><p>The stream values are sent in blocks to all registered consumers whenever <b>updateState</b> is called.</p>
<p>In order to consume streaming, you can subclass <b>OSCPConsumerRealTimeSampleArrayMetricStateHandler</b>. You will then receive a block of next values instead.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>StreamConsumerEventHandler : <span class="keyword">public</span> OSCPConsumerRealTimeSampleArrayMetricStateHandler {</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> onStateChanged(<span class="keyword">const</span> RealTimeSampleArrayMetricState &amp; state) {</div><div class="line">    std::vector&lt;double&gt; values = state.getObservedValue().getSamples().getValues();</div><div class="line">    </div><div class="line">    ...</div><div class="line">  }</div><div class="line">  </div><div class="line">  std::string getHandle() {</div><div class="line">    ...</div><div class="line">  }  </div><div class="line">  </div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="oscp_activation"></a>
Custom commands using activations</h2>
<p>Whenever a (parameterless) function should be called that is not connected directly to a state, a custom activate operation can be defined. For example, this can be used for relative value increases or for simple switches like ON / OFF.</p>
<p>Definition of the handler on the provider's side:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CommandHandler : <span class="keyword">public</span> OSCPProviderActivateOperationHandler {</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  CommandHandler() {</div><div class="line">  }</div><div class="line"></div><div class="line">  InvocationState onActivateRequest(<span class="keyword">const</span> MDIBContainer &amp; , <span class="keyword">const</span> OperationInvocationContext &amp; ) {</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Provider: Received command!&quot;</span> &lt;&lt; endl;</div><div class="line">    </div><div class="line">    <span class="comment">// TODO: if needed, make changes in the MDIB (e.g. increase max value) using updateState</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> InvocationState::FINISHED;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::string getHandle()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;handle_cmd&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>The following code must be used in the provider to register the operation descriptor using an operation handle and target:</p>
<div class="fragment"><div class="line">ActivateOperationDescriptor aod;</div><div class="line">aod.setHandle(<span class="stringliteral">&quot;handle_cmd&quot;</span>).setOperationTarget(<span class="stringliteral">&quot;handle_max&quot;</span>);</div><div class="line"><span class="comment">// Add the operation descriptor</span></div><div class="line">addActivateOperationForDescriptor(aod, holdingDeviceSystem);</div></div><!-- fragment --><p>Then at last, the command handler itself must be registered:</p>
<div class="fragment"><div class="line">CommandHandler cmdHandler;  <span class="comment">// Use this as private member in the provider</span></div><div class="line">...</div><div class="line">addMDStateHandler(&amp;cmdHandler);</div></div><!-- fragment --><p>To send an activate request, use the following code:</p>
<div class="fragment"><div class="line">FutureInvocationState fis;</div><div class="line">consumer-&gt;activate(<span class="stringliteral">&quot;handle_cmd&quot;</span>, fis)</div><div class="line"><span class="keywordflow">if</span> (fis.waitReceived(InvocationState::FINISHED, 1000)) {</div><div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Consumer: Activation succeeded!&quot;</span> &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="oscp_contexts"></a>
Using contexts</h2>
<p>To handle incoming commits on the provider's side, there can be only one handler which processes all incoming commits.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ContextHandler : <span class="keyword">public</span> OSCPProviderContextStateHandler {</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  ContextHandler() {</div><div class="line">  }</div><div class="line">   </div><div class="line">  <span class="keyword">virtual</span> ~ContextHandler() { }</div><div class="line"></div><div class="line">  <span class="comment">// Get inital states</span></div><div class="line">  <span class="keyword">virtual</span> std::vector&lt;LocationContextState&gt; getLocationContextStates()<span class="keyword"> override </span>{</div><div class="line">    LocationContextState locationState;</div><div class="line">    <span class="comment">// This device magically knows its location</span></div><div class="line">    locationState</div><div class="line">      .setHandle(<span class="stringliteral">&quot;location_context_state&quot;</span>)</div><div class="line">      .setDescriptorHandle(<span class="stringliteral">&quot;location_context&quot;</span>)</div><div class="line">      .addIdentification(</div><div class="line">        InstanceIdentifier()</div><div class="line">          .setroot(<span class="stringliteral">&quot;MyHospital&quot;</span>)</div><div class="line">          .setextension(<span class="stringliteral">&quot;Room 23&quot;</span>)</div><div class="line">        );</div><div class="line">    std::vector&lt;LocationContextState&gt; result;</div><div class="line">    result.push_back(locationState);</div><div class="line">    <span class="keywordflow">return</span> result;</div><div class="line">  }</div><div class="line"></div><div class="line">   <span class="comment">// TODO: other initial states...</span></div><div class="line">  </div><div class="line">  <span class="keyword">virtual</span> InvocationState onStateChangeRequest(<span class="keyword">const</span> std::vector&lt;EnsembleContextState&gt; &amp; ecStates,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;LocationContextState&gt; &amp; lcStates,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;OperatorContextState&gt; &amp; ocStates,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;PatientContextState&gt; &amp; pcStates,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;WorkflowContextState&gt; &amp; wcStates,</div><div class="line">    <span class="keyword">const</span> OperationInvocationContext &amp; oic)<span class="keyword"> override </span>{</div><div class="line">    </div><div class="line">    notifyOperationInvoked(oic, InvocationState::STARTED);</div><div class="line">    <span class="comment">// TODO: check handles and return InvocationState::FAILED;</span></div><div class="line">                </div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Provider: ContextHandler received state change request&quot;</span> &lt;&lt; endl;</div><div class="line">        </div><div class="line">    <span class="comment">// TODO: Iterate lcStates, call updateState on the given states</span></div><div class="line">        </div><div class="line">    <span class="keywordflow">return</span> InvocationState::FINISHED;</div><div class="line">  }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>For the descriptive part, we need context descriptors for each state and must add them to the MDS:</p>
<div class="fragment"><div class="line">LocationContextDescriptor location;  <span class="comment">// Use this as private member in the provider</span></div><div class="line">...</div><div class="line">location.setHandle(<span class="stringliteral">&quot;location_context&quot;</span>);  <span class="comment">// Init like this in constructor</span></div><div class="line">...</div><div class="line">holdingDeviceSystem  <span class="comment">// Use in getMDDescription</span></div><div class="line">    .setContext(</div><div class="line">        SystemContext().setLocationContext(location)</div><div class="line">    )</div></div><!-- fragment --><p>Multiple contexts can be added using method chaning, e.g.:</p>
<div class="fragment"><div class="line">holdingDeviceSystem</div><div class="line">  .setContext(</div><div class="line">     SystemContext()</div><div class="line">       .setLocationContext(...)</div><div class="line">       .setPatientContext(...)</div><div class="line">       .setWorkflowContext(...)</div><div class="line">       .setEnsembleContext(...)</div><div class="line">       .setOperatorContext(...)</div><div class="line">  )</div></div><!-- fragment --><p>The context handler must be registered in the provider:</p>
<div class="fragment"><div class="line">ContextHandler contextHandler;  <span class="comment">// Use this as private member in the provider</span></div><div class="line">...</div><div class="line">addMDStateHandler(&amp;contextHandler);  <span class="comment">// Use in constructor</span></div></div><!-- fragment --><p>On the consumer's side, requesting and committing context states is no more different than handling any other state, the same rules and methods (<b>requestState</b> and <b>commitState</b>) apply. To receive events, subclass <b>OSCPConsumerContextStateChangedHandler</b> and override <b>onContextStateChanged</b>.</p>
<h2><a class="anchor" id="oscp_stringenums"></a>
Using string enums</h2>
<p>On the provider side, please use the following steps (similar to the ones of conventional metrics):</p>
<ul>
<li>
Create a handler by subclassing <b>OSCPProviderEnumStringMetricStateHandler</b> and override <b>onStateChangeRequest</b> and <b>getInitialState</b>. Initialize the handler's internal state (of type <b>EnumStringMetricState</b> in the constructor. Set a descriptor handle and optionally, a state handle (remember that you MUST set a state handle in cases when multiple states refer to the same descriptor!). </li>
<li>
Create a member variable of the handler in the provider and add the handler using <b>addMDStateHandler</b>. </li>
<li>
In provider constructor, add the metric descriptor to a channel (using <b>addMetric</b>). Then add a SET operation using <b>createSetOperationForDescriptor</b>, if the state shoulb be writable (consumer can commit)! </li>
</ul>
<p>On the consumer side:</p>
<ul>
<li>
Use <b>requestState</b> and <b>commitState</b> to request and commit string enum states (as usual). </li>
<li>
Subclass <b>OSCPConsumerEnumStringMetricStateHandler</b> and override <b>onStateChanged</b> method for the type <b>EnumStringMetricState</b>, if events need to be received. Then register the handler in the consumer (<b>registerStateEventHandler</b>). Don't forget to unregister! </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jul 25 2016 12:34:45 for OSCLib by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
