/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.2
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_OSCLib_WRAP_H_
#define SWIG_OSCLib_WRAP_H_

#include <map>
#include <string>


class SwigDirector_OSCPConsumerEventHandler : public OSCLib::Data::OSCP::OSCPConsumerEventHandler, public Swig::Director {

public:
    SwigDirector_OSCPConsumerEventHandler(PyObject *self);
    virtual ~SwigDirector_OSCPConsumerEventHandler();
    virtual void onOperationInvoked(OSCLib::Data::OSCP::OperationInvocationContext const &oic, OSCLib::Data::OSCP::InvocationState is);
    virtual std::string getHandle();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPConsumerEventHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_OSCPConsumerAlertConditionStateHandler : public OSCLib::Data::OSCP::OSCPConsumerAlertConditionStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPConsumerAlertConditionStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPConsumerAlertConditionStateHandler();
    virtual void onOperationInvoked(OSCLib::Data::OSCP::OperationInvocationContext const &oic, OSCLib::Data::OSCP::InvocationState is);
    virtual std::string getHandle();
    virtual void onStateChanged(OSCLib::Data::OSCP::AlertConditionState const &state);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPConsumerAlertConditionStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_OSCPConsumerAlertSignalStateHandler : public OSCLib::Data::OSCP::OSCPConsumerAlertSignalStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPConsumerAlertSignalStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPConsumerAlertSignalStateHandler();
    virtual void onOperationInvoked(OSCLib::Data::OSCP::OperationInvocationContext const &oic, OSCLib::Data::OSCP::InvocationState is);
    virtual std::string getHandle();
    virtual void onStateChanged(OSCLib::Data::OSCP::AlertSignalState const &state);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPConsumerAlertSignalStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_OSCPConsumerAlertSystemStateHandler : public OSCLib::Data::OSCP::OSCPConsumerAlertSystemStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPConsumerAlertSystemStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPConsumerAlertSystemStateHandler();
    virtual void onOperationInvoked(OSCLib::Data::OSCP::OperationInvocationContext const &oic, OSCLib::Data::OSCP::InvocationState is);
    virtual std::string getHandle();
    virtual void onStateChanged(OSCLib::Data::OSCP::AlertSystemState const &state);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPConsumerAlertSystemStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_OSCPConsumerConnectionLostHandler : public OSCLib::Data::OSCP::OSCPConsumerConnectionLostHandler, public Swig::Director {

public:
    SwigDirector_OSCPConsumerConnectionLostHandler(PyObject *self);
    virtual ~SwigDirector_OSCPConsumerConnectionLostHandler();
    virtual void onConnectionLost();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPConsumerConnectionLostHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_OSCPConsumerContextStateChangedHandler : public OSCLib::Data::OSCP::OSCPConsumerContextStateChangedHandler, public Swig::Director {

public:
    SwigDirector_OSCPConsumerContextStateChangedHandler(PyObject *self);
    virtual ~SwigDirector_OSCPConsumerContextStateChangedHandler();
    virtual void onContextStateChanged(std::vector< std::string,std::allocator< std::string > > const &handles);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPConsumerContextStateChangedHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_OSCPConsumerEnumStringMetricStateHandler : public OSCLib::Data::OSCP::OSCPConsumerEnumStringMetricStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPConsumerEnumStringMetricStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPConsumerEnumStringMetricStateHandler();
    virtual void onOperationInvoked(OSCLib::Data::OSCP::OperationInvocationContext const &oic, OSCLib::Data::OSCP::InvocationState is);
    virtual std::string getHandle();
    virtual void onStateChanged(OSCLib::Data::OSCP::EnumStringMetricState const &state);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPConsumerEnumStringMetricStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_OSCPConsumerLimitAlertConditionStateHandler : public OSCLib::Data::OSCP::OSCPConsumerLimitAlertConditionStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPConsumerLimitAlertConditionStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPConsumerLimitAlertConditionStateHandler();
    virtual void onOperationInvoked(OSCLib::Data::OSCP::OperationInvocationContext const &oic, OSCLib::Data::OSCP::InvocationState is);
    virtual std::string getHandle();
    virtual void onStateChanged(OSCLib::Data::OSCP::LimitAlertConditionState const &state);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPConsumerLimitAlertConditionStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_OSCPConsumerNumericMetricStateHandler : public OSCLib::Data::OSCP::OSCPConsumerNumericMetricStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPConsumerNumericMetricStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPConsumerNumericMetricStateHandler();
    virtual void onOperationInvoked(OSCLib::Data::OSCP::OperationInvocationContext const &oic, OSCLib::Data::OSCP::InvocationState is);
    virtual std::string getHandle();
    virtual void onStateChanged(OSCLib::Data::OSCP::NumericMetricState const &state);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPConsumerNumericMetricStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_OSCPConsumerRealTimeSampleArrayMetricStateHandler : public OSCLib::Data::OSCP::OSCPConsumerRealTimeSampleArrayMetricStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPConsumerRealTimeSampleArrayMetricStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPConsumerRealTimeSampleArrayMetricStateHandler();
    virtual void onOperationInvoked(OSCLib::Data::OSCP::OperationInvocationContext const &oic, OSCLib::Data::OSCP::InvocationState is);
    virtual std::string getHandle();
    virtual void onStateChanged(OSCLib::Data::OSCP::RealTimeSampleArrayMetricState const &state);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPConsumerRealTimeSampleArrayMetricStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_OSCPConsumerStringMetricStateHandler : public OSCLib::Data::OSCP::OSCPConsumerStringMetricStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPConsumerStringMetricStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPConsumerStringMetricStateHandler();
    virtual void onOperationInvoked(OSCLib::Data::OSCP::OperationInvocationContext const &oic, OSCLib::Data::OSCP::InvocationState is);
    virtual std::string getHandle();
    virtual void onStateChanged(OSCLib::Data::OSCP::StringMetricState const &state);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPConsumerStringMetricStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_OSCPProviderMDStateHandler : public OSCLib::Data::OSCP::OSCPProviderMDStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPProviderMDStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPProviderMDStateHandler();
    virtual std::string getHandle();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPProviderMDStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_OSCPProviderActivateOperationHandler : public OSCLib::Data::OSCP::OSCPProviderActivateOperationHandler, public Swig::Director {

public:
    SwigDirector_OSCPProviderActivateOperationHandler(PyObject *self);
    virtual ~SwigDirector_OSCPProviderActivateOperationHandler();
    virtual std::string getHandle();
    virtual OSCLib::Data::OSCP::InvocationState onActivateRequest(OSCLib::Data::OSCP::MDIBContainer const &mdib, OSCLib::Data::OSCP::OperationInvocationContext const &oic);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPProviderActivateOperationHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_OSCPProviderAlertConditionStateHandler : public OSCLib::Data::OSCP::OSCPProviderAlertConditionStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPProviderAlertConditionStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPProviderAlertConditionStateHandler();
    virtual std::string getHandle();
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequest(OSCLib::Data::OSCP::AlertConditionState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic);
    virtual OSCLib::Data::OSCP::AlertConditionState getState();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPProviderAlertConditionStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_OSCPProviderAlertSignalStateHandler : public OSCLib::Data::OSCP::OSCPProviderAlertSignalStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPProviderAlertSignalStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPProviderAlertSignalStateHandler();
    virtual std::string getHandle();
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequest(OSCLib::Data::OSCP::AlertSignalState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic);
    virtual OSCLib::Data::OSCP::AlertSignalState getState();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPProviderAlertSignalStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_OSCPProviderAlertSystemStateHandler : public OSCLib::Data::OSCP::OSCPProviderAlertSystemStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPProviderAlertSystemStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPProviderAlertSystemStateHandler();
    virtual std::string getHandle();
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequest(OSCLib::Data::OSCP::AlertSystemState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic);
    virtual OSCLib::Data::OSCP::AlertSystemState getState();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPProviderAlertSystemStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_OSCPProviderClockStateHandler : public OSCLib::Data::OSCP::OSCPProviderClockStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPProviderClockStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPProviderClockStateHandler();
    virtual std::string getHandle();
    virtual OSCLib::Data::OSCP::ClockState getState();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPProviderClockStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_OSCPProviderComponentStateHandler : public OSCLib::Data::OSCP::OSCPProviderComponentStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPProviderComponentStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPProviderComponentStateHandler();
    virtual std::string getHandle();
    virtual OSCLib::Data::OSCP::ComponentState getState();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPProviderComponentStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_OSCPProviderContextStateHandler : public OSCLib::Data::OSCP::OSCPProviderContextStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPProviderContextStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPProviderContextStateHandler();
    virtual std::string getHandle();
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequest(std::vector< OSCLib::Data::OSCP::EnsembleContextState,std::allocator< OSCLib::Data::OSCP::EnsembleContextState > > const &ecStates, std::vector< OSCLib::Data::OSCP::LocationContextState,std::allocator< OSCLib::Data::OSCP::LocationContextState > > const &lcStates, std::vector< OSCLib::Data::OSCP::OperatorContextState,std::allocator< OSCLib::Data::OSCP::OperatorContextState > > const &ocStates, std::vector< OSCLib::Data::OSCP::PatientContextState,std::allocator< OSCLib::Data::OSCP::PatientContextState > > const &pcStates, std::vector< OSCLib::Data::OSCP::WorkflowContextState,std::allocator< OSCLib::Data::OSCP::WorkflowContextState > > const &wcStates, OSCLib::Data::OSCP::OperationInvocationContext const &oic);
    virtual std::vector< OSCLib::Data::OSCP::EnsembleContextState,std::allocator< OSCLib::Data::OSCP::EnsembleContextState > > getEnsembleContextStates();
    virtual std::vector< OSCLib::Data::OSCP::LocationContextState,std::allocator< OSCLib::Data::OSCP::LocationContextState > > getLocationContextStates();
    virtual std::vector< OSCLib::Data::OSCP::OperatorContextState,std::allocator< OSCLib::Data::OSCP::OperatorContextState > > getOperatorContextStates();
    virtual std::vector< OSCLib::Data::OSCP::PatientContextState,std::allocator< OSCLib::Data::OSCP::PatientContextState > > getPatientContextStates();
    virtual std::vector< OSCLib::Data::OSCP::WorkflowContextState,std::allocator< OSCLib::Data::OSCP::WorkflowContextState > > getWorkflowContextStates();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPProviderContextStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_OSCPProviderEnumStringMetricStateHandler : public OSCLib::Data::OSCP::OSCPProviderEnumStringMetricStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPProviderEnumStringMetricStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPProviderEnumStringMetricStateHandler();
    virtual std::string getHandle();
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequest(OSCLib::Data::OSCP::EnumStringMetricState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic);
    virtual OSCLib::Data::OSCP::EnumStringMetricState getState();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPProviderEnumStringMetricStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_OSCPProvider : public OSCLib::Data::OSCP::OSCPProvider, public Swig::Director {

public:
    SwigDirector_OSCPProvider(PyObject *self);
    virtual ~SwigDirector_OSCPProvider();
    virtual OSCLib::Data::OSCP::MDIBContainer getMDIB();
    virtual OSCLib::Data::OSCP::MDDescription getMDDescription();
    virtual OSCLib::Data::OSCP::MDState getMDState();
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequest(OSCLib::Data::OSCP::EnumStringMetricState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic);
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequestSwigPublic(OSCLib::Data::OSCP::EnumStringMetricState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic) {
      return OSCLib::Data::OSCP::OSCPProvider::onStateChangeRequest(state,oic);
    }
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequest(OSCLib::Data::OSCP::NumericMetricState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic);
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequestSwigPublic(OSCLib::Data::OSCP::NumericMetricState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic) {
      return OSCLib::Data::OSCP::OSCPProvider::onStateChangeRequest(state,oic);
    }
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequest(OSCLib::Data::OSCP::StringMetricState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic);
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequestSwigPublic(OSCLib::Data::OSCP::StringMetricState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic) {
      return OSCLib::Data::OSCP::OSCPProvider::onStateChangeRequest(state,oic);
    }
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequest(OSCLib::Data::OSCP::RealTimeSampleArrayMetricState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic);
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequestSwigPublic(OSCLib::Data::OSCP::RealTimeSampleArrayMetricState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic) {
      return OSCLib::Data::OSCP::OSCPProvider::onStateChangeRequest(state,oic);
    }
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequest(OSCLib::Data::OSCP::AlertSystemState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic);
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequestSwigPublic(OSCLib::Data::OSCP::AlertSystemState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic) {
      return OSCLib::Data::OSCP::OSCPProvider::onStateChangeRequest(state,oic);
    }
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequest(OSCLib::Data::OSCP::AlertConditionState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic);
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequestSwigPublic(OSCLib::Data::OSCP::AlertConditionState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic) {
      return OSCLib::Data::OSCP::OSCPProvider::onStateChangeRequest(state,oic);
    }
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequest(OSCLib::Data::OSCP::AlertSignalState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic);
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequestSwigPublic(OSCLib::Data::OSCP::AlertSignalState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic) {
      return OSCLib::Data::OSCP::OSCPProvider::onStateChangeRequest(state,oic);
    }
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequest(OSCLib::Data::OSCP::LimitAlertConditionState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic);
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequestSwigPublic(OSCLib::Data::OSCP::LimitAlertConditionState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic) {
      return OSCLib::Data::OSCP::OSCPProvider::onStateChangeRequest(state,oic);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPProvider doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[11];
#endif

};


class SwigDirector_OSCPProviderHydraMDSStateHandler : public OSCLib::Data::OSCP::OSCPProviderHydraMDSStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPProviderHydraMDSStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPProviderHydraMDSStateHandler();
    virtual std::string getHandle();
    virtual OSCLib::Data::OSCP::HydraMDSState getState();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPProviderHydraMDSStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_OSCPProviderLimitAlertConditionStateHandler : public OSCLib::Data::OSCP::OSCPProviderLimitAlertConditionStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPProviderLimitAlertConditionStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPProviderLimitAlertConditionStateHandler();
    virtual std::string getHandle();
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequest(OSCLib::Data::OSCP::LimitAlertConditionState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic);
    virtual OSCLib::Data::OSCP::LimitAlertConditionState getState();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPProviderLimitAlertConditionStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_OSCPProviderNumericMetricStateHandler : public OSCLib::Data::OSCP::OSCPProviderNumericMetricStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPProviderNumericMetricStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPProviderNumericMetricStateHandler();
    virtual std::string getHandle();
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequest(OSCLib::Data::OSCP::NumericMetricState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic);
    virtual OSCLib::Data::OSCP::NumericMetricState getState();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPProviderNumericMetricStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_OSCPProviderRealTimeSampleArrayMetricStateHandler : public OSCLib::Data::OSCP::OSCPProviderRealTimeSampleArrayMetricStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPProviderRealTimeSampleArrayMetricStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPProviderRealTimeSampleArrayMetricStateHandler();
    virtual std::string getHandle();
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequest(OSCLib::Data::OSCP::RealTimeSampleArrayMetricState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic);
    virtual OSCLib::Data::OSCP::RealTimeSampleArrayMetricState getState();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPProviderRealTimeSampleArrayMetricStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_OSCPProviderStringMetricStateHandler : public OSCLib::Data::OSCP::OSCPProviderStringMetricStateHandler, public Swig::Director {

public:
    SwigDirector_OSCPProviderStringMetricStateHandler(PyObject *self);
    virtual ~SwigDirector_OSCPProviderStringMetricStateHandler();
    virtual std::string getHandle();
    virtual OSCLib::Data::OSCP::InvocationState onStateChangeRequest(OSCLib::Data::OSCP::StringMetricState const &state, OSCLib::Data::OSCP::OperationInvocationContext const &oic);
    virtual OSCLib::Data::OSCP::StringMetricState getState();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool val) const {
      swig_inner[swig_protected_method_name] = val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OSCPProviderStringMetricStateHandler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


#endif
