// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "wsdd-dpws-1.1-schema-os.hxx"

namespace WS
{
  namespace DPWS
  {
    // ThisModelType
    // 

    const ThisModelType::ManufacturerSequence& ThisModelType::
    Manufacturer () const
    {
      return this->Manufacturer_;
    }

    ThisModelType::ManufacturerSequence& ThisModelType::
    Manufacturer ()
    {
      return this->Manufacturer_;
    }

    void ThisModelType::
    Manufacturer (const ManufacturerSequence& s)
    {
      this->Manufacturer_ = s;
    }

    const ThisModelType::ManufacturerUrlOptional& ThisModelType::
    ManufacturerUrl () const
    {
      return this->ManufacturerUrl_;
    }

    ThisModelType::ManufacturerUrlOptional& ThisModelType::
    ManufacturerUrl ()
    {
      return this->ManufacturerUrl_;
    }

    void ThisModelType::
    ManufacturerUrl (const ManufacturerUrlType& x)
    {
      this->ManufacturerUrl_.set (x);
    }

    void ThisModelType::
    ManufacturerUrl (const ManufacturerUrlOptional& x)
    {
      this->ManufacturerUrl_ = x;
    }

    void ThisModelType::
    ManufacturerUrl (::std::unique_ptr< ManufacturerUrlType > x)
    {
      this->ManufacturerUrl_.set (std::move (x));
    }

    const ThisModelType::ModelNameSequence& ThisModelType::
    ModelName () const
    {
      return this->ModelName_;
    }

    ThisModelType::ModelNameSequence& ThisModelType::
    ModelName ()
    {
      return this->ModelName_;
    }

    void ThisModelType::
    ModelName (const ModelNameSequence& s)
    {
      this->ModelName_ = s;
    }

    const ThisModelType::ModelNumberOptional& ThisModelType::
    ModelNumber () const
    {
      return this->ModelNumber_;
    }

    ThisModelType::ModelNumberOptional& ThisModelType::
    ModelNumber ()
    {
      return this->ModelNumber_;
    }

    void ThisModelType::
    ModelNumber (const ModelNumberType& x)
    {
      this->ModelNumber_.set (x);
    }

    void ThisModelType::
    ModelNumber (const ModelNumberOptional& x)
    {
      this->ModelNumber_ = x;
    }

    void ThisModelType::
    ModelNumber (::std::unique_ptr< ModelNumberType > x)
    {
      this->ModelNumber_.set (std::move (x));
    }

    const ThisModelType::ModelUrlOptional& ThisModelType::
    ModelUrl () const
    {
      return this->ModelUrl_;
    }

    ThisModelType::ModelUrlOptional& ThisModelType::
    ModelUrl ()
    {
      return this->ModelUrl_;
    }

    void ThisModelType::
    ModelUrl (const ModelUrlType& x)
    {
      this->ModelUrl_.set (x);
    }

    void ThisModelType::
    ModelUrl (const ModelUrlOptional& x)
    {
      this->ModelUrl_ = x;
    }

    void ThisModelType::
    ModelUrl (::std::unique_ptr< ModelUrlType > x)
    {
      this->ModelUrl_.set (std::move (x));
    }

    const ThisModelType::PresentationUrlOptional& ThisModelType::
    PresentationUrl () const
    {
      return this->PresentationUrl_;
    }

    ThisModelType::PresentationUrlOptional& ThisModelType::
    PresentationUrl ()
    {
      return this->PresentationUrl_;
    }

    void ThisModelType::
    PresentationUrl (const PresentationUrlType& x)
    {
      this->PresentationUrl_.set (x);
    }

    void ThisModelType::
    PresentationUrl (const PresentationUrlOptional& x)
    {
      this->PresentationUrl_ = x;
    }

    void ThisModelType::
    PresentationUrl (::std::unique_ptr< PresentationUrlType > x)
    {
      this->PresentationUrl_.set (std::move (x));
    }


    // ThisDeviceType
    // 

    const ThisDeviceType::FriendlyNameSequence& ThisDeviceType::
    FriendlyName () const
    {
      return this->FriendlyName_;
    }

    ThisDeviceType::FriendlyNameSequence& ThisDeviceType::
    FriendlyName ()
    {
      return this->FriendlyName_;
    }

    void ThisDeviceType::
    FriendlyName (const FriendlyNameSequence& s)
    {
      this->FriendlyName_ = s;
    }

    const ThisDeviceType::FirmwareVersionOptional& ThisDeviceType::
    FirmwareVersion () const
    {
      return this->FirmwareVersion_;
    }

    ThisDeviceType::FirmwareVersionOptional& ThisDeviceType::
    FirmwareVersion ()
    {
      return this->FirmwareVersion_;
    }

    void ThisDeviceType::
    FirmwareVersion (const FirmwareVersionType& x)
    {
      this->FirmwareVersion_.set (x);
    }

    void ThisDeviceType::
    FirmwareVersion (const FirmwareVersionOptional& x)
    {
      this->FirmwareVersion_ = x;
    }

    void ThisDeviceType::
    FirmwareVersion (::std::unique_ptr< FirmwareVersionType > x)
    {
      this->FirmwareVersion_.set (std::move (x));
    }

    const ThisDeviceType::SerialNumberOptional& ThisDeviceType::
    SerialNumber () const
    {
      return this->SerialNumber_;
    }

    ThisDeviceType::SerialNumberOptional& ThisDeviceType::
    SerialNumber ()
    {
      return this->SerialNumber_;
    }

    void ThisDeviceType::
    SerialNumber (const SerialNumberType& x)
    {
      this->SerialNumber_.set (x);
    }

    void ThisDeviceType::
    SerialNumber (const SerialNumberOptional& x)
    {
      this->SerialNumber_ = x;
    }

    void ThisDeviceType::
    SerialNumber (::std::unique_ptr< SerialNumberType > x)
    {
      this->SerialNumber_.set (std::move (x));
    }


    // LocalizedStringType
    // 


    // DeviceRelationshipTypes
    //

    DeviceRelationshipTypes::
    DeviceRelationshipTypes (const char* s)
    : ::xml_schema::String (s)
    {
    }

    DeviceRelationshipTypes::
    DeviceRelationshipTypes (const ::std::string& s)
    : ::xml_schema::String (s)
    {
    }

    DeviceRelationshipTypes::
    DeviceRelationshipTypes (const DeviceRelationshipTypes& o,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (o, f, c)
    {
    }

    // DeviceRelationshipTypeURIs
    // 

    DeviceRelationshipTypeURIs::
    DeviceRelationshipTypeURIs (const ::xml_schema::Uri& v)
    : ::xml_schema::Uri (v)
    {
    }

    DeviceRelationshipTypeURIs::
    DeviceRelationshipTypeURIs (const DeviceRelationshipTypeURIs& v,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::Uri (v, f, c)
    {
    }


    // DeviceMetadataDialectURIs
    // 

    DeviceMetadataDialectURIs::
    DeviceMetadataDialectURIs (const ::xml_schema::Uri& v)
    : ::xml_schema::Uri (v)
    {
    }

    DeviceMetadataDialectURIs::
    DeviceMetadataDialectURIs (const DeviceMetadataDialectURIs& v,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::Uri (v, f, c)
    {
    }


    // DeviceEventingFilterDialects
    //

    DeviceEventingFilterDialects::
    DeviceEventingFilterDialects (const char* s)
    : ::xml_schema::String (s)
    {
    }

    DeviceEventingFilterDialects::
    DeviceEventingFilterDialects (const ::std::string& s)
    : ::xml_schema::String (s)
    {
    }

    DeviceEventingFilterDialects::
    DeviceEventingFilterDialects (const DeviceEventingFilterDialects& o,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::String (o, f, c)
    {
    }

    // DeviceEventingFilterDialectURIs
    // 

    DeviceEventingFilterDialectURIs::
    DeviceEventingFilterDialectURIs (const ::xml_schema::Uri& v)
    : ::xml_schema::Uri (v)
    {
    }

    DeviceEventingFilterDialectURIs::
    DeviceEventingFilterDialectURIs (const DeviceEventingFilterDialectURIs& v,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::Uri (v, f, c)
    {
    }


    // DeviceActionURIs
    // 

    DeviceActionURIs::
    DeviceActionURIs (const ::xml_schema::Uri& v)
    : ::xml_schema::Uri (v)
    {
    }

    DeviceActionURIs::
    DeviceActionURIs (const DeviceActionURIs& v,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Uri (v, f, c)
    {
    }


    // DeviceSoapFaultSubcodes
    //

    DeviceSoapFaultSubcodes::
    DeviceSoapFaultSubcodes (const char* s)
    : ::xml_schema::String (s)
    {
    }

    DeviceSoapFaultSubcodes::
    DeviceSoapFaultSubcodes (const ::std::string& s)
    : ::xml_schema::String (s)
    {
    }

    DeviceSoapFaultSubcodes::
    DeviceSoapFaultSubcodes (const DeviceSoapFaultSubcodes& o,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (o, f, c)
    {
    }

    // DeviceSoapFaultSubcodeQNames
    // 

    DeviceSoapFaultSubcodeQNames::
    DeviceSoapFaultSubcodeQNames (const ::xml_schema::Qname& v)
    : ::xml_schema::Qname (v)
    {
    }

    DeviceSoapFaultSubcodeQNames::
    DeviceSoapFaultSubcodeQNames (const DeviceSoapFaultSubcodeQNames& v,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::Qname (v, f, c)
    {
    }


    // HostServiceType
    // 

    const HostServiceType::EndpointReferenceType& HostServiceType::
    EndpointReference () const
    {
      return this->EndpointReference_.get ();
    }

    HostServiceType::EndpointReferenceType& HostServiceType::
    EndpointReference ()
    {
      return this->EndpointReference_.get ();
    }

    void HostServiceType::
    EndpointReference (const EndpointReferenceType& x)
    {
      this->EndpointReference_.set (x);
    }

    void HostServiceType::
    EndpointReference (::std::unique_ptr< EndpointReferenceType > x)
    {
      this->EndpointReference_.set (std::move (x));
    }

    const HostServiceType::TypesOptional& HostServiceType::
    Types () const
    {
      return this->Types_;
    }

    HostServiceType::TypesOptional& HostServiceType::
    Types ()
    {
      return this->Types_;
    }

    void HostServiceType::
    Types (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void HostServiceType::
    Types (const TypesOptional& x)
    {
      this->Types_ = x;
    }

    void HostServiceType::
    Types (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }


    // HostedServiceType
    // 

    const HostedServiceType::EndpointReferenceSequence& HostedServiceType::
    EndpointReference () const
    {
      return this->EndpointReference_;
    }

    HostedServiceType::EndpointReferenceSequence& HostedServiceType::
    EndpointReference ()
    {
      return this->EndpointReference_;
    }

    void HostedServiceType::
    EndpointReference (const EndpointReferenceSequence& s)
    {
      this->EndpointReference_ = s;
    }

    const HostedServiceType::TypesType& HostedServiceType::
    Types () const
    {
      return this->Types_.get ();
    }

    HostedServiceType::TypesType& HostedServiceType::
    Types ()
    {
      return this->Types_.get ();
    }

    void HostedServiceType::
    Types (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void HostedServiceType::
    Types (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }

    const HostedServiceType::ServiceIdType& HostedServiceType::
    ServiceId () const
    {
      return this->ServiceId_.get ();
    }

    HostedServiceType::ServiceIdType& HostedServiceType::
    ServiceId ()
    {
      return this->ServiceId_.get ();
    }

    void HostedServiceType::
    ServiceId (const ServiceIdType& x)
    {
      this->ServiceId_.set (x);
    }

    void HostedServiceType::
    ServiceId (::std::unique_ptr< ServiceIdType > x)
    {
      this->ServiceId_.set (std::move (x));
    }


    // QNameListType
    //

    QNameListType::
    QNameListType ()
    : ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (this)
    {
    }

    QNameListType::
    QNameListType (size_type n, const ::xml_schema::Qname& x)
    : ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (n, x, this)
    {
    }

    QNameListType::
    QNameListType (const QNameListType& o,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (o, f, this)
    {
    }

    // DiscoveryTypeValues
    // 

    DiscoveryTypeValues::
    DiscoveryTypeValues (const ::xml_schema::Qname& v)
    : ::xml_schema::Qname (v)
    {
    }

    DiscoveryTypeValues::
    DiscoveryTypeValues (const DiscoveryTypeValues& v,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Qname (v, f, c)
    {
    }


    // AssertionType
    // 


    // Relationship
    // 

    const Relationship::HostType& Relationship::
    Host () const
    {
      return this->Host_.get ();
    }

    Relationship::HostType& Relationship::
    Host ()
    {
      return this->Host_.get ();
    }

    void Relationship::
    Host (const HostType& x)
    {
      this->Host_.set (x);
    }

    void Relationship::
    Host (::std::unique_ptr< HostType > x)
    {
      this->Host_.set (std::move (x));
    }

    const Relationship::HostedSequence& Relationship::
    Hosted () const
    {
      return this->Hosted_;
    }

    Relationship::HostedSequence& Relationship::
    Hosted ()
    {
      return this->Hosted_;
    }

    void Relationship::
    Hosted (const HostedSequence& s)
    {
      this->Hosted_ = s;
    }

    const Relationship::TypeType& Relationship::
    Type () const
    {
      return this->Type_.get ();
    }

    Relationship::TypeType& Relationship::
    Type ()
    {
      return this->Type_.get ();
    }

    void Relationship::
    Type (const TypeType& x)
    {
      this->Type_.set (x);
    }

    void Relationship::
    Type (::std::unique_ptr< TypeType > x)
    {
      this->Type_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace WS
{
  namespace DPWS
  {
    // ThisModelType
    //

    ThisModelType::
    ThisModelType ()
    : ::xml_schema::Type (),
      Manufacturer_ (this),
      ManufacturerUrl_ (this),
      ModelName_ (this),
      ModelNumber_ (this),
      ModelUrl_ (this),
      PresentationUrl_ (this)
    {
    }

    ThisModelType::
    ThisModelType (const ThisModelType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Manufacturer_ (x.Manufacturer_, f, this),
      ManufacturerUrl_ (x.ManufacturerUrl_, f, this),
      ModelName_ (x.ModelName_, f, this),
      ModelNumber_ (x.ModelNumber_, f, this),
      ModelUrl_ (x.ModelUrl_, f, this),
      PresentationUrl_ (x.PresentationUrl_, f, this)
    {
    }

    ThisModelType::
    ThisModelType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Manufacturer_ (this),
      ManufacturerUrl_ (this),
      ModelName_ (this),
      ModelNumber_ (this),
      ModelUrl_ (this),
      PresentationUrl_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThisModelType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Manufacturer
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Manufacturer",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< ManufacturerType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ManufacturerType > r (
              dynamic_cast< ManufacturerType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Manufacturer_.push_back (::std::move (r));
            continue;
          }
        }

        // ManufacturerUrl
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ManufacturerUrl",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< ManufacturerUrlType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->ManufacturerUrl_)
            {
              ::std::unique_ptr< ManufacturerUrlType > r (
                dynamic_cast< ManufacturerUrlType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->ManufacturerUrl_.set (::std::move (r));
              continue;
            }
          }
        }

        // ModelName
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ModelName",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< ModelNameType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ModelNameType > r (
              dynamic_cast< ModelNameType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ModelName_.push_back (::std::move (r));
            continue;
          }
        }

        // ModelNumber
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ModelNumber",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< ModelNumberType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->ModelNumber_)
            {
              ::std::unique_ptr< ModelNumberType > r (
                dynamic_cast< ModelNumberType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->ModelNumber_.set (::std::move (r));
              continue;
            }
          }
        }

        // ModelUrl
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ModelUrl",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< ModelUrlType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->ModelUrl_)
            {
              ::std::unique_ptr< ModelUrlType > r (
                dynamic_cast< ModelUrlType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->ModelUrl_.set (::std::move (r));
              continue;
            }
          }
        }

        // PresentationUrl
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "PresentationUrl",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< PresentationUrlType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->PresentationUrl_)
            {
              ::std::unique_ptr< PresentationUrlType > r (
                dynamic_cast< PresentationUrlType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->PresentationUrl_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    ThisModelType* ThisModelType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ThisModelType (*this, f, c);
    }

    ThisModelType& ThisModelType::
    operator= (const ThisModelType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->Manufacturer_ = x.Manufacturer_;
        this->ManufacturerUrl_ = x.ManufacturerUrl_;
        this->ModelName_ = x.ModelName_;
        this->ModelNumber_ = x.ModelNumber_;
        this->ModelUrl_ = x.ModelUrl_;
        this->PresentationUrl_ = x.PresentationUrl_;
      }

      return *this;
    }

    ThisModelType::
    ~ThisModelType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ThisModelType >
    _xsd_ThisModelType_type_factory_init (
      "ThisModelType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // ThisDeviceType
    //

    ThisDeviceType::
    ThisDeviceType ()
    : ::xml_schema::Type (),
      FriendlyName_ (this),
      FirmwareVersion_ (this),
      SerialNumber_ (this)
    {
    }

    ThisDeviceType::
    ThisDeviceType (const ThisDeviceType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      FriendlyName_ (x.FriendlyName_, f, this),
      FirmwareVersion_ (x.FirmwareVersion_, f, this),
      SerialNumber_ (x.SerialNumber_, f, this)
    {
    }

    ThisDeviceType::
    ThisDeviceType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      FriendlyName_ (this),
      FirmwareVersion_ (this),
      SerialNumber_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThisDeviceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FriendlyName
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "FriendlyName",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< FriendlyNameType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< FriendlyNameType > r (
              dynamic_cast< FriendlyNameType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FriendlyName_.push_back (::std::move (r));
            continue;
          }
        }

        // FirmwareVersion
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "FirmwareVersion",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< FirmwareVersionType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->FirmwareVersion_)
            {
              ::std::unique_ptr< FirmwareVersionType > r (
                dynamic_cast< FirmwareVersionType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->FirmwareVersion_.set (::std::move (r));
              continue;
            }
          }
        }

        // SerialNumber
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "SerialNumber",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< SerialNumberType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->SerialNumber_)
            {
              ::std::unique_ptr< SerialNumberType > r (
                dynamic_cast< SerialNumberType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->SerialNumber_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    ThisDeviceType* ThisDeviceType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ThisDeviceType (*this, f, c);
    }

    ThisDeviceType& ThisDeviceType::
    operator= (const ThisDeviceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->FriendlyName_ = x.FriendlyName_;
        this->FirmwareVersion_ = x.FirmwareVersion_;
        this->SerialNumber_ = x.SerialNumber_;
      }

      return *this;
    }

    ThisDeviceType::
    ~ThisDeviceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ThisDeviceType >
    _xsd_ThisDeviceType_type_factory_init (
      "ThisDeviceType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // LocalizedStringType
    //

    LocalizedStringType::
    LocalizedStringType ()
    : ::xml_schema::String ()
    {
    }

    LocalizedStringType::
    LocalizedStringType (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    LocalizedStringType::
    LocalizedStringType (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    LocalizedStringType::
    LocalizedStringType (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    LocalizedStringType::
    LocalizedStringType (const LocalizedStringType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    LocalizedStringType::
    LocalizedStringType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    LocalizedStringType* LocalizedStringType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class LocalizedStringType (*this, f, c);
    }

    LocalizedStringType::
    ~LocalizedStringType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, LocalizedStringType >
    _xsd_LocalizedStringType_type_factory_init (
      "LocalizedStringType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DeviceRelationshipTypes
    //

    DeviceRelationshipTypes::
    DeviceRelationshipTypes (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    DeviceRelationshipTypes::
    DeviceRelationshipTypes (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    DeviceRelationshipTypes::
    DeviceRelationshipTypes (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    DeviceRelationshipTypes* DeviceRelationshipTypes::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DeviceRelationshipTypes (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DeviceRelationshipTypes >
    _xsd_DeviceRelationshipTypes_type_factory_init (
      "DeviceRelationshipTypes",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DeviceRelationshipTypeURIs
    //

    DeviceRelationshipTypeURIs::
    DeviceRelationshipTypeURIs (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::Uri (e, f, c)
    {
    }

    DeviceRelationshipTypeURIs::
    DeviceRelationshipTypeURIs (const ::xercesc::DOMAttr& a,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::Uri (a, f, c)
    {
    }

    DeviceRelationshipTypeURIs::
    DeviceRelationshipTypeURIs (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::Uri (s, e, f, c)
    {
    }

    DeviceRelationshipTypeURIs* DeviceRelationshipTypeURIs::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DeviceRelationshipTypeURIs (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DeviceRelationshipTypeURIs >
    _xsd_DeviceRelationshipTypeURIs_type_factory_init (
      "DeviceRelationshipTypeURIs",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DeviceMetadataDialectURIs
    //

    DeviceMetadataDialectURIs::
    DeviceMetadataDialectURIs (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::Uri (e, f, c)
    {
    }

    DeviceMetadataDialectURIs::
    DeviceMetadataDialectURIs (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::Uri (a, f, c)
    {
    }

    DeviceMetadataDialectURIs::
    DeviceMetadataDialectURIs (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::Uri (s, e, f, c)
    {
    }

    DeviceMetadataDialectURIs* DeviceMetadataDialectURIs::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DeviceMetadataDialectURIs (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DeviceMetadataDialectURIs >
    _xsd_DeviceMetadataDialectURIs_type_factory_init (
      "DeviceMetadataDialectURIs",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DeviceEventingFilterDialects
    //

    DeviceEventingFilterDialects::
    DeviceEventingFilterDialects (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    DeviceEventingFilterDialects::
    DeviceEventingFilterDialects (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    DeviceEventingFilterDialects::
    DeviceEventingFilterDialects (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    DeviceEventingFilterDialects* DeviceEventingFilterDialects::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DeviceEventingFilterDialects (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DeviceEventingFilterDialects >
    _xsd_DeviceEventingFilterDialects_type_factory_init (
      "DeviceEventingFilterDialects",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DeviceEventingFilterDialectURIs
    //

    DeviceEventingFilterDialectURIs::
    DeviceEventingFilterDialectURIs (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::Uri (e, f, c)
    {
    }

    DeviceEventingFilterDialectURIs::
    DeviceEventingFilterDialectURIs (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::Uri (a, f, c)
    {
    }

    DeviceEventingFilterDialectURIs::
    DeviceEventingFilterDialectURIs (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::Uri (s, e, f, c)
    {
    }

    DeviceEventingFilterDialectURIs* DeviceEventingFilterDialectURIs::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DeviceEventingFilterDialectURIs (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DeviceEventingFilterDialectURIs >
    _xsd_DeviceEventingFilterDialectURIs_type_factory_init (
      "DeviceEventingFilterDialectURIs",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DeviceActionURIs
    //

    DeviceActionURIs::
    DeviceActionURIs (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Uri (e, f, c)
    {
    }

    DeviceActionURIs::
    DeviceActionURIs (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Uri (a, f, c)
    {
    }

    DeviceActionURIs::
    DeviceActionURIs (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Uri (s, e, f, c)
    {
    }

    DeviceActionURIs* DeviceActionURIs::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DeviceActionURIs (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DeviceActionURIs >
    _xsd_DeviceActionURIs_type_factory_init (
      "DeviceActionURIs",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DeviceSoapFaultSubcodes
    //

    DeviceSoapFaultSubcodes::
    DeviceSoapFaultSubcodes (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    DeviceSoapFaultSubcodes::
    DeviceSoapFaultSubcodes (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    DeviceSoapFaultSubcodes::
    DeviceSoapFaultSubcodes (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    DeviceSoapFaultSubcodes* DeviceSoapFaultSubcodes::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DeviceSoapFaultSubcodes (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DeviceSoapFaultSubcodes >
    _xsd_DeviceSoapFaultSubcodes_type_factory_init (
      "DeviceSoapFaultSubcodes",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DeviceSoapFaultSubcodeQNames
    //

    DeviceSoapFaultSubcodeQNames::
    DeviceSoapFaultSubcodeQNames (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::Qname (e, f, c)
    {
    }

    DeviceSoapFaultSubcodeQNames::
    DeviceSoapFaultSubcodeQNames (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::Qname (a, f, c)
    {
    }

    DeviceSoapFaultSubcodeQNames::
    DeviceSoapFaultSubcodeQNames (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::Qname (s, e, f, c)
    {
    }

    DeviceSoapFaultSubcodeQNames* DeviceSoapFaultSubcodeQNames::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DeviceSoapFaultSubcodeQNames (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DeviceSoapFaultSubcodeQNames >
    _xsd_DeviceSoapFaultSubcodeQNames_type_factory_init (
      "DeviceSoapFaultSubcodeQNames",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // HostServiceType
    //

    HostServiceType::
    HostServiceType (const EndpointReferenceType& EndpointReference)
    : ::xml_schema::Type (),
      EndpointReference_ (EndpointReference, this),
      Types_ (this)
    {
    }

    HostServiceType::
    HostServiceType (::std::unique_ptr< EndpointReferenceType > EndpointReference)
    : ::xml_schema::Type (),
      EndpointReference_ (std::move (EndpointReference), this),
      Types_ (this)
    {
    }

    HostServiceType::
    HostServiceType (const HostServiceType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this),
      Types_ (x.Types_, f, this)
    {
    }

    HostServiceType::
    HostServiceType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this),
      Types_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void HostServiceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EndpointReference_.present ())
            {
              ::std::unique_ptr< EndpointReferenceType > r (
                dynamic_cast< EndpointReferenceType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->EndpointReference_.set (::std::move (r));
              continue;
            }
          }
        }

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Types_)
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!EndpointReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndpointReference",
          "http://www.w3.org/2005/08/addressing");
      }
    }

    HostServiceType* HostServiceType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class HostServiceType (*this, f, c);
    }

    HostServiceType& HostServiceType::
    operator= (const HostServiceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
        this->Types_ = x.Types_;
      }

      return *this;
    }

    HostServiceType::
    ~HostServiceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, HostServiceType >
    _xsd_HostServiceType_type_factory_init (
      "HostServiceType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // HostedServiceType
    //

    HostedServiceType::
    HostedServiceType (const TypesType& Types,
                       const ServiceIdType& ServiceId)
    : ::xml_schema::Type (),
      EndpointReference_ (this),
      Types_ (Types, this),
      ServiceId_ (ServiceId, this)
    {
    }

    HostedServiceType::
    HostedServiceType (::std::unique_ptr< TypesType > Types,
                       ::std::unique_ptr< ServiceIdType > ServiceId)
    : ::xml_schema::Type (),
      EndpointReference_ (this),
      Types_ (std::move (Types), this),
      ServiceId_ (std::move (ServiceId), this)
    {
    }

    HostedServiceType::
    HostedServiceType (const HostedServiceType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this),
      Types_ (x.Types_, f, this),
      ServiceId_ (x.ServiceId_, f, this)
    {
    }

    HostedServiceType::
    HostedServiceType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this),
      Types_ (this),
      ServiceId_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void HostedServiceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< EndpointReferenceType > r (
              dynamic_cast< EndpointReferenceType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->EndpointReference_.push_back (::std::move (r));
            continue;
          }
        }

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Types_.present ())
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        // ServiceId
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ServiceId",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< ServiceIdType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!ServiceId_.present ())
            {
              ::std::unique_ptr< ServiceIdType > r (
                dynamic_cast< ServiceIdType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->ServiceId_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!Types_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Types",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
      }

      if (!ServiceId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ServiceId",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
      }
    }

    HostedServiceType* HostedServiceType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class HostedServiceType (*this, f, c);
    }

    HostedServiceType& HostedServiceType::
    operator= (const HostedServiceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
        this->Types_ = x.Types_;
        this->ServiceId_ = x.ServiceId_;
      }

      return *this;
    }

    HostedServiceType::
    ~HostedServiceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, HostedServiceType >
    _xsd_HostedServiceType_type_factory_init (
      "HostedServiceType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // QNameListType
    //

    QNameListType::
    QNameListType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (e, f, this)
    {
    }

    QNameListType::
    QNameListType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (a, f, this)
    {
    }

    QNameListType::
    QNameListType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (s, e, f, this)
    {
    }

    QNameListType* QNameListType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class QNameListType (*this, f, c);
    }

    QNameListType::
    ~QNameListType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, QNameListType >
    _xsd_QNameListType_type_factory_init (
      "QNameListType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DiscoveryTypeValues
    //

    DiscoveryTypeValues::
    DiscoveryTypeValues (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Qname (e, f, c)
    {
    }

    DiscoveryTypeValues::
    DiscoveryTypeValues (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Qname (a, f, c)
    {
    }

    DiscoveryTypeValues::
    DiscoveryTypeValues (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Qname (s, e, f, c)
    {
    }

    DiscoveryTypeValues* DiscoveryTypeValues::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DiscoveryTypeValues (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DiscoveryTypeValues >
    _xsd_DiscoveryTypeValues_type_factory_init (
      "DiscoveryTypeValues",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // AssertionType
    //

    AssertionType::
    AssertionType ()
    : ::xml_schema::Type ()
    {
    }

    AssertionType::
    AssertionType (const ::xml_schema::Type& _xsd_Type_base)
    : ::xml_schema::Type (_xsd_Type_base)
    {
    }

    AssertionType::
    AssertionType (const AssertionType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c)
    {
    }

    AssertionType::
    AssertionType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f, c)
    {
    }

    AssertionType* AssertionType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class AssertionType (*this, f, c);
    }

    AssertionType::
    ~AssertionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, AssertionType >
    _xsd_AssertionType_type_factory_init (
      "AssertionType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // Relationship
    //

    Relationship::
    Relationship (const HostType& Host,
                  const TypeType& Type)
    : ::xml_schema::Type (),
      Host_ (Host, this),
      Hosted_ (this),
      Type_ (Type, this)
    {
    }

    Relationship::
    Relationship (::std::unique_ptr< HostType > Host,
                  const TypeType& Type)
    : ::xml_schema::Type (),
      Host_ (std::move (Host), this),
      Hosted_ (this),
      Type_ (Type, this)
    {
    }

    Relationship::
    Relationship (const Relationship& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Host_ (x.Host_, f, this),
      Hosted_ (x.Hosted_, f, this),
      Type_ (x.Type_, f, this)
    {
    }

    Relationship::
    Relationship (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Host_ (this),
      Hosted_ (this),
      Type_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Relationship::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Host
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Host",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< HostType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Host_.present ())
            {
              ::std::unique_ptr< HostType > r (
                dynamic_cast< HostType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Host_.set (::std::move (r));
              continue;
            }
          }
        }

        // Hosted
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Hosted",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< HostedType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< HostedType > r (
              dynamic_cast< HostedType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Hosted_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Host_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Host",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Type" && n.namespace_ ().empty ())
        {
          this->Type_.set (TypeTraits::create (i, f, this));
          continue;
        }
      }

      if (!Type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "Type",
          "");
      }
    }

    Relationship* Relationship::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Relationship (*this, f, c);
    }

    Relationship& Relationship::
    operator= (const Relationship& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->Host_ = x.Host_;
        this->Hosted_ = x.Hosted_;
        this->Type_ = x.Type_;
      }

      return *this;
    }

    Relationship::
    ~Relationship ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace WS
{
  namespace DPWS
  {
    ::std::unique_ptr< ::WS::DPWS::ThisModelType >
    ThisModel (const ::std::string& u,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DPWS::ThisModelType > (
        ::WS::DPWS::ThisModel (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::ThisModelType >
    ThisModel (const ::std::string& u,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::ThisModelType > (
        ::WS::DPWS::ThisModel (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::ThisModelType >
    ThisModel (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::ThisModelType > (
        ::WS::DPWS::ThisModel (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::ThisModelType >
    ThisModel (::std::istream& is,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::ThisModel (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::ThisModelType >
    ThisModel (::std::istream& is,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::ThisModel (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::ThisModelType >
    ThisModel (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::ThisModel (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::ThisModelType >
    ThisModel (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::ThisModel (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::ThisModelType >
    ThisModel (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::ThisModel (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::ThisModelType >
    ThisModel (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::ThisModel (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::ThisModelType >
    ThisModel (::xercesc::InputSource& i,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DPWS::ThisModelType > (
        ::WS::DPWS::ThisModel (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::ThisModelType >
    ThisModel (::xercesc::InputSource& i,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::ThisModelType > (
        ::WS::DPWS::ThisModel (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::ThisModelType >
    ThisModel (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::ThisModelType > (
        ::WS::DPWS::ThisModel (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::ThisModelType >
    ThisModel (const ::xercesc::DOMDocument& doc,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DPWS::ThisModelType > (
          ::WS::DPWS::ThisModel (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ThisModel",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DPWS::ThisModelType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DPWS::ThisModelType > r (
          dynamic_cast< ::WS::DPWS::ThisModelType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ThisModel",
        "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
    }

    ::std::unique_ptr< ::WS::DPWS::ThisModelType >
    ThisModel (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ThisModel",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DPWS::ThisModelType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DPWS::ThisModelType > r (
          dynamic_cast< ::WS::DPWS::ThisModelType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ThisModel",
        "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
    }

    ::std::unique_ptr< ::WS::DPWS::ThisDeviceType >
    ThisDevice (const ::std::string& u,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DPWS::ThisDeviceType > (
        ::WS::DPWS::ThisDevice (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::ThisDeviceType >
    ThisDevice (const ::std::string& u,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::ThisDeviceType > (
        ::WS::DPWS::ThisDevice (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::ThisDeviceType >
    ThisDevice (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::ThisDeviceType > (
        ::WS::DPWS::ThisDevice (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::ThisDeviceType >
    ThisDevice (::std::istream& is,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::ThisDevice (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::ThisDeviceType >
    ThisDevice (::std::istream& is,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::ThisDevice (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::ThisDeviceType >
    ThisDevice (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::ThisDevice (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::ThisDeviceType >
    ThisDevice (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::ThisDevice (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::ThisDeviceType >
    ThisDevice (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::ThisDevice (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::ThisDeviceType >
    ThisDevice (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::ThisDevice (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::ThisDeviceType >
    ThisDevice (::xercesc::InputSource& i,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DPWS::ThisDeviceType > (
        ::WS::DPWS::ThisDevice (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::ThisDeviceType >
    ThisDevice (::xercesc::InputSource& i,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::ThisDeviceType > (
        ::WS::DPWS::ThisDevice (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::ThisDeviceType >
    ThisDevice (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::ThisDeviceType > (
        ::WS::DPWS::ThisDevice (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::ThisDeviceType >
    ThisDevice (const ::xercesc::DOMDocument& doc,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DPWS::ThisDeviceType > (
          ::WS::DPWS::ThisDevice (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ThisDevice",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DPWS::ThisDeviceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DPWS::ThisDeviceType > r (
          dynamic_cast< ::WS::DPWS::ThisDeviceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ThisDevice",
        "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
    }

    ::std::unique_ptr< ::WS::DPWS::ThisDeviceType >
    ThisDevice (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ThisDevice",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DPWS::ThisDeviceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DPWS::ThisDeviceType > r (
          dynamic_cast< ::WS::DPWS::ThisDeviceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ThisDevice",
        "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
    }

    ::std::unique_ptr< ::WS::DPWS::Relationship >
    Relationship_ (const ::std::string& u,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DPWS::Relationship > (
        ::WS::DPWS::Relationship_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::Relationship >
    Relationship_ (const ::std::string& u,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::Relationship > (
        ::WS::DPWS::Relationship_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::Relationship >
    Relationship_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::Relationship > (
        ::WS::DPWS::Relationship_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::Relationship >
    Relationship_ (::std::istream& is,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::Relationship_ (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::Relationship >
    Relationship_ (::std::istream& is,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::Relationship_ (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::Relationship >
    Relationship_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::Relationship_ (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::Relationship >
    Relationship_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::Relationship_ (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::Relationship >
    Relationship_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::Relationship_ (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::Relationship >
    Relationship_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::Relationship_ (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::Relationship >
    Relationship_ (::xercesc::InputSource& i,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DPWS::Relationship > (
        ::WS::DPWS::Relationship_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::Relationship >
    Relationship_ (::xercesc::InputSource& i,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::Relationship > (
        ::WS::DPWS::Relationship_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::Relationship >
    Relationship_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::Relationship > (
        ::WS::DPWS::Relationship_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::Relationship >
    Relationship_ (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DPWS::Relationship > (
          ::WS::DPWS::Relationship_ (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Relationship" &&
          n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01")
      {
        ::std::unique_ptr< ::WS::DPWS::Relationship > r (
          ::xsd::cxx::tree::traits< ::WS::DPWS::Relationship, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Relationship",
        "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
    }

    ::std::unique_ptr< ::WS::DPWS::Relationship >
    Relationship_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Relationship" &&
          n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01")
      {
        ::std::unique_ptr< ::WS::DPWS::Relationship > r (
          ::xsd::cxx::tree::traits< ::WS::DPWS::Relationship, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Relationship",
        "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
    }

    ::std::unique_ptr< ::WS::DPWS::HostServiceType >
    Host (const ::std::string& u,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DPWS::HostServiceType > (
        ::WS::DPWS::Host (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::HostServiceType >
    Host (const ::std::string& u,
          ::xml_schema::ErrorHandler& h,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::HostServiceType > (
        ::WS::DPWS::Host (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::HostServiceType >
    Host (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::HostServiceType > (
        ::WS::DPWS::Host (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::HostServiceType >
    Host (::std::istream& is,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::Host (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::HostServiceType >
    Host (::std::istream& is,
          ::xml_schema::ErrorHandler& h,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::Host (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::HostServiceType >
    Host (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::Host (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::HostServiceType >
    Host (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::Host (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::HostServiceType >
    Host (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::ErrorHandler& h,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::Host (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::HostServiceType >
    Host (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::Host (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::HostServiceType >
    Host (::xercesc::InputSource& i,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DPWS::HostServiceType > (
        ::WS::DPWS::Host (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::HostServiceType >
    Host (::xercesc::InputSource& i,
          ::xml_schema::ErrorHandler& h,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::HostServiceType > (
        ::WS::DPWS::Host (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::HostServiceType >
    Host (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::HostServiceType > (
        ::WS::DPWS::Host (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::HostServiceType >
    Host (const ::xercesc::DOMDocument& doc,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DPWS::HostServiceType > (
          ::WS::DPWS::Host (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Host",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DPWS::HostServiceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DPWS::HostServiceType > r (
          dynamic_cast< ::WS::DPWS::HostServiceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Host",
        "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
    }

    ::std::unique_ptr< ::WS::DPWS::HostServiceType >
    Host (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Host",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DPWS::HostServiceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DPWS::HostServiceType > r (
          dynamic_cast< ::WS::DPWS::HostServiceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Host",
        "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
    }

    ::std::unique_ptr< ::WS::DPWS::HostedServiceType >
    Hosted (const ::std::string& u,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DPWS::HostedServiceType > (
        ::WS::DPWS::Hosted (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::HostedServiceType >
    Hosted (const ::std::string& u,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::HostedServiceType > (
        ::WS::DPWS::Hosted (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::HostedServiceType >
    Hosted (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::HostedServiceType > (
        ::WS::DPWS::Hosted (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::HostedServiceType >
    Hosted (::std::istream& is,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::Hosted (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::HostedServiceType >
    Hosted (::std::istream& is,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::Hosted (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::HostedServiceType >
    Hosted (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::Hosted (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::HostedServiceType >
    Hosted (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::Hosted (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::HostedServiceType >
    Hosted (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::Hosted (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::HostedServiceType >
    Hosted (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::Hosted (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::HostedServiceType >
    Hosted (::xercesc::InputSource& i,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DPWS::HostedServiceType > (
        ::WS::DPWS::Hosted (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::HostedServiceType >
    Hosted (::xercesc::InputSource& i,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::HostedServiceType > (
        ::WS::DPWS::Hosted (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::HostedServiceType >
    Hosted (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::HostedServiceType > (
        ::WS::DPWS::Hosted (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::HostedServiceType >
    Hosted (const ::xercesc::DOMDocument& doc,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DPWS::HostedServiceType > (
          ::WS::DPWS::Hosted (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Hosted",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DPWS::HostedServiceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DPWS::HostedServiceType > r (
          dynamic_cast< ::WS::DPWS::HostedServiceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Hosted",
        "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
    }

    ::std::unique_ptr< ::WS::DPWS::HostedServiceType >
    Hosted (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Hosted",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DPWS::HostedServiceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DPWS::HostedServiceType > r (
          dynamic_cast< ::WS::DPWS::HostedServiceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Hosted",
        "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
    }

    ::std::unique_ptr< ::xml_schema::Uri >
    ServiceId (const ::std::string& u,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::xml_schema::Uri > (
        ::WS::DPWS::ServiceId (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::Uri >
    ServiceId (const ::std::string& u,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::xml_schema::Uri > (
        ::WS::DPWS::ServiceId (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::Uri >
    ServiceId (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::xml_schema::Uri > (
        ::WS::DPWS::ServiceId (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::Uri >
    ServiceId (::std::istream& is,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::ServiceId (isrc, f, p);
    }

    ::std::unique_ptr< ::xml_schema::Uri >
    ServiceId (::std::istream& is,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::ServiceId (isrc, h, f, p);
    }

    ::std::unique_ptr< ::xml_schema::Uri >
    ServiceId (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::ServiceId (isrc, h, f, p);
    }

    ::std::unique_ptr< ::xml_schema::Uri >
    ServiceId (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::ServiceId (isrc, f, p);
    }

    ::std::unique_ptr< ::xml_schema::Uri >
    ServiceId (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::ServiceId (isrc, h, f, p);
    }

    ::std::unique_ptr< ::xml_schema::Uri >
    ServiceId (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::ServiceId (isrc, h, f, p);
    }

    ::std::unique_ptr< ::xml_schema::Uri >
    ServiceId (::xercesc::InputSource& i,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::xml_schema::Uri > (
        ::WS::DPWS::ServiceId (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::Uri >
    ServiceId (::xercesc::InputSource& i,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::xml_schema::Uri > (
        ::WS::DPWS::ServiceId (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::Uri >
    ServiceId (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::xml_schema::Uri > (
        ::WS::DPWS::ServiceId (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::Uri >
    ServiceId (const ::xercesc::DOMDocument& doc,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::xml_schema::Uri > (
          ::WS::DPWS::ServiceId (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ServiceId",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::Uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::xml_schema::Uri > r (
          dynamic_cast< ::xml_schema::Uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ServiceId",
        "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
    }

    ::std::unique_ptr< ::xml_schema::Uri >
    ServiceId (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ServiceId",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::Uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::xml_schema::Uri > r (
          dynamic_cast< ::xml_schema::Uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ServiceId",
        "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
    }

    ::std::unique_ptr< ::WS::DPWS::QNameListType >
    Types (const ::std::string& u,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DPWS::QNameListType > (
        ::WS::DPWS::Types (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::QNameListType >
    Types (const ::std::string& u,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::QNameListType > (
        ::WS::DPWS::Types (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::QNameListType >
    Types (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::QNameListType > (
        ::WS::DPWS::Types (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::QNameListType >
    Types (::std::istream& is,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::Types (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::QNameListType >
    Types (::std::istream& is,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::Types (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::QNameListType >
    Types (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::Types (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::QNameListType >
    Types (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::Types (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::QNameListType >
    Types (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::Types (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::QNameListType >
    Types (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::Types (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::QNameListType >
    Types (::xercesc::InputSource& i,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DPWS::QNameListType > (
        ::WS::DPWS::Types (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::QNameListType >
    Types (::xercesc::InputSource& i,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::QNameListType > (
        ::WS::DPWS::Types (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::QNameListType >
    Types (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::QNameListType > (
        ::WS::DPWS::Types (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::QNameListType >
    Types (const ::xercesc::DOMDocument& doc,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DPWS::QNameListType > (
          ::WS::DPWS::Types (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Types",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DPWS::QNameListType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DPWS::QNameListType > r (
          dynamic_cast< ::WS::DPWS::QNameListType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Types",
        "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
    }

    ::std::unique_ptr< ::WS::DPWS::QNameListType >
    Types (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Types",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DPWS::QNameListType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DPWS::QNameListType > r (
          dynamic_cast< ::WS::DPWS::QNameListType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Types",
        "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
    }

    ::std::unique_ptr< ::WS::DPWS::AssertionType >
    Profile (const ::std::string& u,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DPWS::AssertionType > (
        ::WS::DPWS::Profile (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::AssertionType >
    Profile (const ::std::string& u,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::AssertionType > (
        ::WS::DPWS::Profile (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::AssertionType >
    Profile (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::AssertionType > (
        ::WS::DPWS::Profile (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::AssertionType >
    Profile (::std::istream& is,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::Profile (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::AssertionType >
    Profile (::std::istream& is,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::Profile (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::AssertionType >
    Profile (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DPWS::Profile (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::AssertionType >
    Profile (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::Profile (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::AssertionType >
    Profile (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::Profile (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::AssertionType >
    Profile (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DPWS::Profile (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DPWS::AssertionType >
    Profile (::xercesc::InputSource& i,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DPWS::AssertionType > (
        ::WS::DPWS::Profile (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::AssertionType >
    Profile (::xercesc::InputSource& i,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::AssertionType > (
        ::WS::DPWS::Profile (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::AssertionType >
    Profile (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DPWS::AssertionType > (
        ::WS::DPWS::Profile (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DPWS::AssertionType >
    Profile (const ::xercesc::DOMDocument& doc,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DPWS::AssertionType > (
          ::WS::DPWS::Profile (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Profile",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DPWS::AssertionType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DPWS::AssertionType > r (
          dynamic_cast< ::WS::DPWS::AssertionType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Profile",
        "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
    }

    ::std::unique_ptr< ::WS::DPWS::AssertionType >
    Profile (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Profile",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DPWS::AssertionType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DPWS::AssertionType > r (
          dynamic_cast< ::WS::DPWS::AssertionType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Profile",
        "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace WS
{
  namespace DPWS
  {
    void
    ThisModel (::std::ostream& o,
               const ::WS::DPWS::ThisModelType& s,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ThisModel (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ThisModel (::std::ostream& o,
               const ::WS::DPWS::ThisModelType& s,
               ::xml_schema::ErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ThisModel (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ThisModel (::std::ostream& o,
               const ::WS::DPWS::ThisModelType& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ThisModel (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ThisModel (::xercesc::XMLFormatTarget& t,
               const ::WS::DPWS::ThisModelType& s,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ThisModel (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ThisModel (::xercesc::XMLFormatTarget& t,
               const ::WS::DPWS::ThisModelType& s,
               ::xml_schema::ErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ThisModel (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ThisModel (::xercesc::XMLFormatTarget& t,
               const ::WS::DPWS::ThisModelType& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ThisModel (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ThisModel (::xercesc::DOMDocument& d,
               const ::WS::DPWS::ThisModelType& s,
               ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DPWS::ThisModelType) == typeid (s))
      {
        if (n.name () == "ThisModel" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "ThisModel",
            "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ThisModel",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    ThisModel (const ::WS::DPWS::ThisModelType& s,
               const ::xml_schema::NamespaceInfomap& m,
               ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DPWS::ThisModelType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "ThisModel",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ThisModel",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          m, s, f);
      }

      ::WS::DPWS::ThisModel (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThisModelType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Manufacturer
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (ThisModelType::ManufacturerConstIterator
             b (i.Manufacturer ().begin ()), n (i.Manufacturer ().end ());
             b != n; ++b)
        {
          if (typeid (ThisModelType::ManufacturerType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Manufacturer",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "Manufacturer",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, *b);
        }
      }

      // ManufacturerUrl
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.ManufacturerUrl ())
        {
          const ThisModelType::ManufacturerUrlType& x (*i.ManufacturerUrl ());
          if (typeid (ThisModelType::ManufacturerUrlType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ManufacturerUrl",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "ManufacturerUrl",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, x);
        }
      }

      // ModelName
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (ThisModelType::ModelNameConstIterator
             b (i.ModelName ().begin ()), n (i.ModelName ().end ());
             b != n; ++b)
        {
          if (typeid (ThisModelType::ModelNameType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ModelName",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "ModelName",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, *b);
        }
      }

      // ModelNumber
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.ModelNumber ())
        {
          const ThisModelType::ModelNumberType& x (*i.ModelNumber ());
          if (typeid (ThisModelType::ModelNumberType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ModelNumber",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "ModelNumber",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, x);
        }
      }

      // ModelUrl
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.ModelUrl ())
        {
          const ThisModelType::ModelUrlType& x (*i.ModelUrl ());
          if (typeid (ThisModelType::ModelUrlType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ModelUrl",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "ModelUrl",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, x);
        }
      }

      // PresentationUrl
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.PresentationUrl ())
        {
          const ThisModelType::PresentationUrlType& x (*i.PresentationUrl ());
          if (typeid (ThisModelType::PresentationUrlType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "PresentationUrl",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "PresentationUrl",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ThisModelType >
    _xsd_ThisModelType_type_serializer_init (
      "ThisModelType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    ThisDevice (::std::ostream& o,
                const ::WS::DPWS::ThisDeviceType& s,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ThisDevice (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ThisDevice (::std::ostream& o,
                const ::WS::DPWS::ThisDeviceType& s,
                ::xml_schema::ErrorHandler& h,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ThisDevice (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ThisDevice (::std::ostream& o,
                const ::WS::DPWS::ThisDeviceType& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ThisDevice (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ThisDevice (::xercesc::XMLFormatTarget& t,
                const ::WS::DPWS::ThisDeviceType& s,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ThisDevice (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ThisDevice (::xercesc::XMLFormatTarget& t,
                const ::WS::DPWS::ThisDeviceType& s,
                ::xml_schema::ErrorHandler& h,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ThisDevice (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ThisDevice (::xercesc::XMLFormatTarget& t,
                const ::WS::DPWS::ThisDeviceType& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ThisDevice (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ThisDevice (::xercesc::DOMDocument& d,
                const ::WS::DPWS::ThisDeviceType& s,
                ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DPWS::ThisDeviceType) == typeid (s))
      {
        if (n.name () == "ThisDevice" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "ThisDevice",
            "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ThisDevice",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    ThisDevice (const ::WS::DPWS::ThisDeviceType& s,
                const ::xml_schema::NamespaceInfomap& m,
                ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DPWS::ThisDeviceType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "ThisDevice",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ThisDevice",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          m, s, f);
      }

      ::WS::DPWS::ThisDevice (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThisDeviceType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // FriendlyName
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (ThisDeviceType::FriendlyNameConstIterator
             b (i.FriendlyName ().begin ()), n (i.FriendlyName ().end ());
             b != n; ++b)
        {
          if (typeid (ThisDeviceType::FriendlyNameType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "FriendlyName",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "FriendlyName",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, *b);
        }
      }

      // FirmwareVersion
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.FirmwareVersion ())
        {
          const ThisDeviceType::FirmwareVersionType& x (*i.FirmwareVersion ());
          if (typeid (ThisDeviceType::FirmwareVersionType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "FirmwareVersion",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "FirmwareVersion",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, x);
        }
      }

      // SerialNumber
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.SerialNumber ())
        {
          const ThisDeviceType::SerialNumberType& x (*i.SerialNumber ());
          if (typeid (ThisDeviceType::SerialNumberType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "SerialNumber",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "SerialNumber",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ThisDeviceType >
    _xsd_ThisDeviceType_type_serializer_init (
      "ThisDeviceType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const LocalizedStringType& i)
    {
      e << static_cast< const ::xml_schema::String& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LocalizedStringType >
    _xsd_LocalizedStringType_type_serializer_init (
      "LocalizedStringType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    Relationship_ (::std::ostream& o,
                   const ::WS::DPWS::Relationship& s,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Relationship_ (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Relationship_ (::std::ostream& o,
                   const ::WS::DPWS::Relationship& s,
                   ::xml_schema::ErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Relationship_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Relationship_ (::std::ostream& o,
                   const ::WS::DPWS::Relationship& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Relationship_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Relationship_ (::xercesc::XMLFormatTarget& t,
                   const ::WS::DPWS::Relationship& s,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Relationship_ (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Relationship_ (::xercesc::XMLFormatTarget& t,
                   const ::WS::DPWS::Relationship& s,
                   ::xml_schema::ErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Relationship_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Relationship_ (::xercesc::XMLFormatTarget& t,
                   const ::WS::DPWS::Relationship& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Relationship_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Relationship_ (::xercesc::DOMDocument& d,
                   const ::WS::DPWS::Relationship& s,
                   ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Relationship" &&
          n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "Relationship",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    Relationship_ (const ::WS::DPWS::Relationship& s,
                   const ::xml_schema::NamespaceInfomap& m,
                   ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "Relationship",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          m, f));

      ::WS::DPWS::Relationship_ (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const DeviceRelationshipTypes& i)
    {
      e << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DeviceRelationshipTypes& i)
    {
      a << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DeviceRelationshipTypes& i)
    {
      l << static_cast< const ::xml_schema::String& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DeviceRelationshipTypes >
    _xsd_DeviceRelationshipTypes_type_serializer_init (
      "DeviceRelationshipTypes",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const DeviceRelationshipTypeURIs& i)
    {
      e << static_cast< const ::xml_schema::Uri& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DeviceRelationshipTypeURIs& i)
    {
      a << static_cast< const ::xml_schema::Uri& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DeviceRelationshipTypeURIs& i)
    {
      l << static_cast< const ::xml_schema::Uri& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DeviceRelationshipTypeURIs >
    _xsd_DeviceRelationshipTypeURIs_type_serializer_init (
      "DeviceRelationshipTypeURIs",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const DeviceMetadataDialectURIs& i)
    {
      e << static_cast< const ::xml_schema::Uri& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DeviceMetadataDialectURIs& i)
    {
      a << static_cast< const ::xml_schema::Uri& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DeviceMetadataDialectURIs& i)
    {
      l << static_cast< const ::xml_schema::Uri& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DeviceMetadataDialectURIs >
    _xsd_DeviceMetadataDialectURIs_type_serializer_init (
      "DeviceMetadataDialectURIs",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const DeviceEventingFilterDialects& i)
    {
      e << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DeviceEventingFilterDialects& i)
    {
      a << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DeviceEventingFilterDialects& i)
    {
      l << static_cast< const ::xml_schema::String& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DeviceEventingFilterDialects >
    _xsd_DeviceEventingFilterDialects_type_serializer_init (
      "DeviceEventingFilterDialects",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const DeviceEventingFilterDialectURIs& i)
    {
      e << static_cast< const ::xml_schema::Uri& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DeviceEventingFilterDialectURIs& i)
    {
      a << static_cast< const ::xml_schema::Uri& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DeviceEventingFilterDialectURIs& i)
    {
      l << static_cast< const ::xml_schema::Uri& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DeviceEventingFilterDialectURIs >
    _xsd_DeviceEventingFilterDialectURIs_type_serializer_init (
      "DeviceEventingFilterDialectURIs",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const DeviceActionURIs& i)
    {
      e << static_cast< const ::xml_schema::Uri& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DeviceActionURIs& i)
    {
      a << static_cast< const ::xml_schema::Uri& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DeviceActionURIs& i)
    {
      l << static_cast< const ::xml_schema::Uri& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DeviceActionURIs >
    _xsd_DeviceActionURIs_type_serializer_init (
      "DeviceActionURIs",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const DeviceSoapFaultSubcodes& i)
    {
      e << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DeviceSoapFaultSubcodes& i)
    {
      a << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DeviceSoapFaultSubcodes& i)
    {
      l << static_cast< const ::xml_schema::String& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DeviceSoapFaultSubcodes >
    _xsd_DeviceSoapFaultSubcodes_type_serializer_init (
      "DeviceSoapFaultSubcodes",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const DeviceSoapFaultSubcodeQNames& i)
    {
      e << static_cast< const ::xml_schema::Qname& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DeviceSoapFaultSubcodeQNames& i)
    {
      a << static_cast< const ::xml_schema::Qname& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DeviceSoapFaultSubcodeQNames& i)
    {
      l << static_cast< const ::xml_schema::Qname& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DeviceSoapFaultSubcodeQNames >
    _xsd_DeviceSoapFaultSubcodeQNames_type_serializer_init (
      "DeviceSoapFaultSubcodeQNames",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    Host (::std::ostream& o,
          const ::WS::DPWS::HostServiceType& s,
          const ::xml_schema::NamespaceInfomap& m,
          const ::std::string& e,
          ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Host (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Host (::std::ostream& o,
          const ::WS::DPWS::HostServiceType& s,
          ::xml_schema::ErrorHandler& h,
          const ::xml_schema::NamespaceInfomap& m,
          const ::std::string& e,
          ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Host (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Host (::std::ostream& o,
          const ::WS::DPWS::HostServiceType& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::NamespaceInfomap& m,
          const ::std::string& e,
          ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Host (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Host (::xercesc::XMLFormatTarget& t,
          const ::WS::DPWS::HostServiceType& s,
          const ::xml_schema::NamespaceInfomap& m,
          const ::std::string& e,
          ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Host (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Host (::xercesc::XMLFormatTarget& t,
          const ::WS::DPWS::HostServiceType& s,
          ::xml_schema::ErrorHandler& h,
          const ::xml_schema::NamespaceInfomap& m,
          const ::std::string& e,
          ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Host (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Host (::xercesc::XMLFormatTarget& t,
          const ::WS::DPWS::HostServiceType& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::NamespaceInfomap& m,
          const ::std::string& e,
          ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Host (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Host (::xercesc::DOMDocument& d,
          const ::WS::DPWS::HostServiceType& s,
          ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DPWS::HostServiceType) == typeid (s))
      {
        if (n.name () == "Host" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Host",
            "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Host",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    Host (const ::WS::DPWS::HostServiceType& s,
          const ::xml_schema::NamespaceInfomap& m,
          ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DPWS::HostServiceType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Host",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Host",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          m, s, f);
      }

      ::WS::DPWS::Host (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const HostServiceType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const HostServiceType::EndpointReferenceType& x (i.EndpointReference ());
        if (typeid (HostServiceType::EndpointReferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EndpointReference",
            "http://www.w3.org/2005/08/addressing",
            true, true, e, x);
      }

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.Types ())
        {
          const HostServiceType::TypesType& x (*i.Types ());
          if (typeid (HostServiceType::TypesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Types",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              true, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, HostServiceType >
    _xsd_HostServiceType_type_serializer_init (
      "HostServiceType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    Hosted (::std::ostream& o,
            const ::WS::DPWS::HostedServiceType& s,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Hosted (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Hosted (::std::ostream& o,
            const ::WS::DPWS::HostedServiceType& s,
            ::xml_schema::ErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Hosted (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Hosted (::std::ostream& o,
            const ::WS::DPWS::HostedServiceType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Hosted (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Hosted (::xercesc::XMLFormatTarget& t,
            const ::WS::DPWS::HostedServiceType& s,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Hosted (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Hosted (::xercesc::XMLFormatTarget& t,
            const ::WS::DPWS::HostedServiceType& s,
            ::xml_schema::ErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Hosted (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Hosted (::xercesc::XMLFormatTarget& t,
            const ::WS::DPWS::HostedServiceType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Hosted (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Hosted (::xercesc::DOMDocument& d,
            const ::WS::DPWS::HostedServiceType& s,
            ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DPWS::HostedServiceType) == typeid (s))
      {
        if (n.name () == "Hosted" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Hosted",
            "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Hosted",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    Hosted (const ::WS::DPWS::HostedServiceType& s,
            const ::xml_schema::NamespaceInfomap& m,
            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DPWS::HostedServiceType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Hosted",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Hosted",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          m, s, f);
      }

      ::WS::DPWS::Hosted (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const HostedServiceType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (HostedServiceType::EndpointReferenceConstIterator
             b (i.EndpointReference ().begin ()), n (i.EndpointReference ().end ());
             b != n; ++b)
        {
          if (typeid (HostedServiceType::EndpointReferenceType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "EndpointReference",
                "http://www.w3.org/2005/08/addressing",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              true, true, e, *b);
        }
      }

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const HostedServiceType::TypesType& x (i.Types ());
        if (typeid (HostedServiceType::TypesType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Types",
            "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
            true, true, e, x);
      }

      // ServiceId
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const HostedServiceType::ServiceIdType& x (i.ServiceId ());
        if (typeid (HostedServiceType::ServiceIdType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ServiceId",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ServiceId",
            "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, HostedServiceType >
    _xsd_HostedServiceType_type_serializer_init (
      "HostedServiceType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    ServiceId (::std::ostream& o,
               const ::xml_schema::Uri& s,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ServiceId (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ServiceId (::std::ostream& o,
               const ::xml_schema::Uri& s,
               ::xml_schema::ErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ServiceId (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ServiceId (::std::ostream& o,
               const ::xml_schema::Uri& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ServiceId (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ServiceId (::xercesc::XMLFormatTarget& t,
               const ::xml_schema::Uri& s,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ServiceId (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ServiceId (::xercesc::XMLFormatTarget& t,
               const ::xml_schema::Uri& s,
               ::xml_schema::ErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ServiceId (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ServiceId (::xercesc::XMLFormatTarget& t,
               const ::xml_schema::Uri& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::ServiceId (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ServiceId (::xercesc::DOMDocument& d,
               const ::xml_schema::Uri& s,
               ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xml_schema::Uri) == typeid (s))
      {
        if (n.name () == "ServiceId" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "ServiceId",
            "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ServiceId",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    ServiceId (const ::xml_schema::Uri& s,
               const ::xml_schema::NamespaceInfomap& m,
               ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xml_schema::Uri) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "ServiceId",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ServiceId",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          m, s, f);
      }

      ::WS::DPWS::ServiceId (*d, s, f);
      return d;
    }

    void
    Types (::std::ostream& o,
           const ::WS::DPWS::QNameListType& s,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Types (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Types (::std::ostream& o,
           const ::WS::DPWS::QNameListType& s,
           ::xml_schema::ErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Types (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Types (::std::ostream& o,
           const ::WS::DPWS::QNameListType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Types (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Types (::xercesc::XMLFormatTarget& t,
           const ::WS::DPWS::QNameListType& s,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Types (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Types (::xercesc::XMLFormatTarget& t,
           const ::WS::DPWS::QNameListType& s,
           ::xml_schema::ErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Types (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Types (::xercesc::XMLFormatTarget& t,
           const ::WS::DPWS::QNameListType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Types (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Types (::xercesc::DOMDocument& d,
           const ::WS::DPWS::QNameListType& s,
           ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DPWS::QNameListType) == typeid (s))
      {
        if (n.name () == "Types" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Types",
            "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Types",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    Types (const ::WS::DPWS::QNameListType& s,
           const ::xml_schema::NamespaceInfomap& m,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DPWS::QNameListType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Types",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Types",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          m, s, f);
      }

      ::WS::DPWS::Types (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const QNameListType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Qname, char >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const QNameListType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Qname, char >& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const QNameListType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Qname, char >& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, QNameListType >
    _xsd_QNameListType_type_serializer_init (
      "QNameListType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const DiscoveryTypeValues& i)
    {
      e << static_cast< const ::xml_schema::Qname& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DiscoveryTypeValues& i)
    {
      a << static_cast< const ::xml_schema::Qname& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DiscoveryTypeValues& i)
    {
      l << static_cast< const ::xml_schema::Qname& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DiscoveryTypeValues >
    _xsd_DiscoveryTypeValues_type_serializer_init (
      "DiscoveryTypeValues",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    Profile (::std::ostream& o,
             const ::WS::DPWS::AssertionType& s,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Profile (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Profile (::std::ostream& o,
             const ::WS::DPWS::AssertionType& s,
             ::xml_schema::ErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Profile (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Profile (::std::ostream& o,
             const ::WS::DPWS::AssertionType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Profile (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Profile (::xercesc::XMLFormatTarget& t,
             const ::WS::DPWS::AssertionType& s,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Profile (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Profile (::xercesc::XMLFormatTarget& t,
             const ::WS::DPWS::AssertionType& s,
             ::xml_schema::ErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Profile (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Profile (::xercesc::XMLFormatTarget& t,
             const ::WS::DPWS::AssertionType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DPWS::Profile (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Profile (::xercesc::DOMDocument& d,
             const ::WS::DPWS::AssertionType& s,
             ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DPWS::AssertionType) == typeid (s))
      {
        if (n.name () == "Profile" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Profile",
            "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Profile",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    Profile (const ::WS::DPWS::AssertionType& s,
             const ::xml_schema::NamespaceInfomap& m,
             ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DPWS::AssertionType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Profile",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Profile",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
          m, s, f);
      }

      ::WS::DPWS::Profile (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const AssertionType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AssertionType >
    _xsd_AssertionType_type_serializer_init (
      "AssertionType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const Relationship& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Host
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const Relationship::HostType& x (i.Host ());
        if (typeid (Relationship::HostType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Host",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Host",
            "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
            true, true, e, x);
      }

      // Hosted
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (Relationship::HostedConstIterator
             b (i.Hosted ().begin ()), n (i.Hosted ().end ());
             b != n; ++b)
        {
          if (typeid (Relationship::HostedType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Hosted",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "Hosted",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              true, true, e, *b);
        }
      }

      // Type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Type",
            e));

        a << i.Type ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

