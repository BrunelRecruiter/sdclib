// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "DataModel/BICEPS_MessageModel.hxx"

namespace MDM
{
  // TransactionId
  // 


  // InvocationState
  // 

  InvocationState::
  InvocationState (Value v)
  : ::xml_schema::String (_xsd_InvocationState_literals_[v])
  {
  }

  InvocationState::
  InvocationState (const char* v)
  : ::xml_schema::String (v)
  {
  }

  InvocationState::
  InvocationState (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  InvocationState::
  InvocationState (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  InvocationState::
  InvocationState (const InvocationState& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  InvocationState& InvocationState::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_InvocationState_literals_[v]);

    return *this;
  }


  // InvocationError
  // 

  InvocationError::
  InvocationError (Value v)
  : ::xml_schema::String (_xsd_InvocationError_literals_[v])
  {
  }

  InvocationError::
  InvocationError (const char* v)
  : ::xml_schema::String (v)
  {
  }

  InvocationError::
  InvocationError (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  InvocationError::
  InvocationError (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  InvocationError::
  InvocationError (const InvocationError& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  InvocationError& InvocationError::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_InvocationError_literals_[v]);

    return *this;
  }


  // InvocationInfo
  // 

  const InvocationInfo::ExtensionOptional& InvocationInfo::
  getExtension () const
  {
    return this->Extension_;
  }

  InvocationInfo::ExtensionOptional& InvocationInfo::
  getExtension ()
  {
    return this->Extension_;
  }

  void InvocationInfo::
  setExtension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void InvocationInfo::
  setExtension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void InvocationInfo::
  setExtension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const InvocationInfo::TransactionIdType& InvocationInfo::
  getTransactionId () const
  {
    return this->TransactionId_.get ();
  }

  InvocationInfo::TransactionIdType& InvocationInfo::
  getTransactionId ()
  {
    return this->TransactionId_.get ();
  }

  void InvocationInfo::
  setTransactionId (const TransactionIdType& x)
  {
    this->TransactionId_.set (x);
  }

  void InvocationInfo::
  setTransactionId (::std::unique_ptr< TransactionIdType > x)
  {
    this->TransactionId_.set (std::move (x));
  }

  const InvocationInfo::InvocationStateType& InvocationInfo::
  getInvocationState () const
  {
    return this->InvocationState_.get ();
  }

  InvocationInfo::InvocationStateType& InvocationInfo::
  getInvocationState ()
  {
    return this->InvocationState_.get ();
  }

  void InvocationInfo::
  setInvocationState (const InvocationStateType& x)
  {
    this->InvocationState_.set (x);
  }

  void InvocationInfo::
  setInvocationState (::std::unique_ptr< InvocationStateType > x)
  {
    this->InvocationState_.set (std::move (x));
  }

  const InvocationInfo::InvocationErrorOptional& InvocationInfo::
  getInvocationError () const
  {
    return this->InvocationError_;
  }

  InvocationInfo::InvocationErrorOptional& InvocationInfo::
  getInvocationError ()
  {
    return this->InvocationError_;
  }

  void InvocationInfo::
  setInvocationError (const InvocationErrorType& x)
  {
    this->InvocationError_.set (x);
  }

  void InvocationInfo::
  setInvocationError (const InvocationErrorOptional& x)
  {
    this->InvocationError_ = x;
  }

  void InvocationInfo::
  setInvocationError (::std::unique_ptr< InvocationErrorType > x)
  {
    this->InvocationError_.set (std::move (x));
  }

  const InvocationInfo::InvocationErrorMessageSequence& InvocationInfo::
  getInvocationErrorMessage () const
  {
    return this->InvocationErrorMessage_;
  }

  InvocationInfo::InvocationErrorMessageSequence& InvocationInfo::
  getInvocationErrorMessage ()
  {
    return this->InvocationErrorMessage_;
  }

  void InvocationInfo::
  setInvocationErrorMessage (const InvocationErrorMessageSequence& s)
  {
    this->InvocationErrorMessage_ = s;
  }


  // AbstractGet
  // 

  const AbstractGet::ExtensionOptional& AbstractGet::
  getExtension () const
  {
    return this->Extension_;
  }

  AbstractGet::ExtensionOptional& AbstractGet::
  getExtension ()
  {
    return this->Extension_;
  }

  void AbstractGet::
  setExtension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractGet::
  setExtension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractGet::
  setExtension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }


  // AbstractGetResponse
  // 

  const AbstractGetResponse::ExtensionOptional& AbstractGetResponse::
  getExtension () const
  {
    return this->Extension_;
  }

  AbstractGetResponse::ExtensionOptional& AbstractGetResponse::
  getExtension ()
  {
    return this->Extension_;
  }

  void AbstractGetResponse::
  setExtension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractGetResponse::
  setExtension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractGetResponse::
  setExtension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const AbstractGetResponse::MdibVersionOptional& AbstractGetResponse::
  getMdibVersion () const
  {
    return this->MdibVersion_;
  }

  AbstractGetResponse::MdibVersionOptional& AbstractGetResponse::
  getMdibVersion ()
  {
    return this->MdibVersion_;
  }

  void AbstractGetResponse::
  setMdibVersion (const MdibVersionType& x)
  {
    this->MdibVersion_.set (x);
  }

  void AbstractGetResponse::
  setMdibVersion (const MdibVersionOptional& x)
  {
    this->MdibVersion_ = x;
  }

  void AbstractGetResponse::
  setMdibVersion (::std::unique_ptr< MdibVersionType > x)
  {
    this->MdibVersion_.set (std::move (x));
  }

  const AbstractGetResponse::SequenceIdType& AbstractGetResponse::
  getSequenceId () const
  {
    return this->SequenceId_.get ();
  }

  AbstractGetResponse::SequenceIdType& AbstractGetResponse::
  getSequenceId ()
  {
    return this->SequenceId_.get ();
  }

  void AbstractGetResponse::
  setSequenceId (const SequenceIdType& x)
  {
    this->SequenceId_.set (x);
  }

  void AbstractGetResponse::
  setSequenceId (::std::unique_ptr< SequenceIdType > x)
  {
    this->SequenceId_.set (std::move (x));
  }

  const AbstractGetResponse::InstanceIdOptional& AbstractGetResponse::
  getInstanceId () const
  {
    return this->InstanceId_;
  }

  AbstractGetResponse::InstanceIdOptional& AbstractGetResponse::
  getInstanceId ()
  {
    return this->InstanceId_;
  }

  void AbstractGetResponse::
  setInstanceId (const InstanceIdType& x)
  {
    this->InstanceId_.set (x);
  }

  void AbstractGetResponse::
  setInstanceId (const InstanceIdOptional& x)
  {
    this->InstanceId_ = x;
  }


  // AbstractReportPart
  // 

  const AbstractReportPart::ExtensionOptional& AbstractReportPart::
  getExtension () const
  {
    return this->Extension_;
  }

  AbstractReportPart::ExtensionOptional& AbstractReportPart::
  getExtension ()
  {
    return this->Extension_;
  }

  void AbstractReportPart::
  setExtension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractReportPart::
  setExtension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractReportPart::
  setExtension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const AbstractReportPart::SourceMdsOptional& AbstractReportPart::
  getSourceMds () const
  {
    return this->SourceMds_;
  }

  AbstractReportPart::SourceMdsOptional& AbstractReportPart::
  getSourceMds ()
  {
    return this->SourceMds_;
  }

  void AbstractReportPart::
  setSourceMds (const SourceMdsType& x)
  {
    this->SourceMds_.set (x);
  }

  void AbstractReportPart::
  setSourceMds (const SourceMdsOptional& x)
  {
    this->SourceMds_ = x;
  }

  void AbstractReportPart::
  setSourceMds (::std::unique_ptr< SourceMdsType > x)
  {
    this->SourceMds_.set (std::move (x));
  }


  // AbstractReport
  // 

  const AbstractReport::ExtensionOptional& AbstractReport::
  getExtension () const
  {
    return this->Extension_;
  }

  AbstractReport::ExtensionOptional& AbstractReport::
  getExtension ()
  {
    return this->Extension_;
  }

  void AbstractReport::
  setExtension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractReport::
  setExtension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractReport::
  setExtension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const AbstractReport::MdibVersionOptional& AbstractReport::
  getMdibVersion () const
  {
    return this->MdibVersion_;
  }

  AbstractReport::MdibVersionOptional& AbstractReport::
  getMdibVersion ()
  {
    return this->MdibVersion_;
  }

  void AbstractReport::
  setMdibVersion (const MdibVersionType& x)
  {
    this->MdibVersion_.set (x);
  }

  void AbstractReport::
  setMdibVersion (const MdibVersionOptional& x)
  {
    this->MdibVersion_ = x;
  }

  void AbstractReport::
  setMdibVersion (::std::unique_ptr< MdibVersionType > x)
  {
    this->MdibVersion_.set (std::move (x));
  }

  const AbstractReport::SequenceIdType& AbstractReport::
  getSequenceId () const
  {
    return this->SequenceId_.get ();
  }

  AbstractReport::SequenceIdType& AbstractReport::
  getSequenceId ()
  {
    return this->SequenceId_.get ();
  }

  void AbstractReport::
  setSequenceId (const SequenceIdType& x)
  {
    this->SequenceId_.set (x);
  }

  void AbstractReport::
  setSequenceId (::std::unique_ptr< SequenceIdType > x)
  {
    this->SequenceId_.set (std::move (x));
  }

  const AbstractReport::InstanceIdOptional& AbstractReport::
  getInstanceId () const
  {
    return this->InstanceId_;
  }

  AbstractReport::InstanceIdOptional& AbstractReport::
  getInstanceId ()
  {
    return this->InstanceId_;
  }

  void AbstractReport::
  setInstanceId (const InstanceIdType& x)
  {
    this->InstanceId_.set (x);
  }

  void AbstractReport::
  setInstanceId (const InstanceIdOptional& x)
  {
    this->InstanceId_ = x;
  }


  // AbstractSet
  // 

  const AbstractSet::ExtensionOptional& AbstractSet::
  getExtension () const
  {
    return this->Extension_;
  }

  AbstractSet::ExtensionOptional& AbstractSet::
  getExtension ()
  {
    return this->Extension_;
  }

  void AbstractSet::
  setExtension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractSet::
  setExtension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractSet::
  setExtension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const AbstractSet::OperationHandleRefType& AbstractSet::
  getOperationHandleRef () const
  {
    return this->OperationHandleRef_.get ();
  }

  AbstractSet::OperationHandleRefType& AbstractSet::
  getOperationHandleRef ()
  {
    return this->OperationHandleRef_.get ();
  }

  void AbstractSet::
  setOperationHandleRef (const OperationHandleRefType& x)
  {
    this->OperationHandleRef_.set (x);
  }

  void AbstractSet::
  setOperationHandleRef (::std::unique_ptr< OperationHandleRefType > x)
  {
    this->OperationHandleRef_.set (std::move (x));
  }


  // AbstractSetResponse
  // 

  const AbstractSetResponse::ExtensionOptional& AbstractSetResponse::
  getExtension () const
  {
    return this->Extension_;
  }

  AbstractSetResponse::ExtensionOptional& AbstractSetResponse::
  getExtension ()
  {
    return this->Extension_;
  }

  void AbstractSetResponse::
  setExtension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractSetResponse::
  setExtension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractSetResponse::
  setExtension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const AbstractSetResponse::InvocationInfoType& AbstractSetResponse::
  getInvocationInfo () const
  {
    return this->InvocationInfo_.get ();
  }

  AbstractSetResponse::InvocationInfoType& AbstractSetResponse::
  getInvocationInfo ()
  {
    return this->InvocationInfo_.get ();
  }

  void AbstractSetResponse::
  setInvocationInfo (const InvocationInfoType& x)
  {
    this->InvocationInfo_.set (x);
  }

  void AbstractSetResponse::
  setInvocationInfo (::std::unique_ptr< InvocationInfoType > x)
  {
    this->InvocationInfo_.set (std::move (x));
  }

  const AbstractSetResponse::MdibVersionOptional& AbstractSetResponse::
  getMdibVersion () const
  {
    return this->MdibVersion_;
  }

  AbstractSetResponse::MdibVersionOptional& AbstractSetResponse::
  getMdibVersion ()
  {
    return this->MdibVersion_;
  }

  void AbstractSetResponse::
  setMdibVersion (const MdibVersionType& x)
  {
    this->MdibVersion_.set (x);
  }

  void AbstractSetResponse::
  setMdibVersion (const MdibVersionOptional& x)
  {
    this->MdibVersion_ = x;
  }

  void AbstractSetResponse::
  setMdibVersion (::std::unique_ptr< MdibVersionType > x)
  {
    this->MdibVersion_.set (std::move (x));
  }

  const AbstractSetResponse::SequenceIdType& AbstractSetResponse::
  getSequenceId () const
  {
    return this->SequenceId_.get ();
  }

  AbstractSetResponse::SequenceIdType& AbstractSetResponse::
  getSequenceId ()
  {
    return this->SequenceId_.get ();
  }

  void AbstractSetResponse::
  setSequenceId (const SequenceIdType& x)
  {
    this->SequenceId_.set (x);
  }

  void AbstractSetResponse::
  setSequenceId (::std::unique_ptr< SequenceIdType > x)
  {
    this->SequenceId_.set (std::move (x));
  }

  const AbstractSetResponse::InstanceIdOptional& AbstractSetResponse::
  getInstanceId () const
  {
    return this->InstanceId_;
  }

  AbstractSetResponse::InstanceIdOptional& AbstractSetResponse::
  getInstanceId ()
  {
    return this->InstanceId_;
  }

  void AbstractSetResponse::
  setInstanceId (const InstanceIdType& x)
  {
    this->InstanceId_.set (x);
  }

  void AbstractSetResponse::
  setInstanceId (const InstanceIdOptional& x)
  {
    this->InstanceId_ = x;
  }


  // AbstractContextReport
  // 

  const AbstractContextReport::ReportPartSequence& AbstractContextReport::
  getReportPart () const
  {
    return this->ReportPart_;
  }

  AbstractContextReport::ReportPartSequence& AbstractContextReport::
  getReportPart ()
  {
    return this->ReportPart_;
  }

  void AbstractContextReport::
  setReportPart (const ReportPartSequence& s)
  {
    this->ReportPart_ = s;
  }


  // VersionFrame
  // 

  const VersionFrame::StartOptional& VersionFrame::
  getStart () const
  {
    return this->Start_;
  }

  VersionFrame::StartOptional& VersionFrame::
  getStart ()
  {
    return this->Start_;
  }

  void VersionFrame::
  setStart (const StartType& x)
  {
    this->Start_.set (x);
  }

  void VersionFrame::
  setStart (const StartOptional& x)
  {
    this->Start_ = x;
  }

  void VersionFrame::
  setStart (::std::unique_ptr< StartType > x)
  {
    this->Start_.set (std::move (x));
  }

  const VersionFrame::EndOptional& VersionFrame::
  getEnd () const
  {
    return this->End_;
  }

  VersionFrame::EndOptional& VersionFrame::
  getEnd ()
  {
    return this->End_;
  }

  void VersionFrame::
  setEnd (const EndType& x)
  {
    this->End_.set (x);
  }

  void VersionFrame::
  setEnd (const EndOptional& x)
  {
    this->End_ = x;
  }

  void VersionFrame::
  setEnd (::std::unique_ptr< EndType > x)
  {
    this->End_.set (std::move (x));
  }


  // TimeFrame
  // 

  const TimeFrame::StartOptional& TimeFrame::
  getStart () const
  {
    return this->Start_;
  }

  TimeFrame::StartOptional& TimeFrame::
  getStart ()
  {
    return this->Start_;
  }

  void TimeFrame::
  setStart (const StartType& x)
  {
    this->Start_.set (x);
  }

  void TimeFrame::
  setStart (const StartOptional& x)
  {
    this->Start_ = x;
  }

  void TimeFrame::
  setStart (::std::unique_ptr< StartType > x)
  {
    this->Start_.set (std::move (x));
  }

  const TimeFrame::EndOptional& TimeFrame::
  getEnd () const
  {
    return this->End_;
  }

  TimeFrame::EndOptional& TimeFrame::
  getEnd ()
  {
    return this->End_;
  }

  void TimeFrame::
  setEnd (const EndType& x)
  {
    this->End_.set (x);
  }

  void TimeFrame::
  setEnd (const EndOptional& x)
  {
    this->End_ = x;
  }

  void TimeFrame::
  setEnd (::std::unique_ptr< EndType > x)
  {
    this->End_.set (std::move (x));
  }


  // AbstractMetricReport
  // 

  const AbstractMetricReport::ReportPartSequence& AbstractMetricReport::
  getReportPart () const
  {
    return this->ReportPart_;
  }

  AbstractMetricReport::ReportPartSequence& AbstractMetricReport::
  getReportPart ()
  {
    return this->ReportPart_;
  }

  void AbstractMetricReport::
  setReportPart (const ReportPartSequence& s)
  {
    this->ReportPart_ = s;
  }


  // AbstractComponentReport
  // 

  const AbstractComponentReport::ReportPartSequence& AbstractComponentReport::
  getReportPart () const
  {
    return this->ReportPart_;
  }

  AbstractComponentReport::ReportPartSequence& AbstractComponentReport::
  getReportPart ()
  {
    return this->ReportPart_;
  }

  void AbstractComponentReport::
  setReportPart (const ReportPartSequence& s)
  {
    this->ReportPart_ = s;
  }


  // AbstractAlertReport
  // 

  const AbstractAlertReport::ReportPartSequence& AbstractAlertReport::
  getReportPart () const
  {
    return this->ReportPart_;
  }

  AbstractAlertReport::ReportPartSequence& AbstractAlertReport::
  getReportPart ()
  {
    return this->ReportPart_;
  }

  void AbstractAlertReport::
  setReportPart (const ReportPartSequence& s)
  {
    this->ReportPart_ = s;
  }


  // AbstractOperationalStateReport
  // 

  const AbstractOperationalStateReport::ReportPartSequence& AbstractOperationalStateReport::
  getReportPart () const
  {
    return this->ReportPart_;
  }

  AbstractOperationalStateReport::ReportPartSequence& AbstractOperationalStateReport::
  getReportPart ()
  {
    return this->ReportPart_;
  }

  void AbstractOperationalStateReport::
  setReportPart (const ReportPartSequence& s)
  {
    this->ReportPart_ = s;
  }


  // DescriptionModificationType
  // 

  DescriptionModificationType::
  DescriptionModificationType (Value v)
  : ::xml_schema::String (_xsd_DescriptionModificationType_literals_[v])
  {
  }

  DescriptionModificationType::
  DescriptionModificationType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  DescriptionModificationType::
  DescriptionModificationType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  DescriptionModificationType::
  DescriptionModificationType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  DescriptionModificationType::
  DescriptionModificationType (const DescriptionModificationType& v,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  DescriptionModificationType& DescriptionModificationType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_DescriptionModificationType_literals_[v]);

    return *this;
  }


  // RetrievabilityMethod
  // 

  RetrievabilityMethod::
  RetrievabilityMethod (Value v)
  : ::xml_schema::String (_xsd_RetrievabilityMethod_literals_[v])
  {
  }

  RetrievabilityMethod::
  RetrievabilityMethod (const char* v)
  : ::xml_schema::String (v)
  {
  }

  RetrievabilityMethod::
  RetrievabilityMethod (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  RetrievabilityMethod::
  RetrievabilityMethod (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  RetrievabilityMethod::
  RetrievabilityMethod (const RetrievabilityMethod& v,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  RetrievabilityMethod& RetrievabilityMethod::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_RetrievabilityMethod_literals_[v]);

    return *this;
  }


  // RetrievabilityInfo
  // 

  const RetrievabilityInfo::ExtensionOptional& RetrievabilityInfo::
  getExtension () const
  {
    return this->Extension_;
  }

  RetrievabilityInfo::ExtensionOptional& RetrievabilityInfo::
  getExtension ()
  {
    return this->Extension_;
  }

  void RetrievabilityInfo::
  setExtension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void RetrievabilityInfo::
  setExtension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void RetrievabilityInfo::
  setExtension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const RetrievabilityInfo::MethodType& RetrievabilityInfo::
  getMethod () const
  {
    return this->Method_.get ();
  }

  RetrievabilityInfo::MethodType& RetrievabilityInfo::
  getMethod ()
  {
    return this->Method_.get ();
  }

  void RetrievabilityInfo::
  setMethod (const MethodType& x)
  {
    this->Method_.set (x);
  }

  void RetrievabilityInfo::
  setMethod (::std::unique_ptr< MethodType > x)
  {
    this->Method_.set (std::move (x));
  }

  const RetrievabilityInfo::UpdatePeriodOptional& RetrievabilityInfo::
  getUpdatePeriod () const
  {
    return this->UpdatePeriod_;
  }

  RetrievabilityInfo::UpdatePeriodOptional& RetrievabilityInfo::
  getUpdatePeriod ()
  {
    return this->UpdatePeriod_;
  }

  void RetrievabilityInfo::
  setUpdatePeriod (const UpdatePeriodType& x)
  {
    this->UpdatePeriod_.set (x);
  }

  void RetrievabilityInfo::
  setUpdatePeriod (const UpdatePeriodOptional& x)
  {
    this->UpdatePeriod_ = x;
  }

  void RetrievabilityInfo::
  setUpdatePeriod (::std::unique_ptr< UpdatePeriodType > x)
  {
    this->UpdatePeriod_.set (std::move (x));
  }


  // GetMdib
  // 


  // GetMdibResponse
  // 

  const GetMdibResponse::MdibType& GetMdibResponse::
  getMdib () const
  {
    return this->Mdib_.get ();
  }

  GetMdibResponse::MdibType& GetMdibResponse::
  getMdib ()
  {
    return this->Mdib_.get ();
  }

  void GetMdibResponse::
  setMdib (const MdibType& x)
  {
    this->Mdib_.set (x);
  }

  void GetMdibResponse::
  setMdib (::std::unique_ptr< MdibType > x)
  {
    this->Mdib_.set (std::move (x));
  }


  // GetMdDescription
  // 

  const GetMdDescription::HandleRefSequence& GetMdDescription::
  getHandleRef () const
  {
    return this->HandleRef_;
  }

  GetMdDescription::HandleRefSequence& GetMdDescription::
  getHandleRef ()
  {
    return this->HandleRef_;
  }

  void GetMdDescription::
  setHandleRef (const HandleRefSequence& s)
  {
    this->HandleRef_ = s;
  }


  // GetMdDescriptionResponse
  // 

  const GetMdDescriptionResponse::MdDescriptionType& GetMdDescriptionResponse::
  getMdDescription () const
  {
    return this->MdDescription_.get ();
  }

  GetMdDescriptionResponse::MdDescriptionType& GetMdDescriptionResponse::
  getMdDescription ()
  {
    return this->MdDescription_.get ();
  }

  void GetMdDescriptionResponse::
  setMdDescription (const MdDescriptionType& x)
  {
    this->MdDescription_.set (x);
  }

  void GetMdDescriptionResponse::
  setMdDescription (::std::unique_ptr< MdDescriptionType > x)
  {
    this->MdDescription_.set (std::move (x));
  }


  // GetMdState
  // 

  const GetMdState::HandleRefSequence& GetMdState::
  getHandleRef () const
  {
    return this->HandleRef_;
  }

  GetMdState::HandleRefSequence& GetMdState::
  getHandleRef ()
  {
    return this->HandleRef_;
  }

  void GetMdState::
  setHandleRef (const HandleRefSequence& s)
  {
    this->HandleRef_ = s;
  }


  // GetMdStateResponse
  // 

  const GetMdStateResponse::MdStateType& GetMdStateResponse::
  getMdState () const
  {
    return this->MdState_.get ();
  }

  GetMdStateResponse::MdStateType& GetMdStateResponse::
  getMdState ()
  {
    return this->MdState_.get ();
  }

  void GetMdStateResponse::
  setMdState (const MdStateType& x)
  {
    this->MdState_.set (x);
  }

  void GetMdStateResponse::
  setMdState (::std::unique_ptr< MdStateType > x)
  {
    this->MdState_.set (std::move (x));
  }


  // GetContextStates
  // 

  const GetContextStates::HandleRefSequence& GetContextStates::
  getHandleRef () const
  {
    return this->HandleRef_;
  }

  GetContextStates::HandleRefSequence& GetContextStates::
  getHandleRef ()
  {
    return this->HandleRef_;
  }

  void GetContextStates::
  setHandleRef (const HandleRefSequence& s)
  {
    this->HandleRef_ = s;
  }


  // GetContextStatesResponse
  // 

  const GetContextStatesResponse::ContextStateSequence& GetContextStatesResponse::
  getContextState () const
  {
    return this->ContextState_;
  }

  GetContextStatesResponse::ContextStateSequence& GetContextStatesResponse::
  getContextState ()
  {
    return this->ContextState_;
  }

  void GetContextStatesResponse::
  setContextState (const ContextStateSequence& s)
  {
    this->ContextState_ = s;
  }


  // GetContextStatesByIdentification
  // 

  const GetContextStatesByIdentification::IdentificationSequence& GetContextStatesByIdentification::
  getIdentification () const
  {
    return this->Identification_;
  }

  GetContextStatesByIdentification::IdentificationSequence& GetContextStatesByIdentification::
  getIdentification ()
  {
    return this->Identification_;
  }

  void GetContextStatesByIdentification::
  setIdentification (const IdentificationSequence& s)
  {
    this->Identification_ = s;
  }

  const GetContextStatesByIdentification::ContextTypeOptional& GetContextStatesByIdentification::
  getContextType () const
  {
    return this->ContextType_;
  }

  GetContextStatesByIdentification::ContextTypeOptional& GetContextStatesByIdentification::
  getContextType ()
  {
    return this->ContextType_;
  }

  void GetContextStatesByIdentification::
  setContextType (const ContextTypeType& x)
  {
    this->ContextType_.set (x);
  }

  void GetContextStatesByIdentification::
  setContextType (const ContextTypeOptional& x)
  {
    this->ContextType_ = x;
  }

  void GetContextStatesByIdentification::
  setContextType (::std::unique_ptr< ContextTypeType > x)
  {
    this->ContextType_.set (std::move (x));
  }


  // GetContextStatesByIdentificationResponse
  // 

  const GetContextStatesByIdentificationResponse::ContextStateSequence& GetContextStatesByIdentificationResponse::
  getContextState () const
  {
    return this->ContextState_;
  }

  GetContextStatesByIdentificationResponse::ContextStateSequence& GetContextStatesByIdentificationResponse::
  getContextState ()
  {
    return this->ContextState_;
  }

  void GetContextStatesByIdentificationResponse::
  setContextState (const ContextStateSequence& s)
  {
    this->ContextState_ = s;
  }


  // GetContextStatesByFilter
  // 

  const GetContextStatesByFilter::FilterSequence& GetContextStatesByFilter::
  getFilter () const
  {
    return this->Filter_;
  }

  GetContextStatesByFilter::FilterSequence& GetContextStatesByFilter::
  getFilter ()
  {
    return this->Filter_;
  }

  void GetContextStatesByFilter::
  setFilter (const FilterSequence& s)
  {
    this->Filter_ = s;
  }

  const GetContextStatesByFilter::ContextTypeOptional& GetContextStatesByFilter::
  getContextType () const
  {
    return this->ContextType_;
  }

  GetContextStatesByFilter::ContextTypeOptional& GetContextStatesByFilter::
  getContextType ()
  {
    return this->ContextType_;
  }

  void GetContextStatesByFilter::
  setContextType (const ContextTypeType& x)
  {
    this->ContextType_.set (x);
  }

  void GetContextStatesByFilter::
  setContextType (const ContextTypeOptional& x)
  {
    this->ContextType_ = x;
  }

  void GetContextStatesByFilter::
  setContextType (::std::unique_ptr< ContextTypeType > x)
  {
    this->ContextType_.set (std::move (x));
  }


  // GetContextStatesByFilterResponse
  // 

  const GetContextStatesByFilterResponse::ContextStateSequence& GetContextStatesByFilterResponse::
  getContextState () const
  {
    return this->ContextState_;
  }

  GetContextStatesByFilterResponse::ContextStateSequence& GetContextStatesByFilterResponse::
  getContextState ()
  {
    return this->ContextState_;
  }

  void GetContextStatesByFilterResponse::
  setContextState (const ContextStateSequence& s)
  {
    this->ContextState_ = s;
  }


  // SetContextState
  // 

  const SetContextState::ProposedContextStateSequence& SetContextState::
  getProposedContextState () const
  {
    return this->ProposedContextState_;
  }

  SetContextState::ProposedContextStateSequence& SetContextState::
  getProposedContextState ()
  {
    return this->ProposedContextState_;
  }

  void SetContextState::
  setProposedContextState (const ProposedContextStateSequence& s)
  {
    this->ProposedContextState_ = s;
  }


  // SetContextStateResponse
  // 


  // ReportPart
  // 

  const ReportPart::ContextStateSequence& ReportPart::
  getContextState () const
  {
    return this->ContextState_;
  }

  ReportPart::ContextStateSequence& ReportPart::
  getContextState ()
  {
    return this->ContextState_;
  }

  void ReportPart::
  setContextState (const ContextStateSequence& s)
  {
    this->ContextState_ = s;
  }


  // PeriodicContextReport
  // 


  // EpisodicContextReport
  // 


  // GetLocalizedText
  // 

  const GetLocalizedText::RefSequence& GetLocalizedText::
  getRef () const
  {
    return this->Ref_;
  }

  GetLocalizedText::RefSequence& GetLocalizedText::
  getRef ()
  {
    return this->Ref_;
  }

  void GetLocalizedText::
  setRef (const RefSequence& s)
  {
    this->Ref_ = s;
  }

  const GetLocalizedText::VersionOptional& GetLocalizedText::
  getVersion () const
  {
    return this->Version_;
  }

  GetLocalizedText::VersionOptional& GetLocalizedText::
  getVersion ()
  {
    return this->Version_;
  }

  void GetLocalizedText::
  setVersion (const VersionType& x)
  {
    this->Version_.set (x);
  }

  void GetLocalizedText::
  setVersion (const VersionOptional& x)
  {
    this->Version_ = x;
  }

  void GetLocalizedText::
  setVersion (::std::unique_ptr< VersionType > x)
  {
    this->Version_.set (std::move (x));
  }

  const GetLocalizedText::LangSequence& GetLocalizedText::
  getLang () const
  {
    return this->Lang_;
  }

  GetLocalizedText::LangSequence& GetLocalizedText::
  getLang ()
  {
    return this->Lang_;
  }

  void GetLocalizedText::
  setLang (const LangSequence& s)
  {
    this->Lang_ = s;
  }

  const GetLocalizedText::TextWidthSequence& GetLocalizedText::
  getTextWidth () const
  {
    return this->TextWidth_;
  }

  GetLocalizedText::TextWidthSequence& GetLocalizedText::
  getTextWidth ()
  {
    return this->TextWidth_;
  }

  void GetLocalizedText::
  setTextWidth (const TextWidthSequence& s)
  {
    this->TextWidth_ = s;
  }

  const GetLocalizedText::NumberOfLinesSequence& GetLocalizedText::
  getNumberOfLines () const
  {
    return this->NumberOfLines_;
  }

  GetLocalizedText::NumberOfLinesSequence& GetLocalizedText::
  getNumberOfLines ()
  {
    return this->NumberOfLines_;
  }

  void GetLocalizedText::
  setNumberOfLines (const NumberOfLinesSequence& s)
  {
    this->NumberOfLines_ = s;
  }


  // GetLocalizedTextResponse
  // 

  const GetLocalizedTextResponse::TextSequence& GetLocalizedTextResponse::
  getText () const
  {
    return this->Text_;
  }

  GetLocalizedTextResponse::TextSequence& GetLocalizedTextResponse::
  getText ()
  {
    return this->Text_;
  }

  void GetLocalizedTextResponse::
  setText (const TextSequence& s)
  {
    this->Text_ = s;
  }


  // GetSupportedLanguages
  // 


  // GetSupportedLanguagesResponse
  // 

  const GetSupportedLanguagesResponse::LangSequence& GetSupportedLanguagesResponse::
  getLang () const
  {
    return this->Lang_;
  }

  GetSupportedLanguagesResponse::LangSequence& GetSupportedLanguagesResponse::
  getLang ()
  {
    return this->Lang_;
  }

  void GetSupportedLanguagesResponse::
  setLang (const LangSequence& s)
  {
    this->Lang_ = s;
  }


  // GetDescriptorsFromArchive
  // 

  const GetDescriptorsFromArchive::DescriptorRevisionsOptional& GetDescriptorsFromArchive::
  getDescriptorRevisions () const
  {
    return this->DescriptorRevisions_;
  }

  GetDescriptorsFromArchive::DescriptorRevisionsOptional& GetDescriptorsFromArchive::
  getDescriptorRevisions ()
  {
    return this->DescriptorRevisions_;
  }

  void GetDescriptorsFromArchive::
  setDescriptorRevisions (const DescriptorRevisionsType& x)
  {
    this->DescriptorRevisions_.set (x);
  }

  void GetDescriptorsFromArchive::
  setDescriptorRevisions (const DescriptorRevisionsOptional& x)
  {
    this->DescriptorRevisions_ = x;
  }

  void GetDescriptorsFromArchive::
  setDescriptorRevisions (::std::unique_ptr< DescriptorRevisionsType > x)
  {
    this->DescriptorRevisions_.set (std::move (x));
  }

  const GetDescriptorsFromArchive::TimeFrameOptional& GetDescriptorsFromArchive::
  getTimeFrame () const
  {
    return this->TimeFrame_;
  }

  GetDescriptorsFromArchive::TimeFrameOptional& GetDescriptorsFromArchive::
  getTimeFrame ()
  {
    return this->TimeFrame_;
  }

  void GetDescriptorsFromArchive::
  setTimeFrame (const TimeFrameType& x)
  {
    this->TimeFrame_.set (x);
  }

  void GetDescriptorsFromArchive::
  setTimeFrame (const TimeFrameOptional& x)
  {
    this->TimeFrame_ = x;
  }

  void GetDescriptorsFromArchive::
  setTimeFrame (::std::unique_ptr< TimeFrameType > x)
  {
    this->TimeFrame_.set (std::move (x));
  }

  const GetDescriptorsFromArchive::HandleSequence& GetDescriptorsFromArchive::
  getHandle () const
  {
    return this->Handle_;
  }

  GetDescriptorsFromArchive::HandleSequence& GetDescriptorsFromArchive::
  getHandle ()
  {
    return this->Handle_;
  }

  void GetDescriptorsFromArchive::
  setHandle (const HandleSequence& s)
  {
    this->Handle_ = s;
  }


  // GetDescriptorsFromArchiveResponse
  // 

  const GetDescriptorsFromArchiveResponse::DescriptorSequence& GetDescriptorsFromArchiveResponse::
  getDescriptor () const
  {
    return this->Descriptor_;
  }

  GetDescriptorsFromArchiveResponse::DescriptorSequence& GetDescriptorsFromArchiveResponse::
  getDescriptor ()
  {
    return this->Descriptor_;
  }

  void GetDescriptorsFromArchiveResponse::
  setDescriptor (const DescriptorSequence& s)
  {
    this->Descriptor_ = s;
  }


  // GetStatesFromArchive
  // 

  const GetStatesFromArchive::StateRevisionsOptional& GetStatesFromArchive::
  getStateRevisions () const
  {
    return this->StateRevisions_;
  }

  GetStatesFromArchive::StateRevisionsOptional& GetStatesFromArchive::
  getStateRevisions ()
  {
    return this->StateRevisions_;
  }

  void GetStatesFromArchive::
  setStateRevisions (const StateRevisionsType& x)
  {
    this->StateRevisions_.set (x);
  }

  void GetStatesFromArchive::
  setStateRevisions (const StateRevisionsOptional& x)
  {
    this->StateRevisions_ = x;
  }

  void GetStatesFromArchive::
  setStateRevisions (::std::unique_ptr< StateRevisionsType > x)
  {
    this->StateRevisions_.set (std::move (x));
  }

  const GetStatesFromArchive::TimeFrameOptional& GetStatesFromArchive::
  getTimeFrame () const
  {
    return this->TimeFrame_;
  }

  GetStatesFromArchive::TimeFrameOptional& GetStatesFromArchive::
  getTimeFrame ()
  {
    return this->TimeFrame_;
  }

  void GetStatesFromArchive::
  setTimeFrame (const TimeFrameType& x)
  {
    this->TimeFrame_.set (x);
  }

  void GetStatesFromArchive::
  setTimeFrame (const TimeFrameOptional& x)
  {
    this->TimeFrame_ = x;
  }

  void GetStatesFromArchive::
  setTimeFrame (::std::unique_ptr< TimeFrameType > x)
  {
    this->TimeFrame_.set (std::move (x));
  }

  const GetStatesFromArchive::HandleSequence& GetStatesFromArchive::
  getHandle () const
  {
    return this->Handle_;
  }

  GetStatesFromArchive::HandleSequence& GetStatesFromArchive::
  getHandle ()
  {
    return this->Handle_;
  }

  void GetStatesFromArchive::
  setHandle (const HandleSequence& s)
  {
    this->Handle_ = s;
  }


  // GetStatesFromArchiveResponse
  // 

  const GetStatesFromArchiveResponse::StateSequence& GetStatesFromArchiveResponse::
  getState () const
  {
    return this->State_;
  }

  GetStatesFromArchiveResponse::StateSequence& GetStatesFromArchiveResponse::
  getState ()
  {
    return this->State_;
  }

  void GetStatesFromArchiveResponse::
  setState (const StateSequence& s)
  {
    this->State_ = s;
  }


  // SetValue
  // 

  const SetValue::RequestedNumericValueType& SetValue::
  getRequestedNumericValue () const
  {
    return this->RequestedNumericValue_.get ();
  }

  SetValue::RequestedNumericValueType& SetValue::
  getRequestedNumericValue ()
  {
    return this->RequestedNumericValue_.get ();
  }

  void SetValue::
  setRequestedNumericValue (const RequestedNumericValueType& x)
  {
    this->RequestedNumericValue_.set (x);
  }


  // SetValueResponse
  // 


  // SetString
  // 

  const SetString::RequestedStringValueType& SetString::
  getRequestedStringValue () const
  {
    return this->RequestedStringValue_.get ();
  }

  SetString::RequestedStringValueType& SetString::
  getRequestedStringValue ()
  {
    return this->RequestedStringValue_.get ();
  }

  void SetString::
  setRequestedStringValue (const RequestedStringValueType& x)
  {
    this->RequestedStringValue_.set (x);
  }

  void SetString::
  setRequestedStringValue (::std::unique_ptr< RequestedStringValueType > x)
  {
    this->RequestedStringValue_.set (std::move (x));
  }


  // SetStringResponse
  // 


  // Activate
  // 

  const Activate::ArgumentSequence& Activate::
  getArgument () const
  {
    return this->Argument_;
  }

  Activate::ArgumentSequence& Activate::
  getArgument ()
  {
    return this->Argument_;
  }

  void Activate::
  setArgument (const ArgumentSequence& s)
  {
    this->Argument_ = s;
  }


  // ActivateResponse
  // 


  // SetAlertState
  // 

  const SetAlertState::ProposedAlertStateType& SetAlertState::
  getProposedAlertState () const
  {
    return this->ProposedAlertState_.get ();
  }

  SetAlertState::ProposedAlertStateType& SetAlertState::
  getProposedAlertState ()
  {
    return this->ProposedAlertState_.get ();
  }

  void SetAlertState::
  setProposedAlertState (const ProposedAlertStateType& x)
  {
    this->ProposedAlertState_.set (x);
  }

  void SetAlertState::
  setProposedAlertState (::std::unique_ptr< ProposedAlertStateType > x)
  {
    this->ProposedAlertState_.set (std::move (x));
  }


  // SetAlertStateResponse
  // 


  // SetComponentState
  // 

  const SetComponentState::ProposedComponentStateSequence& SetComponentState::
  getProposedComponentState () const
  {
    return this->ProposedComponentState_;
  }

  SetComponentState::ProposedComponentStateSequence& SetComponentState::
  getProposedComponentState ()
  {
    return this->ProposedComponentState_;
  }

  void SetComponentState::
  setProposedComponentState (const ProposedComponentStateSequence& s)
  {
    this->ProposedComponentState_ = s;
  }


  // SetComponentStateResponse
  // 


  // SetMetricState
  // 

  const SetMetricState::ProposedMetricStateSequence& SetMetricState::
  getProposedMetricState () const
  {
    return this->ProposedMetricState_;
  }

  SetMetricState::ProposedMetricStateSequence& SetMetricState::
  getProposedMetricState ()
  {
    return this->ProposedMetricState_;
  }

  void SetMetricState::
  setProposedMetricState (const ProposedMetricStateSequence& s)
  {
    this->ProposedMetricState_ = s;
  }


  // SetMetricStateResponse
  // 


  // OperationInvokedReport
  // 

  const OperationInvokedReport::ReportPartSequence& OperationInvokedReport::
  getReportPart () const
  {
    return this->ReportPart_;
  }

  OperationInvokedReport::ReportPartSequence& OperationInvokedReport::
  getReportPart ()
  {
    return this->ReportPart_;
  }

  void OperationInvokedReport::
  setReportPart (const ReportPartSequence& s)
  {
    this->ReportPart_ = s;
  }


  // GetContainmentTree
  // 

  const GetContainmentTree::HandleRefSequence& GetContainmentTree::
  getHandleRef () const
  {
    return this->HandleRef_;
  }

  GetContainmentTree::HandleRefSequence& GetContainmentTree::
  getHandleRef ()
  {
    return this->HandleRef_;
  }

  void GetContainmentTree::
  setHandleRef (const HandleRefSequence& s)
  {
    this->HandleRef_ = s;
  }


  // GetContainmentTreeResponse
  // 

  const GetContainmentTreeResponse::ContainmentTreeType& GetContainmentTreeResponse::
  getContainmentTree () const
  {
    return this->ContainmentTree_.get ();
  }

  GetContainmentTreeResponse::ContainmentTreeType& GetContainmentTreeResponse::
  getContainmentTree ()
  {
    return this->ContainmentTree_.get ();
  }

  void GetContainmentTreeResponse::
  setContainmentTree (const ContainmentTreeType& x)
  {
    this->ContainmentTree_.set (x);
  }

  void GetContainmentTreeResponse::
  setContainmentTree (::std::unique_ptr< ContainmentTreeType > x)
  {
    this->ContainmentTree_.set (std::move (x));
  }


  // GetDescriptor
  // 

  const GetDescriptor::HandleRefSequence& GetDescriptor::
  getHandleRef () const
  {
    return this->HandleRef_;
  }

  GetDescriptor::HandleRefSequence& GetDescriptor::
  getHandleRef ()
  {
    return this->HandleRef_;
  }

  void GetDescriptor::
  setHandleRef (const HandleRefSequence& s)
  {
    this->HandleRef_ = s;
  }


  // GetDescriptorResponse
  // 

  const GetDescriptorResponse::DescriptorSequence& GetDescriptorResponse::
  getDescriptor () const
  {
    return this->Descriptor_;
  }

  GetDescriptorResponse::DescriptorSequence& GetDescriptorResponse::
  getDescriptor ()
  {
    return this->Descriptor_;
  }

  void GetDescriptorResponse::
  setDescriptor (const DescriptorSequence& s)
  {
    this->Descriptor_ = s;
  }


  // ReportPart1
  // 

  const ReportPart1::MetricStateSequence& ReportPart1::
  getMetricState () const
  {
    return this->MetricState_;
  }

  ReportPart1::MetricStateSequence& ReportPart1::
  getMetricState ()
  {
    return this->MetricState_;
  }

  void ReportPart1::
  setMetricState (const MetricStateSequence& s)
  {
    this->MetricState_ = s;
  }


  // EpisodicMetricReport
  // 


  // PeriodicMetricReport
  // 


  // ReportPart2
  // 

  const ReportPart2::ComponentStateSequence& ReportPart2::
  getComponentState () const
  {
    return this->ComponentState_;
  }

  ReportPart2::ComponentStateSequence& ReportPart2::
  getComponentState ()
  {
    return this->ComponentState_;
  }

  void ReportPart2::
  setComponentState (const ComponentStateSequence& s)
  {
    this->ComponentState_ = s;
  }


  // EpisodicComponentReport
  // 


  // PeriodicComponentReport
  // 


  // ReportPart3
  // 

  const ReportPart3::AlertStateSequence& ReportPart3::
  getAlertState () const
  {
    return this->AlertState_;
  }

  ReportPart3::AlertStateSequence& ReportPart3::
  getAlertState ()
  {
    return this->AlertState_;
  }

  void ReportPart3::
  setAlertState (const AlertStateSequence& s)
  {
    this->AlertState_ = s;
  }


  // EpisodicAlertReport
  // 


  // PeriodicAlertReport
  // 


  // ReportPart4
  // 

  const ReportPart4::OperationStateSequence& ReportPart4::
  getOperationState () const
  {
    return this->OperationState_;
  }

  ReportPart4::OperationStateSequence& ReportPart4::
  getOperationState ()
  {
    return this->OperationState_;
  }

  void ReportPart4::
  setOperationState (const OperationStateSequence& s)
  {
    this->OperationState_ = s;
  }


  // EpisodicOperationalStateReport
  // 


  // PeriodicOperationalStateReport
  // 


  // SystemErrorReport
  // 

  const SystemErrorReport::ReportPartSequence& SystemErrorReport::
  getReportPart () const
  {
    return this->ReportPart_;
  }

  SystemErrorReport::ReportPartSequence& SystemErrorReport::
  getReportPart ()
  {
    return this->ReportPart_;
  }

  void SystemErrorReport::
  setReportPart (const ReportPartSequence& s)
  {
    this->ReportPart_ = s;
  }


  // DescriptionModificationReport
  // 

  const DescriptionModificationReport::ReportPartSequence& DescriptionModificationReport::
  getReportPart () const
  {
    return this->ReportPart_;
  }

  DescriptionModificationReport::ReportPartSequence& DescriptionModificationReport::
  getReportPart ()
  {
    return this->ReportPart_;
  }

  void DescriptionModificationReport::
  setReportPart (const ReportPartSequence& s)
  {
    this->ReportPart_ = s;
  }


  // WaveformStream
  // 

  const WaveformStream::StateSequence& WaveformStream::
  getState () const
  {
    return this->State_;
  }

  WaveformStream::StateSequence& WaveformStream::
  getState ()
  {
    return this->State_;
  }

  void WaveformStream::
  setState (const StateSequence& s)
  {
    this->State_ = s;
  }


  // ObservedValueStream
  // 

  const ObservedValueStream::ValueSequence& ObservedValueStream::
  getValue () const
  {
    return this->Value_;
  }

  ObservedValueStream::ValueSequence& ObservedValueStream::
  getValue ()
  {
    return this->Value_;
  }

  void ObservedValueStream::
  setValue (const ValueSequence& s)
  {
    this->Value_ = s;
  }


  // Retrievability
  // 

  const Retrievability::BySequence& Retrievability::
  getBy () const
  {
    return this->By_;
  }

  Retrievability::BySequence& Retrievability::
  getBy ()
  {
    return this->By_;
  }

  void Retrievability::
  setBy (const BySequence& s)
  {
    this->By_ = s;
  }


  // Argument
  // 

  const Argument::ExtensionOptional& Argument::
  getExtension () const
  {
    return this->Extension_;
  }

  Argument::ExtensionOptional& Argument::
  getExtension ()
  {
    return this->Extension_;
  }

  void Argument::
  setExtension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void Argument::
  setExtension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void Argument::
  setExtension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const Argument::ArgValueType& Argument::
  getArgValue () const
  {
    return this->ArgValue_.get ();
  }

  Argument::ArgValueType& Argument::
  getArgValue ()
  {
    return this->ArgValue_.get ();
  }

  void Argument::
  setArgValue (const ArgValueType& x)
  {
    this->ArgValue_.set (x);
  }

  void Argument::
  setArgValue (::std::unique_ptr< ArgValueType > x)
  {
    this->ArgValue_.set (std::move (x));
  }


  // ReportPart5
  // 

  const ReportPart5::InvocationInfoType& ReportPart5::
  getInvocationInfo () const
  {
    return this->InvocationInfo_.get ();
  }

  ReportPart5::InvocationInfoType& ReportPart5::
  getInvocationInfo ()
  {
    return this->InvocationInfo_.get ();
  }

  void ReportPart5::
  setInvocationInfo (const InvocationInfoType& x)
  {
    this->InvocationInfo_.set (x);
  }

  void ReportPart5::
  setInvocationInfo (::std::unique_ptr< InvocationInfoType > x)
  {
    this->InvocationInfo_.set (std::move (x));
  }

  const ReportPart5::InvocationSourceType& ReportPart5::
  getInvocationSource () const
  {
    return this->InvocationSource_.get ();
  }

  ReportPart5::InvocationSourceType& ReportPart5::
  getInvocationSource ()
  {
    return this->InvocationSource_.get ();
  }

  void ReportPart5::
  setInvocationSource (const InvocationSourceType& x)
  {
    this->InvocationSource_.set (x);
  }

  void ReportPart5::
  setInvocationSource (::std::unique_ptr< InvocationSourceType > x)
  {
    this->InvocationSource_.set (std::move (x));
  }

  const ReportPart5::OperationHandleRefType& ReportPart5::
  getOperationHandleRef () const
  {
    return this->OperationHandleRef_.get ();
  }

  ReportPart5::OperationHandleRefType& ReportPart5::
  getOperationHandleRef ()
  {
    return this->OperationHandleRef_.get ();
  }

  void ReportPart5::
  setOperationHandleRef (const OperationHandleRefType& x)
  {
    this->OperationHandleRef_.set (x);
  }

  void ReportPart5::
  setOperationHandleRef (::std::unique_ptr< OperationHandleRefType > x)
  {
    this->OperationHandleRef_.set (std::move (x));
  }

  const ReportPart5::OperationTargetOptional& ReportPart5::
  getOperationTarget () const
  {
    return this->OperationTarget_;
  }

  ReportPart5::OperationTargetOptional& ReportPart5::
  getOperationTarget ()
  {
    return this->OperationTarget_;
  }

  void ReportPart5::
  setOperationTarget (const OperationTargetType& x)
  {
    this->OperationTarget_.set (x);
  }

  void ReportPart5::
  setOperationTarget (const OperationTargetOptional& x)
  {
    this->OperationTarget_ = x;
  }

  void ReportPart5::
  setOperationTarget (::std::unique_ptr< OperationTargetType > x)
  {
    this->OperationTarget_.set (std::move (x));
  }


  // ReportPart6
  // 

  const ReportPart6::ErrorCodeType& ReportPart6::
  getErrorCode () const
  {
    return this->ErrorCode_.get ();
  }

  ReportPart6::ErrorCodeType& ReportPart6::
  getErrorCode ()
  {
    return this->ErrorCode_.get ();
  }

  void ReportPart6::
  setErrorCode (const ErrorCodeType& x)
  {
    this->ErrorCode_.set (x);
  }

  void ReportPart6::
  setErrorCode (::std::unique_ptr< ErrorCodeType > x)
  {
    this->ErrorCode_.set (std::move (x));
  }

  const ReportPart6::ErrorInfoOptional& ReportPart6::
  getErrorInfo () const
  {
    return this->ErrorInfo_;
  }

  ReportPart6::ErrorInfoOptional& ReportPart6::
  getErrorInfo ()
  {
    return this->ErrorInfo_;
  }

  void ReportPart6::
  setErrorInfo (const ErrorInfoType& x)
  {
    this->ErrorInfo_.set (x);
  }

  void ReportPart6::
  setErrorInfo (const ErrorInfoOptional& x)
  {
    this->ErrorInfo_ = x;
  }

  void ReportPart6::
  setErrorInfo (::std::unique_ptr< ErrorInfoType > x)
  {
    this->ErrorInfo_.set (std::move (x));
  }


  // ReportPart7
  // 

  const ReportPart7::DescriptorSequence& ReportPart7::
  getDescriptor () const
  {
    return this->Descriptor_;
  }

  ReportPart7::DescriptorSequence& ReportPart7::
  getDescriptor ()
  {
    return this->Descriptor_;
  }

  void ReportPart7::
  setDescriptor (const DescriptorSequence& s)
  {
    this->Descriptor_ = s;
  }

  const ReportPart7::StateSequence& ReportPart7::
  getState () const
  {
    return this->State_;
  }

  ReportPart7::StateSequence& ReportPart7::
  getState ()
  {
    return this->State_;
  }

  void ReportPart7::
  setState (const StateSequence& s)
  {
    this->State_ = s;
  }

  const ReportPart7::ParentDescriptorOptional& ReportPart7::
  getParentDescriptor () const
  {
    return this->ParentDescriptor_;
  }

  ReportPart7::ParentDescriptorOptional& ReportPart7::
  getParentDescriptor ()
  {
    return this->ParentDescriptor_;
  }

  void ReportPart7::
  setParentDescriptor (const ParentDescriptorType& x)
  {
    this->ParentDescriptor_.set (x);
  }

  void ReportPart7::
  setParentDescriptor (const ParentDescriptorOptional& x)
  {
    this->ParentDescriptor_ = x;
  }

  void ReportPart7::
  setParentDescriptor (::std::unique_ptr< ParentDescriptorType > x)
  {
    this->ParentDescriptor_.set (std::move (x));
  }

  const ReportPart7::ModificationTypeOptional& ReportPart7::
  getModificationType () const
  {
    return this->ModificationType_;
  }

  ReportPart7::ModificationTypeOptional& ReportPart7::
  getModificationType ()
  {
    return this->ModificationType_;
  }

  void ReportPart7::
  setModificationType (const ModificationTypeType& x)
  {
    this->ModificationType_.set (x);
  }

  void ReportPart7::
  setModificationType (const ModificationTypeOptional& x)
  {
    this->ModificationType_ = x;
  }

  void ReportPart7::
  setModificationType (::std::unique_ptr< ModificationTypeType > x)
  {
    this->ModificationType_.set (std::move (x));
  }


  // Value
  // 

  const Value::Value1Optional& Value::
  getValue1 () const
  {
    return this->Value1_;
  }

  Value::Value1Optional& Value::
  getValue1 ()
  {
    return this->Value1_;
  }

  void Value::
  setValue1 (const Value1Type& x)
  {
    this->Value1_.set (x);
  }

  void Value::
  setValue1 (const Value1Optional& x)
  {
    this->Value1_ = x;
  }

  void Value::
  setValue1 (::std::unique_ptr< Value1Type > x)
  {
    this->Value1_.set (std::move (x));
  }

  const Value::MetricType& Value::
  getMetric () const
  {
    return this->Metric_.get ();
  }

  Value::MetricType& Value::
  getMetric ()
  {
    return this->Metric_.get ();
  }

  void Value::
  setMetric (const MetricType& x)
  {
    this->Metric_.set (x);
  }

  void Value::
  setMetric (::std::unique_ptr< MetricType > x)
  {
    this->Metric_.set (std::move (x));
  }

  const Value::StateVersionOptional& Value::
  getStateVersion () const
  {
    return this->StateVersion_;
  }

  Value::StateVersionOptional& Value::
  getStateVersion ()
  {
    return this->StateVersion_;
  }

  void Value::
  setStateVersion (const StateVersionType& x)
  {
    this->StateVersion_.set (x);
  }

  void Value::
  setStateVersion (const StateVersionOptional& x)
  {
    this->StateVersion_ = x;
  }

  void Value::
  setStateVersion (::std::unique_ptr< StateVersionType > x)
  {
    this->StateVersion_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace MDM
{
  // TransactionId
  //

  TransactionId::
  TransactionId (const ::xml_schema::UnsignedInt& _xsd_UnsignedInt_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType > (_xsd_UnsignedInt_base)
  {
  }

  TransactionId::
  TransactionId (const TransactionId& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  TransactionId::
  TransactionId (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  TransactionId::
  TransactionId (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  TransactionId::
  TransactionId (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  TransactionId* TransactionId::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TransactionId (*this, f, c);
  }

  TransactionId::
  ~TransactionId ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, TransactionId >
  _xsd_TransactionId_type_factory_init (
    "TransactionId",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // InvocationState
  //

  InvocationState::
  InvocationState (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_InvocationState_convert ();
  }

  InvocationState::
  InvocationState (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_InvocationState_convert ();
  }

  InvocationState::
  InvocationState (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_InvocationState_convert ();
  }

  InvocationState* InvocationState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InvocationState (*this, f, c);
  }

  InvocationState::Value InvocationState::
  _xsd_InvocationState_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_InvocationState_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_InvocationState_indexes_,
                      _xsd_InvocationState_indexes_ + 7,
                      *this,
                      c));

    if (i == _xsd_InvocationState_indexes_ + 7 || _xsd_InvocationState_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const InvocationState::
  _xsd_InvocationState_literals_[7] =
  {
    "Wait",
    "Start",
    "Cnclld",
    "CnclldMan",
    "Fin",
    "FinMod",
    "Fail"
  };

  const InvocationState::Value InvocationState::
  _xsd_InvocationState_indexes_[7] =
  {
    ::MDM::InvocationState::Cnclld,
    ::MDM::InvocationState::CnclldMan,
    ::MDM::InvocationState::Fail,
    ::MDM::InvocationState::Fin,
    ::MDM::InvocationState::FinMod,
    ::MDM::InvocationState::Start,
    ::MDM::InvocationState::Wait
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, InvocationState >
  _xsd_InvocationState_type_factory_init (
    "InvocationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // InvocationError
  //

  InvocationError::
  InvocationError (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_InvocationError_convert ();
  }

  InvocationError::
  InvocationError (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_InvocationError_convert ();
  }

  InvocationError::
  InvocationError (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_InvocationError_convert ();
  }

  InvocationError* InvocationError::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InvocationError (*this, f, c);
  }

  InvocationError::Value InvocationError::
  _xsd_InvocationError_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_InvocationError_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_InvocationError_indexes_,
                      _xsd_InvocationError_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_InvocationError_indexes_ + 4 || _xsd_InvocationError_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const InvocationError::
  _xsd_InvocationError_literals_[4] =
  {
    "Unspec",
    "Unkn",
    "Inv",
    "Oth"
  };

  const InvocationError::Value InvocationError::
  _xsd_InvocationError_indexes_[4] =
  {
    ::MDM::InvocationError::Inv,
    ::MDM::InvocationError::Oth,
    ::MDM::InvocationError::Unkn,
    ::MDM::InvocationError::Unspec
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, InvocationError >
  _xsd_InvocationError_type_factory_init (
    "InvocationError",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // InvocationInfo
  //

  InvocationInfo::
  InvocationInfo (const TransactionIdType& TransactionId,
                  const InvocationStateType& InvocationState)
  : ::xml_schema::Type (),
    Extension_ (this),
    TransactionId_ (TransactionId, this),
    InvocationState_ (InvocationState, this),
    InvocationError_ (this),
    InvocationErrorMessage_ (this)
  {
  }

  InvocationInfo::
  InvocationInfo (::std::unique_ptr< TransactionIdType > TransactionId,
                  ::std::unique_ptr< InvocationStateType > InvocationState)
  : ::xml_schema::Type (),
    Extension_ (this),
    TransactionId_ (std::move (TransactionId), this),
    InvocationState_ (std::move (InvocationState), this),
    InvocationError_ (this),
    InvocationErrorMessage_ (this)
  {
  }

  InvocationInfo::
  InvocationInfo (const InvocationInfo& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    TransactionId_ (x.TransactionId_, f, this),
    InvocationState_ (x.InvocationState_, f, this),
    InvocationError_ (x.InvocationError_, f, this),
    InvocationErrorMessage_ (x.InvocationErrorMessage_, f, this)
  {
  }

  InvocationInfo::
  InvocationInfo (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    TransactionId_ (this),
    InvocationState_ (this),
    InvocationError_ (this),
    InvocationErrorMessage_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void InvocationInfo::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // TransactionId
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TransactionId",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< TransactionIdType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!TransactionId_.present ())
          {
            ::std::unique_ptr< TransactionIdType > r (
              dynamic_cast< TransactionIdType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->TransactionId_.set (::std::move (r));
            continue;
          }
        }
      }

      // InvocationState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "InvocationState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< InvocationStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!InvocationState_.present ())
          {
            ::std::unique_ptr< InvocationStateType > r (
              dynamic_cast< InvocationStateType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->InvocationState_.set (::std::move (r));
            continue;
          }
        }
      }

      // InvocationError
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "InvocationError",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< InvocationErrorType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->InvocationError_)
          {
            ::std::unique_ptr< InvocationErrorType > r (
              dynamic_cast< InvocationErrorType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->InvocationError_.set (::std::move (r));
            continue;
          }
        }
      }

      // InvocationErrorMessage
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "InvocationErrorMessage",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< InvocationErrorMessageType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< InvocationErrorMessageType > r (
            dynamic_cast< InvocationErrorMessageType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->InvocationErrorMessage_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!TransactionId_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TransactionId",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }

    if (!InvocationState_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "InvocationState",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  InvocationInfo* InvocationInfo::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InvocationInfo (*this, f, c);
  }

  InvocationInfo& InvocationInfo::
  operator= (const InvocationInfo& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->TransactionId_ = x.TransactionId_;
      this->InvocationState_ = x.InvocationState_;
      this->InvocationError_ = x.InvocationError_;
      this->InvocationErrorMessage_ = x.InvocationErrorMessage_;
    }

    return *this;
  }

  InvocationInfo::
  ~InvocationInfo ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, InvocationInfo >
  _xsd_InvocationInfo_type_factory_init (
    "InvocationInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractGet
  //

  AbstractGet::
  AbstractGet ()
  : ::xml_schema::Type (),
    Extension_ (this)
  {
  }

  AbstractGet::
  AbstractGet (const AbstractGet& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this)
  {
  }

  AbstractGet::
  AbstractGet (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AbstractGet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  AbstractGet* AbstractGet::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractGet (*this, f, c);
  }

  AbstractGet& AbstractGet::
  operator= (const AbstractGet& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
    }

    return *this;
  }

  AbstractGet::
  ~AbstractGet ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractGet >
  _xsd_AbstractGet_type_factory_init (
    "AbstractGet",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractGetResponse
  //

  AbstractGetResponse::
  AbstractGetResponse (const SequenceIdType& SequenceId)
  : ::xml_schema::Type (),
    Extension_ (this),
    MdibVersion_ (this),
    SequenceId_ (SequenceId, this),
    InstanceId_ (this)
  {
  }

  AbstractGetResponse::
  AbstractGetResponse (const AbstractGetResponse& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    MdibVersion_ (x.MdibVersion_, f, this),
    SequenceId_ (x.SequenceId_, f, this),
    InstanceId_ (x.InstanceId_, f, this)
  {
  }

  AbstractGetResponse::
  AbstractGetResponse (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    MdibVersion_ (this),
    SequenceId_ (this),
    InstanceId_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractGetResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MdibVersion" && n.namespace_ ().empty ())
      {
        this->MdibVersion_.set (MdibVersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "SequenceId" && n.namespace_ ().empty ())
      {
        this->SequenceId_.set (SequenceIdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "InstanceId" && n.namespace_ ().empty ())
      {
        this->InstanceId_.set (InstanceIdTraits::create (i, f, this));
        continue;
      }
    }

    if (!SequenceId_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "SequenceId",
        "");
    }
  }

  AbstractGetResponse* AbstractGetResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractGetResponse (*this, f, c);
  }

  AbstractGetResponse& AbstractGetResponse::
  operator= (const AbstractGetResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->MdibVersion_ = x.MdibVersion_;
      this->SequenceId_ = x.SequenceId_;
      this->InstanceId_ = x.InstanceId_;
    }

    return *this;
  }

  AbstractGetResponse::
  ~AbstractGetResponse ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractGetResponse >
  _xsd_AbstractGetResponse_type_factory_init (
    "AbstractGetResponse",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractReportPart
  //

  AbstractReportPart::
  AbstractReportPart ()
  : ::xml_schema::Type (),
    Extension_ (this),
    SourceMds_ (this)
  {
  }

  AbstractReportPart::
  AbstractReportPart (const AbstractReportPart& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    SourceMds_ (x.SourceMds_, f, this)
  {
  }

  AbstractReportPart::
  AbstractReportPart (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    SourceMds_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AbstractReportPart::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // SourceMds
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SourceMds",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< SourceMdsType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->SourceMds_)
          {
            ::std::unique_ptr< SourceMdsType > r (
              dynamic_cast< SourceMdsType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SourceMds_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  AbstractReportPart* AbstractReportPart::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractReportPart (*this, f, c);
  }

  AbstractReportPart& AbstractReportPart::
  operator= (const AbstractReportPart& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->SourceMds_ = x.SourceMds_;
    }

    return *this;
  }

  AbstractReportPart::
  ~AbstractReportPart ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractReportPart >
  _xsd_AbstractReportPart_type_factory_init (
    "AbstractReportPart",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractReport
  //

  AbstractReport::
  AbstractReport (const SequenceIdType& SequenceId)
  : ::xml_schema::Type (),
    Extension_ (this),
    MdibVersion_ (this),
    SequenceId_ (SequenceId, this),
    InstanceId_ (this)
  {
  }

  AbstractReport::
  AbstractReport (const AbstractReport& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    MdibVersion_ (x.MdibVersion_, f, this),
    SequenceId_ (x.SequenceId_, f, this),
    InstanceId_ (x.InstanceId_, f, this)
  {
  }

  AbstractReport::
  AbstractReport (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    MdibVersion_ (this),
    SequenceId_ (this),
    InstanceId_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MdibVersion" && n.namespace_ ().empty ())
      {
        this->MdibVersion_.set (MdibVersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "SequenceId" && n.namespace_ ().empty ())
      {
        this->SequenceId_.set (SequenceIdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "InstanceId" && n.namespace_ ().empty ())
      {
        this->InstanceId_.set (InstanceIdTraits::create (i, f, this));
        continue;
      }
    }

    if (!SequenceId_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "SequenceId",
        "");
    }
  }

  AbstractReport* AbstractReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractReport (*this, f, c);
  }

  AbstractReport& AbstractReport::
  operator= (const AbstractReport& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->MdibVersion_ = x.MdibVersion_;
      this->SequenceId_ = x.SequenceId_;
      this->InstanceId_ = x.InstanceId_;
    }

    return *this;
  }

  AbstractReport::
  ~AbstractReport ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractReport >
  _xsd_AbstractReport_type_factory_init (
    "AbstractReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractSet
  //

  AbstractSet::
  AbstractSet (const OperationHandleRefType& OperationHandleRef)
  : ::xml_schema::Type (),
    Extension_ (this),
    OperationHandleRef_ (OperationHandleRef, this)
  {
  }

  AbstractSet::
  AbstractSet (::std::unique_ptr< OperationHandleRefType > OperationHandleRef)
  : ::xml_schema::Type (),
    Extension_ (this),
    OperationHandleRef_ (std::move (OperationHandleRef), this)
  {
  }

  AbstractSet::
  AbstractSet (const AbstractSet& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    OperationHandleRef_ (x.OperationHandleRef_, f, this)
  {
  }

  AbstractSet::
  AbstractSet (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    OperationHandleRef_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AbstractSet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // OperationHandleRef
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OperationHandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< OperationHandleRefType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!OperationHandleRef_.present ())
          {
            ::std::unique_ptr< OperationHandleRefType > r (
              dynamic_cast< OperationHandleRefType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OperationHandleRef_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!OperationHandleRef_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "OperationHandleRef",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  AbstractSet* AbstractSet::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractSet (*this, f, c);
  }

  AbstractSet& AbstractSet::
  operator= (const AbstractSet& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->OperationHandleRef_ = x.OperationHandleRef_;
    }

    return *this;
  }

  AbstractSet::
  ~AbstractSet ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractSet >
  _xsd_AbstractSet_type_factory_init (
    "AbstractSet",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractSetResponse
  //

  AbstractSetResponse::
  AbstractSetResponse (const InvocationInfoType& InvocationInfo,
                       const SequenceIdType& SequenceId)
  : ::xml_schema::Type (),
    Extension_ (this),
    InvocationInfo_ (InvocationInfo, this),
    MdibVersion_ (this),
    SequenceId_ (SequenceId, this),
    InstanceId_ (this)
  {
  }

  AbstractSetResponse::
  AbstractSetResponse (::std::unique_ptr< InvocationInfoType > InvocationInfo,
                       const SequenceIdType& SequenceId)
  : ::xml_schema::Type (),
    Extension_ (this),
    InvocationInfo_ (std::move (InvocationInfo), this),
    MdibVersion_ (this),
    SequenceId_ (SequenceId, this),
    InstanceId_ (this)
  {
  }

  AbstractSetResponse::
  AbstractSetResponse (const AbstractSetResponse& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    InvocationInfo_ (x.InvocationInfo_, f, this),
    MdibVersion_ (x.MdibVersion_, f, this),
    SequenceId_ (x.SequenceId_, f, this),
    InstanceId_ (x.InstanceId_, f, this)
  {
  }

  AbstractSetResponse::
  AbstractSetResponse (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    InvocationInfo_ (this),
    MdibVersion_ (this),
    SequenceId_ (this),
    InstanceId_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractSetResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // InvocationInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "InvocationInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< InvocationInfoType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!InvocationInfo_.present ())
          {
            ::std::unique_ptr< InvocationInfoType > r (
              dynamic_cast< InvocationInfoType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->InvocationInfo_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!InvocationInfo_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "InvocationInfo",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MdibVersion" && n.namespace_ ().empty ())
      {
        this->MdibVersion_.set (MdibVersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "SequenceId" && n.namespace_ ().empty ())
      {
        this->SequenceId_.set (SequenceIdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "InstanceId" && n.namespace_ ().empty ())
      {
        this->InstanceId_.set (InstanceIdTraits::create (i, f, this));
        continue;
      }
    }

    if (!SequenceId_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "SequenceId",
        "");
    }
  }

  AbstractSetResponse* AbstractSetResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractSetResponse (*this, f, c);
  }

  AbstractSetResponse& AbstractSetResponse::
  operator= (const AbstractSetResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->InvocationInfo_ = x.InvocationInfo_;
      this->MdibVersion_ = x.MdibVersion_;
      this->SequenceId_ = x.SequenceId_;
      this->InstanceId_ = x.InstanceId_;
    }

    return *this;
  }

  AbstractSetResponse::
  ~AbstractSetResponse ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractSetResponse >
  _xsd_AbstractSetResponse_type_factory_init (
    "AbstractSetResponse",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractContextReport
  //

  AbstractContextReport::
  AbstractContextReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    ReportPart_ (this)
  {
  }

  AbstractContextReport::
  AbstractContextReport (const AbstractContextReport& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    ReportPart_ (x.ReportPart_, f, this)
  {
  }

  AbstractContextReport::
  AbstractContextReport (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    ReportPart_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractContextReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReportPart
      //
      if (n.name () == "ReportPart" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ReportPartType > r (
          ReportPartTraits::create (i, f, this));

        this->ReportPart_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AbstractContextReport* AbstractContextReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractContextReport (*this, f, c);
  }

  AbstractContextReport& AbstractContextReport::
  operator= (const AbstractContextReport& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->ReportPart_ = x.ReportPart_;
    }

    return *this;
  }

  AbstractContextReport::
  ~AbstractContextReport ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractContextReport >
  _xsd_AbstractContextReport_type_factory_init (
    "AbstractContextReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // VersionFrame
  //

  VersionFrame::
  VersionFrame ()
  : ::xml_schema::Type (),
    Start_ (this),
    End_ (this)
  {
  }

  VersionFrame::
  VersionFrame (const VersionFrame& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Start_ (x.Start_, f, this),
    End_ (x.End_, f, this)
  {
  }

  VersionFrame::
  VersionFrame (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Start_ (this),
    End_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void VersionFrame::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Start" && n.namespace_ ().empty ())
      {
        this->Start_.set (StartTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "End" && n.namespace_ ().empty ())
      {
        this->End_.set (EndTraits::create (i, f, this));
        continue;
      }
    }
  }

  VersionFrame* VersionFrame::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VersionFrame (*this, f, c);
  }

  VersionFrame& VersionFrame::
  operator= (const VersionFrame& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Start_ = x.Start_;
      this->End_ = x.End_;
    }

    return *this;
  }

  VersionFrame::
  ~VersionFrame ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, VersionFrame >
  _xsd_VersionFrame_type_factory_init (
    "VersionFrame",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // TimeFrame
  //

  TimeFrame::
  TimeFrame ()
  : ::xml_schema::Type (),
    Start_ (this),
    End_ (this)
  {
  }

  TimeFrame::
  TimeFrame (const TimeFrame& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Start_ (x.Start_, f, this),
    End_ (x.End_, f, this)
  {
  }

  TimeFrame::
  TimeFrame (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Start_ (this),
    End_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void TimeFrame::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Start" && n.namespace_ ().empty ())
      {
        this->Start_.set (StartTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "End" && n.namespace_ ().empty ())
      {
        this->End_.set (EndTraits::create (i, f, this));
        continue;
      }
    }
  }

  TimeFrame* TimeFrame::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimeFrame (*this, f, c);
  }

  TimeFrame& TimeFrame::
  operator= (const TimeFrame& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Start_ = x.Start_;
      this->End_ = x.End_;
    }

    return *this;
  }

  TimeFrame::
  ~TimeFrame ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, TimeFrame >
  _xsd_TimeFrame_type_factory_init (
    "TimeFrame",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractMetricReport
  //

  AbstractMetricReport::
  AbstractMetricReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    ReportPart_ (this)
  {
  }

  AbstractMetricReport::
  AbstractMetricReport (const AbstractMetricReport& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    ReportPart_ (x.ReportPart_, f, this)
  {
  }

  AbstractMetricReport::
  AbstractMetricReport (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    ReportPart_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractMetricReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReportPart
      //
      if (n.name () == "ReportPart" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ReportPartType > r (
          ReportPartTraits::create (i, f, this));

        this->ReportPart_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AbstractMetricReport* AbstractMetricReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractMetricReport (*this, f, c);
  }

  AbstractMetricReport& AbstractMetricReport::
  operator= (const AbstractMetricReport& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->ReportPart_ = x.ReportPart_;
    }

    return *this;
  }

  AbstractMetricReport::
  ~AbstractMetricReport ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractMetricReport >
  _xsd_AbstractMetricReport_type_factory_init (
    "AbstractMetricReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractComponentReport
  //

  AbstractComponentReport::
  AbstractComponentReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    ReportPart_ (this)
  {
  }

  AbstractComponentReport::
  AbstractComponentReport (const AbstractComponentReport& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    ReportPart_ (x.ReportPart_, f, this)
  {
  }

  AbstractComponentReport::
  AbstractComponentReport (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    ReportPart_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractComponentReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReportPart
      //
      if (n.name () == "ReportPart" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ReportPartType > r (
          ReportPartTraits::create (i, f, this));

        this->ReportPart_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AbstractComponentReport* AbstractComponentReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractComponentReport (*this, f, c);
  }

  AbstractComponentReport& AbstractComponentReport::
  operator= (const AbstractComponentReport& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->ReportPart_ = x.ReportPart_;
    }

    return *this;
  }

  AbstractComponentReport::
  ~AbstractComponentReport ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractComponentReport >
  _xsd_AbstractComponentReport_type_factory_init (
    "AbstractComponentReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractAlertReport
  //

  AbstractAlertReport::
  AbstractAlertReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    ReportPart_ (this)
  {
  }

  AbstractAlertReport::
  AbstractAlertReport (const AbstractAlertReport& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    ReportPart_ (x.ReportPart_, f, this)
  {
  }

  AbstractAlertReport::
  AbstractAlertReport (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    ReportPart_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractAlertReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReportPart
      //
      if (n.name () == "ReportPart" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ReportPartType > r (
          ReportPartTraits::create (i, f, this));

        this->ReportPart_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AbstractAlertReport* AbstractAlertReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractAlertReport (*this, f, c);
  }

  AbstractAlertReport& AbstractAlertReport::
  operator= (const AbstractAlertReport& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->ReportPart_ = x.ReportPart_;
    }

    return *this;
  }

  AbstractAlertReport::
  ~AbstractAlertReport ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractAlertReport >
  _xsd_AbstractAlertReport_type_factory_init (
    "AbstractAlertReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractOperationalStateReport
  //

  AbstractOperationalStateReport::
  AbstractOperationalStateReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    ReportPart_ (this)
  {
  }

  AbstractOperationalStateReport::
  AbstractOperationalStateReport (const AbstractOperationalStateReport& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    ReportPart_ (x.ReportPart_, f, this)
  {
  }

  AbstractOperationalStateReport::
  AbstractOperationalStateReport (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    ReportPart_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractOperationalStateReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReportPart
      //
      if (n.name () == "ReportPart" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ReportPartType > r (
          ReportPartTraits::create (i, f, this));

        this->ReportPart_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AbstractOperationalStateReport* AbstractOperationalStateReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractOperationalStateReport (*this, f, c);
  }

  AbstractOperationalStateReport& AbstractOperationalStateReport::
  operator= (const AbstractOperationalStateReport& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->ReportPart_ = x.ReportPart_;
    }

    return *this;
  }

  AbstractOperationalStateReport::
  ~AbstractOperationalStateReport ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractOperationalStateReport >
  _xsd_AbstractOperationalStateReport_type_factory_init (
    "AbstractOperationalStateReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // DescriptionModificationType
  //

  DescriptionModificationType::
  DescriptionModificationType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_DescriptionModificationType_convert ();
  }

  DescriptionModificationType::
  DescriptionModificationType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_DescriptionModificationType_convert ();
  }

  DescriptionModificationType::
  DescriptionModificationType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_DescriptionModificationType_convert ();
  }

  DescriptionModificationType* DescriptionModificationType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DescriptionModificationType (*this, f, c);
  }

  DescriptionModificationType::Value DescriptionModificationType::
  _xsd_DescriptionModificationType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_DescriptionModificationType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_DescriptionModificationType_indexes_,
                      _xsd_DescriptionModificationType_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_DescriptionModificationType_indexes_ + 3 || _xsd_DescriptionModificationType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const DescriptionModificationType::
  _xsd_DescriptionModificationType_literals_[3] =
  {
    "Crt",
    "Upt",
    "Del"
  };

  const DescriptionModificationType::Value DescriptionModificationType::
  _xsd_DescriptionModificationType_indexes_[3] =
  {
    ::MDM::DescriptionModificationType::Crt,
    ::MDM::DescriptionModificationType::Del,
    ::MDM::DescriptionModificationType::Upt
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, DescriptionModificationType >
  _xsd_DescriptionModificationType_type_factory_init (
    "DescriptionModificationType",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // RetrievabilityMethod
  //

  RetrievabilityMethod::
  RetrievabilityMethod (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_RetrievabilityMethod_convert ();
  }

  RetrievabilityMethod::
  RetrievabilityMethod (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_RetrievabilityMethod_convert ();
  }

  RetrievabilityMethod::
  RetrievabilityMethod (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_RetrievabilityMethod_convert ();
  }

  RetrievabilityMethod* RetrievabilityMethod::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RetrievabilityMethod (*this, f, c);
  }

  RetrievabilityMethod::Value RetrievabilityMethod::
  _xsd_RetrievabilityMethod_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RetrievabilityMethod_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_RetrievabilityMethod_indexes_,
                      _xsd_RetrievabilityMethod_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_RetrievabilityMethod_indexes_ + 4 || _xsd_RetrievabilityMethod_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const RetrievabilityMethod::
  _xsd_RetrievabilityMethod_literals_[4] =
  {
    "Get",
    "Per",
    "Ep",
    "Strm"
  };

  const RetrievabilityMethod::Value RetrievabilityMethod::
  _xsd_RetrievabilityMethod_indexes_[4] =
  {
    ::MDM::RetrievabilityMethod::Ep,
    ::MDM::RetrievabilityMethod::Get,
    ::MDM::RetrievabilityMethod::Per,
    ::MDM::RetrievabilityMethod::Strm
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RetrievabilityMethod >
  _xsd_RetrievabilityMethod_type_factory_init (
    "RetrievabilityMethod",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // RetrievabilityInfo
  //

  RetrievabilityInfo::
  RetrievabilityInfo (const MethodType& Method)
  : ::xml_schema::Type (),
    Extension_ (this),
    Method_ (Method, this),
    UpdatePeriod_ (this)
  {
  }

  RetrievabilityInfo::
  RetrievabilityInfo (const RetrievabilityInfo& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Method_ (x.Method_, f, this),
    UpdatePeriod_ (x.UpdatePeriod_, f, this)
  {
  }

  RetrievabilityInfo::
  RetrievabilityInfo (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Method_ (this),
    UpdatePeriod_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void RetrievabilityInfo::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Method" && n.namespace_ ().empty ())
      {
        this->Method_.set (MethodTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "UpdatePeriod" && n.namespace_ ().empty ())
      {
        this->UpdatePeriod_.set (UpdatePeriodTraits::create (i, f, this));
        continue;
      }
    }

    if (!Method_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Method",
        "");
    }
  }

  RetrievabilityInfo* RetrievabilityInfo::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RetrievabilityInfo (*this, f, c);
  }

  RetrievabilityInfo& RetrievabilityInfo::
  operator= (const RetrievabilityInfo& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Method_ = x.Method_;
      this->UpdatePeriod_ = x.UpdatePeriod_;
    }

    return *this;
  }

  RetrievabilityInfo::
  ~RetrievabilityInfo ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RetrievabilityInfo >
  _xsd_RetrievabilityInfo_type_factory_init (
    "RetrievabilityInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // GetMdib
  //

  GetMdib::
  GetMdib ()
  : ::MDM::AbstractGet ()
  {
  }

  GetMdib::
  GetMdib (const GetMdib& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c)
  {
  }

  GetMdib::
  GetMdib (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f, c)
  {
  }

  GetMdib* GetMdib::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetMdib (*this, f, c);
  }

  GetMdib::
  ~GetMdib ()
  {
  }

  // GetMdibResponse
  //

  GetMdibResponse::
  GetMdibResponse (const SequenceIdType& SequenceId,
                   const MdibType& Mdib)
  : ::MDM::AbstractGetResponse (SequenceId),
    Mdib_ (Mdib, this)
  {
  }

  GetMdibResponse::
  GetMdibResponse (const SequenceIdType& SequenceId,
                   ::std::unique_ptr< MdibType > Mdib)
  : ::MDM::AbstractGetResponse (SequenceId),
    Mdib_ (std::move (Mdib), this)
  {
  }

  GetMdibResponse::
  GetMdibResponse (const GetMdibResponse& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    Mdib_ (x.Mdib_, f, this)
  {
  }

  GetMdibResponse::
  GetMdibResponse (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    Mdib_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetMdibResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Mdib
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Mdib",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< MdibType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Mdib_.present ())
          {
            ::std::unique_ptr< MdibType > r (
              dynamic_cast< MdibType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Mdib_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Mdib_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Mdib",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  GetMdibResponse* GetMdibResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetMdibResponse (*this, f, c);
  }

  GetMdibResponse& GetMdibResponse::
  operator= (const GetMdibResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->Mdib_ = x.Mdib_;
    }

    return *this;
  }

  GetMdibResponse::
  ~GetMdibResponse ()
  {
  }

  // GetMdDescription
  //

  GetMdDescription::
  GetMdDescription ()
  : ::MDM::AbstractGet (),
    HandleRef_ (this)
  {
  }

  GetMdDescription::
  GetMdDescription (const GetMdDescription& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    HandleRef_ (x.HandleRef_, f, this)
  {
  }

  GetMdDescription::
  GetMdDescription (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    HandleRef_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GetMdDescription::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HandleRef
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< HandleRefType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< HandleRefType > r (
            dynamic_cast< HandleRefType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->HandleRef_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetMdDescription* GetMdDescription::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetMdDescription (*this, f, c);
  }

  GetMdDescription& GetMdDescription::
  operator= (const GetMdDescription& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->HandleRef_ = x.HandleRef_;
    }

    return *this;
  }

  GetMdDescription::
  ~GetMdDescription ()
  {
  }

  // GetMdDescriptionResponse
  //

  GetMdDescriptionResponse::
  GetMdDescriptionResponse (const SequenceIdType& SequenceId,
                            const MdDescriptionType& MdDescription)
  : ::MDM::AbstractGetResponse (SequenceId),
    MdDescription_ (MdDescription, this)
  {
  }

  GetMdDescriptionResponse::
  GetMdDescriptionResponse (const SequenceIdType& SequenceId,
                            ::std::unique_ptr< MdDescriptionType > MdDescription)
  : ::MDM::AbstractGetResponse (SequenceId),
    MdDescription_ (std::move (MdDescription), this)
  {
  }

  GetMdDescriptionResponse::
  GetMdDescriptionResponse (const GetMdDescriptionResponse& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    MdDescription_ (x.MdDescription_, f, this)
  {
  }

  GetMdDescriptionResponse::
  GetMdDescriptionResponse (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    MdDescription_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetMdDescriptionResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MdDescription
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MdDescription",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< MdDescriptionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MdDescription_.present ())
          {
            ::std::unique_ptr< MdDescriptionType > r (
              dynamic_cast< MdDescriptionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MdDescription_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!MdDescription_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MdDescription",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  GetMdDescriptionResponse* GetMdDescriptionResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetMdDescriptionResponse (*this, f, c);
  }

  GetMdDescriptionResponse& GetMdDescriptionResponse::
  operator= (const GetMdDescriptionResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->MdDescription_ = x.MdDescription_;
    }

    return *this;
  }

  GetMdDescriptionResponse::
  ~GetMdDescriptionResponse ()
  {
  }

  // GetMdState
  //

  GetMdState::
  GetMdState ()
  : ::MDM::AbstractGet (),
    HandleRef_ (this)
  {
  }

  GetMdState::
  GetMdState (const GetMdState& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    HandleRef_ (x.HandleRef_, f, this)
  {
  }

  GetMdState::
  GetMdState (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    HandleRef_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GetMdState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HandleRef
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< HandleRefType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< HandleRefType > r (
            dynamic_cast< HandleRefType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->HandleRef_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetMdState* GetMdState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetMdState (*this, f, c);
  }

  GetMdState& GetMdState::
  operator= (const GetMdState& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->HandleRef_ = x.HandleRef_;
    }

    return *this;
  }

  GetMdState::
  ~GetMdState ()
  {
  }

  // GetMdStateResponse
  //

  GetMdStateResponse::
  GetMdStateResponse (const SequenceIdType& SequenceId,
                      const MdStateType& MdState)
  : ::MDM::AbstractGetResponse (SequenceId),
    MdState_ (MdState, this)
  {
  }

  GetMdStateResponse::
  GetMdStateResponse (const SequenceIdType& SequenceId,
                      ::std::unique_ptr< MdStateType > MdState)
  : ::MDM::AbstractGetResponse (SequenceId),
    MdState_ (std::move (MdState), this)
  {
  }

  GetMdStateResponse::
  GetMdStateResponse (const GetMdStateResponse& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    MdState_ (x.MdState_, f, this)
  {
  }

  GetMdStateResponse::
  GetMdStateResponse (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    MdState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetMdStateResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MdState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MdState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< MdStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MdState_.present ())
          {
            ::std::unique_ptr< MdStateType > r (
              dynamic_cast< MdStateType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MdState_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!MdState_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MdState",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  GetMdStateResponse* GetMdStateResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetMdStateResponse (*this, f, c);
  }

  GetMdStateResponse& GetMdStateResponse::
  operator= (const GetMdStateResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->MdState_ = x.MdState_;
    }

    return *this;
  }

  GetMdStateResponse::
  ~GetMdStateResponse ()
  {
  }

  // GetContextStates
  //

  GetContextStates::
  GetContextStates ()
  : ::MDM::AbstractGet (),
    HandleRef_ (this)
  {
  }

  GetContextStates::
  GetContextStates (const GetContextStates& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    HandleRef_ (x.HandleRef_, f, this)
  {
  }

  GetContextStates::
  GetContextStates (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    HandleRef_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GetContextStates::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HandleRef
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< HandleRefType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< HandleRefType > r (
            dynamic_cast< HandleRefType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->HandleRef_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetContextStates* GetContextStates::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetContextStates (*this, f, c);
  }

  GetContextStates& GetContextStates::
  operator= (const GetContextStates& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->HandleRef_ = x.HandleRef_;
    }

    return *this;
  }

  GetContextStates::
  ~GetContextStates ()
  {
  }

  // GetContextStatesResponse
  //

  GetContextStatesResponse::
  GetContextStatesResponse (const SequenceIdType& SequenceId)
  : ::MDM::AbstractGetResponse (SequenceId),
    ContextState_ (this)
  {
  }

  GetContextStatesResponse::
  GetContextStatesResponse (const GetContextStatesResponse& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    ContextState_ (x.ContextState_, f, this)
  {
  }

  GetContextStatesResponse::
  GetContextStatesResponse (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    ContextState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetContextStatesResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ContextState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ContextStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ContextStateType > r (
            dynamic_cast< ContextStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ContextState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetContextStatesResponse* GetContextStatesResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetContextStatesResponse (*this, f, c);
  }

  GetContextStatesResponse& GetContextStatesResponse::
  operator= (const GetContextStatesResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->ContextState_ = x.ContextState_;
    }

    return *this;
  }

  GetContextStatesResponse::
  ~GetContextStatesResponse ()
  {
  }

  // GetContextStatesByIdentification
  //

  GetContextStatesByIdentification::
  GetContextStatesByIdentification ()
  : ::MDM::AbstractGet (),
    Identification_ (this),
    ContextType_ (this)
  {
  }

  GetContextStatesByIdentification::
  GetContextStatesByIdentification (const GetContextStatesByIdentification& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    Identification_ (x.Identification_, f, this),
    ContextType_ (x.ContextType_, f, this)
  {
  }

  GetContextStatesByIdentification::
  GetContextStatesByIdentification (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    Identification_ (this),
    ContextType_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetContextStatesByIdentification::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Identification
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Identification",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< IdentificationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< IdentificationType > r (
            dynamic_cast< IdentificationType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Identification_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ContextType" && n.namespace_ ().empty ())
      {
        this->ContextType_.set (ContextTypeTraits::create (i, f, this));
        continue;
      }
    }
  }

  GetContextStatesByIdentification* GetContextStatesByIdentification::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetContextStatesByIdentification (*this, f, c);
  }

  GetContextStatesByIdentification& GetContextStatesByIdentification::
  operator= (const GetContextStatesByIdentification& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->Identification_ = x.Identification_;
      this->ContextType_ = x.ContextType_;
    }

    return *this;
  }

  GetContextStatesByIdentification::
  ~GetContextStatesByIdentification ()
  {
  }

  // GetContextStatesByIdentificationResponse
  //

  GetContextStatesByIdentificationResponse::
  GetContextStatesByIdentificationResponse (const SequenceIdType& SequenceId)
  : ::MDM::AbstractGetResponse (SequenceId),
    ContextState_ (this)
  {
  }

  GetContextStatesByIdentificationResponse::
  GetContextStatesByIdentificationResponse (const GetContextStatesByIdentificationResponse& x,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    ContextState_ (x.ContextState_, f, this)
  {
  }

  GetContextStatesByIdentificationResponse::
  GetContextStatesByIdentificationResponse (const ::xercesc::DOMElement& e,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    ContextState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetContextStatesByIdentificationResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ContextState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ContextStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ContextStateType > r (
            dynamic_cast< ContextStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ContextState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetContextStatesByIdentificationResponse* GetContextStatesByIdentificationResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetContextStatesByIdentificationResponse (*this, f, c);
  }

  GetContextStatesByIdentificationResponse& GetContextStatesByIdentificationResponse::
  operator= (const GetContextStatesByIdentificationResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->ContextState_ = x.ContextState_;
    }

    return *this;
  }

  GetContextStatesByIdentificationResponse::
  ~GetContextStatesByIdentificationResponse ()
  {
  }

  // GetContextStatesByFilter
  //

  GetContextStatesByFilter::
  GetContextStatesByFilter ()
  : ::MDM::AbstractGet (),
    Filter_ (this),
    ContextType_ (this)
  {
  }

  GetContextStatesByFilter::
  GetContextStatesByFilter (const GetContextStatesByFilter& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    Filter_ (x.Filter_, f, this),
    ContextType_ (x.ContextType_, f, this)
  {
  }

  GetContextStatesByFilter::
  GetContextStatesByFilter (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    Filter_ (this),
    ContextType_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetContextStatesByFilter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Filter
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Filter",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< FilterType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< FilterType > r (
            dynamic_cast< FilterType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Filter_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ContextType" && n.namespace_ ().empty ())
      {
        this->ContextType_.set (ContextTypeTraits::create (i, f, this));
        continue;
      }
    }
  }

  GetContextStatesByFilter* GetContextStatesByFilter::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetContextStatesByFilter (*this, f, c);
  }

  GetContextStatesByFilter& GetContextStatesByFilter::
  operator= (const GetContextStatesByFilter& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->Filter_ = x.Filter_;
      this->ContextType_ = x.ContextType_;
    }

    return *this;
  }

  GetContextStatesByFilter::
  ~GetContextStatesByFilter ()
  {
  }

  // GetContextStatesByFilterResponse
  //

  GetContextStatesByFilterResponse::
  GetContextStatesByFilterResponse (const SequenceIdType& SequenceId)
  : ::MDM::AbstractGetResponse (SequenceId),
    ContextState_ (this)
  {
  }

  GetContextStatesByFilterResponse::
  GetContextStatesByFilterResponse (const GetContextStatesByFilterResponse& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    ContextState_ (x.ContextState_, f, this)
  {
  }

  GetContextStatesByFilterResponse::
  GetContextStatesByFilterResponse (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    ContextState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetContextStatesByFilterResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ContextState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ContextStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ContextStateType > r (
            dynamic_cast< ContextStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ContextState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetContextStatesByFilterResponse* GetContextStatesByFilterResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetContextStatesByFilterResponse (*this, f, c);
  }

  GetContextStatesByFilterResponse& GetContextStatesByFilterResponse::
  operator= (const GetContextStatesByFilterResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->ContextState_ = x.ContextState_;
    }

    return *this;
  }

  GetContextStatesByFilterResponse::
  ~GetContextStatesByFilterResponse ()
  {
  }

  // SetContextState
  //

  SetContextState::
  SetContextState (const OperationHandleRefType& OperationHandleRef)
  : ::MDM::AbstractSet (OperationHandleRef),
    ProposedContextState_ (this)
  {
  }

  SetContextState::
  SetContextState (::std::unique_ptr< OperationHandleRefType > OperationHandleRef)
  : ::MDM::AbstractSet (std::move (OperationHandleRef)),
    ProposedContextState_ (this)
  {
  }

  SetContextState::
  SetContextState (const SetContextState& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::MDM::AbstractSet (x, f, c),
    ProposedContextState_ (x.ProposedContextState_, f, this)
  {
  }

  SetContextState::
  SetContextState (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::MDM::AbstractSet (e, f | ::xml_schema::Flags::base, c),
    ProposedContextState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SetContextState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractSet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ProposedContextState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ProposedContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ProposedContextStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ProposedContextStateType > r (
            dynamic_cast< ProposedContextStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ProposedContextState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SetContextState* SetContextState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetContextState (*this, f, c);
  }

  SetContextState& SetContextState::
  operator= (const SetContextState& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractSet& > (*this) = x;
      this->ProposedContextState_ = x.ProposedContextState_;
    }

    return *this;
  }

  SetContextState::
  ~SetContextState ()
  {
  }

  // SetContextStateResponse
  //

  SetContextStateResponse::
  SetContextStateResponse (const InvocationInfoType& InvocationInfo,
                           const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (InvocationInfo,
                                SequenceId)
  {
  }

  SetContextStateResponse::
  SetContextStateResponse (::std::unique_ptr< InvocationInfoType > InvocationInfo,
                           const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (std::move (InvocationInfo),
                                SequenceId)
  {
  }

  SetContextStateResponse::
  SetContextStateResponse (const SetContextStateResponse& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (x, f, c)
  {
  }

  SetContextStateResponse::
  SetContextStateResponse (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (e, f, c)
  {
  }

  SetContextStateResponse* SetContextStateResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetContextStateResponse (*this, f, c);
  }

  SetContextStateResponse::
  ~SetContextStateResponse ()
  {
  }

  // ReportPart
  //

  ReportPart::
  ReportPart ()
  : ::MDM::AbstractReportPart (),
    ContextState_ (this)
  {
  }

  ReportPart::
  ReportPart (const ReportPart& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (x, f, c),
    ContextState_ (x.ContextState_, f, this)
  {
  }

  ReportPart::
  ReportPart (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (e, f | ::xml_schema::Flags::base, c),
    ContextState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ReportPart::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReportPart::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ContextState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ContextStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ContextStateType > r (
            dynamic_cast< ContextStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ContextState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ReportPart* ReportPart::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReportPart (*this, f, c);
  }

  ReportPart& ReportPart::
  operator= (const ReportPart& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReportPart& > (*this) = x;
      this->ContextState_ = x.ContextState_;
    }

    return *this;
  }

  ReportPart::
  ~ReportPart ()
  {
  }

  // PeriodicContextReport
  //

  PeriodicContextReport::
  PeriodicContextReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractContextReport (SequenceId)
  {
  }

  PeriodicContextReport::
  PeriodicContextReport (const PeriodicContextReport& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractContextReport (x, f, c)
  {
  }

  PeriodicContextReport::
  PeriodicContextReport (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractContextReport (e, f, c)
  {
  }

  PeriodicContextReport* PeriodicContextReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PeriodicContextReport (*this, f, c);
  }

  PeriodicContextReport::
  ~PeriodicContextReport ()
  {
  }

  // EpisodicContextReport
  //

  EpisodicContextReport::
  EpisodicContextReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractContextReport (SequenceId)
  {
  }

  EpisodicContextReport::
  EpisodicContextReport (const EpisodicContextReport& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractContextReport (x, f, c)
  {
  }

  EpisodicContextReport::
  EpisodicContextReport (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractContextReport (e, f, c)
  {
  }

  EpisodicContextReport* EpisodicContextReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EpisodicContextReport (*this, f, c);
  }

  EpisodicContextReport::
  ~EpisodicContextReport ()
  {
  }

  // GetLocalizedText
  //

  GetLocalizedText::
  GetLocalizedText ()
  : ::MDM::AbstractGet (),
    Ref_ (this),
    Version_ (this),
    Lang_ (this),
    TextWidth_ (this),
    NumberOfLines_ (this)
  {
  }

  GetLocalizedText::
  GetLocalizedText (const GetLocalizedText& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    Ref_ (x.Ref_, f, this),
    Version_ (x.Version_, f, this),
    Lang_ (x.Lang_, f, this),
    TextWidth_ (x.TextWidth_, f, this),
    NumberOfLines_ (x.NumberOfLines_, f, this)
  {
  }

  GetLocalizedText::
  GetLocalizedText (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    Ref_ (this),
    Version_ (this),
    Lang_ (this),
    TextWidth_ (this),
    NumberOfLines_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GetLocalizedText::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Ref
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Ref",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< RefType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< RefType > r (
            dynamic_cast< RefType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Ref_.push_back (::std::move (r));
          continue;
        }
      }

      // Version
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Version",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< VersionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Version_)
          {
            ::std::unique_ptr< VersionType > r (
              dynamic_cast< VersionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Version_.set (::std::move (r));
            continue;
          }
        }
      }

      // Lang
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Lang",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< LangType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< LangType > r (
            dynamic_cast< LangType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Lang_.push_back (::std::move (r));
          continue;
        }
      }

      // TextWidth
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TextWidth",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< TextWidthType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< TextWidthType > r (
            dynamic_cast< TextWidthType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TextWidth_.push_back (::std::move (r));
          continue;
        }
      }

      // NumberOfLines
      //
      if (n.name () == "NumberOfLines" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        this->NumberOfLines_.push_back (NumberOfLinesTraits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  GetLocalizedText* GetLocalizedText::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetLocalizedText (*this, f, c);
  }

  GetLocalizedText& GetLocalizedText::
  operator= (const GetLocalizedText& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->Ref_ = x.Ref_;
      this->Version_ = x.Version_;
      this->Lang_ = x.Lang_;
      this->TextWidth_ = x.TextWidth_;
      this->NumberOfLines_ = x.NumberOfLines_;
    }

    return *this;
  }

  GetLocalizedText::
  ~GetLocalizedText ()
  {
  }

  // GetLocalizedTextResponse
  //

  GetLocalizedTextResponse::
  GetLocalizedTextResponse (const SequenceIdType& SequenceId)
  : ::MDM::AbstractGetResponse (SequenceId),
    Text_ (this)
  {
  }

  GetLocalizedTextResponse::
  GetLocalizedTextResponse (const GetLocalizedTextResponse& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    Text_ (x.Text_, f, this)
  {
  }

  GetLocalizedTextResponse::
  GetLocalizedTextResponse (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    Text_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetLocalizedTextResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Text
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Text",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< TextType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< TextType > r (
            dynamic_cast< TextType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Text_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetLocalizedTextResponse* GetLocalizedTextResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetLocalizedTextResponse (*this, f, c);
  }

  GetLocalizedTextResponse& GetLocalizedTextResponse::
  operator= (const GetLocalizedTextResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->Text_ = x.Text_;
    }

    return *this;
  }

  GetLocalizedTextResponse::
  ~GetLocalizedTextResponse ()
  {
  }

  // GetSupportedLanguages
  //

  GetSupportedLanguages::
  GetSupportedLanguages ()
  : ::MDM::AbstractGet ()
  {
  }

  GetSupportedLanguages::
  GetSupportedLanguages (const GetSupportedLanguages& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c)
  {
  }

  GetSupportedLanguages::
  GetSupportedLanguages (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f, c)
  {
  }

  GetSupportedLanguages* GetSupportedLanguages::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetSupportedLanguages (*this, f, c);
  }

  GetSupportedLanguages::
  ~GetSupportedLanguages ()
  {
  }

  // GetSupportedLanguagesResponse
  //

  GetSupportedLanguagesResponse::
  GetSupportedLanguagesResponse (const SequenceIdType& SequenceId)
  : ::MDM::AbstractGetResponse (SequenceId),
    Lang_ (this)
  {
  }

  GetSupportedLanguagesResponse::
  GetSupportedLanguagesResponse (const GetSupportedLanguagesResponse& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    Lang_ (x.Lang_, f, this)
  {
  }

  GetSupportedLanguagesResponse::
  GetSupportedLanguagesResponse (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    Lang_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetSupportedLanguagesResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Lang
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Lang",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< LangType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< LangType > r (
            dynamic_cast< LangType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Lang_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetSupportedLanguagesResponse* GetSupportedLanguagesResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetSupportedLanguagesResponse (*this, f, c);
  }

  GetSupportedLanguagesResponse& GetSupportedLanguagesResponse::
  operator= (const GetSupportedLanguagesResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->Lang_ = x.Lang_;
    }

    return *this;
  }

  GetSupportedLanguagesResponse::
  ~GetSupportedLanguagesResponse ()
  {
  }

  // GetDescriptorsFromArchive
  //

  GetDescriptorsFromArchive::
  GetDescriptorsFromArchive ()
  : ::MDM::AbstractGet (),
    DescriptorRevisions_ (this),
    TimeFrame_ (this),
    Handle_ (this)
  {
  }

  GetDescriptorsFromArchive::
  GetDescriptorsFromArchive (const GetDescriptorsFromArchive& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    DescriptorRevisions_ (x.DescriptorRevisions_, f, this),
    TimeFrame_ (x.TimeFrame_, f, this),
    Handle_ (x.Handle_, f, this)
  {
  }

  GetDescriptorsFromArchive::
  GetDescriptorsFromArchive (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    DescriptorRevisions_ (this),
    TimeFrame_ (this),
    Handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GetDescriptorsFromArchive::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DescriptorRevisions
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DescriptorRevisions",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< DescriptorRevisionsType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DescriptorRevisions_)
          {
            ::std::unique_ptr< DescriptorRevisionsType > r (
              dynamic_cast< DescriptorRevisionsType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DescriptorRevisions_.set (::std::move (r));
            continue;
          }
        }
      }

      // TimeFrame
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TimeFrame",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< TimeFrameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->TimeFrame_)
          {
            ::std::unique_ptr< TimeFrameType > r (
              dynamic_cast< TimeFrameType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->TimeFrame_.set (::std::move (r));
            continue;
          }
        }
      }

      // Handle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Handle",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< HandleType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< HandleType > r (
            dynamic_cast< HandleType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Handle_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetDescriptorsFromArchive* GetDescriptorsFromArchive::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetDescriptorsFromArchive (*this, f, c);
  }

  GetDescriptorsFromArchive& GetDescriptorsFromArchive::
  operator= (const GetDescriptorsFromArchive& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->DescriptorRevisions_ = x.DescriptorRevisions_;
      this->TimeFrame_ = x.TimeFrame_;
      this->Handle_ = x.Handle_;
    }

    return *this;
  }

  GetDescriptorsFromArchive::
  ~GetDescriptorsFromArchive ()
  {
  }

  // GetDescriptorsFromArchiveResponse
  //

  GetDescriptorsFromArchiveResponse::
  GetDescriptorsFromArchiveResponse (const SequenceIdType& SequenceId)
  : ::MDM::AbstractGetResponse (SequenceId),
    Descriptor_ (this)
  {
  }

  GetDescriptorsFromArchiveResponse::
  GetDescriptorsFromArchiveResponse (const GetDescriptorsFromArchiveResponse& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    Descriptor_ (x.Descriptor_, f, this)
  {
  }

  GetDescriptorsFromArchiveResponse::
  GetDescriptorsFromArchiveResponse (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    Descriptor_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetDescriptorsFromArchiveResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Descriptor
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Descriptor",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< DescriptorType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< DescriptorType > r (
            dynamic_cast< DescriptorType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Descriptor_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetDescriptorsFromArchiveResponse* GetDescriptorsFromArchiveResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetDescriptorsFromArchiveResponse (*this, f, c);
  }

  GetDescriptorsFromArchiveResponse& GetDescriptorsFromArchiveResponse::
  operator= (const GetDescriptorsFromArchiveResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->Descriptor_ = x.Descriptor_;
    }

    return *this;
  }

  GetDescriptorsFromArchiveResponse::
  ~GetDescriptorsFromArchiveResponse ()
  {
  }

  // GetStatesFromArchive
  //

  GetStatesFromArchive::
  GetStatesFromArchive ()
  : ::MDM::AbstractGet (),
    StateRevisions_ (this),
    TimeFrame_ (this),
    Handle_ (this)
  {
  }

  GetStatesFromArchive::
  GetStatesFromArchive (const GetStatesFromArchive& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    StateRevisions_ (x.StateRevisions_, f, this),
    TimeFrame_ (x.TimeFrame_, f, this),
    Handle_ (x.Handle_, f, this)
  {
  }

  GetStatesFromArchive::
  GetStatesFromArchive (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    StateRevisions_ (this),
    TimeFrame_ (this),
    Handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GetStatesFromArchive::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // StateRevisions
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "StateRevisions",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< StateRevisionsType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->StateRevisions_)
          {
            ::std::unique_ptr< StateRevisionsType > r (
              dynamic_cast< StateRevisionsType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->StateRevisions_.set (::std::move (r));
            continue;
          }
        }
      }

      // TimeFrame
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TimeFrame",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< TimeFrameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->TimeFrame_)
          {
            ::std::unique_ptr< TimeFrameType > r (
              dynamic_cast< TimeFrameType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->TimeFrame_.set (::std::move (r));
            continue;
          }
        }
      }

      // Handle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Handle",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< HandleType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< HandleType > r (
            dynamic_cast< HandleType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Handle_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetStatesFromArchive* GetStatesFromArchive::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetStatesFromArchive (*this, f, c);
  }

  GetStatesFromArchive& GetStatesFromArchive::
  operator= (const GetStatesFromArchive& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->StateRevisions_ = x.StateRevisions_;
      this->TimeFrame_ = x.TimeFrame_;
      this->Handle_ = x.Handle_;
    }

    return *this;
  }

  GetStatesFromArchive::
  ~GetStatesFromArchive ()
  {
  }

  // GetStatesFromArchiveResponse
  //

  GetStatesFromArchiveResponse::
  GetStatesFromArchiveResponse (const SequenceIdType& SequenceId)
  : ::MDM::AbstractGetResponse (SequenceId),
    State_ (this)
  {
  }

  GetStatesFromArchiveResponse::
  GetStatesFromArchiveResponse (const GetStatesFromArchiveResponse& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    State_ (x.State_, f, this)
  {
  }

  GetStatesFromArchiveResponse::
  GetStatesFromArchiveResponse (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    State_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetStatesFromArchiveResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // State
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "State",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< StateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< StateType > r (
            dynamic_cast< StateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->State_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetStatesFromArchiveResponse* GetStatesFromArchiveResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetStatesFromArchiveResponse (*this, f, c);
  }

  GetStatesFromArchiveResponse& GetStatesFromArchiveResponse::
  operator= (const GetStatesFromArchiveResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->State_ = x.State_;
    }

    return *this;
  }

  GetStatesFromArchiveResponse::
  ~GetStatesFromArchiveResponse ()
  {
  }

  // SetValue
  //

  SetValue::
  SetValue (const OperationHandleRefType& OperationHandleRef,
            const RequestedNumericValueType& RequestedNumericValue)
  : ::MDM::AbstractSet (OperationHandleRef),
    RequestedNumericValue_ (RequestedNumericValue, this)
  {
  }

  SetValue::
  SetValue (::std::unique_ptr< OperationHandleRefType > OperationHandleRef,
            const RequestedNumericValueType& RequestedNumericValue)
  : ::MDM::AbstractSet (std::move (OperationHandleRef)),
    RequestedNumericValue_ (RequestedNumericValue, this)
  {
  }

  SetValue::
  SetValue (const SetValue& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::MDM::AbstractSet (x, f, c),
    RequestedNumericValue_ (x.RequestedNumericValue_, f, this)
  {
  }

  SetValue::
  SetValue (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::MDM::AbstractSet (e, f | ::xml_schema::Flags::base, c),
    RequestedNumericValue_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SetValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractSet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // RequestedNumericValue
      //
      if (n.name () == "RequestedNumericValue" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        if (!RequestedNumericValue_.present ())
        {
          this->RequestedNumericValue_.set (RequestedNumericValueTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!RequestedNumericValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "RequestedNumericValue",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  SetValue* SetValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetValue (*this, f, c);
  }

  SetValue& SetValue::
  operator= (const SetValue& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractSet& > (*this) = x;
      this->RequestedNumericValue_ = x.RequestedNumericValue_;
    }

    return *this;
  }

  SetValue::
  ~SetValue ()
  {
  }

  // SetValueResponse
  //

  SetValueResponse::
  SetValueResponse (const InvocationInfoType& InvocationInfo,
                    const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (InvocationInfo,
                                SequenceId)
  {
  }

  SetValueResponse::
  SetValueResponse (::std::unique_ptr< InvocationInfoType > InvocationInfo,
                    const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (std::move (InvocationInfo),
                                SequenceId)
  {
  }

  SetValueResponse::
  SetValueResponse (const SetValueResponse& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (x, f, c)
  {
  }

  SetValueResponse::
  SetValueResponse (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (e, f, c)
  {
  }

  SetValueResponse* SetValueResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetValueResponse (*this, f, c);
  }

  SetValueResponse::
  ~SetValueResponse ()
  {
  }

  // SetString
  //

  SetString::
  SetString (const OperationHandleRefType& OperationHandleRef,
             const RequestedStringValueType& RequestedStringValue)
  : ::MDM::AbstractSet (OperationHandleRef),
    RequestedStringValue_ (RequestedStringValue, this)
  {
  }

  SetString::
  SetString (::std::unique_ptr< OperationHandleRefType > OperationHandleRef,
             ::std::unique_ptr< RequestedStringValueType > RequestedStringValue)
  : ::MDM::AbstractSet (std::move (OperationHandleRef)),
    RequestedStringValue_ (std::move (RequestedStringValue), this)
  {
  }

  SetString::
  SetString (const SetString& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::MDM::AbstractSet (x, f, c),
    RequestedStringValue_ (x.RequestedStringValue_, f, this)
  {
  }

  SetString::
  SetString (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::MDM::AbstractSet (e, f | ::xml_schema::Flags::base, c),
    RequestedStringValue_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SetString::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractSet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // RequestedStringValue
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "RequestedStringValue",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< RequestedStringValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!RequestedStringValue_.present ())
          {
            ::std::unique_ptr< RequestedStringValueType > r (
              dynamic_cast< RequestedStringValueType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->RequestedStringValue_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!RequestedStringValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "RequestedStringValue",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  SetString* SetString::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetString (*this, f, c);
  }

  SetString& SetString::
  operator= (const SetString& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractSet& > (*this) = x;
      this->RequestedStringValue_ = x.RequestedStringValue_;
    }

    return *this;
  }

  SetString::
  ~SetString ()
  {
  }

  // SetStringResponse
  //

  SetStringResponse::
  SetStringResponse (const InvocationInfoType& InvocationInfo,
                     const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (InvocationInfo,
                                SequenceId)
  {
  }

  SetStringResponse::
  SetStringResponse (::std::unique_ptr< InvocationInfoType > InvocationInfo,
                     const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (std::move (InvocationInfo),
                                SequenceId)
  {
  }

  SetStringResponse::
  SetStringResponse (const SetStringResponse& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (x, f, c)
  {
  }

  SetStringResponse::
  SetStringResponse (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (e, f, c)
  {
  }

  SetStringResponse* SetStringResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetStringResponse (*this, f, c);
  }

  SetStringResponse::
  ~SetStringResponse ()
  {
  }

  // Activate
  //

  Activate::
  Activate (const OperationHandleRefType& OperationHandleRef)
  : ::MDM::AbstractSet (OperationHandleRef),
    Argument_ (this)
  {
  }

  Activate::
  Activate (::std::unique_ptr< OperationHandleRefType > OperationHandleRef)
  : ::MDM::AbstractSet (std::move (OperationHandleRef)),
    Argument_ (this)
  {
  }

  Activate::
  Activate (const Activate& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::MDM::AbstractSet (x, f, c),
    Argument_ (x.Argument_, f, this)
  {
  }

  Activate::
  Activate (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::MDM::AbstractSet (e, f | ::xml_schema::Flags::base, c),
    Argument_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Activate::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractSet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Argument
      //
      if (n.name () == "Argument" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ArgumentType > r (
          ArgumentTraits::create (i, f, this));

        this->Argument_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Activate* Activate::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Activate (*this, f, c);
  }

  Activate& Activate::
  operator= (const Activate& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractSet& > (*this) = x;
      this->Argument_ = x.Argument_;
    }

    return *this;
  }

  Activate::
  ~Activate ()
  {
  }

  // ActivateResponse
  //

  ActivateResponse::
  ActivateResponse (const InvocationInfoType& InvocationInfo,
                    const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (InvocationInfo,
                                SequenceId)
  {
  }

  ActivateResponse::
  ActivateResponse (::std::unique_ptr< InvocationInfoType > InvocationInfo,
                    const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (std::move (InvocationInfo),
                                SequenceId)
  {
  }

  ActivateResponse::
  ActivateResponse (const ActivateResponse& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (x, f, c)
  {
  }

  ActivateResponse::
  ActivateResponse (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (e, f, c)
  {
  }

  ActivateResponse* ActivateResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ActivateResponse (*this, f, c);
  }

  ActivateResponse::
  ~ActivateResponse ()
  {
  }

  // SetAlertState
  //

  SetAlertState::
  SetAlertState (const OperationHandleRefType& OperationHandleRef,
                 const ProposedAlertStateType& ProposedAlertState)
  : ::MDM::AbstractSet (OperationHandleRef),
    ProposedAlertState_ (ProposedAlertState, this)
  {
  }

  SetAlertState::
  SetAlertState (const OperationHandleRefType& OperationHandleRef,
                 ::std::unique_ptr< ProposedAlertStateType > ProposedAlertState)
  : ::MDM::AbstractSet (OperationHandleRef),
    ProposedAlertState_ (std::move (ProposedAlertState), this)
  {
  }

  SetAlertState::
  SetAlertState (::std::unique_ptr< OperationHandleRefType > OperationHandleRef,
                 ::std::unique_ptr< ProposedAlertStateType > ProposedAlertState)
  : ::MDM::AbstractSet (std::move (OperationHandleRef)),
    ProposedAlertState_ (std::move (ProposedAlertState), this)
  {
  }

  SetAlertState::
  SetAlertState (const SetAlertState& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::MDM::AbstractSet (x, f, c),
    ProposedAlertState_ (x.ProposedAlertState_, f, this)
  {
  }

  SetAlertState::
  SetAlertState (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::MDM::AbstractSet (e, f | ::xml_schema::Flags::base, c),
    ProposedAlertState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SetAlertState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractSet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ProposedAlertState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ProposedAlertState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ProposedAlertStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ProposedAlertState_.present ())
          {
            ::std::unique_ptr< ProposedAlertStateType > r (
              dynamic_cast< ProposedAlertStateType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ProposedAlertState_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ProposedAlertState_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ProposedAlertState",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  SetAlertState* SetAlertState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetAlertState (*this, f, c);
  }

  SetAlertState& SetAlertState::
  operator= (const SetAlertState& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractSet& > (*this) = x;
      this->ProposedAlertState_ = x.ProposedAlertState_;
    }

    return *this;
  }

  SetAlertState::
  ~SetAlertState ()
  {
  }

  // SetAlertStateResponse
  //

  SetAlertStateResponse::
  SetAlertStateResponse (const InvocationInfoType& InvocationInfo,
                         const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (InvocationInfo,
                                SequenceId)
  {
  }

  SetAlertStateResponse::
  SetAlertStateResponse (::std::unique_ptr< InvocationInfoType > InvocationInfo,
                         const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (std::move (InvocationInfo),
                                SequenceId)
  {
  }

  SetAlertStateResponse::
  SetAlertStateResponse (const SetAlertStateResponse& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (x, f, c)
  {
  }

  SetAlertStateResponse::
  SetAlertStateResponse (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (e, f, c)
  {
  }

  SetAlertStateResponse* SetAlertStateResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetAlertStateResponse (*this, f, c);
  }

  SetAlertStateResponse::
  ~SetAlertStateResponse ()
  {
  }

  // SetComponentState
  //

  SetComponentState::
  SetComponentState (const OperationHandleRefType& OperationHandleRef)
  : ::MDM::AbstractSet (OperationHandleRef),
    ProposedComponentState_ (this)
  {
  }

  SetComponentState::
  SetComponentState (::std::unique_ptr< OperationHandleRefType > OperationHandleRef)
  : ::MDM::AbstractSet (std::move (OperationHandleRef)),
    ProposedComponentState_ (this)
  {
  }

  SetComponentState::
  SetComponentState (const SetComponentState& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::MDM::AbstractSet (x, f, c),
    ProposedComponentState_ (x.ProposedComponentState_, f, this)
  {
  }

  SetComponentState::
  SetComponentState (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::MDM::AbstractSet (e, f | ::xml_schema::Flags::base, c),
    ProposedComponentState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SetComponentState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractSet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ProposedComponentState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ProposedComponentState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ProposedComponentStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ProposedComponentStateType > r (
            dynamic_cast< ProposedComponentStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ProposedComponentState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SetComponentState* SetComponentState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetComponentState (*this, f, c);
  }

  SetComponentState& SetComponentState::
  operator= (const SetComponentState& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractSet& > (*this) = x;
      this->ProposedComponentState_ = x.ProposedComponentState_;
    }

    return *this;
  }

  SetComponentState::
  ~SetComponentState ()
  {
  }

  // SetComponentStateResponse
  //

  SetComponentStateResponse::
  SetComponentStateResponse (const InvocationInfoType& InvocationInfo,
                             const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (InvocationInfo,
                                SequenceId)
  {
  }

  SetComponentStateResponse::
  SetComponentStateResponse (::std::unique_ptr< InvocationInfoType > InvocationInfo,
                             const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (std::move (InvocationInfo),
                                SequenceId)
  {
  }

  SetComponentStateResponse::
  SetComponentStateResponse (const SetComponentStateResponse& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (x, f, c)
  {
  }

  SetComponentStateResponse::
  SetComponentStateResponse (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (e, f, c)
  {
  }

  SetComponentStateResponse* SetComponentStateResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetComponentStateResponse (*this, f, c);
  }

  SetComponentStateResponse::
  ~SetComponentStateResponse ()
  {
  }

  // SetMetricState
  //

  SetMetricState::
  SetMetricState (const OperationHandleRefType& OperationHandleRef)
  : ::MDM::AbstractSet (OperationHandleRef),
    ProposedMetricState_ (this)
  {
  }

  SetMetricState::
  SetMetricState (::std::unique_ptr< OperationHandleRefType > OperationHandleRef)
  : ::MDM::AbstractSet (std::move (OperationHandleRef)),
    ProposedMetricState_ (this)
  {
  }

  SetMetricState::
  SetMetricState (const SetMetricState& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::MDM::AbstractSet (x, f, c),
    ProposedMetricState_ (x.ProposedMetricState_, f, this)
  {
  }

  SetMetricState::
  SetMetricState (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::MDM::AbstractSet (e, f | ::xml_schema::Flags::base, c),
    ProposedMetricState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SetMetricState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractSet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ProposedMetricState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ProposedMetricState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ProposedMetricStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ProposedMetricStateType > r (
            dynamic_cast< ProposedMetricStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ProposedMetricState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SetMetricState* SetMetricState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetMetricState (*this, f, c);
  }

  SetMetricState& SetMetricState::
  operator= (const SetMetricState& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractSet& > (*this) = x;
      this->ProposedMetricState_ = x.ProposedMetricState_;
    }

    return *this;
  }

  SetMetricState::
  ~SetMetricState ()
  {
  }

  // SetMetricStateResponse
  //

  SetMetricStateResponse::
  SetMetricStateResponse (const InvocationInfoType& InvocationInfo,
                          const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (InvocationInfo,
                                SequenceId)
  {
  }

  SetMetricStateResponse::
  SetMetricStateResponse (::std::unique_ptr< InvocationInfoType > InvocationInfo,
                          const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (std::move (InvocationInfo),
                                SequenceId)
  {
  }

  SetMetricStateResponse::
  SetMetricStateResponse (const SetMetricStateResponse& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (x, f, c)
  {
  }

  SetMetricStateResponse::
  SetMetricStateResponse (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (e, f, c)
  {
  }

  SetMetricStateResponse* SetMetricStateResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetMetricStateResponse (*this, f, c);
  }

  SetMetricStateResponse::
  ~SetMetricStateResponse ()
  {
  }

  // OperationInvokedReport
  //

  OperationInvokedReport::
  OperationInvokedReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    ReportPart_ (this)
  {
  }

  OperationInvokedReport::
  OperationInvokedReport (const OperationInvokedReport& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    ReportPart_ (x.ReportPart_, f, this)
  {
  }

  OperationInvokedReport::
  OperationInvokedReport (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    ReportPart_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void OperationInvokedReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReportPart
      //
      if (n.name () == "ReportPart" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ReportPartType > r (
          ReportPartTraits::create (i, f, this));

        this->ReportPart_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  OperationInvokedReport* OperationInvokedReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OperationInvokedReport (*this, f, c);
  }

  OperationInvokedReport& OperationInvokedReport::
  operator= (const OperationInvokedReport& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->ReportPart_ = x.ReportPart_;
    }

    return *this;
  }

  OperationInvokedReport::
  ~OperationInvokedReport ()
  {
  }

  // GetContainmentTree
  //

  GetContainmentTree::
  GetContainmentTree ()
  : ::MDM::AbstractGet (),
    HandleRef_ (this)
  {
  }

  GetContainmentTree::
  GetContainmentTree (const GetContainmentTree& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    HandleRef_ (x.HandleRef_, f, this)
  {
  }

  GetContainmentTree::
  GetContainmentTree (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    HandleRef_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GetContainmentTree::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HandleRef
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< HandleRefType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< HandleRefType > r (
            dynamic_cast< HandleRefType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->HandleRef_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetContainmentTree* GetContainmentTree::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetContainmentTree (*this, f, c);
  }

  GetContainmentTree& GetContainmentTree::
  operator= (const GetContainmentTree& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->HandleRef_ = x.HandleRef_;
    }

    return *this;
  }

  GetContainmentTree::
  ~GetContainmentTree ()
  {
  }

  // GetContainmentTreeResponse
  //

  GetContainmentTreeResponse::
  GetContainmentTreeResponse (const SequenceIdType& SequenceId,
                              const ContainmentTreeType& ContainmentTree)
  : ::MDM::AbstractGetResponse (SequenceId),
    ContainmentTree_ (ContainmentTree, this)
  {
  }

  GetContainmentTreeResponse::
  GetContainmentTreeResponse (const SequenceIdType& SequenceId,
                              ::std::unique_ptr< ContainmentTreeType > ContainmentTree)
  : ::MDM::AbstractGetResponse (SequenceId),
    ContainmentTree_ (std::move (ContainmentTree), this)
  {
  }

  GetContainmentTreeResponse::
  GetContainmentTreeResponse (const GetContainmentTreeResponse& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    ContainmentTree_ (x.ContainmentTree_, f, this)
  {
  }

  GetContainmentTreeResponse::
  GetContainmentTreeResponse (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    ContainmentTree_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetContainmentTreeResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ContainmentTree
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ContainmentTree",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ContainmentTreeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ContainmentTree_.present ())
          {
            ::std::unique_ptr< ContainmentTreeType > r (
              dynamic_cast< ContainmentTreeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ContainmentTree_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ContainmentTree_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ContainmentTree",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  GetContainmentTreeResponse* GetContainmentTreeResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetContainmentTreeResponse (*this, f, c);
  }

  GetContainmentTreeResponse& GetContainmentTreeResponse::
  operator= (const GetContainmentTreeResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->ContainmentTree_ = x.ContainmentTree_;
    }

    return *this;
  }

  GetContainmentTreeResponse::
  ~GetContainmentTreeResponse ()
  {
  }

  // GetDescriptor
  //

  GetDescriptor::
  GetDescriptor ()
  : ::MDM::AbstractGet (),
    HandleRef_ (this)
  {
  }

  GetDescriptor::
  GetDescriptor (const GetDescriptor& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    HandleRef_ (x.HandleRef_, f, this)
  {
  }

  GetDescriptor::
  GetDescriptor (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    HandleRef_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GetDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HandleRef
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< HandleRefType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< HandleRefType > r (
            dynamic_cast< HandleRefType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->HandleRef_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetDescriptor* GetDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetDescriptor (*this, f, c);
  }

  GetDescriptor& GetDescriptor::
  operator= (const GetDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->HandleRef_ = x.HandleRef_;
    }

    return *this;
  }

  GetDescriptor::
  ~GetDescriptor ()
  {
  }

  // GetDescriptorResponse
  //

  GetDescriptorResponse::
  GetDescriptorResponse (const SequenceIdType& SequenceId)
  : ::MDM::AbstractGetResponse (SequenceId),
    Descriptor_ (this)
  {
  }

  GetDescriptorResponse::
  GetDescriptorResponse (const GetDescriptorResponse& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    Descriptor_ (x.Descriptor_, f, this)
  {
  }

  GetDescriptorResponse::
  GetDescriptorResponse (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    Descriptor_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetDescriptorResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Descriptor
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Descriptor",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< DescriptorType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< DescriptorType > r (
            dynamic_cast< DescriptorType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Descriptor_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetDescriptorResponse* GetDescriptorResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetDescriptorResponse (*this, f, c);
  }

  GetDescriptorResponse& GetDescriptorResponse::
  operator= (const GetDescriptorResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->Descriptor_ = x.Descriptor_;
    }

    return *this;
  }

  GetDescriptorResponse::
  ~GetDescriptorResponse ()
  {
  }

  // ReportPart1
  //

  ReportPart1::
  ReportPart1 ()
  : ::MDM::AbstractReportPart (),
    MetricState_ (this)
  {
  }

  ReportPart1::
  ReportPart1 (const ReportPart1& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (x, f, c),
    MetricState_ (x.MetricState_, f, this)
  {
  }

  ReportPart1::
  ReportPart1 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (e, f | ::xml_schema::Flags::base, c),
    MetricState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ReportPart1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReportPart::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MetricState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MetricState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< MetricStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< MetricStateType > r (
            dynamic_cast< MetricStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->MetricState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ReportPart1* ReportPart1::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReportPart1 (*this, f, c);
  }

  ReportPart1& ReportPart1::
  operator= (const ReportPart1& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReportPart& > (*this) = x;
      this->MetricState_ = x.MetricState_;
    }

    return *this;
  }

  ReportPart1::
  ~ReportPart1 ()
  {
  }

  // EpisodicMetricReport
  //

  EpisodicMetricReport::
  EpisodicMetricReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractMetricReport (SequenceId)
  {
  }

  EpisodicMetricReport::
  EpisodicMetricReport (const EpisodicMetricReport& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::MDM::AbstractMetricReport (x, f, c)
  {
  }

  EpisodicMetricReport::
  EpisodicMetricReport (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::MDM::AbstractMetricReport (e, f, c)
  {
  }

  EpisodicMetricReport* EpisodicMetricReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EpisodicMetricReport (*this, f, c);
  }

  EpisodicMetricReport::
  ~EpisodicMetricReport ()
  {
  }

  // PeriodicMetricReport
  //

  PeriodicMetricReport::
  PeriodicMetricReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractMetricReport (SequenceId)
  {
  }

  PeriodicMetricReport::
  PeriodicMetricReport (const PeriodicMetricReport& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::MDM::AbstractMetricReport (x, f, c)
  {
  }

  PeriodicMetricReport::
  PeriodicMetricReport (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::MDM::AbstractMetricReport (e, f, c)
  {
  }

  PeriodicMetricReport* PeriodicMetricReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PeriodicMetricReport (*this, f, c);
  }

  PeriodicMetricReport::
  ~PeriodicMetricReport ()
  {
  }

  // ReportPart2
  //

  ReportPart2::
  ReportPart2 ()
  : ::MDM::AbstractReportPart (),
    ComponentState_ (this)
  {
  }

  ReportPart2::
  ReportPart2 (const ReportPart2& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (x, f, c),
    ComponentState_ (x.ComponentState_, f, this)
  {
  }

  ReportPart2::
  ReportPart2 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (e, f | ::xml_schema::Flags::base, c),
    ComponentState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ReportPart2::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReportPart::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ComponentState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ComponentState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ComponentStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ComponentStateType > r (
            dynamic_cast< ComponentStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ComponentState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ReportPart2* ReportPart2::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReportPart2 (*this, f, c);
  }

  ReportPart2& ReportPart2::
  operator= (const ReportPart2& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReportPart& > (*this) = x;
      this->ComponentState_ = x.ComponentState_;
    }

    return *this;
  }

  ReportPart2::
  ~ReportPart2 ()
  {
  }

  // EpisodicComponentReport
  //

  EpisodicComponentReport::
  EpisodicComponentReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractComponentReport (SequenceId)
  {
  }

  EpisodicComponentReport::
  EpisodicComponentReport (const EpisodicComponentReport& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::MDM::AbstractComponentReport (x, f, c)
  {
  }

  EpisodicComponentReport::
  EpisodicComponentReport (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::MDM::AbstractComponentReport (e, f, c)
  {
  }

  EpisodicComponentReport* EpisodicComponentReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EpisodicComponentReport (*this, f, c);
  }

  EpisodicComponentReport::
  ~EpisodicComponentReport ()
  {
  }

  // PeriodicComponentReport
  //

  PeriodicComponentReport::
  PeriodicComponentReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractComponentReport (SequenceId)
  {
  }

  PeriodicComponentReport::
  PeriodicComponentReport (const PeriodicComponentReport& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::MDM::AbstractComponentReport (x, f, c)
  {
  }

  PeriodicComponentReport::
  PeriodicComponentReport (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::MDM::AbstractComponentReport (e, f, c)
  {
  }

  PeriodicComponentReport* PeriodicComponentReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PeriodicComponentReport (*this, f, c);
  }

  PeriodicComponentReport::
  ~PeriodicComponentReport ()
  {
  }

  // ReportPart3
  //

  ReportPart3::
  ReportPart3 ()
  : ::MDM::AbstractReportPart (),
    AlertState_ (this)
  {
  }

  ReportPart3::
  ReportPart3 (const ReportPart3& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (x, f, c),
    AlertState_ (x.AlertState_, f, this)
  {
  }

  ReportPart3::
  ReportPart3 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (e, f | ::xml_schema::Flags::base, c),
    AlertState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ReportPart3::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReportPart::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AlertState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AlertState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< AlertStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< AlertStateType > r (
            dynamic_cast< AlertStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->AlertState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ReportPart3* ReportPart3::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReportPart3 (*this, f, c);
  }

  ReportPart3& ReportPart3::
  operator= (const ReportPart3& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReportPart& > (*this) = x;
      this->AlertState_ = x.AlertState_;
    }

    return *this;
  }

  ReportPart3::
  ~ReportPart3 ()
  {
  }

  // EpisodicAlertReport
  //

  EpisodicAlertReport::
  EpisodicAlertReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractAlertReport (SequenceId)
  {
  }

  EpisodicAlertReport::
  EpisodicAlertReport (const EpisodicAlertReport& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::MDM::AbstractAlertReport (x, f, c)
  {
  }

  EpisodicAlertReport::
  EpisodicAlertReport (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::MDM::AbstractAlertReport (e, f, c)
  {
  }

  EpisodicAlertReport* EpisodicAlertReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EpisodicAlertReport (*this, f, c);
  }

  EpisodicAlertReport::
  ~EpisodicAlertReport ()
  {
  }

  // PeriodicAlertReport
  //

  PeriodicAlertReport::
  PeriodicAlertReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractAlertReport (SequenceId)
  {
  }

  PeriodicAlertReport::
  PeriodicAlertReport (const PeriodicAlertReport& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::MDM::AbstractAlertReport (x, f, c)
  {
  }

  PeriodicAlertReport::
  PeriodicAlertReport (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::MDM::AbstractAlertReport (e, f, c)
  {
  }

  PeriodicAlertReport* PeriodicAlertReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PeriodicAlertReport (*this, f, c);
  }

  PeriodicAlertReport::
  ~PeriodicAlertReport ()
  {
  }

  // ReportPart4
  //

  ReportPart4::
  ReportPart4 ()
  : ::MDM::AbstractReportPart (),
    OperationState_ (this)
  {
  }

  ReportPart4::
  ReportPart4 (const ReportPart4& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (x, f, c),
    OperationState_ (x.OperationState_, f, this)
  {
  }

  ReportPart4::
  ReportPart4 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (e, f | ::xml_schema::Flags::base, c),
    OperationState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ReportPart4::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReportPart::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OperationState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OperationState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< OperationStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< OperationStateType > r (
            dynamic_cast< OperationStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->OperationState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ReportPart4* ReportPart4::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReportPart4 (*this, f, c);
  }

  ReportPart4& ReportPart4::
  operator= (const ReportPart4& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReportPart& > (*this) = x;
      this->OperationState_ = x.OperationState_;
    }

    return *this;
  }

  ReportPart4::
  ~ReportPart4 ()
  {
  }

  // EpisodicOperationalStateReport
  //

  EpisodicOperationalStateReport::
  EpisodicOperationalStateReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractOperationalStateReport (SequenceId)
  {
  }

  EpisodicOperationalStateReport::
  EpisodicOperationalStateReport (const EpisodicOperationalStateReport& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::MDM::AbstractOperationalStateReport (x, f, c)
  {
  }

  EpisodicOperationalStateReport::
  EpisodicOperationalStateReport (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::MDM::AbstractOperationalStateReport (e, f, c)
  {
  }

  EpisodicOperationalStateReport* EpisodicOperationalStateReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EpisodicOperationalStateReport (*this, f, c);
  }

  EpisodicOperationalStateReport::
  ~EpisodicOperationalStateReport ()
  {
  }

  // PeriodicOperationalStateReport
  //

  PeriodicOperationalStateReport::
  PeriodicOperationalStateReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractOperationalStateReport (SequenceId)
  {
  }

  PeriodicOperationalStateReport::
  PeriodicOperationalStateReport (const PeriodicOperationalStateReport& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::MDM::AbstractOperationalStateReport (x, f, c)
  {
  }

  PeriodicOperationalStateReport::
  PeriodicOperationalStateReport (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::MDM::AbstractOperationalStateReport (e, f, c)
  {
  }

  PeriodicOperationalStateReport* PeriodicOperationalStateReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PeriodicOperationalStateReport (*this, f, c);
  }

  PeriodicOperationalStateReport::
  ~PeriodicOperationalStateReport ()
  {
  }

  // SystemErrorReport
  //

  SystemErrorReport::
  SystemErrorReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    ReportPart_ (this)
  {
  }

  SystemErrorReport::
  SystemErrorReport (const SystemErrorReport& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    ReportPart_ (x.ReportPart_, f, this)
  {
  }

  SystemErrorReport::
  SystemErrorReport (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    ReportPart_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SystemErrorReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReportPart
      //
      if (n.name () == "ReportPart" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ReportPartType > r (
          ReportPartTraits::create (i, f, this));

        this->ReportPart_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  SystemErrorReport* SystemErrorReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SystemErrorReport (*this, f, c);
  }

  SystemErrorReport& SystemErrorReport::
  operator= (const SystemErrorReport& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->ReportPart_ = x.ReportPart_;
    }

    return *this;
  }

  SystemErrorReport::
  ~SystemErrorReport ()
  {
  }

  // DescriptionModificationReport
  //

  DescriptionModificationReport::
  DescriptionModificationReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    ReportPart_ (this)
  {
  }

  DescriptionModificationReport::
  DescriptionModificationReport (const DescriptionModificationReport& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    ReportPart_ (x.ReportPart_, f, this)
  {
  }

  DescriptionModificationReport::
  DescriptionModificationReport (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    ReportPart_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DescriptionModificationReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReportPart
      //
      if (n.name () == "ReportPart" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ReportPartType > r (
          ReportPartTraits::create (i, f, this));

        this->ReportPart_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  DescriptionModificationReport* DescriptionModificationReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DescriptionModificationReport (*this, f, c);
  }

  DescriptionModificationReport& DescriptionModificationReport::
  operator= (const DescriptionModificationReport& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->ReportPart_ = x.ReportPart_;
    }

    return *this;
  }

  DescriptionModificationReport::
  ~DescriptionModificationReport ()
  {
  }

  // WaveformStream
  //

  WaveformStream::
  WaveformStream (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    State_ (this)
  {
  }

  WaveformStream::
  WaveformStream (const WaveformStream& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    State_ (x.State_, f, this)
  {
  }

  WaveformStream::
  WaveformStream (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    State_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void WaveformStream::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // State
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "State",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< StateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< StateType > r (
            dynamic_cast< StateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->State_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  WaveformStream* WaveformStream::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class WaveformStream (*this, f, c);
  }

  WaveformStream& WaveformStream::
  operator= (const WaveformStream& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->State_ = x.State_;
    }

    return *this;
  }

  WaveformStream::
  ~WaveformStream ()
  {
  }

  // ObservedValueStream
  //

  ObservedValueStream::
  ObservedValueStream (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    Value_ (this)
  {
  }

  ObservedValueStream::
  ObservedValueStream (const ObservedValueStream& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    Value_ (x.Value_, f, this)
  {
  }

  ObservedValueStream::
  ObservedValueStream (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    Value_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ObservedValueStream::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Value
      //
      if (n.name () == "Value" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ValueType > r (
          ValueTraits::create (i, f, this));

        this->Value_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ObservedValueStream* ObservedValueStream::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ObservedValueStream (*this, f, c);
  }

  ObservedValueStream& ObservedValueStream::
  operator= (const ObservedValueStream& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->Value_ = x.Value_;
    }

    return *this;
  }

  ObservedValueStream::
  ~ObservedValueStream ()
  {
  }

  // Retrievability
  //

  Retrievability::
  Retrievability ()
  : ::xml_schema::Type (),
    By_ (this)
  {
  }

  Retrievability::
  Retrievability (const Retrievability& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    By_ (x.By_, f, this)
  {
  }

  Retrievability::
  Retrievability (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    By_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Retrievability::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // By
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "By",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ByType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ByType > r (
            dynamic_cast< ByType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->By_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Retrievability* Retrievability::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Retrievability (*this, f, c);
  }

  Retrievability& Retrievability::
  operator= (const Retrievability& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->By_ = x.By_;
    }

    return *this;
  }

  Retrievability::
  ~Retrievability ()
  {
  }

  // Argument
  //

  Argument::
  Argument (const ArgValueType& ArgValue)
  : ::xml_schema::Type (),
    Extension_ (this),
    ArgValue_ (ArgValue, this)
  {
  }

  Argument::
  Argument (::std::unique_ptr< ArgValueType > ArgValue)
  : ::xml_schema::Type (),
    Extension_ (this),
    ArgValue_ (std::move (ArgValue), this)
  {
  }

  Argument::
  Argument (const Argument& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    ArgValue_ (x.ArgValue_, f, this)
  {
  }

  Argument::
  Argument (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    ArgValue_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Argument::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // ArgValue
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ArgValue",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ArgValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ArgValue_.present ())
          {
            ::std::unique_ptr< ArgValueType > r (
              dynamic_cast< ArgValueType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ArgValue_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ArgValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ArgValue",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  Argument* Argument::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Argument (*this, f, c);
  }

  Argument& Argument::
  operator= (const Argument& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->ArgValue_ = x.ArgValue_;
    }

    return *this;
  }

  Argument::
  ~Argument ()
  {
  }

  // ReportPart5
  //

  ReportPart5::
  ReportPart5 (const InvocationInfoType& InvocationInfo,
               const InvocationSourceType& InvocationSource,
               const OperationHandleRefType& OperationHandleRef)
  : ::MDM::AbstractReportPart (),
    InvocationInfo_ (InvocationInfo, this),
    InvocationSource_ (InvocationSource, this),
    OperationHandleRef_ (OperationHandleRef, this),
    OperationTarget_ (this)
  {
  }

  ReportPart5::
  ReportPart5 (::std::unique_ptr< InvocationInfoType > InvocationInfo,
               ::std::unique_ptr< InvocationSourceType > InvocationSource,
               const OperationHandleRefType& OperationHandleRef)
  : ::MDM::AbstractReportPart (),
    InvocationInfo_ (std::move (InvocationInfo), this),
    InvocationSource_ (std::move (InvocationSource), this),
    OperationHandleRef_ (OperationHandleRef, this),
    OperationTarget_ (this)
  {
  }

  ReportPart5::
  ReportPart5 (const ReportPart5& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (x, f, c),
    InvocationInfo_ (x.InvocationInfo_, f, this),
    InvocationSource_ (x.InvocationSource_, f, this),
    OperationHandleRef_ (x.OperationHandleRef_, f, this),
    OperationTarget_ (x.OperationTarget_, f, this)
  {
  }

  ReportPart5::
  ReportPart5 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (e, f | ::xml_schema::Flags::base, c),
    InvocationInfo_ (this),
    InvocationSource_ (this),
    OperationHandleRef_ (this),
    OperationTarget_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ReportPart5::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReportPart::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // InvocationInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "InvocationInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< InvocationInfoType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!InvocationInfo_.present ())
          {
            ::std::unique_ptr< InvocationInfoType > r (
              dynamic_cast< InvocationInfoType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->InvocationInfo_.set (::std::move (r));
            continue;
          }
        }
      }

      // InvocationSource
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "InvocationSource",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< InvocationSourceType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!InvocationSource_.present ())
          {
            ::std::unique_ptr< InvocationSourceType > r (
              dynamic_cast< InvocationSourceType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->InvocationSource_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!InvocationInfo_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "InvocationInfo",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }

    if (!InvocationSource_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "InvocationSource",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "OperationHandleRef" && n.namespace_ ().empty ())
      {
        this->OperationHandleRef_.set (OperationHandleRefTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "OperationTarget" && n.namespace_ ().empty ())
      {
        this->OperationTarget_.set (OperationTargetTraits::create (i, f, this));
        continue;
      }
    }

    if (!OperationHandleRef_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "OperationHandleRef",
        "");
    }
  }

  ReportPart5* ReportPart5::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReportPart5 (*this, f, c);
  }

  ReportPart5& ReportPart5::
  operator= (const ReportPart5& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReportPart& > (*this) = x;
      this->InvocationInfo_ = x.InvocationInfo_;
      this->InvocationSource_ = x.InvocationSource_;
      this->OperationHandleRef_ = x.OperationHandleRef_;
      this->OperationTarget_ = x.OperationTarget_;
    }

    return *this;
  }

  ReportPart5::
  ~ReportPart5 ()
  {
  }

  // ReportPart6
  //

  ReportPart6::
  ReportPart6 (const ErrorCodeType& ErrorCode)
  : ::MDM::AbstractReportPart (),
    ErrorCode_ (ErrorCode, this),
    ErrorInfo_ (this)
  {
  }

  ReportPart6::
  ReportPart6 (::std::unique_ptr< ErrorCodeType > ErrorCode)
  : ::MDM::AbstractReportPart (),
    ErrorCode_ (std::move (ErrorCode), this),
    ErrorInfo_ (this)
  {
  }

  ReportPart6::
  ReportPart6 (const ReportPart6& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (x, f, c),
    ErrorCode_ (x.ErrorCode_, f, this),
    ErrorInfo_ (x.ErrorInfo_, f, this)
  {
  }

  ReportPart6::
  ReportPart6 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (e, f | ::xml_schema::Flags::base, c),
    ErrorCode_ (this),
    ErrorInfo_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ReportPart6::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReportPart::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ErrorCode
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ErrorCode",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ErrorCodeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ErrorCode_.present ())
          {
            ::std::unique_ptr< ErrorCodeType > r (
              dynamic_cast< ErrorCodeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ErrorCode_.set (::std::move (r));
            continue;
          }
        }
      }

      // ErrorInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ErrorInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ErrorInfoType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ErrorInfo_)
          {
            ::std::unique_ptr< ErrorInfoType > r (
              dynamic_cast< ErrorInfoType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ErrorInfo_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ErrorCode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ErrorCode",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ReportPart6* ReportPart6::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReportPart6 (*this, f, c);
  }

  ReportPart6& ReportPart6::
  operator= (const ReportPart6& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReportPart& > (*this) = x;
      this->ErrorCode_ = x.ErrorCode_;
      this->ErrorInfo_ = x.ErrorInfo_;
    }

    return *this;
  }

  ReportPart6::
  ~ReportPart6 ()
  {
  }

  // ReportPart7
  //

  ReportPart7::
  ReportPart7 ()
  : ::MDM::AbstractReportPart (),
    Descriptor_ (this),
    State_ (this),
    ParentDescriptor_ (this),
    ModificationType_ (this)
  {
  }

  ReportPart7::
  ReportPart7 (const ReportPart7& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (x, f, c),
    Descriptor_ (x.Descriptor_, f, this),
    State_ (x.State_, f, this),
    ParentDescriptor_ (x.ParentDescriptor_, f, this),
    ModificationType_ (x.ModificationType_, f, this)
  {
  }

  ReportPart7::
  ReportPart7 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (e, f | ::xml_schema::Flags::base, c),
    Descriptor_ (this),
    State_ (this),
    ParentDescriptor_ (this),
    ModificationType_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ReportPart7::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReportPart::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Descriptor
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Descriptor",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< DescriptorType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< DescriptorType > r (
            dynamic_cast< DescriptorType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Descriptor_.push_back (::std::move (r));
          continue;
        }
      }

      // State
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "State",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< StateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< StateType > r (
            dynamic_cast< StateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->State_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ParentDescriptor" && n.namespace_ ().empty ())
      {
        this->ParentDescriptor_.set (ParentDescriptorTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ModificationType" && n.namespace_ ().empty ())
      {
        this->ModificationType_.set (ModificationTypeTraits::create (i, f, this));
        continue;
      }
    }
  }

  ReportPart7* ReportPart7::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReportPart7 (*this, f, c);
  }

  ReportPart7& ReportPart7::
  operator= (const ReportPart7& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReportPart& > (*this) = x;
      this->Descriptor_ = x.Descriptor_;
      this->State_ = x.State_;
      this->ParentDescriptor_ = x.ParentDescriptor_;
      this->ModificationType_ = x.ModificationType_;
    }

    return *this;
  }

  ReportPart7::
  ~ReportPart7 ()
  {
  }

  // Value
  //

  Value::
  Value (const MetricType& Metric)
  : ::xml_schema::Type (),
    Value1_ (this),
    Metric_ (Metric, this),
    StateVersion_ (this)
  {
  }

  Value::
  Value (const Value& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Value1_ (x.Value1_, f, this),
    Metric_ (x.Metric_, f, this),
    StateVersion_ (x.StateVersion_, f, this)
  {
  }

  Value::
  Value (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Value1_ (this),
    Metric_ (this),
    StateVersion_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Value::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Value
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Value",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< Value1Type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Value1_)
          {
            ::std::unique_ptr< Value1Type > r (
              dynamic_cast< Value1Type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Value1_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Metric" && n.namespace_ ().empty ())
      {
        this->Metric_.set (MetricTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "StateVersion" && n.namespace_ ().empty ())
      {
        this->StateVersion_.set (StateVersionTraits::create (i, f, this));
        continue;
      }
    }

    if (!Metric_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Metric",
        "");
    }
  }

  Value* Value::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Value (*this, f, c);
  }

  Value& Value::
  operator= (const Value& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Value1_ = x.Value1_;
      this->Metric_ = x.Metric_;
      this->StateVersion_ = x.StateVersion_;
    }

    return *this;
  }

  Value::
  ~Value ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace MDM
{
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace MDM
{
  void
  operator<< (::xercesc::DOMElement& e, const TransactionId& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const TransactionId& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const TransactionId& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TransactionId >
  _xsd_TransactionId_type_serializer_init (
    "TransactionId",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const InvocationState& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const InvocationState& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const InvocationState& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, InvocationState >
  _xsd_InvocationState_type_serializer_init (
    "InvocationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const InvocationError& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const InvocationError& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const InvocationError& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, InvocationError >
  _xsd_InvocationError_type_serializer_init (
    "InvocationError",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const InvocationInfo& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getExtension ())
      {
        const InvocationInfo::ExtensionType& x (*i.getExtension ());
        if (typeid (InvocationInfo::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // TransactionId
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const InvocationInfo::TransactionIdType& x (i.getTransactionId ());
      if (typeid (InvocationInfo::TransactionIdType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TransactionId",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "TransactionId",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }

    // InvocationState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const InvocationInfo::InvocationStateType& x (i.getInvocationState ());
      if (typeid (InvocationInfo::InvocationStateType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InvocationState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "InvocationState",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }

    // InvocationError
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getInvocationError ())
      {
        const InvocationInfo::InvocationErrorType& x (*i.getInvocationError ());
        if (typeid (InvocationInfo::InvocationErrorType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "InvocationError",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "InvocationError",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }

    // InvocationErrorMessage
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (InvocationInfo::InvocationErrorMessageConstIterator
           b (i.getInvocationErrorMessage ().begin ()), n (i.getInvocationErrorMessage ().end ());
           b != n; ++b)
      {
        if (typeid (InvocationInfo::InvocationErrorMessageType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "InvocationErrorMessage",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "InvocationErrorMessage",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, InvocationInfo >
  _xsd_InvocationInfo_type_serializer_init (
    "InvocationInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractGet& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getExtension ())
      {
        const AbstractGet::ExtensionType& x (*i.getExtension ());
        if (typeid (AbstractGet::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractGet >
  _xsd_AbstractGet_type_serializer_init (
    "AbstractGet",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractGetResponse& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getExtension ())
      {
        const AbstractGetResponse::ExtensionType& x (*i.getExtension ());
        if (typeid (AbstractGetResponse::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // MdibVersion
    //
    if (i.getMdibVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MdibVersion",
          e));

      a << *i.getMdibVersion ();
    }

    // SequenceId
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "SequenceId",
          e));

      a << i.getSequenceId ();
    }

    // InstanceId
    //
    if (i.getInstanceId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "InstanceId",
          e));

      a << *i.getInstanceId ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractGetResponse >
  _xsd_AbstractGetResponse_type_serializer_init (
    "AbstractGetResponse",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractReportPart& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getExtension ())
      {
        const AbstractReportPart::ExtensionType& x (*i.getExtension ());
        if (typeid (AbstractReportPart::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // SourceMds
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getSourceMds ())
      {
        const AbstractReportPart::SourceMdsType& x (*i.getSourceMds ());
        if (typeid (AbstractReportPart::SourceMdsType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SourceMds",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "SourceMds",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractReportPart >
  _xsd_AbstractReportPart_type_serializer_init (
    "AbstractReportPart",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractReport& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getExtension ())
      {
        const AbstractReport::ExtensionType& x (*i.getExtension ());
        if (typeid (AbstractReport::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // MdibVersion
    //
    if (i.getMdibVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MdibVersion",
          e));

      a << *i.getMdibVersion ();
    }

    // SequenceId
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "SequenceId",
          e));

      a << i.getSequenceId ();
    }

    // InstanceId
    //
    if (i.getInstanceId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "InstanceId",
          e));

      a << *i.getInstanceId ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractReport >
  _xsd_AbstractReport_type_serializer_init (
    "AbstractReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractSet& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getExtension ())
      {
        const AbstractSet::ExtensionType& x (*i.getExtension ());
        if (typeid (AbstractSet::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // OperationHandleRef
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AbstractSet::OperationHandleRefType& x (i.getOperationHandleRef ());
      if (typeid (AbstractSet::OperationHandleRefType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OperationHandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "OperationHandleRef",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractSet >
  _xsd_AbstractSet_type_serializer_init (
    "AbstractSet",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractSetResponse& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getExtension ())
      {
        const AbstractSetResponse::ExtensionType& x (*i.getExtension ());
        if (typeid (AbstractSetResponse::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // InvocationInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AbstractSetResponse::InvocationInfoType& x (i.getInvocationInfo ());
      if (typeid (AbstractSetResponse::InvocationInfoType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InvocationInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "InvocationInfo",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }

    // MdibVersion
    //
    if (i.getMdibVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MdibVersion",
          e));

      a << *i.getMdibVersion ();
    }

    // SequenceId
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "SequenceId",
          e));

      a << i.getSequenceId ();
    }

    // InstanceId
    //
    if (i.getInstanceId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "InstanceId",
          e));

      a << *i.getInstanceId ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractSetResponse >
  _xsd_AbstractSetResponse_type_serializer_init (
    "AbstractSetResponse",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractContextReport& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // ReportPart
    //
    for (AbstractContextReport::ReportPartConstIterator
         b (i.getReportPart ().begin ()), n (i.getReportPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReportPart",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractContextReport >
  _xsd_AbstractContextReport_type_serializer_init (
    "AbstractContextReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const VersionFrame& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Start
    //
    if (i.getStart ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Start",
          e));

      a << *i.getStart ();
    }

    // End
    //
    if (i.getEnd ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "End",
          e));

      a << *i.getEnd ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, VersionFrame >
  _xsd_VersionFrame_type_serializer_init (
    "VersionFrame",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const TimeFrame& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Start
    //
    if (i.getStart ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Start",
          e));

      a << *i.getStart ();
    }

    // End
    //
    if (i.getEnd ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "End",
          e));

      a << *i.getEnd ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TimeFrame >
  _xsd_TimeFrame_type_serializer_init (
    "TimeFrame",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractMetricReport& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // ReportPart
    //
    for (AbstractMetricReport::ReportPartConstIterator
         b (i.getReportPart ().begin ()), n (i.getReportPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReportPart",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractMetricReport >
  _xsd_AbstractMetricReport_type_serializer_init (
    "AbstractMetricReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractComponentReport& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // ReportPart
    //
    for (AbstractComponentReport::ReportPartConstIterator
         b (i.getReportPart ().begin ()), n (i.getReportPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReportPart",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractComponentReport >
  _xsd_AbstractComponentReport_type_serializer_init (
    "AbstractComponentReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractAlertReport& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // ReportPart
    //
    for (AbstractAlertReport::ReportPartConstIterator
         b (i.getReportPart ().begin ()), n (i.getReportPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReportPart",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractAlertReport >
  _xsd_AbstractAlertReport_type_serializer_init (
    "AbstractAlertReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractOperationalStateReport& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // ReportPart
    //
    for (AbstractOperationalStateReport::ReportPartConstIterator
         b (i.getReportPart ().begin ()), n (i.getReportPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReportPart",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractOperationalStateReport >
  _xsd_AbstractOperationalStateReport_type_serializer_init (
    "AbstractOperationalStateReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const DescriptionModificationType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DescriptionModificationType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const DescriptionModificationType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DescriptionModificationType >
  _xsd_DescriptionModificationType_type_serializer_init (
    "DescriptionModificationType",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const RetrievabilityMethod& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const RetrievabilityMethod& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const RetrievabilityMethod& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RetrievabilityMethod >
  _xsd_RetrievabilityMethod_type_serializer_init (
    "RetrievabilityMethod",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const RetrievabilityInfo& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getExtension ())
      {
        const RetrievabilityInfo::ExtensionType& x (*i.getExtension ());
        if (typeid (RetrievabilityInfo::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Method
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Method",
          e));

      a << i.getMethod ();
    }

    // UpdatePeriod
    //
    if (i.getUpdatePeriod ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "UpdatePeriod",
          e));

      a << *i.getUpdatePeriod ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RetrievabilityInfo >
  _xsd_RetrievabilityInfo_type_serializer_init (
    "RetrievabilityInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const GetMdib& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetMdibResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // Mdib
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const GetMdibResponse::MdibType& x (i.getMdib ());
      if (typeid (GetMdibResponse::MdibType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Mdib",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Mdib",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetMdDescription& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // HandleRef
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetMdDescription::HandleRefConstIterator
           b (i.getHandleRef ().begin ()), n (i.getHandleRef ().end ());
           b != n; ++b)
      {
        if (typeid (GetMdDescription::HandleRefType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "HandleRef",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetMdDescriptionResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // MdDescription
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const GetMdDescriptionResponse::MdDescriptionType& x (i.getMdDescription ());
      if (typeid (GetMdDescriptionResponse::MdDescriptionType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MdDescription",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MdDescription",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetMdState& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // HandleRef
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetMdState::HandleRefConstIterator
           b (i.getHandleRef ().begin ()), n (i.getHandleRef ().end ());
           b != n; ++b)
      {
        if (typeid (GetMdState::HandleRefType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "HandleRef",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetMdStateResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // MdState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const GetMdStateResponse::MdStateType& x (i.getMdState ());
      if (typeid (GetMdStateResponse::MdStateType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MdState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MdState",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetContextStates& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // HandleRef
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetContextStates::HandleRefConstIterator
           b (i.getHandleRef ().begin ()), n (i.getHandleRef ().end ());
           b != n; ++b)
      {
        if (typeid (GetContextStates::HandleRefType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "HandleRef",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetContextStatesResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // ContextState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetContextStatesResponse::ContextStateConstIterator
           b (i.getContextState ().begin ()), n (i.getContextState ().end ());
           b != n; ++b)
      {
        if (typeid (GetContextStatesResponse::ContextStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ContextState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetContextStatesByIdentification& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // Identification
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetContextStatesByIdentification::IdentificationConstIterator
           b (i.getIdentification ().begin ()), n (i.getIdentification ().end ());
           b != n; ++b)
      {
        if (typeid (GetContextStatesByIdentification::IdentificationType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Identification",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Identification",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }

    // ContextType
    //
    if (i.getContextType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ContextType",
          e));

      a << *i.getContextType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetContextStatesByIdentificationResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // ContextState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetContextStatesByIdentificationResponse::ContextStateConstIterator
           b (i.getContextState ().begin ()), n (i.getContextState ().end ());
           b != n; ++b)
      {
        if (typeid (GetContextStatesByIdentificationResponse::ContextStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ContextState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetContextStatesByFilter& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // Filter
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetContextStatesByFilter::FilterConstIterator
           b (i.getFilter ().begin ()), n (i.getFilter ().end ());
           b != n; ++b)
      {
        if (typeid (GetContextStatesByFilter::FilterType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Filter",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Filter",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }

    // ContextType
    //
    if (i.getContextType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ContextType",
          e));

      a << *i.getContextType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetContextStatesByFilterResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // ContextState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetContextStatesByFilterResponse::ContextStateConstIterator
           b (i.getContextState ().begin ()), n (i.getContextState ().end ());
           b != n; ++b)
      {
        if (typeid (GetContextStatesByFilterResponse::ContextStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ContextState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetContextState& i)
  {
    e << static_cast< const ::MDM::AbstractSet& > (i);

    // ProposedContextState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SetContextState::ProposedContextStateConstIterator
           b (i.getProposedContextState ().begin ()), n (i.getProposedContextState ().end ());
           b != n; ++b)
      {
        if (typeid (SetContextState::ProposedContextStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ProposedContextState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ProposedContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetContextStateResponse& i)
  {
    e << static_cast< const ::MDM::AbstractSetResponse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReportPart& i)
  {
    e << static_cast< const ::MDM::AbstractReportPart& > (i);

    // ContextState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ReportPart::ContextStateConstIterator
           b (i.getContextState ().begin ()), n (i.getContextState ().end ());
           b != n; ++b)
      {
        if (typeid (ReportPart::ContextStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ContextState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PeriodicContextReport& i)
  {
    e << static_cast< const ::MDM::AbstractContextReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const EpisodicContextReport& i)
  {
    e << static_cast< const ::MDM::AbstractContextReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetLocalizedText& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // Ref
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetLocalizedText::RefConstIterator
           b (i.getRef ().begin ()), n (i.getRef ().end ());
           b != n; ++b)
      {
        if (typeid (GetLocalizedText::RefType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Ref",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Ref",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }

    // Version
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getVersion ())
      {
        const GetLocalizedText::VersionType& x (*i.getVersion ());
        if (typeid (GetLocalizedText::VersionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Version",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Version",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }

    // Lang
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetLocalizedText::LangConstIterator
           b (i.getLang ().begin ()), n (i.getLang ().end ());
           b != n; ++b)
      {
        if (typeid (GetLocalizedText::LangType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Lang",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Lang",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }

    // TextWidth
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetLocalizedText::TextWidthConstIterator
           b (i.getTextWidth ().begin ()), n (i.getTextWidth ().end ());
           b != n; ++b)
      {
        if (typeid (GetLocalizedText::TextWidthType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TextWidth",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "TextWidth",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }

    // NumberOfLines
    //
    for (GetLocalizedText::NumberOfLinesConstIterator
         b (i.getNumberOfLines ().begin ()), n (i.getNumberOfLines ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "NumberOfLines",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetLocalizedTextResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // Text
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetLocalizedTextResponse::TextConstIterator
           b (i.getText ().begin ()), n (i.getText ().end ());
           b != n; ++b)
      {
        if (typeid (GetLocalizedTextResponse::TextType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Text",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Text",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetSupportedLanguages& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetSupportedLanguagesResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // Lang
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetSupportedLanguagesResponse::LangConstIterator
           b (i.getLang ().begin ()), n (i.getLang ().end ());
           b != n; ++b)
      {
        if (typeid (GetSupportedLanguagesResponse::LangType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Lang",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Lang",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetDescriptorsFromArchive& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // DescriptorRevisions
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getDescriptorRevisions ())
      {
        const GetDescriptorsFromArchive::DescriptorRevisionsType& x (*i.getDescriptorRevisions ());
        if (typeid (GetDescriptorsFromArchive::DescriptorRevisionsType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DescriptorRevisions",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DescriptorRevisions",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }

    // TimeFrame
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getTimeFrame ())
      {
        const GetDescriptorsFromArchive::TimeFrameType& x (*i.getTimeFrame ());
        if (typeid (GetDescriptorsFromArchive::TimeFrameType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TimeFrame",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "TimeFrame",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }

    // Handle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetDescriptorsFromArchive::HandleConstIterator
           b (i.getHandle ().begin ()), n (i.getHandle ().end ());
           b != n; ++b)
      {
        if (typeid (GetDescriptorsFromArchive::HandleType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Handle",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Handle",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetDescriptorsFromArchiveResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // Descriptor
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetDescriptorsFromArchiveResponse::DescriptorConstIterator
           b (i.getDescriptor ().begin ()), n (i.getDescriptor ().end ());
           b != n; ++b)
      {
        if (typeid (GetDescriptorsFromArchiveResponse::DescriptorType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Descriptor",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Descriptor",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetStatesFromArchive& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // StateRevisions
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getStateRevisions ())
      {
        const GetStatesFromArchive::StateRevisionsType& x (*i.getStateRevisions ());
        if (typeid (GetStatesFromArchive::StateRevisionsType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "StateRevisions",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "StateRevisions",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }

    // TimeFrame
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getTimeFrame ())
      {
        const GetStatesFromArchive::TimeFrameType& x (*i.getTimeFrame ());
        if (typeid (GetStatesFromArchive::TimeFrameType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TimeFrame",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "TimeFrame",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }

    // Handle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetStatesFromArchive::HandleConstIterator
           b (i.getHandle ().begin ()), n (i.getHandle ().end ());
           b != n; ++b)
      {
        if (typeid (GetStatesFromArchive::HandleType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Handle",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Handle",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetStatesFromArchiveResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // State
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetStatesFromArchiveResponse::StateConstIterator
           b (i.getState ().begin ()), n (i.getState ().end ());
           b != n; ++b)
      {
        if (typeid (GetStatesFromArchiveResponse::StateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "State",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "State",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetValue& i)
  {
    e << static_cast< const ::MDM::AbstractSet& > (i);

    // RequestedNumericValue
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RequestedNumericValue",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << ::xml_schema::AsDecimal(i.getRequestedNumericValue ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetValueResponse& i)
  {
    e << static_cast< const ::MDM::AbstractSetResponse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetString& i)
  {
    e << static_cast< const ::MDM::AbstractSet& > (i);

    // RequestedStringValue
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const SetString::RequestedStringValueType& x (i.getRequestedStringValue ());
      if (typeid (SetString::RequestedStringValueType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RequestedStringValue",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "RequestedStringValue",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetStringResponse& i)
  {
    e << static_cast< const ::MDM::AbstractSetResponse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Activate& i)
  {
    e << static_cast< const ::MDM::AbstractSet& > (i);

    // Argument
    //
    for (Activate::ArgumentConstIterator
         b (i.getArgument ().begin ()), n (i.getArgument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Argument",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ActivateResponse& i)
  {
    e << static_cast< const ::MDM::AbstractSetResponse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetAlertState& i)
  {
    e << static_cast< const ::MDM::AbstractSet& > (i);

    // ProposedAlertState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const SetAlertState::ProposedAlertStateType& x (i.getProposedAlertState ());
      if (typeid (SetAlertState::ProposedAlertStateType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProposedAlertState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ProposedAlertState",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetAlertStateResponse& i)
  {
    e << static_cast< const ::MDM::AbstractSetResponse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetComponentState& i)
  {
    e << static_cast< const ::MDM::AbstractSet& > (i);

    // ProposedComponentState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SetComponentState::ProposedComponentStateConstIterator
           b (i.getProposedComponentState ().begin ()), n (i.getProposedComponentState ().end ());
           b != n; ++b)
      {
        if (typeid (SetComponentState::ProposedComponentStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ProposedComponentState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ProposedComponentState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetComponentStateResponse& i)
  {
    e << static_cast< const ::MDM::AbstractSetResponse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetMetricState& i)
  {
    e << static_cast< const ::MDM::AbstractSet& > (i);

    // ProposedMetricState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SetMetricState::ProposedMetricStateConstIterator
           b (i.getProposedMetricState ().begin ()), n (i.getProposedMetricState ().end ());
           b != n; ++b)
      {
        if (typeid (SetMetricState::ProposedMetricStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ProposedMetricState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ProposedMetricState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetMetricStateResponse& i)
  {
    e << static_cast< const ::MDM::AbstractSetResponse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const OperationInvokedReport& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // ReportPart
    //
    for (OperationInvokedReport::ReportPartConstIterator
         b (i.getReportPart ().begin ()), n (i.getReportPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReportPart",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetContainmentTree& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // HandleRef
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetContainmentTree::HandleRefConstIterator
           b (i.getHandleRef ().begin ()), n (i.getHandleRef ().end ());
           b != n; ++b)
      {
        if (typeid (GetContainmentTree::HandleRefType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "HandleRef",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetContainmentTreeResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // ContainmentTree
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const GetContainmentTreeResponse::ContainmentTreeType& x (i.getContainmentTree ());
      if (typeid (GetContainmentTreeResponse::ContainmentTreeType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ContainmentTree",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ContainmentTree",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetDescriptor& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // HandleRef
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetDescriptor::HandleRefConstIterator
           b (i.getHandleRef ().begin ()), n (i.getHandleRef ().end ());
           b != n; ++b)
      {
        if (typeid (GetDescriptor::HandleRefType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "HandleRef",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetDescriptorResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // Descriptor
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetDescriptorResponse::DescriptorConstIterator
           b (i.getDescriptor ().begin ()), n (i.getDescriptor ().end ());
           b != n; ++b)
      {
        if (typeid (GetDescriptorResponse::DescriptorType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Descriptor",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Descriptor",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReportPart1& i)
  {
    e << static_cast< const ::MDM::AbstractReportPart& > (i);

    // MetricState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ReportPart1::MetricStateConstIterator
           b (i.getMetricState ().begin ()), n (i.getMetricState ().end ());
           b != n; ++b)
      {
        if (typeid (ReportPart1::MetricStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MetricState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "MetricState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EpisodicMetricReport& i)
  {
    e << static_cast< const ::MDM::AbstractMetricReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const PeriodicMetricReport& i)
  {
    e << static_cast< const ::MDM::AbstractMetricReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReportPart2& i)
  {
    e << static_cast< const ::MDM::AbstractReportPart& > (i);

    // ComponentState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ReportPart2::ComponentStateConstIterator
           b (i.getComponentState ().begin ()), n (i.getComponentState ().end ());
           b != n; ++b)
      {
        if (typeid (ReportPart2::ComponentStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ComponentState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ComponentState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EpisodicComponentReport& i)
  {
    e << static_cast< const ::MDM::AbstractComponentReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const PeriodicComponentReport& i)
  {
    e << static_cast< const ::MDM::AbstractComponentReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReportPart3& i)
  {
    e << static_cast< const ::MDM::AbstractReportPart& > (i);

    // AlertState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ReportPart3::AlertStateConstIterator
           b (i.getAlertState ().begin ()), n (i.getAlertState ().end ());
           b != n; ++b)
      {
        if (typeid (ReportPart3::AlertStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AlertState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "AlertState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EpisodicAlertReport& i)
  {
    e << static_cast< const ::MDM::AbstractAlertReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const PeriodicAlertReport& i)
  {
    e << static_cast< const ::MDM::AbstractAlertReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReportPart4& i)
  {
    e << static_cast< const ::MDM::AbstractReportPart& > (i);

    // OperationState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ReportPart4::OperationStateConstIterator
           b (i.getOperationState ().begin ()), n (i.getOperationState ().end ());
           b != n; ++b)
      {
        if (typeid (ReportPart4::OperationStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OperationState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "OperationState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EpisodicOperationalStateReport& i)
  {
    e << static_cast< const ::MDM::AbstractOperationalStateReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const PeriodicOperationalStateReport& i)
  {
    e << static_cast< const ::MDM::AbstractOperationalStateReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const SystemErrorReport& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // ReportPart
    //
    for (SystemErrorReport::ReportPartConstIterator
         b (i.getReportPart ().begin ()), n (i.getReportPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReportPart",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DescriptionModificationReport& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // ReportPart
    //
    for (DescriptionModificationReport::ReportPartConstIterator
         b (i.getReportPart ().begin ()), n (i.getReportPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReportPart",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const WaveformStream& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // State
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (WaveformStream::StateConstIterator
           b (i.getState ().begin ()), n (i.getState ().end ());
           b != n; ++b)
      {
        if (typeid (WaveformStream::StateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "State",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "State",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ObservedValueStream& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // Value
    //
    for (ObservedValueStream::ValueConstIterator
         b (i.getValue ().begin ()), n (i.getValue ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Value",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Retrievability& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // By
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (Retrievability::ByConstIterator
           b (i.getBy ().begin ()), n (i.getBy ().end ());
           b != n; ++b)
      {
        if (typeid (Retrievability::ByType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "By",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "By",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Argument& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getExtension ())
      {
        const Argument::ExtensionType& x (*i.getExtension ());
        if (typeid (Argument::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // ArgValue
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const Argument::ArgValueType& x (i.getArgValue ());
      if (typeid (Argument::ArgValueType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ArgValue",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ArgValue",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReportPart5& i)
  {
    e << static_cast< const ::MDM::AbstractReportPart& > (i);

    // InvocationInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ReportPart5::InvocationInfoType& x (i.getInvocationInfo ());
      if (typeid (ReportPart5::InvocationInfoType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InvocationInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "InvocationInfo",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }

    // InvocationSource
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ReportPart5::InvocationSourceType& x (i.getInvocationSource ());
      if (typeid (ReportPart5::InvocationSourceType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InvocationSource",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "InvocationSource",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }

    // OperationHandleRef
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "OperationHandleRef",
          e));

      a << i.getOperationHandleRef ();
    }

    // OperationTarget
    //
    if (i.getOperationTarget ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "OperationTarget",
          e));

      a << *i.getOperationTarget ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReportPart6& i)
  {
    e << static_cast< const ::MDM::AbstractReportPart& > (i);

    // ErrorCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ReportPart6::ErrorCodeType& x (i.getErrorCode ());
      if (typeid (ReportPart6::ErrorCodeType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ErrorCode",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ErrorCode",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }

    // ErrorInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getErrorInfo ())
      {
        const ReportPart6::ErrorInfoType& x (*i.getErrorInfo ());
        if (typeid (ReportPart6::ErrorInfoType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ErrorInfo",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ErrorInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReportPart7& i)
  {
    e << static_cast< const ::MDM::AbstractReportPart& > (i);

    // Descriptor
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ReportPart7::DescriptorConstIterator
           b (i.getDescriptor ().begin ()), n (i.getDescriptor ().end ());
           b != n; ++b)
      {
        if (typeid (ReportPart7::DescriptorType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Descriptor",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Descriptor",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }

    // State
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ReportPart7::StateConstIterator
           b (i.getState ().begin ()), n (i.getState ().end ());
           b != n; ++b)
      {
        if (typeid (ReportPart7::StateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "State",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "State",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }

    // ParentDescriptor
    //
    if (i.getParentDescriptor ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ParentDescriptor",
          e));

      a << *i.getParentDescriptor ();
    }

    // ModificationType
    //
    if (i.getModificationType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ModificationType",
          e));

      a << *i.getModificationType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Value& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Value
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getValue1 ())
      {
        const Value::Value1Type& x (*i.getValue1 ());
        if (typeid (Value::Value1Type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Value",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Value",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }

    // Metric
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Metric",
          e));

      a << i.getMetric ();
    }

    // StateVersion
    //
    if (i.getStateVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "StateVersion",
          e));

      a << *i.getStateVersion ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

