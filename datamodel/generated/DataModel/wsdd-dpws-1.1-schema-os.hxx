// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from wsdd-dpws-1.1-schema-os.xsd.
 */

#ifndef WSDD_DPWS_1_1_SCHEMA_OS_HXX
#define WSDD_DPWS_1_1_SCHEMA_OS_HXX

#include "DataModel/wsdd-dpws-1.1-schema-os-fwd.hxx"

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "DataModel/ws-addressing.hxx"

namespace WS
{
  /**
   * @brief C++ namespace for the %http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01
   * schema namespace.
   */
  namespace DPWS
  {
    /**
     * @brief Class corresponding to the %ThisModelType schema type.
     *
     * @nosubgrouping
     */
    class ThisModelType: public ::xml_schema::Type
    {
      public:
      /**
       * @name Manufacturer
       *
       * @brief Accessor and modifier functions for the %Manufacturer
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DPWS::LocalizedStringType ManufacturerType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< ManufacturerType > ManufacturerSequence;

      /**
       * @brief Element iterator type.
       */
      typedef ManufacturerSequence::iterator ManufacturerIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef ManufacturerSequence::const_iterator ManufacturerConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ManufacturerType, char > ManufacturerTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const ManufacturerSequence&
      getManufacturer () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      ManufacturerSequence&
      getManufacturer ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      setManufacturer (const ManufacturerSequence& s);

      //@}

      /**
       * @name ManufacturerUrl
       *
       * @brief Accessor and modifier functions for the %ManufacturerUrl
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::Uri ManufacturerUrlType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ManufacturerUrlType > ManufacturerUrlOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ManufacturerUrlType, char > ManufacturerUrlTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ManufacturerUrlOptional&
      getManufacturerUrl () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      ManufacturerUrlOptional&
      getManufacturerUrl ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setManufacturerUrl (const ManufacturerUrlType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setManufacturerUrl (const ManufacturerUrlOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setManufacturerUrl (::std::unique_ptr< ManufacturerUrlType > p);

      //@}

      /**
       * @name ModelName
       *
       * @brief Accessor and modifier functions for the %ModelName
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DPWS::LocalizedStringType ModelNameType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< ModelNameType > ModelNameSequence;

      /**
       * @brief Element iterator type.
       */
      typedef ModelNameSequence::iterator ModelNameIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef ModelNameSequence::const_iterator ModelNameConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ModelNameType, char > ModelNameTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const ModelNameSequence&
      getModelName () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      ModelNameSequence&
      getModelName ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      setModelName (const ModelNameSequence& s);

      //@}

      /**
       * @name ModelNumber
       *
       * @brief Accessor and modifier functions for the %ModelNumber
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String ModelNumberType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ModelNumberType > ModelNumberOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ModelNumberType, char > ModelNumberTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ModelNumberOptional&
      getModelNumber () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      ModelNumberOptional&
      getModelNumber ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setModelNumber (const ModelNumberType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setModelNumber (const ModelNumberOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setModelNumber (::std::unique_ptr< ModelNumberType > p);

      //@}

      /**
       * @name ModelUrl
       *
       * @brief Accessor and modifier functions for the %ModelUrl
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::Uri ModelUrlType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ModelUrlType > ModelUrlOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ModelUrlType, char > ModelUrlTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ModelUrlOptional&
      getModelUrl () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      ModelUrlOptional&
      getModelUrl ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setModelUrl (const ModelUrlType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setModelUrl (const ModelUrlOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setModelUrl (::std::unique_ptr< ModelUrlType > p);

      //@}

      /**
       * @name PresentationUrl
       *
       * @brief Accessor and modifier functions for the %PresentationUrl
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::Uri PresentationUrlType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< PresentationUrlType > PresentationUrlOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< PresentationUrlType, char > PresentationUrlTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const PresentationUrlOptional&
      getPresentationUrl () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      PresentationUrlOptional&
      getPresentationUrl ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setPresentationUrl (const PresentationUrlType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setPresentationUrl (const PresentationUrlOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setPresentationUrl (::std::unique_ptr< PresentationUrlType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ThisModelType ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ThisModelType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ThisModelType (const ThisModelType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ThisModelType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ThisModelType&
      operator= (const ThisModelType& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ThisModelType ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ManufacturerSequence Manufacturer_;
      ManufacturerUrlOptional ManufacturerUrl_;
      ModelNameSequence ModelName_;
      ModelNumberOptional ModelNumber_;
      ModelUrlOptional ModelUrl_;
      PresentationUrlOptional PresentationUrl_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %ThisDeviceType schema type.
     *
     * @nosubgrouping
     */
    class ThisDeviceType: public ::xml_schema::Type
    {
      public:
      /**
       * @name FriendlyName
       *
       * @brief Accessor and modifier functions for the %FriendlyName
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DPWS::LocalizedStringType FriendlyNameType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< FriendlyNameType > FriendlyNameSequence;

      /**
       * @brief Element iterator type.
       */
      typedef FriendlyNameSequence::iterator FriendlyNameIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef FriendlyNameSequence::const_iterator FriendlyNameConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< FriendlyNameType, char > FriendlyNameTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const FriendlyNameSequence&
      getFriendlyName () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      FriendlyNameSequence&
      getFriendlyName ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      setFriendlyName (const FriendlyNameSequence& s);

      //@}

      /**
       * @name FirmwareVersion
       *
       * @brief Accessor and modifier functions for the %FirmwareVersion
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String FirmwareVersionType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< FirmwareVersionType > FirmwareVersionOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< FirmwareVersionType, char > FirmwareVersionTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const FirmwareVersionOptional&
      getFirmwareVersion () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      FirmwareVersionOptional&
      getFirmwareVersion ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setFirmwareVersion (const FirmwareVersionType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setFirmwareVersion (const FirmwareVersionOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setFirmwareVersion (::std::unique_ptr< FirmwareVersionType > p);

      //@}

      /**
       * @name SerialNumber
       *
       * @brief Accessor and modifier functions for the %SerialNumber
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String SerialNumberType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< SerialNumberType > SerialNumberOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< SerialNumberType, char > SerialNumberTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const SerialNumberOptional&
      getSerialNumber () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      SerialNumberOptional&
      getSerialNumber ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setSerialNumber (const SerialNumberType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setSerialNumber (const SerialNumberOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setSerialNumber (::std::unique_ptr< SerialNumberType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ThisDeviceType ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ThisDeviceType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ThisDeviceType (const ThisDeviceType& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ThisDeviceType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ThisDeviceType&
      operator= (const ThisDeviceType& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ThisDeviceType ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      FriendlyNameSequence FriendlyName_;
      FirmwareVersionOptional FirmwareVersion_;
      SerialNumberOptional SerialNumber_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %LocalizedStringType schema type.
     *
     * @nosubgrouping
     */
    class LocalizedStringType: public ::xml_schema::String
    {
      public:
      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from initializers for required 
       * elements and attributes.
       */
      LocalizedStringType ();

      /**
       * @brief Create an instance from a C string and initializers
       * for required elements and attributes.
       */
      LocalizedStringType (const char*);

      /**
       * @brief Create an instance from a string andinitializers
       * for required elements and attributes.
       */
      LocalizedStringType (const ::std::string&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      LocalizedStringType (const ::xml_schema::String&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      LocalizedStringType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      LocalizedStringType (const LocalizedStringType& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual LocalizedStringType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~LocalizedStringType ();
    };

    /**
     * @brief Union class corresponding to the %DeviceRelationshipTypes
     * schema type.
     *
     * The mapping represents unions as strings.
     */
    class DeviceRelationshipTypes: public ::xml_schema::String
    {
      public:

      /**
       * @brief Create an instance from a C string.
       *
       * @param v A string value.
       */
      DeviceRelationshipTypes (const char* v);

      /**
       * @brief Create an instance from a string.
       *
       * @param v A string value.
       */
      DeviceRelationshipTypes (const ::std::string& v);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceRelationshipTypes (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceRelationshipTypes (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceRelationshipTypes (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DeviceRelationshipTypes (const DeviceRelationshipTypes& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual DeviceRelationshipTypes*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;
    };

    /**
     * @brief Enumeration class corresponding to the %DeviceRelationshipTypeURIs
     * schema type.
     */
    class DeviceRelationshipTypeURIs: public ::xml_schema::Uri
    {
      public:
      /**
       * @brief Create an instance from the base value.
       *
       * @param v A base value.
       */
      DeviceRelationshipTypeURIs (const ::xml_schema::Uri& v);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceRelationshipTypeURIs (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceRelationshipTypeURIs (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceRelationshipTypeURIs (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DeviceRelationshipTypeURIs (const DeviceRelationshipTypeURIs& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual DeviceRelationshipTypeURIs*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;
    };

    /**
     * @brief Enumeration class corresponding to the %DeviceMetadataDialectURIs
     * schema type.
     */
    class DeviceMetadataDialectURIs: public ::xml_schema::Uri
    {
      public:
      /**
       * @brief Create an instance from the base value.
       *
       * @param v A base value.
       */
      DeviceMetadataDialectURIs (const ::xml_schema::Uri& v);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceMetadataDialectURIs (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceMetadataDialectURIs (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceMetadataDialectURIs (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DeviceMetadataDialectURIs (const DeviceMetadataDialectURIs& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual DeviceMetadataDialectURIs*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;
    };

    /**
     * @brief Union class corresponding to the %DeviceEventingFilterDialects
     * schema type.
     *
     * The mapping represents unions as strings.
     */
    class DeviceEventingFilterDialects: public ::xml_schema::String
    {
      public:

      /**
       * @brief Create an instance from a C string.
       *
       * @param v A string value.
       */
      DeviceEventingFilterDialects (const char* v);

      /**
       * @brief Create an instance from a string.
       *
       * @param v A string value.
       */
      DeviceEventingFilterDialects (const ::std::string& v);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceEventingFilterDialects (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceEventingFilterDialects (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceEventingFilterDialects (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DeviceEventingFilterDialects (const DeviceEventingFilterDialects& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual DeviceEventingFilterDialects*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;
    };

    /**
     * @brief Enumeration class corresponding to the %DeviceEventingFilterDialectURIs
     * schema type.
     */
    class DeviceEventingFilterDialectURIs: public ::xml_schema::Uri
    {
      public:
      /**
       * @brief Create an instance from the base value.
       *
       * @param v A base value.
       */
      DeviceEventingFilterDialectURIs (const ::xml_schema::Uri& v);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceEventingFilterDialectURIs (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceEventingFilterDialectURIs (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceEventingFilterDialectURIs (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DeviceEventingFilterDialectURIs (const DeviceEventingFilterDialectURIs& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual DeviceEventingFilterDialectURIs*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;
    };

    /**
     * @brief Enumeration class corresponding to the %DeviceActionURIs
     * schema type.
     */
    class DeviceActionURIs: public ::xml_schema::Uri
    {
      public:
      /**
       * @brief Create an instance from the base value.
       *
       * @param v A base value.
       */
      DeviceActionURIs (const ::xml_schema::Uri& v);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceActionURIs (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceActionURIs (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceActionURIs (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DeviceActionURIs (const DeviceActionURIs& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual DeviceActionURIs*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;
    };

    /**
     * @brief Union class corresponding to the %DeviceSoapFaultSubcodes
     * schema type.
     *
     * The mapping represents unions as strings.
     */
    class DeviceSoapFaultSubcodes: public ::xml_schema::String
    {
      public:

      /**
       * @brief Create an instance from a C string.
       *
       * @param v A string value.
       */
      DeviceSoapFaultSubcodes (const char* v);

      /**
       * @brief Create an instance from a string.
       *
       * @param v A string value.
       */
      DeviceSoapFaultSubcodes (const ::std::string& v);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceSoapFaultSubcodes (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceSoapFaultSubcodes (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceSoapFaultSubcodes (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DeviceSoapFaultSubcodes (const DeviceSoapFaultSubcodes& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual DeviceSoapFaultSubcodes*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;
    };

    /**
     * @brief Enumeration class corresponding to the %DeviceSoapFaultSubcodeQNames
     * schema type.
     */
    class DeviceSoapFaultSubcodeQNames: public ::xml_schema::Qname
    {
      public:
      /**
       * @brief Create an instance from the base value.
       *
       * @param v A base value.
       */
      DeviceSoapFaultSubcodeQNames (const ::xml_schema::Qname& v);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceSoapFaultSubcodeQNames (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceSoapFaultSubcodeQNames (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DeviceSoapFaultSubcodeQNames (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DeviceSoapFaultSubcodeQNames (const DeviceSoapFaultSubcodeQNames& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual DeviceSoapFaultSubcodeQNames*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;
    };

    /**
     * @brief Class corresponding to the %HostServiceType schema type.
     *
     * @nosubgrouping
     */
    class HostServiceType: public ::xml_schema::Type
    {
      public:
      /**
       * @name EndpointReference
       *
       * @brief Accessor and modifier functions for the %EndpointReference
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::ADDRESSING::EndpointReferenceType EndpointReferenceType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< EndpointReferenceType, char > EndpointReferenceTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const EndpointReferenceType&
      getEndpointReference () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      EndpointReferenceType&
      getEndpointReference ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setEndpointReference (const EndpointReferenceType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      setEndpointReference (::std::unique_ptr< EndpointReferenceType > p);

      //@}

      /**
       * @name Types
       *
       * @brief Accessor and modifier functions for the %Types
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DPWS::QNameListType TypesType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< TypesType > TypesOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TypesType, char > TypesTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const TypesOptional&
      getTypes () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      TypesOptional&
      getTypes ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setTypes (const TypesType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setTypes (const TypesOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setTypes (::std::unique_ptr< TypesType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      HostServiceType (const EndpointReferenceType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      HostServiceType (::std::unique_ptr< EndpointReferenceType >);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      HostServiceType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      HostServiceType (const HostServiceType& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual HostServiceType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      HostServiceType&
      operator= (const HostServiceType& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~HostServiceType ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< EndpointReferenceType > EndpointReference_;
      TypesOptional Types_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %HostedServiceType schema type.
     *
     * @nosubgrouping
     */
    class HostedServiceType: public ::xml_schema::Type
    {
      public:
      /**
       * @name EndpointReference
       *
       * @brief Accessor and modifier functions for the %EndpointReference
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::ADDRESSING::EndpointReferenceType EndpointReferenceType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< EndpointReferenceType > EndpointReferenceSequence;

      /**
       * @brief Element iterator type.
       */
      typedef EndpointReferenceSequence::iterator EndpointReferenceIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef EndpointReferenceSequence::const_iterator EndpointReferenceConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< EndpointReferenceType, char > EndpointReferenceTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const EndpointReferenceSequence&
      getEndpointReference () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      EndpointReferenceSequence&
      getEndpointReference ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      setEndpointReference (const EndpointReferenceSequence& s);

      //@}

      /**
       * @name Types
       *
       * @brief Accessor and modifier functions for the %Types
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DPWS::QNameListType TypesType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TypesType, char > TypesTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const TypesType&
      getTypes () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      TypesType&
      getTypes ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setTypes (const TypesType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      setTypes (::std::unique_ptr< TypesType > p);

      //@}

      /**
       * @name ServiceId
       *
       * @brief Accessor and modifier functions for the %ServiceId
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::Uri ServiceIdType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ServiceIdType, char > ServiceIdTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const ServiceIdType&
      getServiceId () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      ServiceIdType&
      getServiceId ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setServiceId (const ServiceIdType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      setServiceId (::std::unique_ptr< ServiceIdType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      HostedServiceType (const TypesType&,
                         const ServiceIdType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      HostedServiceType (::std::unique_ptr< TypesType >,
                         ::std::unique_ptr< ServiceIdType >);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      HostedServiceType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      HostedServiceType (const HostedServiceType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual HostedServiceType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      HostedServiceType&
      operator= (const HostedServiceType& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~HostedServiceType ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      EndpointReferenceSequence EndpointReference_;
      ::xsd::cxx::tree::one< TypesType > Types_;
      ::xsd::cxx::tree::one< ServiceIdType > ServiceId_;

      //@endcond
    };

    /**
     * @brief List class corresponding to the %QNameListType
     * schema type.
     *
     * This class has an interface of a standard C++ sequence (e.g.,
     * std::vector).
     */
    class QNameListType: public ::xml_schema::SimpleType,
      public ::xsd::cxx::tree::list< ::xml_schema::Qname, char >
    {
      public:
      /**
       * @brief Default constructor.
       *
       * Creates an empty list.
       */
      QNameListType ();

      /**
       * @brief Create a list with copies of the specified element.
       *
       * @param n A number of elements to copy.
       * @param x An element to copy.
       *
       * This constructor creates a list with @a n copies of @a x.
       */
      QNameListType (size_type n, const ::xml_schema::Qname& x);

      /**
       * @brief Create a list from an iterator range.
       *
       * @param begin An iterator pointing to the first element.
       * @param end An iterator pointing to the one past the last element.
       *
       * This constructor creates a list consisting of copies of the
       * elements in the range [begin,end).
       */
      template < typename I >
      QNameListType (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (begin, end, this)
      {
      }

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      QNameListType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      QNameListType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      QNameListType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      QNameListType (const QNameListType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual QNameListType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Destructor.
       */
      virtual 
      ~QNameListType ();
    };

    /**
     * @brief Enumeration class corresponding to the %DiscoveryTypeValues
     * schema type.
     */
    class DiscoveryTypeValues: public ::xml_schema::Qname
    {
      public:
      /**
       * @brief Create an instance from the base value.
       *
       * @param v A base value.
       */
      DiscoveryTypeValues (const ::xml_schema::Qname& v);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DiscoveryTypeValues (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DiscoveryTypeValues (const ::xercesc::DOMAttr& a,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DiscoveryTypeValues (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DiscoveryTypeValues (const DiscoveryTypeValues& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual DiscoveryTypeValues*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;
    };

    /**
     * @brief Class corresponding to the %AssertionType schema type.
     *
     * @nosubgrouping
     */
    class AssertionType: public ::xml_schema::Type
    {
      public:
      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from initializers for required 
       * elements and attributes.
       */
      AssertionType ();

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      AssertionType (const ::xml_schema::Type&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      AssertionType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      AssertionType (const AssertionType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual AssertionType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~AssertionType ();
    };

    /**
     * @brief Class corresponding to the %Relationship schema type.
     *
     * @nosubgrouping
     */
    class Relationship: public ::xml_schema::Type
    {
      public:
      /**
       * @name Host
       *
       * @brief Accessor and modifier functions for the %Host
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DPWS::HostServiceType HostType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< HostType, char > HostTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const HostType&
      getHost () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      HostType&
      getHost ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setHost (const HostType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      setHost (::std::unique_ptr< HostType > p);

      //@}

      /**
       * @name Hosted
       *
       * @brief Accessor and modifier functions for the %Hosted
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DPWS::HostedServiceType HostedType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< HostedType > HostedSequence;

      /**
       * @brief Element iterator type.
       */
      typedef HostedSequence::iterator HostedIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef HostedSequence::const_iterator HostedConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< HostedType, char > HostedTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const HostedSequence&
      getHosted () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      HostedSequence&
      getHosted ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      setHosted (const HostedSequence& s);

      //@}

      /**
       * @name Type
       *
       * @brief Accessor and modifier functions for the %Type
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::WS::DPWS::DeviceRelationshipTypes TypeType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const TypeType&
      getType () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      TypeType&
      getType ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      setType (const TypeType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      setType (::std::unique_ptr< TypeType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      Relationship (const HostType&,
                    const TypeType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      Relationship (::std::unique_ptr< HostType >,
                    const TypeType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      Relationship (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Relationship (const Relationship& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual Relationship*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Relationship&
      operator= (const Relationship& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~Relationship ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< HostType > Host_;
      HostedSequence Hosted_;
      ::xsd::cxx::tree::one< TypeType > Type_;

      //@endcond
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace WS
{
  namespace DPWS
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace WS
{
  namespace DPWS
  {
    void
    operator<< (::xercesc::DOMElement&, const ThisModelType&);

    void
    operator<< (::xercesc::DOMElement&, const ThisDeviceType&);

    void
    operator<< (::xercesc::DOMElement&, const LocalizedStringType&);

    void
    operator<< (::xercesc::DOMElement&, const DeviceRelationshipTypes&);

    void
    operator<< (::xercesc::DOMAttr&, const DeviceRelationshipTypes&);

    void
    operator<< (::xml_schema::ListStream&,
                const DeviceRelationshipTypes&);

    void
    operator<< (::xercesc::DOMElement&, const DeviceRelationshipTypeURIs&);

    void
    operator<< (::xercesc::DOMAttr&, const DeviceRelationshipTypeURIs&);

    void
    operator<< (::xml_schema::ListStream&,
                const DeviceRelationshipTypeURIs&);

    void
    operator<< (::xercesc::DOMElement&, const DeviceMetadataDialectURIs&);

    void
    operator<< (::xercesc::DOMAttr&, const DeviceMetadataDialectURIs&);

    void
    operator<< (::xml_schema::ListStream&,
                const DeviceMetadataDialectURIs&);

    void
    operator<< (::xercesc::DOMElement&, const DeviceEventingFilterDialects&);

    void
    operator<< (::xercesc::DOMAttr&, const DeviceEventingFilterDialects&);

    void
    operator<< (::xml_schema::ListStream&,
                const DeviceEventingFilterDialects&);

    void
    operator<< (::xercesc::DOMElement&, const DeviceEventingFilterDialectURIs&);

    void
    operator<< (::xercesc::DOMAttr&, const DeviceEventingFilterDialectURIs&);

    void
    operator<< (::xml_schema::ListStream&,
                const DeviceEventingFilterDialectURIs&);

    void
    operator<< (::xercesc::DOMElement&, const DeviceActionURIs&);

    void
    operator<< (::xercesc::DOMAttr&, const DeviceActionURIs&);

    void
    operator<< (::xml_schema::ListStream&,
                const DeviceActionURIs&);

    void
    operator<< (::xercesc::DOMElement&, const DeviceSoapFaultSubcodes&);

    void
    operator<< (::xercesc::DOMAttr&, const DeviceSoapFaultSubcodes&);

    void
    operator<< (::xml_schema::ListStream&,
                const DeviceSoapFaultSubcodes&);

    void
    operator<< (::xercesc::DOMElement&, const DeviceSoapFaultSubcodeQNames&);

    void
    operator<< (::xercesc::DOMAttr&, const DeviceSoapFaultSubcodeQNames&);

    void
    operator<< (::xml_schema::ListStream&,
                const DeviceSoapFaultSubcodeQNames&);

    void
    operator<< (::xercesc::DOMElement&, const HostServiceType&);

    void
    operator<< (::xercesc::DOMElement&, const HostedServiceType&);

    void
    operator<< (::xercesc::DOMElement&, const QNameListType&);

    void
    operator<< (::xercesc::DOMAttr&, const QNameListType&);

    void
    operator<< (::xml_schema::ListStream&,
                const QNameListType&);

    void
    operator<< (::xercesc::DOMElement&, const DiscoveryTypeValues&);

    void
    operator<< (::xercesc::DOMAttr&, const DiscoveryTypeValues&);

    void
    operator<< (::xml_schema::ListStream&,
                const DiscoveryTypeValues&);

    void
    operator<< (::xercesc::DOMElement&, const AssertionType&);

    void
    operator<< (::xercesc::DOMElement&, const Relationship&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // WSDD_DPWS_1_1_SCHEMA_OS_HXX
