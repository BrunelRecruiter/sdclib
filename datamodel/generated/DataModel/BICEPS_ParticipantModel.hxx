// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from BICEPS_ParticipantModel.xsd.
 */

#ifndef BICEPS_PARTICIPANT_MODEL_HXX
#define BICEPS_PARTICIPANT_MODEL_HXX

#include "DataModel/BICEPS_ParticipantModel-fwd.hxx"

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "DataModel/ExtensionPoint.hxx"

/**
 * @brief C++ namespace for the %http://standards.ieee.org/downloads/11073/11073-10207-2017/participant
 * schema namespace.
 */
namespace CDM
{
  /**
   * @brief Class corresponding to the %Mdib schema type.
   *
   * Root object that comprises the capability description of the
   * represented MDSs in pm:MdDescription (descriptive part) as well as the
   * current state in pm:MdState (state part).
   *
   * @nosubgrouping
   */
  class Mdib: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name MdDescription
     *
     * @brief Accessor and modifier functions for the %MdDescription
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::MdDescription MdDescriptionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MdDescriptionType > MdDescriptionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MdDescriptionType, char > MdDescriptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MdDescriptionOptional&
    getMdDescription () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MdDescriptionOptional&
    getMdDescription ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMdDescription (const MdDescriptionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMdDescription (const MdDescriptionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMdDescription (::std::unique_ptr< MdDescriptionType > p);

    //@}

    /**
     * @name MdState
     *
     * @brief Accessor and modifier functions for the %MdState
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::MdState MdStateType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MdStateType > MdStateOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MdStateType, char > MdStateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MdStateOptional&
    getMdState () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MdStateOptional&
    getMdState ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMdState (const MdStateType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMdState (const MdStateOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMdState (::std::unique_ptr< MdStateType > p);

    //@}

    /**
     * @name MdibVersion
     *
     * @brief Accessor and modifier functions for the %MdibVersion
     * optional attribute.
     *
     * The unique change version number of the MDIB. The implied value of the
     * initial version SHALL be "0".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::VersionCounter MdibVersionType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MdibVersionType > MdibVersionOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MdibVersionType, char > MdibVersionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MdibVersionOptional&
    getMdibVersion () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MdibVersionOptional&
    getMdibVersion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMdibVersion (const MdibVersionType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMdibVersion (const MdibVersionOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMdibVersion (::std::unique_ptr< MdibVersionType > p);

    //@}

    /**
     * @name SequenceId
     *
     * @brief Accessor and modifier functions for the %SequenceId
     * required attribute.
     *
     * SequenceId identifies a sequence within the context of ./@InstanceId.
     * 
     * __R5029: SequenceId SHALL be compared per RFC 3986 Section 6.2.1
     * Simple String Comparison [RFC3986].__
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Uri SequenceIdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SequenceIdType, char > SequenceIdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const SequenceIdType&
    getSequenceId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    SequenceIdType&
    getSequenceId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSequenceId (const SequenceIdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSequenceId (::std::unique_ptr< SequenceIdType > p);

    //@}

    /**
     * @name InstanceId
     *
     * @brief Accessor and modifier functions for the %InstanceId
     * optional attribute.
     *
     * Value that indicates an instantiation counter.
     * 
     * __R5004: If InstanceId is used, it SHALL be incremented by a positive
     * value (>= 1) when the SequenceId has changed.__
     * 
     * NOTE?This occurs each time the POC MEDICAL DEVICE has gone down, lost
     * state, and came back up again.
     * 
     * __R5005: InstanceId SHOULD NOT be incremented otherwise than defined
     * in R5004.__
     * 
     * NOTE 1?Means to set this value include, but are not limited to:
     * 
     * - A counter that is incremented on each cold boot
     * - The boot time of the POC MEDICAL DEVICE, expressed as seconds
     * elapsed since midnight January 1, 1970
     * 
     * NOTE 2?The MDIB version's instance id is different to the
     * pm:InstanceIdentifier data type.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::UnsignedLong InstanceIdType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< InstanceIdType > InstanceIdOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InstanceIdType, char > InstanceIdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const InstanceIdOptional&
    getInstanceId () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    InstanceIdOptional&
    getInstanceId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInstanceId (const InstanceIdType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setInstanceId (const InstanceIdOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Mdib (const SequenceIdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Mdib (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Mdib (const Mdib& x,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Mdib*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Mdib&
    operator= (const Mdib& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Mdib ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    MdDescriptionOptional MdDescription_;
    MdStateOptional MdState_;
    MdibVersionOptional MdibVersion_;
    ::xsd::cxx::tree::one< SequenceIdType > SequenceId_;
    InstanceIdOptional InstanceId_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MdDescription schema type.
   *
   * MdDescription is the root container to represent the descriptive part
   * of the MDIB. The descriptive part describes the capabilities provided
   * by a POC MEDICAL DEVICE, e.g., which measurements, alerts and settings
   * it provides. As the descriptive part does not change as frequently as
   * the state part, it is well-known as the (almost) static part of the
   * MDIB. The MdDescription's counterpart is pm:MdState.
   *
   * @nosubgrouping
   */
  class MdDescription: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Mds
     *
     * @brief Accessor and modifier functions for the %Mds
     * sequence element.
     *
     * List of MDSs that are contained in the MDIB.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::MdsDescriptor MdsType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< MdsType > MdsSequence;

    /**
     * @brief Element iterator type.
     */
    typedef MdsSequence::iterator MdsIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef MdsSequence::const_iterator MdsConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MdsType, char > MdsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const MdsSequence&
    getMds () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    MdsSequence&
    getMds ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setMds (const MdsSequence& s);

    //@}

    /**
     * @name DescriptionVersion
     *
     * @brief Accessor and modifier functions for the %DescriptionVersion
     * optional attribute.
     *
     * Version number of the description. The version number is incremented
     * by one every time the descriptive part changes. The implied value
     * SHALL be "0".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::VersionCounter DescriptionVersionType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DescriptionVersionType > DescriptionVersionOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DescriptionVersionType, char > DescriptionVersionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DescriptionVersionOptional&
    getDescriptionVersion () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    DescriptionVersionOptional&
    getDescriptionVersion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDescriptionVersion (const DescriptionVersionType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setDescriptionVersion (const DescriptionVersionOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDescriptionVersion (::std::unique_ptr< DescriptionVersionType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MdDescription ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MdDescription (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MdDescription (const MdDescription& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MdDescription*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MdDescription&
    operator= (const MdDescription& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MdDescription ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    MdsSequence Mds_;
    DescriptionVersionOptional DescriptionVersion_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MdState schema type.
   *
   * MdState is the root container to represent the state part of the MDIB.
   * The state part describes the values provided by a POC MEDICAL DEVICE,
   * e.g., which measurement or alert values as well as patient
   * demographics it provides. As the state part most often changes very
   * frequently, it is well-known as the dynamic part of the MDIB. The
   * MdState's counterpart is pm:MdDescription.
   *
   * @nosubgrouping
   */
  class MdState: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name State
     *
     * @brief Accessor and modifier functions for the %State
     * sequence element.
     *
     * List of states that describe the volatile status of the objects in the
     * MDIB.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::AbstractState StateType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< StateType > StateSequence;

    /**
     * @brief Element iterator type.
     */
    typedef StateSequence::iterator StateIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef StateSequence::const_iterator StateConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const StateSequence&
    getState () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    StateSequence&
    getState ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setState (const StateSequence& s);

    //@}

    /**
     * @name StateVersion
     *
     * @brief Accessor and modifier functions for the %StateVersion
     * optional attribute.
     *
     * Version number of the states. The version number is incremented by one
     * every time the state part changes. The implied value SHALL be "0".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::VersionCounter StateVersionType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StateVersionType > StateVersionOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateVersionType, char > StateVersionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StateVersionOptional&
    getStateVersion () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    StateVersionOptional&
    getStateVersion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setStateVersion (const StateVersionType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setStateVersion (const StateVersionOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStateVersion (::std::unique_ptr< StateVersionType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MdState ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MdState (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MdState (const MdState& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MdState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MdState&
    operator= (const MdState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MdState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    StateSequence State_;
    StateVersionOptional StateVersion_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %MeasurementValidity
   * schema type.
   *
   * Level of validity of a measured value.
   */
  class MeasurementValidity: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Vld = Valid. A measured value that is correct from the perspective of
       * the measuring device.
       */
      Vld,
      /**
       * Vldated = Validated Data. A measured value where the validity has been
       * confirmed by an external actor, e.g., an operator, other than the POC
       * MEDICAL DEVICE.
       */
      Vldated,
      /**
       * Ong = Measurement Ongoing. Indicates that a new measurement is just
       * being taken and therefore measured value is not available.
       */
      Ong,
      /**
       * Qst = Questionable. A measured value where correctness can not be
       * guaranteed.
       */
      Qst,
      /**
       * Calib = Calibration Ongoing. A measured value where correctness can
       * not be guaranteed, because a calibration is currently going on.
       */
      Calib,
      /**
       * Inv = Invalid. A measured value that is incorrect from the perspective
       * of the measuring device.
       */
      Inv,
      /**
       * Oflw = Overflow. A measured value where correctness cannot be
       * guaranteed as it is above all defined technical ranges.
       */
      Oflw,
      /**
       * Uflw = Underflow. A measured value where correctness cannot be
       * guaranteed as it is below all defined technical ranges.
       */
      Uflw,
      /**
       * NA = Not Available. No value can be derived, e.g., if a sensor is not
       * placed correctly.
       */
      NA
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    MeasurementValidity (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    MeasurementValidity (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    MeasurementValidity (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    MeasurementValidity (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MeasurementValidity (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MeasurementValidity (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MeasurementValidity (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MeasurementValidity (const MeasurementValidity& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MeasurementValidity*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    MeasurementValidity&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_MeasurementValidity_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_MeasurementValidity_convert () const;

    public:
    static const char* const _xsd_MeasurementValidity_literals_[9];
    static const Value _xsd_MeasurementValidity_indexes_[9];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Timestamp schema type.
   *
   * An unsigned 64-bit integer value that represents a timestamp.
   * 
   * __R5001: A timestamp SHALL count the milliseconds between the current
   * time and midnight, January 1, 1970 UTC without leap seconds.__
   * 
   * __R5002: Timestamps are an optional feature of the MDIB. If anywhere
   * in the MDIB a timestamp is used, the SERVICE PROVIDER SHALL provide a
   * pm:ClockDescriptor ELEMENT.__
   * 
   * NOTE 1?Typically all systems assume that a day has 86400 seconds.
   * NOTE 2?While the unit of time of pm:Timestamp is a millisecond, the
   * granularity of the value depends on the hardware/software system and
   * might be larger (e.g., tens of milliseconds).
   *
   * @nosubgrouping
   */
  class Timestamp: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Timestamp (const ::xml_schema::UnsignedLong&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Timestamp (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Timestamp (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Timestamp (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Timestamp (const Timestamp& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Timestamp*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Timestamp ();
  };

  /**
   * @brief Class corresponding to the %VersionCounter schema type.
   *
   * A version counter to provide versionized MDIB objects. The initial
   * value of a version counter SHALL be "0".
   * 
   * __R5003: VersionCounter values SHALL never be decremented.__
   *
   * @nosubgrouping
   */
  class VersionCounter: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    VersionCounter (const ::xml_schema::UnsignedLong&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VersionCounter (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VersionCounter (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VersionCounter (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VersionCounter (const VersionCounter& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual VersionCounter*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~VersionCounter ();
  };

  /**
   * @brief Class corresponding to the %ReferencedVersion schema type.
   *
   * In contrast to pm:VersionCounter, ReferencedVersion does not represent
   * a version of an MDIB object, but a reference to a particular version
   * of an MDIB object.
   *
   * @nosubgrouping
   */
  class ReferencedVersion: public ::CDM::VersionCounter
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ReferencedVersion (const ::xml_schema::UnsignedLong&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReferencedVersion (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReferencedVersion (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReferencedVersion (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReferencedVersion (const ReferencedVersion& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ReferencedVersion*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ReferencedVersion ();
  };

  /**
   * @brief Class corresponding to the %CodeIdentifier schema type.
   *
   * CodeIdentifier defines an arbitrary CODE identifier with a minimum
   * length of 1 character.
   *
   * @nosubgrouping
   */
  class CodeIdentifier: public ::xml_schema::String
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    CodeIdentifier ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    CodeIdentifier (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    CodeIdentifier (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    CodeIdentifier (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CodeIdentifier (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CodeIdentifier (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CodeIdentifier (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CodeIdentifier (const CodeIdentifier& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CodeIdentifier*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~CodeIdentifier ();
  };

  /**
   * @brief Class corresponding to the %SymbolicCodeName schema type.
   *
   * SymbolicCodeName is a symbolic, programmatic form of a
   * pm:CodeIdentifier term.
   * 
   * NOTE?SymbolicCodeName is the equivalent of the Reference ID attribute
   * that is defined in IEEE 11073-10101.
   *
   * @nosubgrouping
   */
  class SymbolicCodeName: public ::xml_schema::String
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    SymbolicCodeName ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    SymbolicCodeName (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    SymbolicCodeName (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SymbolicCodeName (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SymbolicCodeName (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SymbolicCodeName (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SymbolicCodeName (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SymbolicCodeName (const SymbolicCodeName& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SymbolicCodeName*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SymbolicCodeName ();
  };

  /**
   * @brief Class corresponding to the %LocalizedTextRef schema type.
   *
   * LocalizedTextRef defines a reference to a localized text.
   *
   * @nosubgrouping
   */
  class LocalizedTextRef: public ::xml_schema::String
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    LocalizedTextRef ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    LocalizedTextRef (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    LocalizedTextRef (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LocalizedTextRef (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LocalizedTextRef (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LocalizedTextRef (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LocalizedTextRef (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LocalizedTextRef (const LocalizedTextRef& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LocalizedTextRef*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LocalizedTextRef ();
  };

  /**
   * @brief Class corresponding to the %LocalizedTextContent schema type.
   *
   * Content restriction for pm:LocalizedText ELEMENTs.
   *
   * @nosubgrouping
   */
  class LocalizedTextContent: public ::xml_schema::String
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    LocalizedTextContent ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    LocalizedTextContent (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    LocalizedTextContent (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LocalizedTextContent (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LocalizedTextContent (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LocalizedTextContent (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LocalizedTextContent (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LocalizedTextContent (const LocalizedTextContent& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LocalizedTextContent*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LocalizedTextContent ();
  };

  /**
   * @brief Enumeration class corresponding to the %LocalizedTextWidth
   * schema type.
   *
   * LocalizedTextWidth indicates the width of a localized text based on
   * the number of fullwidth characters in order to allow a SERVICE
   * CONSUMER an effective filtering and querying for translations.
   * 
   * In the following, a line is defined as the content of the text from
   * either the beginning of the text or the beginning of a previous line
   * until the next occurance of period mark, question mark, exclamation
   * mark, or paragraph.
   */
  class LocalizedTextWidth: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * A line has 4 or less fullwidth characters.
       */
      xs,
      /**
       * A line has 8 or less fullwidth characters.
       */
      s,
      /**
       * A line has 12 or less fullwidth characters.
       */
      m,
      /**
       * A line has 16 or less fullwidth characters.
       */
      l,
      /**
       * A line has 20 or less fullwidth characters.
       */
      xl,
      /**
       * A line has 21 or more fullwidth characters.
       */
      xxl
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    LocalizedTextWidth (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    LocalizedTextWidth (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    LocalizedTextWidth (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    LocalizedTextWidth (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LocalizedTextWidth (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LocalizedTextWidth (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LocalizedTextWidth (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LocalizedTextWidth (const LocalizedTextWidth& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LocalizedTextWidth*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    LocalizedTextWidth&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_LocalizedTextWidth_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_LocalizedTextWidth_convert () const;

    public:
    static const char* const _xsd_LocalizedTextWidth_literals_[6];
    static const Value _xsd_LocalizedTextWidth_indexes_[6];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LocalizedText schema type.
   *
   * LocalizedText is a bundled ELEMENT to reference texts in different
   * languages or to provide a text in a specific language.
   * 
   * The goal of text references is to shrink the overall size of the MDIB
   * by only providing a single reference to a text file that translates a
   * text into multiple languages instead of flooding the MDIB with all
   * translated texts. Referenced texts can be requested by the
   * LOCALIZATION SERVICE. If no LOCALIZATION SERVICE exist, the
   * application can make use of LocalizedText to represent a text in a
   * single language.
   * 
   * __R5047: If ./@Lang and ./@Ref are present, then the text SHALL be
   * only available in the language specified by ./@Lang.__
   * 
   * __R5048: If ./@Lang is present and ./@Ref is not present, then ./@Lang
   * SHALL specify the language of the LocalizedText's content. The Text is
   * not available through the LOCALIZATION SERVICE.__
   * 
   * __R5049: If ./@Lang is not present and ./@Ref is present, then the
   * text SHALL be available through the LOCALIZATION SERVICE.__
   * 
   * __R5050: If ./@Lang and ./@Ref are not present, then the language of
   * the LocalizedText's content is unknown. The text SHALL NOT be
   * available through the LOCALIZATION SERVICE.__
   *
   * @nosubgrouping
   */
  class LocalizedText: public ::CDM::LocalizedTextContent
  {
    public:
    /**
     * @name Ref
     *
     * @brief Accessor and modifier functions for the %Ref
     * optional attribute.
     *
     * References a text in a localized text file.
     * 
     * Text references SHALL be unique regardless of any HANDLE name.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::LocalizedTextRef RefType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RefType > RefOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RefOptional&
    getRef () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    RefOptional&
    getRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRef (const RefType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setRef (const RefOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRef (::std::unique_ptr< RefType > p);

    //@}

    /**
     * @name Lang
     *
     * @brief Accessor and modifier functions for the %Lang
     * optional attribute.
     *
     * Lang specifies the language of the localized text.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Language LangType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LangType > LangOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LangType, char > LangTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LangOptional&
    getLang () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    LangOptional&
    getLang ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setLang (const LangType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setLang (const LangOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLang (::std::unique_ptr< LangType > p);

    //@}

    /**
     * @name Version
     *
     * @brief Accessor and modifier functions for the %Version
     * optional attribute.
     *
     * Version defines the current revision of the referenced text in the
     * localized text file.
     * 
     * __R5006: Texts might change over time, but references are per
     * definition unique and typically do not change. To check if a text that
     * is referenced by ./@Ref has changed, pm:LocalizedText SHALL include
     * Version if ./@Ref is set.
     * 
     * NOTE?This saves to query a localized text file if the referencing
     * ELEMENT has changed, but the referenced text has not. If Version is
     * not given, a client has to assume that the text changes every time the
     * referencing ELEMENT changes. In this case, the client is encouraged to
     * query the localized text file on each modification.__
     * 
     * __R5007: To keep things simple, every translated text in a localized
     * text file that belongs to a particular reference SHALL share the same
     * version number.__
     * 
     * NOTE?From this it follows that if Version has changed, every
     * translation of a referenced text is obsolete even if only a single
     * translation has changed.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::ReferencedVersion VersionType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< VersionType > VersionOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< VersionType, char > VersionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const VersionOptional&
    getVersion () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    VersionOptional&
    getVersion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setVersion (const VersionType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setVersion (const VersionOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setVersion (::std::unique_ptr< VersionType > p);

    //@}

    /**
     * @name TextWidth
     *
     * @brief Accessor and modifier functions for the %TextWidth
     * optional attribute.
     *
     * Text width as defined in pm:LocalizedTextWidth.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::LocalizedTextWidth TextWidthType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TextWidthType > TextWidthOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TextWidthType, char > TextWidthTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TextWidthOptional&
    getTextWidth () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    TextWidthOptional&
    getTextWidth ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setTextWidth (const TextWidthType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setTextWidth (const TextWidthOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTextWidth (::std::unique_ptr< TextWidthType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    LocalizedText ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    LocalizedText (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    LocalizedText (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LocalizedText (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LocalizedText (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LocalizedText (const LocalizedText& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LocalizedText*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LocalizedText&
    operator= (const LocalizedText& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LocalizedText ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    RefOptional Ref_;
    LangOptional Lang_;
    VersionOptional Version_;
    TextWidthOptional TextWidth_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %CodedValue schema type.
   *
   * In general, in an interoperability format, objects, attributes, and
   * methods are identified by nomenclature codes. CodedValue offers the
   * ability to represent such nomenclature codes.
   * 
   * Two CodedValue objects C1 and C2 are equivalent, if
   * 
   * - C1/@Code equals C2/@Code
   * - C1/@CodingSystem equals C2/@CodingSystem, both with expanded default
   * values
   * - C1/@CodingSystemVersion equals C2/@CodingSystemVersion
   * - If there exists a CodedValue object T1 in C1/pm:Translation and a
   * CodedValue object T2 in C2/pm:Translation such that T1 and T2 are
   * equivalent, C1 and T2 are equivalent, or C2 and T1 are equivalent.
   * 
   * NOTE 1?In case that ./@CodingSystem is not explicitly defined in
   * CodedValue, it is replaced implicitly by a default identifier. The
   * ./@CodingSystem ATTRIBUTE is then called "expanded". 
   * NOTE 2?As prescribed in ./@CodingSystemVersion, a version is set only
   * if a unique version identification by ./@CodingSystem is not possible.
   * Hence, there can be no implicit version mismatch.
   * NOTE 3?Equivalence between CodedValue objects is not necessarily
   * transitive.
   *
   * @nosubgrouping
   */
  class CodedValue: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name CodingSystemName
     *
     * @brief Accessor and modifier functions for the %CodingSystemName
     * sequence element.
     *
     * Human-readable name of the CODING SYSTEM that is described by
     * pm:CodedValue/@CodingSystem.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::LocalizedText CodingSystemNameType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< CodingSystemNameType > CodingSystemNameSequence;

    /**
     * @brief Element iterator type.
     */
    typedef CodingSystemNameSequence::iterator CodingSystemNameIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef CodingSystemNameSequence::const_iterator CodingSystemNameConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CodingSystemNameType, char > CodingSystemNameTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const CodingSystemNameSequence&
    getCodingSystemName () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    CodingSystemNameSequence&
    getCodingSystemName ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setCodingSystemName (const CodingSystemNameSequence& s);

    //@}

    /**
     * @name ConceptDescription
     *
     * @brief Accessor and modifier functions for the %ConceptDescription
     * sequence element.
     *
     * Multiple OPTIONAL human-readable texts that describe the CODE in more
     * detail.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::LocalizedText ConceptDescriptionType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ConceptDescriptionType > ConceptDescriptionSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ConceptDescriptionSequence::iterator ConceptDescriptionIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ConceptDescriptionSequence::const_iterator ConceptDescriptionConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ConceptDescriptionType, char > ConceptDescriptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ConceptDescriptionSequence&
    getConceptDescription () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ConceptDescriptionSequence&
    getConceptDescription ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setConceptDescription (const ConceptDescriptionSequence& s);

    //@}

    /**
     * @name Translation
     *
     * @brief Accessor and modifier functions for the %Translation
     * sequence element.
     *
     * Set of alternative or equivalent representations.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Translation TranslationType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TranslationType > TranslationSequence;

    /**
     * @brief Element iterator type.
     */
    typedef TranslationSequence::iterator TranslationIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef TranslationSequence::const_iterator TranslationConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TranslationType, char > TranslationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TranslationSequence&
    getTranslation () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TranslationSequence&
    getTranslation ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTranslation (const TranslationSequence& s);

    //@}

    /**
     * @name Code
     *
     * @brief Accessor and modifier functions for the %Code
     * required attribute.
     *
     * REQUIRED unique identifier of the CODE in the CODING SYSTEM.
     * 
     * Example: as "20720" from Block 2, of IEEE 11073-10101:2004, is the id
     * for "MDC_PRESS_AWAY", the context-free CODE (CF_Code10) is "151792"
     * which represents the unique identifier used within IEEE
     * 11073-10101:2004.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::CodeIdentifier CodeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< CodeType, char > CodeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const CodeType&
    getCode () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    CodeType&
    getCode ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setCode (const CodeType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCode (::std::unique_ptr< CodeType > p);

    //@}

    /**
     * @name CodingSystem
     *
     * @brief Accessor and modifier functions for the %CodingSystem
     * optional attribute.
     *
     * Unique identifier of a CODING SYSTEM that pm:CodedValue/@Code
     * originating from.
     * 
     * If no CODING SYSTEM is defined, the implied value SHALL be
     * "urn:oid:1.2.840.10004.1.1.1.0.0.1", which refers to ISO/IEC
     * 11073-10101.
     * 
     * Example: "urn:oid:1.2.840.10004.1.1.1.0.0.1" for the ISO/IEC
     * 11073-10101.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Uri CodingSystemType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CodingSystemType > CodingSystemOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< CodingSystemType, char > CodingSystemTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CodingSystemOptional&
    getCodingSystem () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    CodingSystemOptional&
    getCodingSystem ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setCodingSystem (const CodingSystemType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setCodingSystem (const CodingSystemOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCodingSystem (::std::unique_ptr< CodingSystemType > p);

    //@}

    /**
     * @name CodingSystemVersion
     *
     * @brief Accessor and modifier functions for the %CodingSystemVersion
     * optional attribute.
     *
     * CodingSystemVersion is a particular version of the CODING SYSTEM
     * defined by pm:CodedValue/@CodingSystem. CodingSystemVersion SHALL be
     * set if multiple versions of the underlying CODING SYSTEM exist and a
     * unique identification of the CODED VALUE is not possible by other
     * means.
     * 
     * Example: "20041215" for the ISO/IEC 11073-10101:2004, as it is the
     * release date of the standard's first edition.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String CodingSystemVersionType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CodingSystemVersionType > CodingSystemVersionOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< CodingSystemVersionType, char > CodingSystemVersionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CodingSystemVersionOptional&
    getCodingSystemVersion () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    CodingSystemVersionOptional&
    getCodingSystemVersion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setCodingSystemVersion (const CodingSystemVersionType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setCodingSystemVersion (const CodingSystemVersionOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCodingSystemVersion (::std::unique_ptr< CodingSystemVersionType > p);

    //@}

    /**
     * @name SymbolicCodeName
     *
     * @brief Accessor and modifier functions for the %SymbolicCodeName
     * optional attribute.
     *
     * See pm:SymbolicCodeName.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::SymbolicCodeName SymbolicCodeNameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SymbolicCodeNameType > SymbolicCodeNameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SymbolicCodeNameType, char > SymbolicCodeNameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SymbolicCodeNameOptional&
    getSymbolicCodeName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    SymbolicCodeNameOptional&
    getSymbolicCodeName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSymbolicCodeName (const SymbolicCodeNameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setSymbolicCodeName (const SymbolicCodeNameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSymbolicCodeName (::std::unique_ptr< SymbolicCodeNameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    CodedValue (const CodeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CodedValue (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CodedValue (const CodedValue& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CodedValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CodedValue&
    operator= (const CodedValue& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~CodedValue ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    CodingSystemNameSequence CodingSystemName_;
    ConceptDescriptionSequence ConceptDescription_;
    TranslationSequence Translation_;
    ::xsd::cxx::tree::one< CodeType > Code_;
    CodingSystemOptional CodingSystem_;
    CodingSystemVersionOptional CodingSystemVersion_;
    SymbolicCodeNameOptional SymbolicCodeName_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %InstanceIdentifier schema type.
   *
   * An identifier that uniquely identifies a thing or object.
   * 
   * Examples: object identifiers for medical record numbers, order ids,
   * location ids, etc. InstanceIdentifier is defined in accordance to
   * [InstanceIdentifier].
   * 
   * ./@Root and ./@Extension of an instance identifier do not identify the
   * type of the object being identified, or the type of the association
   * between the object and the identifier - they only form the identifier
   * itself. The identifier type SHALL be expressed by ./Type.
   *
   * @nosubgrouping
   */
  class InstanceIdentifier: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Type
     *
     * @brief Accessor and modifier functions for the %Type
     * optional element.
     *
     * Type designates the type of the instance identifier, e.g., whether it
     * is an MRN, license number, visit number etc.
     * 
     * Since it is possible that semantic meaning of an instance identifier
     * is comprehensively conveyed using the encompassing XML ELEMENTs, Type
     * is OPTIONAL.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue TypeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TypeOptional&
    getType () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TypeOptional&
    getType ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setType (const TypeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setType (const TypeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setType (::std::unique_ptr< TypeType > p);

    //@}

    /**
     * @name IdentifierName
     *
     * @brief Accessor and modifier functions for the %IdentifierName
     * sequence element.
     *
     * IdentifierName is a localized human-readable name for the namespace
     * represented in ./@Root.
     * 
     * NOTE?IdentifierName has no computational value and hence can never
     * modify the meaning of ./@Root. The purpose of IdentifierName is to
     * assist an unaided human interpreter of an instance identifier value to
     * interpret the identifier. Applications ought not to perform any
     * decision-making, matching, filtering or other processing based on this
     * presence or value of this property. It is for display and development
     * assistance only.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::LocalizedText IdentifierNameType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< IdentifierNameType > IdentifierNameSequence;

    /**
     * @brief Element iterator type.
     */
    typedef IdentifierNameSequence::iterator IdentifierNameIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef IdentifierNameSequence::const_iterator IdentifierNameConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdentifierNameType, char > IdentifierNameTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const IdentifierNameSequence&
    getIdentifierName () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    IdentifierNameSequence&
    getIdentifierName ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setIdentifierName (const IdentifierNameSequence& s);

    //@}

    /**
     * @name Root
     *
     * @brief Accessor and modifier functions for the %Root
     * optional attribute.
     *
     * A unique identifier that guarantees the global uniqueness of the
     * instance identifier. Root alone is allowed to build the entire
     * instance identifier.
     * 
     * If ./@Extension is present, Root is the unique identifier for the
     * "namespace" of the identifier in ./@Extension.
     * 
     * In situations where ./@Extension is known, but Root is not known, the
     * implied value of a non-existent Root SHALL match the value defined in
     * R0135. 
     * 
     * NOTE?Example: a POC MEDICAL DEVICE with an attached simple bar code
     * scanner could create a new instance identifier with an unknown root
     * and an extension that is set to the bar code number. Root is then
     * applied later in time.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::Root RootType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RootType > RootOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RootType, char > RootTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RootOptional&
    getRoot () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    RootOptional&
    getRoot ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRoot (const RootType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setRoot (const RootOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRoot (::std::unique_ptr< RootType > p);

    //@}

    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional attribute.
     *
     * A character string as a unique identifier within the scope of
     * pm:InstanceIdentifier/pm:Root.
     * If a non-null Extension exists, pm:InstanceIdentifier/pm:Root
     * specifies a namespace ("assigning authority" or "identifier type").
     * 
     * __R5008: Extension MAY be empty if pm:InstanceIdentifier/pm:Root is
     * the complete unique identifier.__
     * 
     * __R5009: If pm:InstanceIdentifier/pm:Root is not a complete unique
     * identifier and Extension is not known, then Extension SHALL be
     * populated with a null-flavor "Unknown".__
     * 
     * NOTE?How the null-flavor "Unknown" is encoded, depends on the use-case
     * and type of pm:InstanceIdentifier/pm:Root URI.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::Extension Extension1Type;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< Extension1Type > Extension1Optional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Extension1Type, char > Extension1Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const Extension1Optional&
    getExtension1 () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    Extension1Optional&
    getExtension1 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setExtension1 (const Extension1Type& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setExtension1 (const Extension1Optional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension1 (::std::unique_ptr< Extension1Type > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InstanceIdentifier ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InstanceIdentifier (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InstanceIdentifier (const InstanceIdentifier& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InstanceIdentifier*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InstanceIdentifier&
    operator= (const InstanceIdentifier& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InstanceIdentifier ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    TypeOptional Type_;
    IdentifierNameSequence IdentifierName_;
    RootOptional Root_;
    Extension1Optional Extension1_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Range schema type.
   *
   * A range of decimal values which provides a lower and an upper bound as
   * well as a step width.
   *
   * @nosubgrouping
   */
  class Range: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Lower
     *
     * @brief Accessor and modifier functions for the %Lower
     * optional attribute.
     *
     * The including lower bound of the range.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Decimal LowerType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LowerType > LowerOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerType, char, ::xsd::cxx::tree::schema_type::decimal > LowerTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LowerOptional&
    getLower () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    LowerOptional&
    getLower ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setLower (const LowerType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setLower (const LowerOptional& x);

    //@}

    /**
     * @name Upper
     *
     * @brief Accessor and modifier functions for the %Upper
     * optional attribute.
     *
     * The including upper bound of the range.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Decimal UpperType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UpperType > UpperOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpperType, char, ::xsd::cxx::tree::schema_type::decimal > UpperTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UpperOptional&
    getUpper () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    UpperOptional&
    getUpper ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setUpper (const UpperType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setUpper (const UpperOptional& x);

    //@}

    /**
     * @name StepWidth
     *
     * @brief Accessor and modifier functions for the %StepWidth
     * optional attribute.
     *
     * The numerical distance between two values in the range of the given
     * upper and lower bound.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Decimal StepWidthType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StepWidthType > StepWidthOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< StepWidthType, char, ::xsd::cxx::tree::schema_type::decimal > StepWidthTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StepWidthOptional&
    getStepWidth () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    StepWidthOptional&
    getStepWidth ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setStepWidth (const StepWidthType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setStepWidth (const StepWidthOptional& x);

    //@}

    /**
     * @name RelativeAccuracy
     *
     * @brief Accessor and modifier functions for the %RelativeAccuracy
     * optional attribute.
     *
     * Maximum relative error in relation to the correct value within the
     * given range.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Decimal RelativeAccuracyType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RelativeAccuracyType > RelativeAccuracyOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RelativeAccuracyType, char, ::xsd::cxx::tree::schema_type::decimal > RelativeAccuracyTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RelativeAccuracyOptional&
    getRelativeAccuracy () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    RelativeAccuracyOptional&
    getRelativeAccuracy ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRelativeAccuracy (const RelativeAccuracyType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setRelativeAccuracy (const RelativeAccuracyOptional& x);

    //@}

    /**
     * @name AbsoluteAccuracy
     *
     * @brief Accessor and modifier functions for the %AbsoluteAccuracy
     * optional attribute.
     *
     * Maximum absolute error in relation to the correct value within the
     * given range.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Decimal AbsoluteAccuracyType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AbsoluteAccuracyType > AbsoluteAccuracyOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< AbsoluteAccuracyType, char, ::xsd::cxx::tree::schema_type::decimal > AbsoluteAccuracyTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AbsoluteAccuracyOptional&
    getAbsoluteAccuracy () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    AbsoluteAccuracyOptional&
    getAbsoluteAccuracy ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setAbsoluteAccuracy (const AbsoluteAccuracyType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setAbsoluteAccuracy (const AbsoluteAccuracyOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Range ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Range (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Range (const Range& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Range*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Range&
    operator= (const Range& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Range ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    LowerOptional Lower_;
    UpperOptional Upper_;
    StepWidthOptional StepWidth_;
    RelativeAccuracyOptional RelativeAccuracy_;
    AbsoluteAccuracyOptional AbsoluteAccuracy_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Measurement schema type.
   *
   * Measurement describes a measurement and is used only for stateful
   * object attributes that do not have a reference to a descriptor object.
   * 
   * Example: Weight of a patient.
   *
   * @nosubgrouping
   */
  class Measurement: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name MeasurementUnit
     *
     * @brief Accessor and modifier functions for the %MeasurementUnit
     * required element.
     *
     * The unit (dimension) of pm:Measurement.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue MeasurementUnitType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MeasurementUnitType, char > MeasurementUnitTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const MeasurementUnitType&
    getMeasurementUnit () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    MeasurementUnitType&
    getMeasurementUnit ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMeasurementUnit (const MeasurementUnitType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMeasurementUnit (::std::unique_ptr< MeasurementUnitType > p);

    //@}

    /**
     * @name MeasuredValue
     *
     * @brief Accessor and modifier functions for the %MeasuredValue
     * required attribute.
     *
     * The value of pm:Measurement.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Decimal MeasuredValueType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MeasuredValueType, char, ::xsd::cxx::tree::schema_type::decimal > MeasuredValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MeasuredValueType&
    getMeasuredValue () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MeasuredValueType&
    getMeasuredValue ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMeasuredValue (const MeasuredValueType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Measurement (const MeasurementUnitType&,
                 const MeasuredValueType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    Measurement (::std::unique_ptr< MeasurementUnitType >,
                 const MeasuredValueType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Measurement (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Measurement (const Measurement& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Measurement*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Measurement&
    operator= (const Measurement& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Measurement ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< MeasurementUnitType > MeasurementUnit_;
    ::xsd::cxx::tree::one< MeasuredValueType > MeasuredValue_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %SafetyClassification
   * schema type.
   *
   * SafetyClassification allows POC MEDICAL DEVICE manufacturers to limit
   * their responsibility for the provided objects that allow informational
   * use or use in clinical functions. It reflects the quality of the
   * respective data from the risk management perspective of the data
   * provider.
   * 
   * Enumeration values prefixed with "Med" indicate that the manufacturer
   * has considered a clinical function related to the object in its
   * development process, particularly the risk management, software
   * development, usability, and verification process.
   */
  class SafetyClassification: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Inf = Informational. The descriptor and the related state information
       * are intended to be used for information purposes only. They are not
       * intended to be used in clinical functions.
       */
      Inf,
      /**
       * MedA = Medical Class A. The descriptor and related state information
       * are intended to be used in clinical functions, specifically for
       * general display in order to support patient and device monitoring. The
       * displayed data is not intended to be used as sole source for
       * diagnostic or therapeutic decisions. Deviations from this intended use
       * are in the sole responsibility of the SERVICE CONSUMER.
       */
      MedA,
      /**
       * MedB = Medical Class B. The descriptor and related state information
       * are intended to be used in clinical functions. The manufacturer has
       * specified and considered a specific intended use for the data, which
       * could result in non-serious injury. Deviations from this intended use
       * are in the sole responsibility of the SERVICE CONSUMER.
       */
      MedB,
      /**
       * MedC = Medical Class C. The descriptor and related state information
       * are intended to be used in clinical functions. The manufacturer has
       * specified and considered a specific intended use for the data, which
       * could result in serious injury. Deviations from this intended use are
       * in the sole responsibility of the SERVICE CONSUMER.
       */
      MedC
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    SafetyClassification (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    SafetyClassification (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    SafetyClassification (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    SafetyClassification (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SafetyClassification (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SafetyClassification (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SafetyClassification (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SafetyClassification (const SafetyClassification& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SafetyClassification*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    SafetyClassification&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_SafetyClassification_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_SafetyClassification_convert () const;

    public:
    static const char* const _xsd_SafetyClassification_literals_[4];
    static const Value _xsd_SafetyClassification_indexes_[4];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ComponentActivation
   * schema type.
   *
   * Activation state of a component, i.e., any type that is derived from
   * pm:AbstractComponentState and pm:AbstractMetricState.
   */
  class ComponentActivation: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * The component is operating.
       */
      On,
      /**
       * NotRdy = Not Ready. The component is not ready to be operated and not
       * operating, but initialization is ongoing.
       */
      NotRdy,
      /**
       * StndBy = Stand By. The component is ready to be operated, but not
       * currently operating.
       */
      StndBy,
      /**
       * The component is inactive.
       */
      Off,
      /**
       * Shtdn = Shutdown. The component is ceasing from being ready to be
       * operated or operating, but not yet inactive.
       */
      Shtdn,
      /**
       * Fail = Failure. The component has detected a failure and is not ready
       * to be operated.
       */
      Fail
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    ComponentActivation (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    ComponentActivation (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    ComponentActivation (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    ComponentActivation (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ComponentActivation (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ComponentActivation (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ComponentActivation (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ComponentActivation (const ComponentActivation& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ComponentActivation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    ComponentActivation&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_ComponentActivation_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_ComponentActivation_convert () const;

    public:
    static const char* const _xsd_ComponentActivation_literals_[6];
    static const Value _xsd_ComponentActivation_indexes_[6];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ApprovedJurisdictions schema type.
   *
   * List of regions in which a DEVICE COMPONENT is approved to be
   * operated. If the list does not contain any entries, then the DEVICE
   * COMPONENT is not approved for any region.
   *
   * @nosubgrouping
   */
  class ApprovedJurisdictions: public ::xml_schema::Type
  {
    public:
    /**
     * @name ApprovedJurisdiction
     *
     * @brief Accessor and modifier functions for the %ApprovedJurisdiction
     * sequence element.
     *
     * Region in which the DEVICE COMPONENT is approved to be operated.
     * 
     * NOTE?See also: https://unstats.un.org/unsd/methodology/m49/
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::InstanceIdentifier ApprovedJurisdictionType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ApprovedJurisdictionType > ApprovedJurisdictionSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ApprovedJurisdictionSequence::iterator ApprovedJurisdictionIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ApprovedJurisdictionSequence::const_iterator ApprovedJurisdictionConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ApprovedJurisdictionType, char > ApprovedJurisdictionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ApprovedJurisdictionSequence&
    getApprovedJurisdiction () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ApprovedJurisdictionSequence&
    getApprovedJurisdiction ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setApprovedJurisdiction (const ApprovedJurisdictionSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ApprovedJurisdictions ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ApprovedJurisdictions (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ApprovedJurisdictions (const ApprovedJurisdictions& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ApprovedJurisdictions*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ApprovedJurisdictions&
    operator= (const ApprovedJurisdictions& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ApprovedJurisdictions ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ApprovedJurisdictionSequence ApprovedJurisdiction_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OperatingJurisdiction schema type.
   *
   * The current region information that is configured for a component. The
   * preferred root SHOULD be https://unstats.un.org/unsd/methodology/m49,
   * which addresses the "Standard country or area codes for statistical
   * use (M49)". Example: a root of
   * "https://unstats.un.org/unsd/methodology/m49" with an extension value
   * of "276" addresses Germany.
   *
   * @nosubgrouping
   */
  class OperatingJurisdiction: public ::CDM::InstanceIdentifier
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OperatingJurisdiction ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OperatingJurisdiction (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OperatingJurisdiction (const OperatingJurisdiction& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OperatingJurisdiction*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OperatingJurisdiction ();
  };

  /**
   * @brief Class corresponding to the %Handle schema type.
   *
   * A HANDLE is used to efficiently identify an object in the MDIB.
   *
   * @nosubgrouping
   */
  class Handle: public ::xml_schema::String
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Handle ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Handle (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Handle (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Handle (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Handle (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Handle (const ::xercesc::DOMAttr& a,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Handle (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Handle (const Handle& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Handle*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Handle ();
  };

  /**
   * @brief Class corresponding to the %HandleRef schema type.
   *
   * HandleRef describes a HANDLE reference. It is used to form logical
   * connections to ELEMENTs that possess a pm:Handle ATTRIBUTE.
   * 
   * Example: a METRIC state is associated with a METRIC descriptor
   * (pm:AbstractDescriptor/@Handle) by means of an ATTRIBUTE of type
   * pm:HandleRef (see pm:AbstractState/@DescriptorHandle).
   *
   * @nosubgrouping
   */
  class HandleRef: public ::xml_schema::String
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    HandleRef ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    HandleRef (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    HandleRef (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HandleRef (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HandleRef (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HandleRef (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HandleRef (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HandleRef (const HandleRef& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HandleRef*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HandleRef ();
  };

  /**
   * @brief Class corresponding to the %PhysicalConnectorInfo schema type.
   *
   * PhysicalConnectorInfo defines a number in order to allow to guide the
   * clinical user for a failure, e.g., in case of a disconnection of a
   * sensor or an ultrasonic handpiece.
   *
   * @nosubgrouping
   */
  class PhysicalConnectorInfo: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Label
     *
     * @brief Accessor and modifier functions for the %Label
     * sequence element.
     *
     * A human-readable label that describes the physical connector.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::LocalizedText LabelType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< LabelType > LabelSequence;

    /**
     * @brief Element iterator type.
     */
    typedef LabelSequence::iterator LabelIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef LabelSequence::const_iterator LabelConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LabelType, char > LabelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const LabelSequence&
    getLabel () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    LabelSequence&
    getLabel ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setLabel (const LabelSequence& s);

    //@}

    /**
     * @name Number
     *
     * @brief Accessor and modifier functions for the %Number
     * optional attribute.
     *
     * Number designates the connector number of the physical connector.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int NumberType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NumberType > NumberOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NumberType, char > NumberTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NumberOptional&
    getNumber () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NumberOptional&
    getNumber ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setNumber (const NumberType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setNumber (const NumberOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PhysicalConnectorInfo ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PhysicalConnectorInfo (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PhysicalConnectorInfo (const PhysicalConnectorInfo& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PhysicalConnectorInfo*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PhysicalConnectorInfo&
    operator= (const PhysicalConnectorInfo& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PhysicalConnectorInfo ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    LabelSequence Label_;
    NumberOptional Number_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AbstractDescriptor schema type.
   *
   * AbstractDescriptor defines foundational meta information of any object
   * that is included in the descriptive part of the MDIB. Any descriptor
   * object is derived from pm:AbstractDescriptor. The AbstractDescriptor's
   * counterpart is pm:AbstractState.
   *
   * @nosubgrouping
   */
  class AbstractDescriptor: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Type
     *
     * @brief Accessor and modifier functions for the %Type
     * optional element.
     *
     * The descriptor type that provides specific information about the
     * descriptor instance, e.g., an pm:MdsDescriptor that designates an
     * anesthesia workstation.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue TypeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TypeOptional&
    getType () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TypeOptional&
    getType ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setType (const TypeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setType (const TypeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setType (::std::unique_ptr< TypeType > p);

    //@}

    /**
     * @name Handle
     *
     * @brief Accessor and modifier functions for the %Handle
     * required attribute.
     *
     * The unique HANDLE of the descriptor. The HANDLE can be used by
     * pm:AbstractState to reference the descriptor.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::Handle HandleType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const HandleType&
    getHandle () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    HandleType&
    getHandle ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHandle (const HandleType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHandle (::std::unique_ptr< HandleType > p);

    //@}

    /**
     * @name DescriptorVersion
     *
     * @brief Accessor and modifier functions for the %DescriptorVersion
     * optional attribute.
     *
     * DescriptorVersion is incremented by one with every descriptor
     * modification. The implied value for the initial descriptor instance
     * SHALL be "0".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::VersionCounter DescriptorVersionType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DescriptorVersionType > DescriptorVersionOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DescriptorVersionType, char > DescriptorVersionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DescriptorVersionOptional&
    getDescriptorVersion () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    DescriptorVersionOptional&
    getDescriptorVersion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDescriptorVersion (const DescriptorVersionType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setDescriptorVersion (const DescriptorVersionOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDescriptorVersion (::std::unique_ptr< DescriptorVersionType > p);

    //@}

    /**
     * @name SafetyClassification
     *
     * @brief Accessor and modifier functions for the %SafetyClassification
     * optional attribute.
     *
     * The safety classification of the data that is described with this
     * descriptor. The implied value SHALL be "Inf".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::SafetyClassification SafetyClassificationType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SafetyClassificationType > SafetyClassificationOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SafetyClassificationType, char > SafetyClassificationTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SafetyClassificationOptional&
    getSafetyClassification () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    SafetyClassificationOptional&
    getSafetyClassification ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSafetyClassification (const SafetyClassificationType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setSafetyClassification (const SafetyClassificationOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSafetyClassification (::std::unique_ptr< SafetyClassificationType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AbstractDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AbstractDescriptor (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractDescriptor (const AbstractDescriptor& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AbstractDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractDescriptor&
    operator= (const AbstractDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AbstractDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    TypeOptional Type_;
    ::xsd::cxx::tree::one< HandleType > Handle_;
    DescriptorVersionOptional DescriptorVersion_;
    SafetyClassificationOptional SafetyClassification_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AbstractState schema type.
   *
   * AbstractState defines foundational meta information of any object that
   * is included in the state part of the MDIB. Any state object is derived
   * from pm:AbstractState. The pm:AbstractState's counterpart is
   * pm:AbstractDescriptor.
   *
   * @nosubgrouping
   */
  class AbstractState: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name StateVersion
     *
     * @brief Accessor and modifier functions for the %StateVersion
     * optional attribute.
     *
     * StateVersion is incremented by one with every state modification. The
     * implied value for the initial state instance SHALL be "0".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::VersionCounter StateVersionType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StateVersionType > StateVersionOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateVersionType, char > StateVersionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StateVersionOptional&
    getStateVersion () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    StateVersionOptional&
    getStateVersion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setStateVersion (const StateVersionType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setStateVersion (const StateVersionOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStateVersion (::std::unique_ptr< StateVersionType > p);

    //@}

    /**
     * @name DescriptorHandle
     *
     * @brief Accessor and modifier functions for the %DescriptorHandle
     * required attribute.
     *
     * The HANDLE reference of a descriptor to which the state belongs.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::HandleRef DescriptorHandleType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DescriptorHandleType, char > DescriptorHandleTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const DescriptorHandleType&
    getDescriptorHandle () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    DescriptorHandleType&
    getDescriptorHandle ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDescriptorHandle (const DescriptorHandleType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDescriptorHandle (::std::unique_ptr< DescriptorHandleType > p);

    //@}

    /**
     * @name DescriptorVersion
     *
     * @brief Accessor and modifier functions for the %DescriptorVersion
     * optional attribute.
     *
     * The current version of the descriptor to that the state belongs to.
     * The implied value for the initial state instance SHALL be "0".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::ReferencedVersion DescriptorVersionType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DescriptorVersionType > DescriptorVersionOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DescriptorVersionType, char > DescriptorVersionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DescriptorVersionOptional&
    getDescriptorVersion () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    DescriptorVersionOptional&
    getDescriptorVersion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDescriptorVersion (const DescriptorVersionType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setDescriptorVersion (const DescriptorVersionOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDescriptorVersion (::std::unique_ptr< DescriptorVersionType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AbstractState (const DescriptorHandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AbstractState (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractState (const AbstractState& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AbstractState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractState&
    operator= (const AbstractState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AbstractState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    StateVersionOptional StateVersion_;
    ::xsd::cxx::tree::one< DescriptorHandleType > DescriptorHandle_;
    DescriptorVersionOptional DescriptorVersion_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AbstractMultiState schema type.
   *
   * AbstractMultiState is derived from pm:AbstractState. In contrast to
   * pm:AbstractState, AbstractMultiState possesses a HANDLE name. The
   * HANDLE name uniquely identifies the state, which is required if the
   * relation to a descriptor is ambiguous.
   *
   * @nosubgrouping
   */
  class AbstractMultiState: public ::CDM::AbstractState
  {
    public:
    /**
     * @name Category
     *
     * @brief Accessor and modifier functions for the %Category
     * optional element.
     *
     * A CODED VALUE that allows to categorize a multi state inside the set
     * of multi states that belong to a descriptor of a certain type.
     * NOTE?By using the pm:AbstractMultiState/pm:Category it is possible to
     * represent, e.g., different steps in a workflow (multiple states) with
     * different association states. This is in contrast to the
     * pm:WorkflowContextDescriptor/pm:Type where different workflow types
     * are described that the POC MEDICAL DEVICE supports. See Clause 5.2.6
     * for more details.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue CategoryType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CategoryType > CategoryOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CategoryType, char > CategoryTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CategoryOptional&
    getCategory () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CategoryOptional&
    getCategory ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCategory (const CategoryType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCategory (const CategoryOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCategory (::std::unique_ptr< CategoryType > p);

    //@}

    /**
     * @name Handle
     *
     * @brief Accessor and modifier functions for the %Handle
     * required attribute.
     *
     * A name to uniquely identify the state.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::Handle HandleType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const HandleType&
    getHandle () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    HandleType&
    getHandle ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHandle (const HandleType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHandle (::std::unique_ptr< HandleType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AbstractMultiState (const DescriptorHandleType&,
                        const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AbstractMultiState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractMultiState (const AbstractMultiState& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AbstractMultiState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractMultiState&
    operator= (const AbstractMultiState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AbstractMultiState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CategoryOptional Category_;
    ::xsd::cxx::tree::one< HandleType > Handle_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AbstractDeviceComponentDescriptor schema type.
   *
   * AbstractDeviceComponentDescriptor describes a basic DEVICE COMPONENT.
   *
   * @nosubgrouping
   */
  class AbstractDeviceComponentDescriptor: public ::CDM::AbstractDescriptor
  {
    public:
    /**
     * @name ProductionSpecification
     *
     * @brief Accessor and modifier functions for the %ProductionSpecification
     * sequence element.
     *
     * List of production specifications of the component. The production
     * specification describes ELEMENTs such as part numbers, serial numbers,
     * revisions, etc.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::ProductionSpecification ProductionSpecificationType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ProductionSpecificationType > ProductionSpecificationSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ProductionSpecificationSequence::iterator ProductionSpecificationIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ProductionSpecificationSequence::const_iterator ProductionSpecificationConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ProductionSpecificationType, char > ProductionSpecificationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ProductionSpecificationSequence&
    getProductionSpecification () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ProductionSpecificationSequence&
    getProductionSpecification ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setProductionSpecification (const ProductionSpecificationSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AbstractDeviceComponentDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AbstractDeviceComponentDescriptor (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractDeviceComponentDescriptor (const AbstractDeviceComponentDescriptor& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AbstractDeviceComponentDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractDeviceComponentDescriptor&
    operator= (const AbstractDeviceComponentDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AbstractDeviceComponentDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ProductionSpecificationSequence ProductionSpecification_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AbstractComplexDeviceComponentDescriptor schema type.
   *
   * AbstractComplexDeviceComponentDescriptor adds an OPTIONAL
   * pm:AlertSystemDescriptor and pm:ScoDescriptor to
   * pm:AbstractDeviceComponentDescriptor.
   *
   * @nosubgrouping
   */
  class AbstractComplexDeviceComponentDescriptor: public ::CDM::AbstractDeviceComponentDescriptor
  {
    public:
    /**
     * @name AlertSystem
     *
     * @brief Accessor and modifier functions for the %AlertSystem
     * optional element.
     *
     * An OPTIONAL ALERT SYSTEM that supervises conditions for all sublevels
     * in the hierarchy including the ALERT SYSTEM hosting node itself.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::AlertSystemDescriptor AlertSystemType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AlertSystemType > AlertSystemOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AlertSystemType, char > AlertSystemTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AlertSystemOptional&
    getAlertSystem () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AlertSystemOptional&
    getAlertSystem ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAlertSystem (const AlertSystemType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAlertSystem (const AlertSystemOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAlertSystem (::std::unique_ptr< AlertSystemType > p);

    //@}

    /**
     * @name Sco
     *
     * @brief Accessor and modifier functions for the %Sco
     * optional element.
     *
     * A service control object to define remote control operations. Any
     * pm:AbstractOperationDescriptor/@OperationTarget within this SCO SHALL
     * only reference this or child descriptors within the CONTAINMENT TREE.
     * 
     * NOTE?In modular systems, dynamically plugged-in modules would
     * typically be modeled as VMDs. Such VMDs potentially have their own
     * SCO. In every other case, SCO operations are modeled in
     * pm:MdsDescriptor/pm:Sco.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::ScoDescriptor ScoType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ScoType > ScoOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ScoType, char > ScoTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ScoOptional&
    getSco () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ScoOptional&
    getSco ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSco (const ScoType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSco (const ScoOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSco (::std::unique_ptr< ScoType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AbstractComplexDeviceComponentDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AbstractComplexDeviceComponentDescriptor (const ::xercesc::DOMElement& e,
                                              ::xml_schema::Flags f = 0,
                                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractComplexDeviceComponentDescriptor (const AbstractComplexDeviceComponentDescriptor& x,
                                              ::xml_schema::Flags f = 0,
                                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AbstractComplexDeviceComponentDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractComplexDeviceComponentDescriptor&
    operator= (const AbstractComplexDeviceComponentDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AbstractComplexDeviceComponentDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AlertSystemOptional AlertSystem_;
    ScoOptional Sco_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %CalibrationState
   * schema type.
   *
   * Calibration state of a component.
   */
  class CalibrationState: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * No = Not Calibrated. Defines that a component is not calibrated.
       */
      No,
      /**
       * Req = Calibration Required. Defines that a component requires a
       * calibration.
       */
      Req,
      /**
       * Run = Running. Defines that a calibration for a component is running.
       */
      Run,
      /**
       * Cal = Calibrated. Defines that a component is calibrated.
       */
      Cal,
      /**
       * Oth = Other. The calibration state is defined by other means.
       */
      Oth
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    CalibrationState (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    CalibrationState (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    CalibrationState (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    CalibrationState (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CalibrationState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CalibrationState (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CalibrationState (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CalibrationState (const CalibrationState& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CalibrationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    CalibrationState&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_CalibrationState_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_CalibrationState_convert () const;

    public:
    static const char* const _xsd_CalibrationState_literals_[5];
    static const Value _xsd_CalibrationState_indexes_[5];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %CalibrationType
   * schema type.
   *
   * Type of a calibration method.
   */
  class CalibrationType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Offset calibration.
       */
      Offset,
      /**
       * Gain calibration
       */
      Gain,
      /**
       * Two point calibration.
       */
      TP,
      /**
       * Unspecified calibration type.
       */
      Unspec
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    CalibrationType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    CalibrationType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    CalibrationType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    CalibrationType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CalibrationType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CalibrationType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CalibrationType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CalibrationType (const CalibrationType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CalibrationType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    CalibrationType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_CalibrationType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_CalibrationType_convert () const;

    public:
    static const char* const _xsd_CalibrationType_literals_[4];
    static const Value _xsd_CalibrationType_indexes_[4];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %CalibrationInfo schema type.
   *
   * Provides information in terms of component calibration. By default, it
   * only maintains a calibration flag.
   *
   * @nosubgrouping
   */
  class CalibrationInfo: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name CalibrationDocumentation
     *
     * @brief Accessor and modifier functions for the %CalibrationDocumentation
     * sequence element.
     *
     * CalibrationDocumentation provides information regarding necessary or
     * performed calibration steps including potential calibration results
     * like accuracy.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CalibrationDocumentation CalibrationDocumentationType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< CalibrationDocumentationType > CalibrationDocumentationSequence;

    /**
     * @brief Element iterator type.
     */
    typedef CalibrationDocumentationSequence::iterator CalibrationDocumentationIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef CalibrationDocumentationSequence::const_iterator CalibrationDocumentationConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CalibrationDocumentationType, char > CalibrationDocumentationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const CalibrationDocumentationSequence&
    getCalibrationDocumentation () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    CalibrationDocumentationSequence&
    getCalibrationDocumentation ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setCalibrationDocumentation (const CalibrationDocumentationSequence& s);

    //@}

    /**
     * @name ComponentCalibrationState
     *
     * @brief Accessor and modifier functions for the %ComponentCalibrationState
     * optional attribute.
     *
     * ATTRIBUTE definition of ComponentCalibration.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::CalibrationState ComponentCalibrationStateType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ComponentCalibrationStateType > ComponentCalibrationStateOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComponentCalibrationStateType, char > ComponentCalibrationStateTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ComponentCalibrationStateOptional&
    getComponentCalibrationState () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ComponentCalibrationStateOptional&
    getComponentCalibrationState ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setComponentCalibrationState (const ComponentCalibrationStateType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setComponentCalibrationState (const ComponentCalibrationStateOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setComponentCalibrationState (::std::unique_ptr< ComponentCalibrationStateType > p);

    //@}

    /**
     * @name Type
     *
     * @brief Accessor and modifier functions for the %Type
     * optional attribute.
     *
     * Type of the calibration. The implied value SHALL be "Unspec".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::CalibrationType TypeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TypeOptional&
    getType () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    TypeOptional&
    getType ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setType (const TypeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setType (const TypeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setType (::std::unique_ptr< TypeType > p);

    //@}

    /**
     * @name Time
     *
     * @brief Accessor and modifier functions for the %Time
     * optional attribute.
     *
     * Time of the calibration.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::Timestamp TimeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TimeType > TimeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeType, char > TimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TimeOptional&
    getTime () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    TimeOptional&
    getTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setTime (const TimeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setTime (const TimeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTime (::std::unique_ptr< TimeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    CalibrationInfo ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CalibrationInfo (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CalibrationInfo (const CalibrationInfo& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CalibrationInfo*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CalibrationInfo&
    operator= (const CalibrationInfo& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~CalibrationInfo ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    CalibrationDocumentationSequence CalibrationDocumentation_;
    ComponentCalibrationStateOptional ComponentCalibrationState_;
    TypeOptional Type_;
    TimeOptional Time_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AbstractDeviceComponentState schema type.
   *
   * State of a component that is part of an MDS.
   *
   * @nosubgrouping
   */
  class AbstractDeviceComponentState: public ::CDM::AbstractState
  {
    public:
    /**
     * @name CalibrationInfo
     *
     * @brief Accessor and modifier functions for the %CalibrationInfo
     * optional element.
     *
     * Provides information about the last calibration that was performed.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CalibrationInfo CalibrationInfoType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CalibrationInfoType > CalibrationInfoOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CalibrationInfoType, char > CalibrationInfoTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CalibrationInfoOptional&
    getCalibrationInfo () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CalibrationInfoOptional&
    getCalibrationInfo ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCalibrationInfo (const CalibrationInfoType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCalibrationInfo (const CalibrationInfoOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCalibrationInfo (::std::unique_ptr< CalibrationInfoType > p);

    //@}

    /**
     * @name NextCalibration
     *
     * @brief Accessor and modifier functions for the %NextCalibration
     * optional element.
     *
     * Provides information about the next calibration that will be
    performed. */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CalibrationInfo NextCalibrationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NextCalibrationType > NextCalibrationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NextCalibrationType, char > NextCalibrationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NextCalibrationOptional&
    getNextCalibration () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NextCalibrationOptional&
    getNextCalibration ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNextCalibration (const NextCalibrationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNextCalibration (const NextCalibrationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNextCalibration (::std::unique_ptr< NextCalibrationType > p);

    //@}

    /**
     * @name PhysicalConnector
     *
     * @brief Accessor and modifier functions for the %PhysicalConnector
     * optional element.
     *
     * The physical connector number for this component, see
     * pm:PhysicalConnectorInfo.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::PhysicalConnectorInfo PhysicalConnectorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PhysicalConnectorType > PhysicalConnectorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PhysicalConnectorType, char > PhysicalConnectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PhysicalConnectorOptional&
    getPhysicalConnector () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PhysicalConnectorOptional&
    getPhysicalConnector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPhysicalConnector (const PhysicalConnectorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPhysicalConnector (const PhysicalConnectorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPhysicalConnector (::std::unique_ptr< PhysicalConnectorType > p);

    //@}

    /**
     * @name ActivationState
     *
     * @brief Accessor and modifier functions for the %ActivationState
     * optional attribute.
     *
     * See pm:ComponentActivation. The implied value SHALL be "On".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::ComponentActivation ActivationStateType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ActivationStateType > ActivationStateOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ActivationStateType, char > ActivationStateTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ActivationStateOptional&
    getActivationState () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ActivationStateOptional&
    getActivationState ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setActivationState (const ActivationStateType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setActivationState (const ActivationStateOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setActivationState (::std::unique_ptr< ActivationStateType > p);

    //@}

    /**
     * @name OperatingHours
     *
     * @brief Accessor and modifier functions for the %OperatingHours
     * optional attribute.
     *
     * OPTIONAL amount of operating hours (e.g., an OR light). There are no
     * further semantics defined.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::UnsignedInt OperatingHoursType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OperatingHoursType > OperatingHoursOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< OperatingHoursType, char > OperatingHoursTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OperatingHoursOptional&
    getOperatingHours () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    OperatingHoursOptional&
    getOperatingHours ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setOperatingHours (const OperatingHoursType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setOperatingHours (const OperatingHoursOptional& x);

    //@}

    /**
     * @name OperatingCycles
     *
     * @brief Accessor and modifier functions for the %OperatingCycles
     * optional attribute.
     *
     * OPTIONAL amount of operarting cycles, e.g., the number of measurements
     * taken within the component. There are no further semantics defined.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int OperatingCyclesType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OperatingCyclesType > OperatingCyclesOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< OperatingCyclesType, char > OperatingCyclesTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OperatingCyclesOptional&
    getOperatingCycles () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    OperatingCyclesOptional&
    getOperatingCycles ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setOperatingCycles (const OperatingCyclesType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setOperatingCycles (const OperatingCyclesOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AbstractDeviceComponentState (const DescriptorHandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AbstractDeviceComponentState (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractDeviceComponentState (const AbstractDeviceComponentState& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AbstractDeviceComponentState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractDeviceComponentState&
    operator= (const AbstractDeviceComponentState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AbstractDeviceComponentState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CalibrationInfoOptional CalibrationInfo_;
    NextCalibrationOptional NextCalibration_;
    PhysicalConnectorOptional PhysicalConnector_;
    ActivationStateOptional ActivationState_;
    OperatingHoursOptional OperatingHours_;
    OperatingCyclesOptional OperatingCycles_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AbstractComplexDeviceComponentState schema type.
   *
   * AbstractComplexDeviceComponentState acts as a base class for DEVICE
   * COMPONENT states that have alerting and SCO capabilities.
   *
   * @nosubgrouping
   */
  class AbstractComplexDeviceComponentState: public ::CDM::AbstractDeviceComponentState
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AbstractComplexDeviceComponentState (const DescriptorHandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AbstractComplexDeviceComponentState (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractComplexDeviceComponentState (const AbstractComplexDeviceComponentState& x,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AbstractComplexDeviceComponentState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AbstractComplexDeviceComponentState ();
  };

  /**
   * @brief Class corresponding to the %MdsDescriptor schema type.
   *
   * MdsDescriptor represents an MDS that in turn represents a POC MEDICAL
   * DEVICE such as an anesthesia workstation. It contains an abstraction
   * of the hardware specification of a POC MEDICAL DEVICE plus a list of
   * VMDs, contextual information and clock object.
   * 
   * NOTE?The IEEE 11073-10201 has different specializations that are all
   * representable by MdsDescriptor.
   *
   * @nosubgrouping
   */
  class MdsDescriptor: public ::CDM::AbstractComplexDeviceComponentDescriptor
  {
    public:
    /**
     * @name MetaData
     *
     * @brief Accessor and modifier functions for the %MetaData
     * optional element.
     *
     * Describes POC MEDICAL DEVICE meta data.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::MetaData MetaDataType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MetaDataType > MetaDataOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MetaDataType, char > MetaDataTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MetaDataOptional&
    getMetaData () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MetaDataOptional&
    getMetaData ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMetaData (const MetaDataType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMetaData (const MetaDataOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMetaData (::std::unique_ptr< MetaDataType > p);

    //@}

    /**
     * @name SystemContext
     *
     * @brief Accessor and modifier functions for the %SystemContext
     * optional element.
     *
     * See pm:SystemContextDescriptor.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::SystemContextDescriptor SystemContextType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SystemContextType > SystemContextOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SystemContextType, char > SystemContextTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SystemContextOptional&
    getSystemContext () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SystemContextOptional&
    getSystemContext ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSystemContext (const SystemContextType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSystemContext (const SystemContextOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSystemContext (::std::unique_ptr< SystemContextType > p);

    //@}

    /**
     * @name Clock
     *
     * @brief Accessor and modifier functions for the %Clock
     * optional element.
     *
     * If supported, an MDS inserts date/time capabilities here.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::ClockDescriptor ClockType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ClockType > ClockOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ClockType, char > ClockTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ClockOptional&
    getClock () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ClockOptional&
    getClock ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setClock (const ClockType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setClock (const ClockOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setClock (::std::unique_ptr< ClockType > p);

    //@}

    /**
     * @name Battery
     *
     * @brief Accessor and modifier functions for the %Battery
     * sequence element.
     *
     * If supported, an MDS inserts battery capabilities here.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::BatteryDescriptor BatteryType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< BatteryType > BatterySequence;

    /**
     * @brief Element iterator type.
     */
    typedef BatterySequence::iterator BatteryIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef BatterySequence::const_iterator BatteryConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BatteryType, char > BatteryTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const BatterySequence&
    getBattery () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    BatterySequence&
    getBattery ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setBattery (const BatterySequence& s);

    //@}

    /**
     * @name ApprovedJurisdictions
     *
     * @brief Accessor and modifier functions for the %ApprovedJurisdictions
     * optional element.
     *
     * List of regions in which the the MDS is approved to be operated. If
     * the list does not contain any entries, then the MDS is not approved
     * for any region. If the list is not specified, then the MDS is approved
     * to be operated in any region.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::ApprovedJurisdictions ApprovedJurisdictionsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ApprovedJurisdictionsType > ApprovedJurisdictionsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ApprovedJurisdictionsType, char > ApprovedJurisdictionsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ApprovedJurisdictionsOptional&
    getApprovedJurisdictions () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ApprovedJurisdictionsOptional&
    getApprovedJurisdictions ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setApprovedJurisdictions (const ApprovedJurisdictionsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setApprovedJurisdictions (const ApprovedJurisdictionsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setApprovedJurisdictions (::std::unique_ptr< ApprovedJurisdictionsType > p);

    //@}

    /**
     * @name Vmd
     *
     * @brief Accessor and modifier functions for the %Vmd
     * sequence element.
     *
     * Ordered list of VMDs that belongs to the MDS. The list is ordered by
     * the position of the VMD in the list where the ELEMENT with a lower
     * list index has a higher clinical relevance than any entry with a
     * higher list index. The SERVICE PROVIDER defines the clinical relevance
     * and MAY reorder the list at any time.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::VmdDescriptor VmdType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< VmdType > VmdSequence;

    /**
     * @brief Element iterator type.
     */
    typedef VmdSequence::iterator VmdIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef VmdSequence::const_iterator VmdConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VmdType, char > VmdTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const VmdSequence&
    getVmd () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    VmdSequence&
    getVmd ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setVmd (const VmdSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MdsDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MdsDescriptor (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MdsDescriptor (const MdsDescriptor& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MdsDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MdsDescriptor&
    operator= (const MdsDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MdsDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MetaDataOptional MetaData_;
    SystemContextOptional SystemContext_;
    ClockOptional Clock_;
    BatterySequence Battery_;
    ApprovedJurisdictionsOptional ApprovedJurisdictions_;
    VmdSequence Vmd_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %MdsOperatingMode
   * schema type.
   *
   * MdsOperatingMode defines the interpretation constraints of the data
   * that is provided by an MDS.
   */
  class MdsOperatingMode: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Nml = Normal. The POC MEDICAL DEVICE operates in a mode that supports
       * the fulfillment of its clinical functions.
       */
      Nml,
      /**
       * Dmo = Demo. The POC MEDICAL DEVICE operates in a mode that is intended
       * for demonstration purposes only. Arbitrary values are generated.
       */
      Dmo,
      /**
       * Srv = Service. The POC MEDICAL DEVICE operates in a mode that is
       * intended for services purposes only.
       */
      Srv,
      /**
       * MTN = Maintenance. The POC MEDICAL DEVICE operates in a mode that is
       * intended for maintenance purposes only.
       */
      Mtn
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    MdsOperatingMode (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    MdsOperatingMode (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    MdsOperatingMode (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    MdsOperatingMode (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MdsOperatingMode (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MdsOperatingMode (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MdsOperatingMode (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MdsOperatingMode (const MdsOperatingMode& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MdsOperatingMode*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    MdsOperatingMode&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_MdsOperatingMode_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_MdsOperatingMode_convert () const;

    public:
    static const char* const _xsd_MdsOperatingMode_literals_[4];
    static const Value _xsd_MdsOperatingMode_indexes_[4];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MdsState schema type.
   *
   * Definition of the state of an pm:MdsDescriptor.
   *
   * @nosubgrouping
   */
  class MdsState: public ::CDM::AbstractComplexDeviceComponentState
  {
    public:
    /**
     * @name OperatingJurisdiction
     *
     * @brief Accessor and modifier functions for the %OperatingJurisdiction
     * optional element.
     *
     * The current region information that is configured for the MDS. See
     * also pm:OperatingJurisdiction. OperatingJurisdiction SHALL NOT be
     * inserted if there is no pm:MdsDescriptor/pm:ApprovedJurisdictions list
     * present.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::OperatingJurisdiction OperatingJurisdictionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OperatingJurisdictionType > OperatingJurisdictionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OperatingJurisdictionType, char > OperatingJurisdictionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OperatingJurisdictionOptional&
    getOperatingJurisdiction () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    OperatingJurisdictionOptional&
    getOperatingJurisdiction ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOperatingJurisdiction (const OperatingJurisdictionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setOperatingJurisdiction (const OperatingJurisdictionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setOperatingJurisdiction (::std::unique_ptr< OperatingJurisdictionType > p);

    //@}

    /**
     * @name Lang
     *
     * @brief Accessor and modifier functions for the %Lang
     * optional attribute.
     *
     * The current locale information that is configured for an MDS in
     * accordance with RFC 5646 (see http://tools.ietf.org/html/rfc5646). For
     * example, this is the language that is used for display purposes on the
     * UI. The implied value SHALL be "en".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Language LangType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LangType > LangOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LangType, char > LangTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LangOptional&
    getLang () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    LangOptional&
    getLang ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setLang (const LangType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setLang (const LangOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLang (::std::unique_ptr< LangType > p);

    //@}

    /**
     * @name OperatingMode
     *
     * @brief Accessor and modifier functions for the %OperatingMode
     * optional attribute.
     *
     * The operating mode of an MDS. Typically, an MDS operates in normal
     * mode, so the implied value SHALL be "Nml".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::MdsOperatingMode OperatingModeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OperatingModeType > OperatingModeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< OperatingModeType, char > OperatingModeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OperatingModeOptional&
    getOperatingMode () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    OperatingModeOptional&
    getOperatingMode ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setOperatingMode (const OperatingModeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setOperatingMode (const OperatingModeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setOperatingMode (::std::unique_ptr< OperatingModeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MdsState (const DescriptorHandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MdsState (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MdsState (const MdsState& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MdsState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MdsState&
    operator= (const MdsState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MdsState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    OperatingJurisdictionOptional OperatingJurisdiction_;
    LangOptional Lang_;
    OperatingModeOptional OperatingMode_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %VmdDescriptor schema type.
   *
   * VmdDescriptor describes a VMD. A VMD is an abstraction for a module
   * (medical-related subsystem) of an MDS. According to IEEE 11073-10201,
   * an MDS with one VMD is a single purpose POC MEDICAL DEVICE in contrast
   * to an MDS with multiple VMDs that has multiple purposes.
   * 
   * Example of a multiple purpose POC MEDICAL DEVICE: an anesthesia
   * workstation (one MDS) with a ventilation unit (one VMD), a patient
   * monitoring unit (another VMD), and gas delivery/monitor system
   * (another VMD). In the IEEE 11073-10201 a VMD might not be a hardware
   * module, it also can be pure software.
   *
   * @nosubgrouping
   */
  class VmdDescriptor: public ::CDM::AbstractComplexDeviceComponentDescriptor
  {
    public:
    /**
     * @name ApprovedJurisdictions
     *
     * @brief Accessor and modifier functions for the %ApprovedJurisdictions
     * optional element.
     *
     * List of regions in which the the VMD is approved to be operated. If
     * the list does not contain any entries, then the VMD is not approved
     * for any region. If the list is not specified, then the VMD is approved
     * to be operated in any region.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::ApprovedJurisdictions ApprovedJurisdictionsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ApprovedJurisdictionsType > ApprovedJurisdictionsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ApprovedJurisdictionsType, char > ApprovedJurisdictionsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ApprovedJurisdictionsOptional&
    getApprovedJurisdictions () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ApprovedJurisdictionsOptional&
    getApprovedJurisdictions ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setApprovedJurisdictions (const ApprovedJurisdictionsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setApprovedJurisdictions (const ApprovedJurisdictionsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setApprovedJurisdictions (::std::unique_ptr< ApprovedJurisdictionsType > p);

    //@}

    /**
     * @name Channel
     *
     * @brief Accessor and modifier functions for the %Channel
     * sequence element.
     *
     * Ordered list of CHANNELs that allow hierarchical information
     * organization of METRICs or ALERT SYSTEMs. The list is ordered by the
     * position of the CHANNEL in the list where the ELEMENT with a lower
     * list index has a higher clinical relevance than any entry with a
     * higher list index. The SERVICE PROVIDER defines the clinical relevance
     * and MAY reorder the list at any time.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::ChannelDescriptor ChannelType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ChannelType > ChannelSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ChannelSequence::iterator ChannelIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ChannelSequence::const_iterator ChannelConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ChannelType, char > ChannelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ChannelSequence&
    getChannel () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ChannelSequence&
    getChannel ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setChannel (const ChannelSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    VmdDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VmdDescriptor (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VmdDescriptor (const VmdDescriptor& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual VmdDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VmdDescriptor&
    operator= (const VmdDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~VmdDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ApprovedJurisdictionsOptional ApprovedJurisdictions_;
    ChannelSequence Channel_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %VmdState schema type.
   *
   * The state of a VMD.
   *
   * @nosubgrouping
   */
  class VmdState: public ::CDM::AbstractComplexDeviceComponentState
  {
    public:
    /**
     * @name OperatingJurisdiction
     *
     * @brief Accessor and modifier functions for the %OperatingJurisdiction
     * optional element.
     *
     * The current region information that is configured for the VMD. See
     * also pm:OperatingJurisdiction. OperatingJurisdiction SHALL NOT be
     * inserted if there is no pm:VmdDescriptor/pm:ApprovedJurisdictions list
     * present.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::OperatingJurisdiction OperatingJurisdictionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OperatingJurisdictionType > OperatingJurisdictionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OperatingJurisdictionType, char > OperatingJurisdictionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OperatingJurisdictionOptional&
    getOperatingJurisdiction () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    OperatingJurisdictionOptional&
    getOperatingJurisdiction ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOperatingJurisdiction (const OperatingJurisdictionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setOperatingJurisdiction (const OperatingJurisdictionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setOperatingJurisdiction (::std::unique_ptr< OperatingJurisdictionType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    VmdState (const DescriptorHandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VmdState (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VmdState (const VmdState& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual VmdState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VmdState&
    operator= (const VmdState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~VmdState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    OperatingJurisdictionOptional OperatingJurisdiction_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ChannelDescriptor schema type.
   *
   * ChannelDescriptor describes a CHANNEL to group METRICs and alerts. It
   * is used for organizational purposes only.
   * 
   * Example: an example would be a blood pressure VMD with one CHANNEL to
   * group together all METRICs that deal with the blood pressure (e.g.,
   * pressure value, pressure waveform). A second CHANNEL object could be
   * used to group together METRICs that deal with heart rate.
   *
   * @nosubgrouping
   */
  class ChannelDescriptor: public ::CDM::AbstractDeviceComponentDescriptor
  {
    public:
    /**
     * @name Metric
     *
     * @brief Accessor and modifier functions for the %Metric
     * sequence element.
     *
     * List of METRICs that are grouped into the CHANNEL. The list is ordered
     * by the position of the METRIC in the list where the ELEMENT with a
     * lower list index has a higher clinical relevance than any entry with a
     * higher list index. The SERVICE PROVIDER defines the clinical relevance
     * and MAY reorder the list at any time.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::AbstractMetricDescriptor MetricType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< MetricType > MetricSequence;

    /**
     * @brief Element iterator type.
     */
    typedef MetricSequence::iterator MetricIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef MetricSequence::const_iterator MetricConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MetricType, char > MetricTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const MetricSequence&
    getMetric () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    MetricSequence&
    getMetric ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setMetric (const MetricSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ChannelDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChannelDescriptor (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDescriptor (const ChannelDescriptor& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ChannelDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelDescriptor&
    operator= (const ChannelDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ChannelDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MetricSequence Metric_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ChannelState schema type.
   *
   * The state of a CHANNEL.
   *
   * @nosubgrouping
   */
  class ChannelState: public ::CDM::AbstractDeviceComponentState
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ChannelState (const DescriptorHandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChannelState (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChannelState (const ChannelState& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ChannelState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ChannelState ();
  };

  /**
   * @brief Class corresponding to the %AbstractAlertDescriptor schema type.
   *
   * AbstractAlertDescriptor acts as a base class for all alert descriptors
   * that contain static alert meta information.
   *
   * @nosubgrouping
   */
  class AbstractAlertDescriptor: public ::CDM::AbstractDescriptor
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AbstractAlertDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AbstractAlertDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractAlertDescriptor (const AbstractAlertDescriptor& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AbstractAlertDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AbstractAlertDescriptor ();
  };

  /**
   * @brief Class corresponding to the %AbstractAlertState schema type.
   *
   * AbstractAlertState acts as a base class for all alert states that
   * contain dynamic/volatile alert meta information.
   *
   * @nosubgrouping
   */
  class AbstractAlertState: public ::CDM::AbstractState
  {
    public:
    /**
     * @name ActivationState
     *
     * @brief Accessor and modifier functions for the %ActivationState
     * required attribute.
     *
     * See pm:AlertActivation.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::AlertActivation ActivationStateType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ActivationStateType, char > ActivationStateTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ActivationStateType&
    getActivationState () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ActivationStateType&
    getActivationState ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setActivationState (const ActivationStateType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setActivationState (::std::unique_ptr< ActivationStateType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AbstractAlertState (const DescriptorHandleType&,
                        const ActivationStateType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AbstractAlertState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractAlertState (const AbstractAlertState& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AbstractAlertState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractAlertState&
    operator= (const AbstractAlertState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AbstractAlertState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ActivationStateType > ActivationState_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %AlertActivation
   * schema type.
   *
   * The activation state of any ALERT SYSTEM ELEMENT, i.e.,
   * pm:AlertSystemState, pm:AlertConditionState,
   * pm:LimitAlertConditionState, and pm:AlertSignalState.
   * 
   * Special meanings MAY apply depending on the ALERT SYSTEM ELEMENT.
   */
  class AlertActivation: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * The ALERT SYSTEM ELEMENT is operating.
       */
      On,
      /**
       * The ALERT SYSTEM ELEMENT is not operating.
       */
      Off,
      /**
       * Psd = Paused. The ALERT SYSTEM ELEMENT is temporarily not operating.
       */
      Psd
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    AlertActivation (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    AlertActivation (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    AlertActivation (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    AlertActivation (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertActivation (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertActivation (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertActivation (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertActivation (const AlertActivation& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlertActivation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    AlertActivation&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_AlertActivation_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_AlertActivation_convert () const;

    public:
    static const char* const _xsd_AlertActivation_literals_[3];
    static const Value _xsd_AlertActivation_indexes_[3];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SystemSignalActivation schema type.
   *
   * Defines a tuple consisting of an pm:AlertSignalManifestation and an
   * pm:AlertActivation to describe the alert activation state of a certain
   * ALERT SIGNAL manifestation.
   * 
   * Example: ./@Manifestation is "Aud" and ./@State is "Psd" means that
   * any audible alert activation is paused.
   *
   * @nosubgrouping
   */
  class SystemSignalActivation: public ::xml_schema::Type
  {
    public:
    /**
     * @name Manifestation
     *
     * @brief Accessor and modifier functions for the %Manifestation
     * required attribute.
     *
     * See pm:AlertSignalManifestation.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::AlertSignalManifestation ManifestationType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ManifestationType, char > ManifestationTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ManifestationType&
    getManifestation () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ManifestationType&
    getManifestation ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setManifestation (const ManifestationType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setManifestation (::std::unique_ptr< ManifestationType > p);

    //@}

    /**
     * @name State
     *
     * @brief Accessor and modifier functions for the %State
     * required attribute.
     *
     * See pm:AlertActivation.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::AlertActivation StateType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const StateType&
    getState () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    StateType&
    getState ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setState (const StateType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setState (::std::unique_ptr< StateType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SystemSignalActivation (const ManifestationType&,
                            const StateType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SystemSignalActivation (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SystemSignalActivation (const SystemSignalActivation& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SystemSignalActivation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SystemSignalActivation&
    operator= (const SystemSignalActivation& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SystemSignalActivation ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ManifestationType > Manifestation_;
    ::xsd::cxx::tree::one< StateType > State_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AlertSystemDescriptor schema type.
   *
   * AlertSystemDescriptor describes an ALERT SYSTEM to detect ALERT
   * CONDITIONs and generate ALERT SIGNALs, which belong to specific ALERT
   * CONDITIONs.
   * 
   * ALERT CONDITIONs are represented by a list of
   * pm:AlertConditionDescriptor ELEMENTs and ALERT SIGNALs are represented
   * by a list of pm:AlertSignalDescriptor ELEMENTs.
   *
   * @nosubgrouping
   */
  class AlertSystemDescriptor: public ::CDM::AbstractAlertDescriptor
  {
    public:
    /**
     * @name AlertCondition
     *
     * @brief Accessor and modifier functions for the %AlertCondition
     * sequence element.
     *
     * Description of all ALERT CONDITIONs that can be detected by the
     * surrounding ALERT SYSTEM.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::AlertConditionDescriptor AlertConditionType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< AlertConditionType > AlertConditionSequence;

    /**
     * @brief Element iterator type.
     */
    typedef AlertConditionSequence::iterator AlertConditionIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef AlertConditionSequence::const_iterator AlertConditionConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AlertConditionType, char > AlertConditionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const AlertConditionSequence&
    getAlertCondition () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    AlertConditionSequence&
    getAlertCondition ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setAlertCondition (const AlertConditionSequence& s);

    //@}

    /**
     * @name AlertSignal
     *
     * @brief Accessor and modifier functions for the %AlertSignal
     * sequence element.
     *
     * Description of all ALERT SIGNALs that MAY be generated by the
     * surrounding ALERT SYSTEM as a consequence of a detected ALERT
     * CONDITIONs.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::AlertSignalDescriptor AlertSignalType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< AlertSignalType > AlertSignalSequence;

    /**
     * @brief Element iterator type.
     */
    typedef AlertSignalSequence::iterator AlertSignalIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef AlertSignalSequence::const_iterator AlertSignalConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AlertSignalType, char > AlertSignalTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const AlertSignalSequence&
    getAlertSignal () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    AlertSignalSequence&
    getAlertSignal ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setAlertSignal (const AlertSignalSequence& s);

    //@}

    /**
     * @name MaxPhysiologicalParallelAlarms
     *
     * @brief Accessor and modifier functions for the %MaxPhysiologicalParallelAlarms
     * optional attribute.
     *
     * The maximum number of physiological alarm conditions that can be
     * present at a point of time. If no value is given, an unlimited number
     * SHALL be assumed.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::UnsignedInt MaxPhysiologicalParallelAlarmsType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxPhysiologicalParallelAlarmsType > MaxPhysiologicalParallelAlarmsOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxPhysiologicalParallelAlarmsType, char > MaxPhysiologicalParallelAlarmsTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxPhysiologicalParallelAlarmsOptional&
    getMaxPhysiologicalParallelAlarms () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxPhysiologicalParallelAlarmsOptional&
    getMaxPhysiologicalParallelAlarms ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxPhysiologicalParallelAlarms (const MaxPhysiologicalParallelAlarmsType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxPhysiologicalParallelAlarms (const MaxPhysiologicalParallelAlarmsOptional& x);

    //@}

    /**
     * @name MaxTechnicalParallelAlarms
     *
     * @brief Accessor and modifier functions for the %MaxTechnicalParallelAlarms
     * optional attribute.
     *
     * The maximum number of technical alarm conditions that can be present
     * at a point of time. If no value is given, an unlimited number SHALL be
     * assumed.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::UnsignedInt MaxTechnicalParallelAlarmsType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxTechnicalParallelAlarmsType > MaxTechnicalParallelAlarmsOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxTechnicalParallelAlarmsType, char > MaxTechnicalParallelAlarmsTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxTechnicalParallelAlarmsOptional&
    getMaxTechnicalParallelAlarms () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxTechnicalParallelAlarmsOptional&
    getMaxTechnicalParallelAlarms ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxTechnicalParallelAlarms (const MaxTechnicalParallelAlarmsType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxTechnicalParallelAlarms (const MaxTechnicalParallelAlarmsOptional& x);

    //@}

    /**
     * @name SelfCheckPeriod
     *
     * @brief Accessor and modifier functions for the %SelfCheckPeriod
     * optional attribute.
     *
     * The self check time period defines the value after which a self test
     * of the ALERT SYSTEM is performed. This self check period MAY be used
     * to detect if an ALERT SYSTEM is still operating.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration SelfCheckPeriodType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SelfCheckPeriodType > SelfCheckPeriodOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SelfCheckPeriodType, char > SelfCheckPeriodTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SelfCheckPeriodOptional&
    getSelfCheckPeriod () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    SelfCheckPeriodOptional&
    getSelfCheckPeriod ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSelfCheckPeriod (const SelfCheckPeriodType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setSelfCheckPeriod (const SelfCheckPeriodOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSelfCheckPeriod (::std::unique_ptr< SelfCheckPeriodType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AlertSystemDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertSystemDescriptor (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertSystemDescriptor (const AlertSystemDescriptor& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlertSystemDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertSystemDescriptor&
    operator= (const AlertSystemDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AlertSystemDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AlertConditionSequence AlertCondition_;
    AlertSignalSequence AlertSignal_;
    MaxPhysiologicalParallelAlarmsOptional MaxPhysiologicalParallelAlarms_;
    MaxTechnicalParallelAlarmsOptional MaxTechnicalParallelAlarms_;
    SelfCheckPeriodOptional SelfCheckPeriod_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AlertSystemState schema type.
   *
   * AlertSystemState contains the dynamic/volatile information of an ALERT
   * SYSTEM. See pm:AlertSystemDescriptor for static information.
   *
   * @nosubgrouping
   */
  class AlertSystemState: public ::CDM::AbstractAlertState
  {
    public:
    /**
     * @name SystemSignalActivation
     *
     * @brief Accessor and modifier functions for the %SystemSignalActivation
     * sequence element.
     *
     * Describes a compound ALERT SIGNAL activation for local audible,
     * visible, and tangible ALERT SIGNALs within the ALERT SYSTEM.
     * 
     * If a SystemSignalActivation SSA is set for any ALERT SIGNAL
     * manifestation within an ALERT SYSTEM, then the following rules SHALL
     * apply for any local ALERT SIGNAL ASi within the ALERT SYSTEM where
     * SSA/@Manifestation is equal to ASi/@Manifestation:
     * 
     * - If SSA/@State is "On", any ASi/@ActivationState is "On", "Off", or
     * "Psd"
     * - If SSA/@State is "Psd", any ASi/@ActivationState is "Psd" or "Off"
     * - If SSA/@State is "Off", all ASi/@ActivationState are "Off"
     * - If any ASi/@ActivationState is "On" then SSA/@State is "On"
     * - If all ASi/@ActivationState are "Psd" then SSA/@State is "Psd"
     * - If all ASi/@ActivationState are "Off" then SSA/@State is "Off"
     * 
     * NOTE 1?A local ALERT SIGNAL is an ALERT SIGNAL where
     * pm:AlertSignalState/@Location is set to "Loc", whereas a remote ALERT
     * SIGNAL is an ALERT SIGNAL where pm:AlertSignalState/@Location is set
     * to "Rem".
     * NOTE 2?Remote signals are not considered by SystemSignalActivation.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::SystemSignalActivation SystemSignalActivationType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< SystemSignalActivationType > SystemSignalActivationSequence;

    /**
     * @brief Element iterator type.
     */
    typedef SystemSignalActivationSequence::iterator SystemSignalActivationIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef SystemSignalActivationSequence::const_iterator SystemSignalActivationConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SystemSignalActivationType, char > SystemSignalActivationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const SystemSignalActivationSequence&
    getSystemSignalActivation () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    SystemSignalActivationSequence&
    getSystemSignalActivation ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setSystemSignalActivation (const SystemSignalActivationSequence& s);

    //@}

    /**
     * @name LastSelfCheck
     *
     * @brief Accessor and modifier functions for the %LastSelfCheck
     * optional attribute.
     *
     * Timepoint when the ALERT SYSTEM has performed a self check the last
     * time. LastSelfCheck SHALL be updated on every
     * pm:AlertSystemDescriptor/pm:SelfCheckPeriod.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::Timestamp LastSelfCheckType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LastSelfCheckType > LastSelfCheckOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LastSelfCheckType, char > LastSelfCheckTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LastSelfCheckOptional&
    getLastSelfCheck () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    LastSelfCheckOptional&
    getLastSelfCheck ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setLastSelfCheck (const LastSelfCheckType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setLastSelfCheck (const LastSelfCheckOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLastSelfCheck (::std::unique_ptr< LastSelfCheckType > p);

    //@}

    /**
     * @name SelfCheckCount
     *
     * @brief Accessor and modifier functions for the %SelfCheckCount
     * optional attribute.
     *
     * Number of self checks performed.
     * 
     * This specification does not prescribe the origin of the value, i.e.,
     * whether the counter is incremented since the last boot or whether the
     * counter represents the self checks ever performed.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Long SelfCheckCountType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SelfCheckCountType > SelfCheckCountOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SelfCheckCountType, char > SelfCheckCountTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SelfCheckCountOptional&
    getSelfCheckCount () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    SelfCheckCountOptional&
    getSelfCheckCount ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSelfCheckCount (const SelfCheckCountType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setSelfCheckCount (const SelfCheckCountOptional& x);

    //@}

    /**
     * @name PresentPhysiologicalAlarmConditions
     *
     * @brief Accessor and modifier functions for the %PresentPhysiologicalAlarmConditions
     * optional attribute.
     *
     * List of HANDLE references to the present physiological alarm
     * conditions that have been determined by the ALERT SYSTEM.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::AlertConditionReference PresentPhysiologicalAlarmConditionsType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PresentPhysiologicalAlarmConditionsType > PresentPhysiologicalAlarmConditionsOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< PresentPhysiologicalAlarmConditionsType, char > PresentPhysiologicalAlarmConditionsTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PresentPhysiologicalAlarmConditionsOptional&
    getPresentPhysiologicalAlarmConditions () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    PresentPhysiologicalAlarmConditionsOptional&
    getPresentPhysiologicalAlarmConditions ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setPresentPhysiologicalAlarmConditions (const PresentPhysiologicalAlarmConditionsType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setPresentPhysiologicalAlarmConditions (const PresentPhysiologicalAlarmConditionsOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPresentPhysiologicalAlarmConditions (::std::unique_ptr< PresentPhysiologicalAlarmConditionsType > p);

    //@}

    /**
     * @name PresentTechnicalAlarmConditions
     *
     * @brief Accessor and modifier functions for the %PresentTechnicalAlarmConditions
     * optional attribute.
     *
     * List of HANDLE references to the present technical alarm conditions
     * that have been determined by the ALERT SYSTEM.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::AlertConditionReference PresentTechnicalAlarmConditionsType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PresentTechnicalAlarmConditionsType > PresentTechnicalAlarmConditionsOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< PresentTechnicalAlarmConditionsType, char > PresentTechnicalAlarmConditionsTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PresentTechnicalAlarmConditionsOptional&
    getPresentTechnicalAlarmConditions () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    PresentTechnicalAlarmConditionsOptional&
    getPresentTechnicalAlarmConditions ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setPresentTechnicalAlarmConditions (const PresentTechnicalAlarmConditionsType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setPresentTechnicalAlarmConditions (const PresentTechnicalAlarmConditionsOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPresentTechnicalAlarmConditions (::std::unique_ptr< PresentTechnicalAlarmConditionsType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AlertSystemState (const DescriptorHandleType&,
                      const ActivationStateType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertSystemState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertSystemState (const AlertSystemState& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlertSystemState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertSystemState&
    operator= (const AlertSystemState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AlertSystemState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SystemSignalActivationSequence SystemSignalActivation_;
    LastSelfCheckOptional LastSelfCheck_;
    SelfCheckCountOptional SelfCheckCount_;
    PresentPhysiologicalAlarmConditionsOptional PresentPhysiologicalAlarmConditions_;
    PresentTechnicalAlarmConditionsOptional PresentTechnicalAlarmConditions_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %CauseInfo schema type.
   *
   * Cause information for an ALERT CONDITION.
   *
   * @nosubgrouping
   */
  class CauseInfo: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name RemedyInfo
     *
     * @brief Accessor and modifier functions for the %RemedyInfo
     * optional element.
     *
     * OPTIONAL information on how to remedy the ALERT CONDITION.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::RemedyInfo RemedyInfoType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RemedyInfoType > RemedyInfoOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RemedyInfoType, char > RemedyInfoTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RemedyInfoOptional&
    getRemedyInfo () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RemedyInfoOptional&
    getRemedyInfo ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRemedyInfo (const RemedyInfoType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRemedyInfo (const RemedyInfoOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRemedyInfo (::std::unique_ptr< RemedyInfoType > p);

    //@}

    /**
     * @name Description
     *
     * @brief Accessor and modifier functions for the %Description
     * sequence element.
     *
     * OPTIONAL human-readable texts that describe the cause.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::LocalizedText DescriptionType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DescriptionType > DescriptionSequence;

    /**
     * @brief Element iterator type.
     */
    typedef DescriptionSequence::iterator DescriptionIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef DescriptionSequence::const_iterator DescriptionConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DescriptionType, char > DescriptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DescriptionSequence&
    getDescription () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DescriptionSequence&
    getDescription ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDescription (const DescriptionSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    CauseInfo ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CauseInfo (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CauseInfo (const CauseInfo& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CauseInfo*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CauseInfo&
    operator= (const CauseInfo& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~CauseInfo ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    RemedyInfoOptional RemedyInfo_;
    DescriptionSequence Description_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %RemedyInfo schema type.
   *
   * Remedy information for a cause of an ALERT CONDITION.
   *
   * @nosubgrouping
   */
  class RemedyInfo: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Description
     *
     * @brief Accessor and modifier functions for the %Description
     * sequence element.
     *
     * OPTIONAL human-readable texts that describe the remedy information.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::LocalizedText DescriptionType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DescriptionType > DescriptionSequence;

    /**
     * @brief Element iterator type.
     */
    typedef DescriptionSequence::iterator DescriptionIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef DescriptionSequence::const_iterator DescriptionConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DescriptionType, char > DescriptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DescriptionSequence&
    getDescription () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DescriptionSequence&
    getDescription ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDescription (const DescriptionSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RemedyInfo ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RemedyInfo (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RemedyInfo (const RemedyInfo& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RemedyInfo*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RemedyInfo&
    operator= (const RemedyInfo& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RemedyInfo ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    DescriptionSequence Description_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %AlertConditionKind
   * schema type.
   *
   * AlertConditionKind categorizes ALERT CONDITIONs by their origin.
   */
  class AlertConditionKind: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Phy = Physiological. The condition arises from a patient-related
       * variable. Examples: "blood pressure high" or "minute volume low".
       */
      Phy,
      /**
       * Tec = Technical. The condition arises from a monitored
       * equipment-related or ALERT SYSTEM-related variable. Examples: "battery
       * low" or "sensor unplugged".
       */
      Tec,
      /**
       * Oth = Other. The condition arises from another origin, e.g.,
       * equipment-user advisory conditions like "room temperature high".
       */
      Oth
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    AlertConditionKind (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    AlertConditionKind (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    AlertConditionKind (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    AlertConditionKind (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertConditionKind (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertConditionKind (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertConditionKind (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertConditionKind (const AlertConditionKind& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlertConditionKind*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    AlertConditionKind&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_AlertConditionKind_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_AlertConditionKind_convert () const;

    public:
    static const char* const _xsd_AlertConditionKind_literals_[3];
    static const Value _xsd_AlertConditionKind_indexes_[3];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %AlertConditionPriority
   * schema type.
   *
   * AlertConditionPriority categorizes ALERT CONDITIONs into priorities.
   * 
   * AlertConditionPriority can be used to distinguish the severity of the
   * potential or actual hazard that exists if an ALERT CONDITION is
   * present.
   * 
   * NOTE?The priority is assigned through risk analysis.
   */
  class AlertConditionPriority: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Lo = Low. Awareness of the ALERT CONDITION is required.
       */
      Lo,
      /**
       * Me = Medium. Prompt response to remove the ALERT CONDITION is
      required. */
      Me,
      /**
       * Hi = High. Immediate response to remove the ALERT CONDITION is
       * required.
       */
      Hi,
      /**
       * No awareness of the ALERT CONDITION is required.
       */
      None
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    AlertConditionPriority (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    AlertConditionPriority (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    AlertConditionPriority (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    AlertConditionPriority (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertConditionPriority (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertConditionPriority (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertConditionPriority (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertConditionPriority (const AlertConditionPriority& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlertConditionPriority*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    AlertConditionPriority&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_AlertConditionPriority_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_AlertConditionPriority_convert () const;

    public:
    static const char* const _xsd_AlertConditionPriority_literals_[4];
    static const Value _xsd_AlertConditionPriority_indexes_[4];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AlertConditionDescriptor schema type.
   *
   * An ALERT CONDITION contains the information about a potentially or
   * actually HAZARDOUS SITUATION. 
   * 
   * Examples: a physiological alarm limit has been exceeded or a sensor
   * has been unplugged.
   *
   * @nosubgrouping
   */
  class AlertConditionDescriptor: public ::CDM::AbstractAlertDescriptor
  {
    public:
    /**
     * @name Source
     *
     * @brief Accessor and modifier functions for the %Source
     * sequence element.
     *
     * A list of HANDLE references to sources (e.g., METRICs) that cause the
     * ALERT CONDITION.
     * 
     * Example if a source is present: the heart rate METRIC is the source
     * for a "heart rate high" ALERT CONDITION.
     * Example if no source is present: a "cable disconnection" ALERT
     * CONDITION has no source.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::HandleRef SourceType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< SourceType > SourceSequence;

    /**
     * @brief Element iterator type.
     */
    typedef SourceSequence::iterator SourceIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef SourceSequence::const_iterator SourceConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SourceType, char > SourceTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const SourceSequence&
    getSource () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    SourceSequence&
    getSource ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setSource (const SourceSequence& s);

    //@}

    /**
     * @name CauseInfo
     *
     * @brief Accessor and modifier functions for the %CauseInfo
     * sequence element.
     *
     * Information about possible causes if the ALERT CONDITION is present.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CauseInfo CauseInfoType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< CauseInfoType > CauseInfoSequence;

    /**
     * @brief Element iterator type.
     */
    typedef CauseInfoSequence::iterator CauseInfoIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef CauseInfoSequence::const_iterator CauseInfoConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CauseInfoType, char > CauseInfoTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const CauseInfoSequence&
    getCauseInfo () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    CauseInfoSequence&
    getCauseInfo ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setCauseInfo (const CauseInfoSequence& s);

    //@}

    /**
     * @name Kind
     *
     * @brief Accessor and modifier functions for the %Kind
     * required attribute.
     *
     * See pm:AlertConditionKind.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::AlertConditionKind KindType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< KindType, char > KindTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const KindType&
    getKind () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    KindType&
    getKind ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setKind (const KindType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setKind (::std::unique_ptr< KindType > p);

    //@}

    /**
     * @name Priority
     *
     * @brief Accessor and modifier functions for the %Priority
     * required attribute.
     *
     * See pm:AlertConditionPriority.
     * 
     * NOTE?If the ATTRIBUTE pm:AlertConditionState/@ActualPriority is
     * present, the priority defined for pm:AlertConditionDescriptor MAY not
     * reflect the current severity of the potential or actual hazard that
     * exists if the ALERT CONDITION is present.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::AlertConditionPriority PriorityType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< PriorityType, char > PriorityTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const PriorityType&
    getPriority () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    PriorityType&
    getPriority ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setPriority (const PriorityType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPriority (::std::unique_ptr< PriorityType > p);

    //@}

    /**
     * @name DefaultConditionGenerationDelay
     *
     * @brief Accessor and modifier functions for the %DefaultConditionGenerationDelay
     * optional attribute.
     *
     * DefaultConditionGenerationDelay is the period that describes delay
     * from the physical fullfilment of an ALERT CONDITION to the generation
     * of the ALERT CONDITION on the POC MEDICAL DEVICE. The implied value
     * SHALL be "PT0S".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration DefaultConditionGenerationDelayType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DefaultConditionGenerationDelayType > DefaultConditionGenerationDelayOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DefaultConditionGenerationDelayType, char > DefaultConditionGenerationDelayTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DefaultConditionGenerationDelayOptional&
    getDefaultConditionGenerationDelay () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    DefaultConditionGenerationDelayOptional&
    getDefaultConditionGenerationDelay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDefaultConditionGenerationDelay (const DefaultConditionGenerationDelayType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setDefaultConditionGenerationDelay (const DefaultConditionGenerationDelayOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDefaultConditionGenerationDelay (::std::unique_ptr< DefaultConditionGenerationDelayType > p);

    //@}

    /**
     * @name CanEscalate
     *
     * @brief Accessor and modifier functions for the %CanEscalate
     * optional attribute.
     *
     * Indicates if an alert condition can escalate from one priority to
     * another.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::CanEscalate CanEscalateType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CanEscalateType > CanEscalateOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< CanEscalateType, char > CanEscalateTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CanEscalateOptional&
    getCanEscalate () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    CanEscalateOptional&
    getCanEscalate ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setCanEscalate (const CanEscalateType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setCanEscalate (const CanEscalateOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCanEscalate (::std::unique_ptr< CanEscalateType > p);

    //@}

    /**
     * @name CanDeescalate
     *
     * @brief Accessor and modifier functions for the %CanDeescalate
     * optional attribute.
     *
     * Indicates if an alert condition can deescalate from one priority to
     * another.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::CanDeescalate CanDeescalateType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CanDeescalateType > CanDeescalateOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< CanDeescalateType, char > CanDeescalateTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CanDeescalateOptional&
    getCanDeescalate () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    CanDeescalateOptional&
    getCanDeescalate ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setCanDeescalate (const CanDeescalateType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setCanDeescalate (const CanDeescalateOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCanDeescalate (::std::unique_ptr< CanDeescalateType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AlertConditionDescriptor (const HandleType&,
                              const KindType&,
                              const PriorityType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertConditionDescriptor (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertConditionDescriptor (const AlertConditionDescriptor& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlertConditionDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertConditionDescriptor&
    operator= (const AlertConditionDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AlertConditionDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SourceSequence Source_;
    CauseInfoSequence CauseInfo_;
    ::xsd::cxx::tree::one< KindType > Kind_;
    ::xsd::cxx::tree::one< PriorityType > Priority_;
    DefaultConditionGenerationDelayOptional DefaultConditionGenerationDelay_;
    CanEscalateOptional CanEscalate_;
    CanDeescalateOptional CanDeescalate_;

    //@endcond
  };

  /**
   * @brief List class corresponding to the %AlertConditionReference
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   *
   * A list of HANDLE references that point to ALERT CONDITIONs.
   */
  class AlertConditionReference: public ::xml_schema::SimpleType,
    public ::xsd::cxx::tree::list< ::CDM::HandleRef, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    AlertConditionReference ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    AlertConditionReference (size_type n, const ::CDM::HandleRef& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    AlertConditionReference (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertConditionReference (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertConditionReference (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertConditionReference (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertConditionReference (const AlertConditionReference& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlertConditionReference*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~AlertConditionReference ();
  };

  /**
   * @brief Class corresponding to the %AlertConditionState schema type.
   *
   * AlertConditionState contains the dynamic/volatile information of an
   * ALERT CONDITION. See pm:AlertConditionDescriptor for static
   * information.
   *
   * @nosubgrouping
   */
  class AlertConditionState: public ::CDM::AbstractAlertState
  {
    public:
    /**
     * @name ActualConditionGenerationDelay
     *
     * @brief Accessor and modifier functions for the %ActualConditionGenerationDelay
     * optional attribute.
     *
     * ActualConditionGenerationDelay overrides
     * pm:AlertConditionDescriptor/@DefaultConditionGenerationDelay.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration ActualConditionGenerationDelayType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ActualConditionGenerationDelayType > ActualConditionGenerationDelayOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ActualConditionGenerationDelayType, char > ActualConditionGenerationDelayTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ActualConditionGenerationDelayOptional&
    getActualConditionGenerationDelay () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ActualConditionGenerationDelayOptional&
    getActualConditionGenerationDelay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setActualConditionGenerationDelay (const ActualConditionGenerationDelayType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setActualConditionGenerationDelay (const ActualConditionGenerationDelayOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setActualConditionGenerationDelay (::std::unique_ptr< ActualConditionGenerationDelayType > p);

    //@}

    /**
     * @name ActualPriority
     *
     * @brief Accessor and modifier functions for the %ActualPriority
     * optional attribute.
     *
     * The current priority of the ALERT CONDITION that has been modified by
     * an escalation or de-escalation process. 
     * 
     * NOTE?If this ATTRIBUTE is present in an pm:AlertConditonState ELEMENT,
     * the related pm:AlertConditionDescritptor/pm:Priority ELEMENT MAY NOT
     * reflect the current severity of the potential or actual hazard that
     * exists if this ALERT CONDITION is present.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::AlertConditionPriority ActualPriorityType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ActualPriorityType > ActualPriorityOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ActualPriorityType, char > ActualPriorityTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ActualPriorityOptional&
    getActualPriority () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ActualPriorityOptional&
    getActualPriority ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setActualPriority (const ActualPriorityType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setActualPriority (const ActualPriorityOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setActualPriority (::std::unique_ptr< ActualPriorityType > p);

    //@}

    /**
     * @name Rank
     *
     * @brief Accessor and modifier functions for the %Rank
     * optional attribute.
     *
     * The rank is an optional ATTRIBUTE allowing finer distinction of ALERT
     * CONDITION priorities. A ranking is a relationship between a set of
     * items such that, for any two items, the first is either "ranked higher
     * than", "ranked lower than" or "ranked equal to" the second.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int RankType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RankType > RankOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RankType, char > RankTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RankOptional&
    getRank () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    RankOptional&
    getRank ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRank (const RankType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setRank (const RankOptional& x);

    //@}

    /**
     * @name Presence
     *
     * @brief Accessor and modifier functions for the %Presence
     * optional attribute.
     *
     * The Presence ATTRIBUTE is set to "true" if the ALERT CONDITION has
     * been detected and is still present. Otherwise it is set to "false".
     * The implied value SHALL be "false".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean PresenceType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PresenceType > PresenceOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< PresenceType, char > PresenceTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PresenceOptional&
    getPresence () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    PresenceOptional&
    getPresence ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setPresence (const PresenceType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setPresence (const PresenceOptional& x);

    //@}

    /**
     * @name DeterminationTime
     *
     * @brief Accessor and modifier functions for the %DeterminationTime
     * optional attribute.
     *
     * Timepoint when the ALERT CONDITION has changed its presence the last
     * time.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::Timestamp DeterminationTimeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DeterminationTimeType > DeterminationTimeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeterminationTimeType, char > DeterminationTimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DeterminationTimeOptional&
    getDeterminationTime () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    DeterminationTimeOptional&
    getDeterminationTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDeterminationTime (const DeterminationTimeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setDeterminationTime (const DeterminationTimeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDeterminationTime (::std::unique_ptr< DeterminationTimeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AlertConditionState (const DescriptorHandleType&,
                         const ActivationStateType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertConditionState (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertConditionState (const AlertConditionState& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlertConditionState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertConditionState&
    operator= (const AlertConditionState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AlertConditionState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ActualConditionGenerationDelayOptional ActualConditionGenerationDelay_;
    ActualPriorityOptional ActualPriority_;
    RankOptional Rank_;
    PresenceOptional Presence_;
    DeterminationTimeOptional DeterminationTime_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LimitAlertConditionDescriptor schema type.
   *
   * LimitAlertConditionDescriptor is a specialization of an ALERT
   * CONDITION that is active if at least one limit for a referenced METRIC
   * has been violated.
   *
   * @nosubgrouping
   */
  class LimitAlertConditionDescriptor: public ::CDM::AlertConditionDescriptor
  {
    public:
    /**
     * @name MaxLimits
     *
     * @brief Accessor and modifier functions for the %MaxLimits
     * required element.
     *
     * The maximum possible range for the limit bounds.
     * 
     * Example: the ECG values can be measured in a specific range. At some
     * point the measured values are afflicted with noise, which makes them
     * not valid for limits. Therefore, the maximum allowed range can be
     * restricted.
     * 
     * The unit of the limits in pm:Range SHALL be the unit of the referenced
     * pm:AlertConditionDescriptor/pm:Source.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Range MaxLimitsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxLimitsType, char > MaxLimitsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const MaxLimitsType&
    getMaxLimits () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    MaxLimitsType&
    getMaxLimits ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMaxLimits (const MaxLimitsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMaxLimits (::std::unique_ptr< MaxLimitsType > p);

    //@}

    /**
     * @name AutoLimitSupported
     *
     * @brief Accessor and modifier functions for the %AutoLimitSupported
     * optional attribute.
     *
     * AutoLimitSupported indicates whether (true) or not (false) a limit
     * ALERT CONDITION provides support for automatic limit adaption. The
     * implied value SHALL be "false".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean AutoLimitSupportedType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AutoLimitSupportedType > AutoLimitSupportedOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< AutoLimitSupportedType, char > AutoLimitSupportedTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AutoLimitSupportedOptional&
    getAutoLimitSupported () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    AutoLimitSupportedOptional&
    getAutoLimitSupported ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setAutoLimitSupported (const AutoLimitSupportedType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setAutoLimitSupported (const AutoLimitSupportedOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LimitAlertConditionDescriptor (const HandleType&,
                                   const KindType&,
                                   const PriorityType&,
                                   const MaxLimitsType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    LimitAlertConditionDescriptor (const HandleType&,
                                   const KindType&,
                                   const PriorityType&,
                                   ::std::unique_ptr< MaxLimitsType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LimitAlertConditionDescriptor (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LimitAlertConditionDescriptor (const LimitAlertConditionDescriptor& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LimitAlertConditionDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LimitAlertConditionDescriptor&
    operator= (const LimitAlertConditionDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LimitAlertConditionDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< MaxLimitsType > MaxLimits_;
    AutoLimitSupportedOptional AutoLimitSupported_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %AlertConditionMonitoredLimits
   * schema type.
   *
   * Indicates which limits of a pm:LimitAlertCondition ELEMENT are
   * monitored to trigger ALERT SIGNALs.
   */
  class AlertConditionMonitoredLimits: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Both alert limits are monitored.
       */
      All,
      /**
       * LoOff = Low-Off. Low-limit violation detection is either currently
       * turned off if the state possesses a low-limit value or is not
       * supported at all.
       */
      LoOff,
      /**
       * HiOff = Hi-Off. High-limit violation detection is either currently
       * turned off if the state possesses a high-limit value or is not
       * supported at all.
       */
      HiOff,
      /**
       * No alert limits are monitored. 
       * 
       * NOTE?This flag is not equal to the activation state "Off" that
       * pm:AlertConditionState/@ActivationState provides, although the result
       * w.r.t. to alert signalization is the same.
       */
      None
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    AlertConditionMonitoredLimits (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    AlertConditionMonitoredLimits (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    AlertConditionMonitoredLimits (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    AlertConditionMonitoredLimits (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertConditionMonitoredLimits (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertConditionMonitoredLimits (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertConditionMonitoredLimits (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertConditionMonitoredLimits (const AlertConditionMonitoredLimits& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlertConditionMonitoredLimits*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    AlertConditionMonitoredLimits&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_AlertConditionMonitoredLimits_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_AlertConditionMonitoredLimits_convert () const;

    public:
    static const char* const _xsd_AlertConditionMonitoredLimits_literals_[4];
    static const Value _xsd_AlertConditionMonitoredLimits_indexes_[4];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LimitAlertConditionState schema type.
   *
   * A state of a limit ALERT CONDITION.
   *
   * @nosubgrouping
   */
  class LimitAlertConditionState: public ::CDM::AlertConditionState
  {
    public:
    /**
     * @name Limits
     *
     * @brief Accessor and modifier functions for the %Limits
     * required element.
     *
     * Limit values for the pm:LimitAlertConditionState type.
     * 
     * The unit of the limits in pm:Range SHALL be the unit of the referenced
     * pm:AlertConditionDescriptor/pm:Source.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Range LimitsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LimitsType, char > LimitsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const LimitsType&
    getLimits () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    LimitsType&
    getLimits ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLimits (const LimitsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLimits (::std::unique_ptr< LimitsType > p);

    //@}

    /**
     * @name MonitoredAlertLimits
     *
     * @brief Accessor and modifier functions for the %MonitoredAlertLimits
     * required attribute.
     *
     * Monitored alert limits of the limit ALERT CONDITION. See
     * pm:AlertConditionMonitoredLimits
     * 
     * NOTE?If the pm:AlertConditionState/@ActivationState ATTRIBUTE is not
     * set to "On", the presence of the limit ALERT CONDITION is not
     * detected. From a consumer perspective this is equivalent to the case
     * when the pm:AlertConditionState/@ActivationState ATTRIBUTE is "On" and
     * pm:AlertConditionState/@MonitoredAlertLimits is "None". The difference
     * is that in the latter case the source for the ALERT CONDITION is still
     * supervised, but the presence flag is not generated even if the limits
     * are violated.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::AlertConditionMonitoredLimits MonitoredAlertLimitsType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MonitoredAlertLimitsType, char > MonitoredAlertLimitsTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MonitoredAlertLimitsType&
    getMonitoredAlertLimits () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MonitoredAlertLimitsType&
    getMonitoredAlertLimits ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMonitoredAlertLimits (const MonitoredAlertLimitsType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMonitoredAlertLimits (::std::unique_ptr< MonitoredAlertLimitsType > p);

    //@}

    /**
     * @name AutoLimitActivationState
     *
     * @brief Accessor and modifier functions for the %AutoLimitActivationState
     * optional attribute.
     *
     * Indicates if the limits for the limit ALERT CONDITION are adjusted
     * automatically.
     * 
     * "On": limit is adjusted automatically
     * "Off": limit is not adjusted automatically
     * "Psd": limit is temporarily not adjusted automatically
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::AlertActivation AutoLimitActivationStateType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AutoLimitActivationStateType > AutoLimitActivationStateOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< AutoLimitActivationStateType, char > AutoLimitActivationStateTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AutoLimitActivationStateOptional&
    getAutoLimitActivationState () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    AutoLimitActivationStateOptional&
    getAutoLimitActivationState ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setAutoLimitActivationState (const AutoLimitActivationStateType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setAutoLimitActivationState (const AutoLimitActivationStateOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAutoLimitActivationState (::std::unique_ptr< AutoLimitActivationStateType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LimitAlertConditionState (const DescriptorHandleType&,
                              const ActivationStateType&,
                              const LimitsType&,
                              const MonitoredAlertLimitsType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    LimitAlertConditionState (const DescriptorHandleType&,
                              const ActivationStateType&,
                              ::std::unique_ptr< LimitsType >,
                              const MonitoredAlertLimitsType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LimitAlertConditionState (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LimitAlertConditionState (const LimitAlertConditionState& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LimitAlertConditionState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LimitAlertConditionState&
    operator= (const LimitAlertConditionState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LimitAlertConditionState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< LimitsType > Limits_;
    ::xsd::cxx::tree::one< MonitoredAlertLimitsType > MonitoredAlertLimits_;
    AutoLimitActivationStateOptional AutoLimitActivationState_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %AlertSignalManifestation
   * schema type.
   *
   * AlertSignalManifestation categorizes ALERT SIGNALs by the way they can
   * be recognized by the alerted human, e.g., the nurse.
   */
  class AlertSignalManifestation: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Aud = Audible. The ALERT SIGNAL manifests in an audible manner, i.e.,
       * the alert can be heard. Example: an alarm sound.
       */
      Aud,
      /**
       * Vis = Visible. The ALERT SIGNAL manifests in a visible manner, i.e.,
       * the alert can be seen. Example: a red flashing light.
       */
      Vis,
      /**
       * Tan = Tangible. The ALERT SIGNAL manifests in a tangible manner, i.e.,
       * the alert can be felt. Example: vibration.
       */
      Tan,
      /**
       * Oth = Other. The ALERT SIGNAL manifests in a manner not further
       * specified.
       */
      Oth
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    AlertSignalManifestation (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    AlertSignalManifestation (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    AlertSignalManifestation (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    AlertSignalManifestation (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertSignalManifestation (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertSignalManifestation (const ::xercesc::DOMAttr& a,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertSignalManifestation (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertSignalManifestation (const AlertSignalManifestation& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlertSignalManifestation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    AlertSignalManifestation&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_AlertSignalManifestation_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_AlertSignalManifestation_convert () const;

    public:
    static const char* const _xsd_AlertSignalManifestation_literals_[4];
    static const Value _xsd_AlertSignalManifestation_indexes_[4];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AlertSignalDescriptor schema type.
   *
   * AlertSignalDescriptor represents an ALERT SIGNAL. An ALERT SIGNAL
   * contains information about the way an ALERT CONDITION is communicated
   * to a human. It is generated by an ALERT SYSTEM to indicate the
   * presence or occurrence of an ALERT CONDITION.
   * 
   * Example: a signal could be a lamp (see
   * pm:AlertSignalDescriptor/pm:Manifestation) on a remote POC MEDICAL
   * DEVICE, such as the nurses handheld device (see
   * pm:AlertSignalDescriptor/pm:SignalDelegationSupported), which starts
   * flashing when the heart rate is exceeding 150bmp (see
   * pm:AlertSignalDescriptor/pm:ConditionSignaled) for more than 2 seconds
   * (see pm:AlertSignalDescriptor/pm:DefaultSignalGenerationDelay), and
   * keeps flashing until the nurse confirms the alarm, even if the alarm
   * condition is not present anymore (see
   * pm:AlertSignalDescriptor/pm:Latching).
   *
   * @nosubgrouping
   */
  class AlertSignalDescriptor: public ::CDM::AbstractAlertDescriptor
  {
    public:
    /**
     * @name ConditionSignaled
     *
     * @brief Accessor and modifier functions for the %ConditionSignaled
     * optional attribute.
     *
     * Reference to an ALERT CONDITION communicated by the ALERT SIGNAL. The
     * ALERT CONDITION signaled has to be in the same ALERT SYSTEM or in an
     * ALERT SYSTEM that is underneath the ALERT SYSTEM of this ALERT SIGNAL
     * in the CONTAINMENT TREE.
     * 
     * Example: assume an MDS possesses two VMDs and an ALERT SYSTEM A, and
     * each of these VMDs possess itself an ALERT SYSTEM (B and C). An ALERT
     * SIGNAL from the ALERT SYSTEM A of the MDS is allowed to reference an
     * ALERT CONDITION from the ALERT SYSTEMs A, B and C. In contrast to this
     * an ALERT SIGNAL from the ALERT SYSTEM B is allowed to reference only
     * ALERT CONDITIONs from the ALERT SYSTEM B and not from the ALERT SYSTEM
     * A or C.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::HandleRef ConditionSignaledType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ConditionSignaledType > ConditionSignaledOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ConditionSignaledType, char > ConditionSignaledTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ConditionSignaledOptional&
    getConditionSignaled () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ConditionSignaledOptional&
    getConditionSignaled ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setConditionSignaled (const ConditionSignaledType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setConditionSignaled (const ConditionSignaledOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setConditionSignaled (::std::unique_ptr< ConditionSignaledType > p);

    //@}

    /**
     * @name Manifestation
     *
     * @brief Accessor and modifier functions for the %Manifestation
     * required attribute.
     *
     * See pm:AlertSignalManifestation.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::AlertSignalManifestation ManifestationType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ManifestationType, char > ManifestationTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ManifestationType&
    getManifestation () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ManifestationType&
    getManifestation ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setManifestation (const ManifestationType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setManifestation (::std::unique_ptr< ManifestationType > p);

    //@}

    /**
     * @name Latching
     *
     * @brief Accessor and modifier functions for the %Latching
     * required attribute.
     *
     * An ALERT SIGNAL is latching if it outlives its triggering ALERT
     * CONDITION until it is stopped by deliberate action.
     * 
     * Example: if the patient's heart rate exceeds a given limit for a
     * certain time, but then normalizes such that the ALERT CONDITION no
     * longer exists, it might be desirable to keep the ALERT SIGNAL alive
     * until, e.g., the nurse confirms it. Otherwise the ALERT CONDITION
     * could pass unnoticed.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean LatchingType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LatchingType, char > LatchingTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const LatchingType&
    getLatching () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    LatchingType&
    getLatching ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setLatching (const LatchingType& x);

    //@}

    /**
     * @name DefaultSignalGenerationDelay
     *
     * @brief Accessor and modifier functions for the %DefaultSignalGenerationDelay
     * optional attribute.
     *
     * DefaultSignalGenerationDelay is the default period from the onset of
     * an ALERT CONDITION to the generation of the ALERT SIGNAL. The implied
     * value SHALL be "PT0S".
     * 
     * Example: if the heart rate exceeds a limit periodically as the actual
     * rate oscillates around the limit value, it might be desirable to not
     * directly generate the ALERT SIGNAL whenever the limit is exceeded, but
     * to wait for the given delay first.
     * 
     * In the case of a FALLBACK ALERT SIGNAL, DefaultSignalGenerationDelay
     * is the default period of time from when a PARTICIPANT last retriggered
     * the SetAlertStateOperation to the generation of the FALLBACK ALERT
     * SIGNAL.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration DefaultSignalGenerationDelayType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DefaultSignalGenerationDelayType > DefaultSignalGenerationDelayOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DefaultSignalGenerationDelayType, char > DefaultSignalGenerationDelayTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DefaultSignalGenerationDelayOptional&
    getDefaultSignalGenerationDelay () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    DefaultSignalGenerationDelayOptional&
    getDefaultSignalGenerationDelay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDefaultSignalGenerationDelay (const DefaultSignalGenerationDelayType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setDefaultSignalGenerationDelay (const DefaultSignalGenerationDelayOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDefaultSignalGenerationDelay (::std::unique_ptr< DefaultSignalGenerationDelayType > p);

    //@}

    /**
     * @name MinSignalGenerationDelay
     *
     * @brief Accessor and modifier functions for the %MinSignalGenerationDelay
     * optional attribute.
     *
     * OPTIONAL minimum delay of
     * pm:AlertSignalState/@ActualSignalGenerationDelay.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration MinSignalGenerationDelayType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MinSignalGenerationDelayType > MinSignalGenerationDelayOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MinSignalGenerationDelayType, char > MinSignalGenerationDelayTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MinSignalGenerationDelayOptional&
    getMinSignalGenerationDelay () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MinSignalGenerationDelayOptional&
    getMinSignalGenerationDelay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMinSignalGenerationDelay (const MinSignalGenerationDelayType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMinSignalGenerationDelay (const MinSignalGenerationDelayOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMinSignalGenerationDelay (::std::unique_ptr< MinSignalGenerationDelayType > p);

    //@}

    /**
     * @name MaxSignalGenerationDelay
     *
     * @brief Accessor and modifier functions for the %MaxSignalGenerationDelay
     * optional attribute.
     *
     * OPTIONAL maximum delay of
     * pm:AlertSignalState/@ActualSignalGenerationDelay.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration MaxSignalGenerationDelayType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxSignalGenerationDelayType > MaxSignalGenerationDelayOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxSignalGenerationDelayType, char > MaxSignalGenerationDelayTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxSignalGenerationDelayOptional&
    getMaxSignalGenerationDelay () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxSignalGenerationDelayOptional&
    getMaxSignalGenerationDelay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxSignalGenerationDelay (const MaxSignalGenerationDelayType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxSignalGenerationDelay (const MaxSignalGenerationDelayOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMaxSignalGenerationDelay (::std::unique_ptr< MaxSignalGenerationDelayType > p);

    //@}

    /**
     * @name SignalDelegationSupported
     *
     * @brief Accessor and modifier functions for the %SignalDelegationSupported
     * optional attribute.
     *
     * SignalDelegationSupported is set to "true" to indicate if the signal
     * can be generated at another PARTICIPANT as primary ALERT SIGNAL,
     * otherwise "false". The implied value SHALL be "false".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean SignalDelegationSupportedType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SignalDelegationSupportedType > SignalDelegationSupportedOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SignalDelegationSupportedType, char > SignalDelegationSupportedTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SignalDelegationSupportedOptional&
    getSignalDelegationSupported () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    SignalDelegationSupportedOptional&
    getSignalDelegationSupported ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSignalDelegationSupported (const SignalDelegationSupportedType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setSignalDelegationSupported (const SignalDelegationSupportedOptional& x);

    //@}

    /**
     * @name AcknowledgementSupported
     *
     * @brief Accessor and modifier functions for the %AcknowledgementSupported
     * optional attribute.
     *
     * AcknowledgementSupported is set to "true" to indicate if the ALERT
     * SIGNAL supports acknowledgment. The implied value SHALL be "false".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean AcknowledgementSupportedType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AcknowledgementSupportedType > AcknowledgementSupportedOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< AcknowledgementSupportedType, char > AcknowledgementSupportedTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AcknowledgementSupportedOptional&
    getAcknowledgementSupported () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    AcknowledgementSupportedOptional&
    getAcknowledgementSupported ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setAcknowledgementSupported (const AcknowledgementSupportedType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setAcknowledgementSupported (const AcknowledgementSupportedOptional& x);

    //@}

    /**
     * @name AcknowledgeTimeout
     *
     * @brief Accessor and modifier functions for the %AcknowledgeTimeout
     * optional attribute.
     *
     * Indicates the acknowledgment timeout if the signal supports
     * acknowledgment. If no duration is defined, an indefinite
     * acknowledgment timeout SHALL be supported.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration AcknowledgeTimeoutType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AcknowledgeTimeoutType > AcknowledgeTimeoutOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< AcknowledgeTimeoutType, char > AcknowledgeTimeoutTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AcknowledgeTimeoutOptional&
    getAcknowledgeTimeout () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    AcknowledgeTimeoutOptional&
    getAcknowledgeTimeout ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setAcknowledgeTimeout (const AcknowledgeTimeoutType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setAcknowledgeTimeout (const AcknowledgeTimeoutOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAcknowledgeTimeout (::std::unique_ptr< AcknowledgeTimeoutType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AlertSignalDescriptor (const HandleType&,
                           const ManifestationType&,
                           const LatchingType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertSignalDescriptor (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertSignalDescriptor (const AlertSignalDescriptor& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlertSignalDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertSignalDescriptor&
    operator= (const AlertSignalDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AlertSignalDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ConditionSignaledOptional ConditionSignaled_;
    ::xsd::cxx::tree::one< ManifestationType > Manifestation_;
    ::xsd::cxx::tree::one< LatchingType > Latching_;
    DefaultSignalGenerationDelayOptional DefaultSignalGenerationDelay_;
    MinSignalGenerationDelayOptional MinSignalGenerationDelay_;
    MaxSignalGenerationDelayOptional MaxSignalGenerationDelay_;
    SignalDelegationSupportedOptional SignalDelegationSupported_;
    AcknowledgementSupportedOptional AcknowledgementSupported_;
    AcknowledgeTimeoutOptional AcknowledgeTimeout_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %AlertSignalPresence
   * schema type.
   *
   * Generation state of an ALERT SIGNAL.
   */
  class AlertSignalPresence: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Indicates that an ALERT SIGNAL is currently generated.
       */
      On,
      /**
       * Indicates that an ALERT SIGNAL is currently not generated.
       */
      Off,
      /**
       * Latch = Latched. "Latched" indicates that an ALERT SIGNAL is currently
       * generated even if the ALERT CONDITION is no longer present.
       */
      Latch,
      /**
       * Ack = Acknowledged. "Acknowledged" indicates that an ALERT SIGNAL is
       * currently not generated due to an acknowledgment even if the ALERT
       * CONDITION is still present. Acknowledged signals are those, where an
       * auditory ALERT SIGNAL that is related to a currently active ALERT
       * CONDITION, is inactive until the ALERT CONDITION is no longer present.
       */
      Ack
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    AlertSignalPresence (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    AlertSignalPresence (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    AlertSignalPresence (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    AlertSignalPresence (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertSignalPresence (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertSignalPresence (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertSignalPresence (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertSignalPresence (const AlertSignalPresence& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlertSignalPresence*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    AlertSignalPresence&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_AlertSignalPresence_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_AlertSignalPresence_convert () const;

    public:
    static const char* const _xsd_AlertSignalPresence_literals_[4];
    static const Value _xsd_AlertSignalPresence_indexes_[4];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %AlertSignalPrimaryLocation
   * schema type.
   *
   * AlertSignalPrimaryLocation defines where the primary ALERT SIGNAL is
   * generated.
   */
  class AlertSignalPrimaryLocation: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Loc = Local. The ALERT SIGNAL is perceivable on the machine where the
       * ALERT CONDITION has been detected.
       */
      Loc,
      /**
       * Rem = Remote. The ALERT SIGNAL is perceivable on a remote machine.
       */
      Rem
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    AlertSignalPrimaryLocation (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    AlertSignalPrimaryLocation (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    AlertSignalPrimaryLocation (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    AlertSignalPrimaryLocation (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertSignalPrimaryLocation (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertSignalPrimaryLocation (const ::xercesc::DOMAttr& a,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertSignalPrimaryLocation (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertSignalPrimaryLocation (const AlertSignalPrimaryLocation& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlertSignalPrimaryLocation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    AlertSignalPrimaryLocation&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_AlertSignalPrimaryLocation_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_AlertSignalPrimaryLocation_convert () const;

    public:
    static const char* const _xsd_AlertSignalPrimaryLocation_literals_[2];
    static const Value _xsd_AlertSignalPrimaryLocation_indexes_[2];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AlertSignalState schema type.
   *
   * AlertSignalState contains the dynamic/volatile information of an ALERT
   * SIGNAL. See pm:AlertSignalDescriptor for static information.
   *
   * @nosubgrouping
   */
  class AlertSignalState: public ::CDM::AbstractAlertState
  {
    public:
    /**
     * @name ActualSignalGenerationDelay
     *
     * @brief Accessor and modifier functions for the %ActualSignalGenerationDelay
     * optional attribute.
     *
     * ActualSignalGenerationDelay overrides
     * pm:AlertSignalDescriptor/@DefaultSignalGenerationDelay.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration ActualSignalGenerationDelayType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ActualSignalGenerationDelayType > ActualSignalGenerationDelayOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ActualSignalGenerationDelayType, char > ActualSignalGenerationDelayTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ActualSignalGenerationDelayOptional&
    getActualSignalGenerationDelay () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ActualSignalGenerationDelayOptional&
    getActualSignalGenerationDelay ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setActualSignalGenerationDelay (const ActualSignalGenerationDelayType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setActualSignalGenerationDelay (const ActualSignalGenerationDelayOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setActualSignalGenerationDelay (::std::unique_ptr< ActualSignalGenerationDelayType > p);

    //@}

    /**
     * @name Presence
     *
     * @brief Accessor and modifier functions for the %Presence
     * optional attribute.
     *
     * See pm:AlertSignalPresence. The implied value SHALL be "Off".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::AlertSignalPresence PresenceType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PresenceType > PresenceOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< PresenceType, char > PresenceTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PresenceOptional&
    getPresence () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    PresenceOptional&
    getPresence ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setPresence (const PresenceType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setPresence (const PresenceOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPresence (::std::unique_ptr< PresenceType > p);

    //@}

    /**
     * @name Location
     *
     * @brief Accessor and modifier functions for the %Location
     * optional attribute.
     *
     * See pm:AlertSignalPrimaryLocation. The implied value SHALL be "Loc".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::AlertSignalPrimaryLocation LocationType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LocationType > LocationOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LocationType, char > LocationTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LocationOptional&
    getLocation () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    LocationOptional&
    getLocation ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setLocation (const LocationType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setLocation (const LocationOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLocation (::std::unique_ptr< LocationType > p);

    //@}

    /**
     * @name Slot
     *
     * @brief Accessor and modifier functions for the %Slot
     * optional attribute.
     *
     * The slot is a 0-based index that allows a prioritization of the ALERT
     * SIGNAL w.r.t. signal tangibility. The Slot SHOULD be used if the
     * medium for signal generation has only a limited capability of parallel
     * signal generation. The smaller the slot index, the higher is the
     * priority in generation of the signal.
     * 
     * Example: if a signal is audible and there are different audio signals
     * for different ALERT SIGNALs, and more than one ALERT SIGNAL has to be
     * generated, the generating system has to decide which of the ALERT
     * SIGNALs it generates as overlaying audio signals might not be
     * desirable. For example, if the first ALERT SIGNAL has a slot number of
     * 0 and the second ALERT SIGNAL has a slot number 1 and both signals are
     * active, than the ALERT SYSTEM generates only the ALERT SIGNAL with the
     * slot number 0.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::UnsignedInt SlotType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SlotType > SlotOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SlotType, char > SlotTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SlotOptional&
    getSlot () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    SlotOptional&
    getSlot ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSlot (const SlotType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setSlot (const SlotOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AlertSignalState (const DescriptorHandleType&,
                      const ActivationStateType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AlertSignalState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertSignalState (const AlertSignalState& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AlertSignalState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AlertSignalState&
    operator= (const AlertSignalState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AlertSignalState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ActualSignalGenerationDelayOptional ActualSignalGenerationDelay_;
    PresenceOptional Presence_;
    LocationOptional Location_;
    SlotOptional Slot_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %QualityIndicator schema type.
   *
   * Indicates the quality of a determined value, where 0 means lowest
   * quality and 1 means high quality w.r.t. to the validity level.
   *
   * @nosubgrouping
   */
  class QualityIndicator: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    QualityIndicator (const ::xml_schema::Decimal&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    QualityIndicator (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    QualityIndicator (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    QualityIndicator (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    QualityIndicator (const QualityIndicator& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual QualityIndicator*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~QualityIndicator ();
  };

  /**
   * @brief Enumeration class corresponding to the %GenerationMode
   * schema type.
   *
   * Describes whether METRIC data is generated by real measurements or
   * under unreal settings (demo or test data).
   */
  class GenerationMode: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Real = Real Data. A value that is generated under real conditions.
       */
      Real,
      /**
       * Test = Test Data. A value that is arbitrary and is for testing
       * purposes only.
       */
      Test,
      /**
       * Demo = Demo Data. A value that is arbitrary and is for demonstration
       * purposes only.
       */
      Demo
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    GenerationMode (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    GenerationMode (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    GenerationMode (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    GenerationMode (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GenerationMode (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GenerationMode (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GenerationMode (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GenerationMode (const GenerationMode& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GenerationMode*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    GenerationMode&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_GenerationMode_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_GenerationMode_convert () const;

    public:
    static const char* const _xsd_GenerationMode_literals_[3];
    static const Value _xsd_GenerationMode_indexes_[3];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AbstractMetricValue schema type.
   *
   * Abstract value of a METRIC.
   *
   * @nosubgrouping
   */
  class AbstractMetricValue: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name MetricQuality
     *
     * @brief Accessor and modifier functions for the %MetricQuality
     * required element.
     *
     * The quality state of the determined value of a METRIC.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::MetricQuality MetricQualityType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MetricQualityType, char > MetricQualityTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const MetricQualityType&
    getMetricQuality () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    MetricQualityType&
    getMetricQuality ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMetricQuality (const MetricQualityType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMetricQuality (::std::unique_ptr< MetricQualityType > p);

    //@}

    /**
     * @name Annotation
     *
     * @brief Accessor and modifier functions for the %Annotation
     * sequence element.
     *
     * Annotation of a METRIC state value.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Annotation AnnotationType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< AnnotationType > AnnotationSequence;

    /**
     * @brief Element iterator type.
     */
    typedef AnnotationSequence::iterator AnnotationIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef AnnotationSequence::const_iterator AnnotationConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const AnnotationSequence&
    getAnnotation () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    AnnotationSequence&
    getAnnotation ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setAnnotation (const AnnotationSequence& s);

    //@}

    /**
     * @name StartTime
     *
     * @brief Accessor and modifier functions for the %StartTime
     * optional attribute.
     *
     * Time when measurement activity was started.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::Timestamp StartTimeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StartTimeType > StartTimeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< StartTimeType, char > StartTimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StartTimeOptional&
    getStartTime () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    StartTimeOptional&
    getStartTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setStartTime (const StartTimeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setStartTime (const StartTimeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStartTime (::std::unique_ptr< StartTimeType > p);

    //@}

    /**
     * @name StopTime
     *
     * @brief Accessor and modifier functions for the %StopTime
     * optional attribute.
     *
     * Time when measurement activity was stopped.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::Timestamp StopTimeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StopTimeType > StopTimeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< StopTimeType, char > StopTimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StopTimeOptional&
    getStopTime () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    StopTimeOptional&
    getStopTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setStopTime (const StopTimeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setStopTime (const StopTimeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStopTime (::std::unique_ptr< StopTimeType > p);

    //@}

    /**
     * @name DeterminationTime
     *
     * @brief Accessor and modifier functions for the %DeterminationTime
     * optional attribute.
     *
     * Time when determined value has been derived from measurement.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::Timestamp DeterminationTimeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DeterminationTimeType > DeterminationTimeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeterminationTimeType, char > DeterminationTimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DeterminationTimeOptional&
    getDeterminationTime () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    DeterminationTimeOptional&
    getDeterminationTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDeterminationTime (const DeterminationTimeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setDeterminationTime (const DeterminationTimeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDeterminationTime (::std::unique_ptr< DeterminationTimeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AbstractMetricValue (const MetricQualityType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    AbstractMetricValue (::std::unique_ptr< MetricQualityType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AbstractMetricValue (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractMetricValue (const AbstractMetricValue& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AbstractMetricValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractMetricValue&
    operator= (const AbstractMetricValue& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AbstractMetricValue ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< MetricQualityType > MetricQuality_;
    AnnotationSequence Annotation_;
    StartTimeOptional StartTime_;
    StopTimeOptional StopTime_;
    DeterminationTimeOptional DeterminationTime_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %NumericMetricValue schema type.
   *
   * Numeric value of a METRIC state.
   *
   * @nosubgrouping
   */
  class NumericMetricValue: public ::CDM::AbstractMetricValue
  {
    public:
    /**
     * @name Value
     *
     * @brief Accessor and modifier functions for the %Value
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Decimal ValueType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ValueType > ValueOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char, ::xsd::cxx::tree::schema_type::decimal > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ValueOptional&
    getValue () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ValueOptional&
    getValue ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setValue (const ValueType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setValue (const ValueOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NumericMetricValue (const MetricQualityType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    NumericMetricValue (::std::unique_ptr< MetricQualityType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NumericMetricValue (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NumericMetricValue (const NumericMetricValue& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NumericMetricValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NumericMetricValue&
    operator= (const NumericMetricValue& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NumericMetricValue ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ValueOptional Value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %StringMetricValue schema type.
   *
   * String value of a METRIC state.
   *
   * @nosubgrouping
   */
  class StringMetricValue: public ::CDM::AbstractMetricValue
  {
    public:
    /**
     * @name Value
     *
     * @brief Accessor and modifier functions for the %Value
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String ValueType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ValueType > ValueOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ValueOptional&
    getValue () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ValueOptional&
    getValue ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setValue (const ValueType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setValue (const ValueOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setValue (::std::unique_ptr< ValueType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    StringMetricValue (const MetricQualityType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    StringMetricValue (::std::unique_ptr< MetricQualityType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    StringMetricValue (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    StringMetricValue (const StringMetricValue& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual StringMetricValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    StringMetricValue&
    operator= (const StringMetricValue& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~StringMetricValue ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ValueOptional Value_;

    //@endcond
  };

  /**
   * @brief List class corresponding to the %RealTimeValueType
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   *
   * Defines the real-time sample array value type comprising a whitespace
   * separated list of decimal numbers.
   */
  class RealTimeValueType: public ::xml_schema::SimpleType,
    public ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    RealTimeValueType ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    RealTimeValueType (size_type n, const ::xml_schema::Decimal& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    RealTimeValueType (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RealTimeValueType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RealTimeValueType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RealTimeValueType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RealTimeValueType (const RealTimeValueType& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RealTimeValueType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~RealTimeValueType ();
  };

  /**
   * @brief Class corresponding to the %SampleArrayValue schema type.
   *
   * Type that contains sequences of values, i.e., sample arrays.
   * 
   * The ./pmMetricQuality ELEMENT relates to all samples.
   * 
   * NOTE 1?pm:Timestamp (see base: pm:AbstractMetricValue) refers to the
   * first value of the array. The individual timestamps of the values can
   * thus be computed from the sample rate (see
   * pm:RealTimeSampleArrayMetricDescriptor).
   * NOTE 2?If ./pmMetricQuality cannot be applied to all samples due to,
   * e.g., some invalid values, a SERVICE PROVIDER can decide to set
   * ./pmMetricQuality/@Validity to "Qst" or "Inv".
   *
   * @nosubgrouping
   */
  class SampleArrayValue: public ::CDM::AbstractMetricValue
  {
    public:
    /**
     * @name ApplyAnnotation
     *
     * @brief Accessor and modifier functions for the %ApplyAnnotation
     * sequence element.
     *
     * Annotations MAY only apply to specific values in the real-time sample
     * array. The ApplyAnnotation set relates annotations to sample indices.
     * If no ApplyAnnotation ELEMENT is provided all annotations are valid
     * for all values in the context.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::ApplyAnnotation ApplyAnnotationType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ApplyAnnotationType > ApplyAnnotationSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ApplyAnnotationSequence::iterator ApplyAnnotationIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ApplyAnnotationSequence::const_iterator ApplyAnnotationConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ApplyAnnotationType, char > ApplyAnnotationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ApplyAnnotationSequence&
    getApplyAnnotation () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ApplyAnnotationSequence&
    getApplyAnnotation ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setApplyAnnotation (const ApplyAnnotationSequence& s);

    //@}

    /**
     * @name Samples
     *
     * @brief Accessor and modifier functions for the %Samples
     * optional attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::RealTimeValueType SamplesType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SamplesType > SamplesOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SamplesType, char > SamplesTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SamplesOptional&
    getSamples () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    SamplesOptional&
    getSamples ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSamples (const SamplesType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setSamples (const SamplesOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSamples (::std::unique_ptr< SamplesType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SampleArrayValue (const MetricQualityType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    SampleArrayValue (::std::unique_ptr< MetricQualityType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SampleArrayValue (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SampleArrayValue (const SampleArrayValue& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SampleArrayValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SampleArrayValue&
    operator= (const SampleArrayValue& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SampleArrayValue ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ApplyAnnotationSequence ApplyAnnotation_;
    SamplesOptional Samples_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %MetricCategory
   * schema type.
   *
   * The METRIC category makes it possible to distinguish between different
   * manifestations of a METRIC like measurements, settings or
   * recommendations. 
   * 
   * Example: if the respiratory rate can be adjusted and the ventilator is
   * smart and provides a recommendation, there are likely be at least
   * three METRICs with a type of "Respiratory Rate": 
   * 
   * - 1 METRIC with MetricCategory set to Measurement. This METRIC is the
   * actual measured value.
   * - 1 METRIC with MetricCategory set to Setting. This METRIC is the
   * adjustable value.
   * - 1 METRIC with MetricCategory set to Recommendation. This METRIC is
   * the recommended value derived from some smart algorithm.
   */
  class MetricCategory: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Unspec = Unspecified. None of the categories in MetricCategory is
       * valid for the METRIC.
       */
      Unspec,
      /**
       * Msrmt = Measurement. The METRIC has been derived by measurement.
       */
      Msrmt,
      /**
       * Clc = Calculation. The METRIC has been derived by calculation only.
       */
      Clc,
      /**
       * Set = Setting. The METRIC has a value that is adjustable by some
       * (local or remote) control means.
       */
      Set,
      /**
       * Preset = Presetting. The METRIC has a value that is adjustable by some
       * (local or remote) control means. Once the value is adjusted, it
       * remains a Preset until committed, at which point it becomes a setting.
       * 
       * Related settings MAY be defined by using
       * pm:AbstractMetricDescriptor/pm:Relation.
       */
      Preset,
      /**
       * Rcmm = Recommendation. The METRIC is a proposal for a setting or
       * presetting. The related setting or presetting MAY be defined by using
       * pm:AbstractMetricDescriptor/pm:Relation.
       */
      Rcmm
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    MetricCategory (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    MetricCategory (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    MetricCategory (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    MetricCategory (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MetricCategory (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MetricCategory (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MetricCategory (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MetricCategory (const MetricCategory& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MetricCategory*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    MetricCategory&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_MetricCategory_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_MetricCategory_convert () const;

    public:
    static const char* const _xsd_MetricCategory_literals_[6];
    static const Value _xsd_MetricCategory_indexes_[6];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %DerivationMethod
   * schema type.
   *
   * In some circumstances, e.g., in spot-check situations or when dealing
   * with settings, METRIC values might be entered manually.
   * DerivationMethod provides an enumeration to designate if a METRIC is
   * set automatically or manually.
   */
  class DerivationMethod: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Auto = Automatic derivation. The METRIC value is derived by an
       * automatic mechanism (e.g., electronically measured).
       */
      Auto,
      /**
       * Man = Manual derivation. The METRIC is derived manually by a
       * clinican/human.
       */
      Man
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    DerivationMethod (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    DerivationMethod (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    DerivationMethod (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    DerivationMethod (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DerivationMethod (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DerivationMethod (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DerivationMethod (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DerivationMethod (const DerivationMethod& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DerivationMethod*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    DerivationMethod&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_DerivationMethod_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_DerivationMethod_convert () const;

    public:
    static const char* const _xsd_DerivationMethod_literals_[2];
    static const Value _xsd_DerivationMethod_indexes_[2];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %MetricAvailability
   * schema type.
   *
   * Availability of the means that derives the METRIC state.
   */
  class MetricAvailability: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Intr = Intermittent. Stopping or ceasing for a time; alternately
       * ceasing and beginning again. 
       * 
       * Example: non-invasive blood pressure measurement.
       */
      Intr,
      /**
       * Cont = Continuous. Without break, cessation, or interruption; without
       * intervening time.
       */
      Cont
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    MetricAvailability (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    MetricAvailability (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    MetricAvailability (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    MetricAvailability (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MetricAvailability (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MetricAvailability (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MetricAvailability (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MetricAvailability (const MetricAvailability& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MetricAvailability*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    MetricAvailability&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_MetricAvailability_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_MetricAvailability_convert () const;

    public:
    static const char* const _xsd_MetricAvailability_literals_[2];
    static const Value _xsd_MetricAvailability_indexes_[2];

    //@endcond
  };

  /**
   * @brief List class corresponding to the %EntryRef
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   *
   * A list of CONTAINMENT TREE ENTRY handle references.
   */
  class EntryRef: public ::xml_schema::SimpleType,
    public ::xsd::cxx::tree::list< ::CDM::HandleRef, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    EntryRef ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    EntryRef (size_type n, const ::CDM::HandleRef& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    EntryRef (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EntryRef (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EntryRef (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EntryRef (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EntryRef (const EntryRef& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual EntryRef*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~EntryRef ();
  };

  /**
   * @brief Class corresponding to the %AbstractMetricDescriptor schema type.
   *
   * An abstract descriptor for a METRIC.
   *
   * @nosubgrouping
   */
  class AbstractMetricDescriptor: public ::CDM::AbstractDescriptor
  {
    public:
    /**
     * @name Unit
     *
     * @brief Accessor and modifier functions for the %Unit
     * required element.
     *
     * CODED VALUE for the unit of a METRIC.
     * 
     * NOTE?If the METRIC is dimensionless and has no unit, use the
     * corresponding CODE from the CODING SYSTEM (e.g., 262656 (4::512) for
     * IEEE 11073-10101 MDC_DIM_DIMLESS).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue UnitType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UnitType, char > UnitTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const UnitType&
    getUnit () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    UnitType&
    getUnit ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUnit (const UnitType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setUnit (::std::unique_ptr< UnitType > p);

    //@}

    /**
     * @name BodySite
     *
     * @brief Accessor and modifier functions for the %BodySite
     * sequence element.
     *
     * OPTIONAL list of CODED VALUEs that describe the body sites where the
     * METRIC is derived from or where it is applied to.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue BodySiteType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< BodySiteType > BodySiteSequence;

    /**
     * @brief Element iterator type.
     */
    typedef BodySiteSequence::iterator BodySiteIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef BodySiteSequence::const_iterator BodySiteConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BodySiteType, char > BodySiteTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const BodySiteSequence&
    getBodySite () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    BodySiteSequence&
    getBodySite ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setBodySite (const BodySiteSequence& s);

    //@}

    /**
     * @name Relation
     *
     * @brief Accessor and modifier functions for the %Relation
     * sequence element.
     *
     * Relation allows the modelling of relationships between a metric and
     * other containtment tree entries. Related containment tree entries are
     * defined in ./@Entries, whereby the flavor of a relationship can be set
     * up in ./@Kind.
     * 
     * The cardinality of Relation is zero or more in order to express
     * relations of different flavors for the same METRIC.
     * 
     * NOTE?Example: some settings of high frequency cutting devices cause
     * changes in measurements (e.g., current form can influences the maximum
     * emitted power). If such a setting is controllable by external means,
     * presumably the SERVICE CONSUMER wants to be able to gain knowledge of
     * affected measurements, which might be then accessed through the
     * Relation element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Relation RelationType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< RelationType > RelationSequence;

    /**
     * @brief Element iterator type.
     */
    typedef RelationSequence::iterator RelationIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef RelationSequence::const_iterator RelationConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RelationType, char > RelationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const RelationSequence&
    getRelation () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    RelationSequence&
    getRelation ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setRelation (const RelationSequence& s);

    //@}

    /**
     * @name MetricCategory
     *
     * @brief Accessor and modifier functions for the %MetricCategory
     * required attribute.
     *
     * See pm:MetricCategory.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::MetricCategory MetricCategoryType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MetricCategoryType, char > MetricCategoryTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MetricCategoryType&
    getMetricCategory () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MetricCategoryType&
    getMetricCategory ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMetricCategory (const MetricCategoryType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMetricCategory (::std::unique_ptr< MetricCategoryType > p);

    //@}

    /**
     * @name DerivationMethod
     *
     * @brief Accessor and modifier functions for the %DerivationMethod
     * optional attribute.
     *
     * See pm:DerivationMethod. The default value SHALL be applied, depending
     * on pm:AbstractDescriptor/@MetricCategory.
     * 
     * - If pm:AbstractDescriptor/@MetricCategory is "Set" or "Preset", then
     * the default value of DerivationMethod is "Man"
     * - If pm:AbstractDescriptor/@MetricCategory is "Clc", "Msrmt", "Rcmm",
     * then the default value of DerivationMethod is "Auto"
     * - If pm:AbstractDescriptor/@MetricCategory is "Unspec", then no
     * default value is being implied
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::DerivationMethod DerivationMethodType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DerivationMethodType > DerivationMethodOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DerivationMethodType, char > DerivationMethodTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DerivationMethodOptional&
    getDerivationMethod () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    DerivationMethodOptional&
    getDerivationMethod ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDerivationMethod (const DerivationMethodType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setDerivationMethod (const DerivationMethodOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDerivationMethod (::std::unique_ptr< DerivationMethodType > p);

    //@}

    /**
     * @name MetricAvailability
     *
     * @brief Accessor and modifier functions for the %MetricAvailability
     * required attribute.
     *
     * See pm:MetricAvailability.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::MetricAvailability MetricAvailabilityType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MetricAvailabilityType, char > MetricAvailabilityTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MetricAvailabilityType&
    getMetricAvailability () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MetricAvailabilityType&
    getMetricAvailability ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMetricAvailability (const MetricAvailabilityType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMetricAvailability (::std::unique_ptr< MetricAvailabilityType > p);

    //@}

    /**
     * @name MaxMeasurementTime
     *
     * @brief Accessor and modifier functions for the %MaxMeasurementTime
     * optional attribute.
     *
     * Maximum duration between start and stop time of measurment.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration MaxMeasurementTimeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxMeasurementTimeType > MaxMeasurementTimeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxMeasurementTimeType, char > MaxMeasurementTimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxMeasurementTimeOptional&
    getMaxMeasurementTime () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxMeasurementTimeOptional&
    getMaxMeasurementTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxMeasurementTime (const MaxMeasurementTimeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxMeasurementTime (const MaxMeasurementTimeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMaxMeasurementTime (::std::unique_ptr< MaxMeasurementTimeType > p);

    //@}

    /**
     * @name MaxDelayTime
     *
     * @brief Accessor and modifier functions for the %MaxDelayTime
     * optional attribute.
     *
     * Maximum delay to real time. 
     * For a measurement or calculation, the maximum delay to real time is
     * the estimated or known maximum difference between the point in time
     * when a physical variable value has been present and when the value has
     * been computed and is ready for communication. This MAY include an
     * averaging period, but it does not include the communication delay. 
     * For a setting, the maximum delay to real time is the estimated or
     * known maximum difference between the point in time when a setting has
     * been confirmed to be applicable and the time when the setting becomes
     * effective on the actuator. This does not include any communication
     * delay.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration MaxDelayTimeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxDelayTimeType > MaxDelayTimeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxDelayTimeType, char > MaxDelayTimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxDelayTimeOptional&
    getMaxDelayTime () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxDelayTimeOptional&
    getMaxDelayTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxDelayTime (const MaxDelayTimeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxDelayTime (const MaxDelayTimeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMaxDelayTime (::std::unique_ptr< MaxDelayTimeType > p);

    //@}

    /**
     * @name DeterminationPeriod
     *
     * @brief Accessor and modifier functions for the %DeterminationPeriod
     * optional attribute.
     *
     * The maximum time interval between two determination steps of
     * determined values under normal conditions.
     * 
     * - For METRICs with sample arrays as determined values where the
     * availability is not continuous, this is the period of time between two
     * determination steps, e.g., waveform snippets that are periodically
     * determined.
     * - For METRICs with sample arrays as determined values where the
     * availability is continuous, this is the period of time until the next
     * waveform frame is generated.
     * 
     * NOTE?The determination period that is defined in the descriptor, might
     * not be the currently active determination period. The active
     * determination period is part of the METRIC state.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration DeterminationPeriodType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DeterminationPeriodType > DeterminationPeriodOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeterminationPeriodType, char > DeterminationPeriodTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DeterminationPeriodOptional&
    getDeterminationPeriod () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    DeterminationPeriodOptional&
    getDeterminationPeriod ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDeterminationPeriod (const DeterminationPeriodType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setDeterminationPeriod (const DeterminationPeriodOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDeterminationPeriod (::std::unique_ptr< DeterminationPeriodType > p);

    //@}

    /**
     * @name LifeTimePeriod
     *
     * @brief Accessor and modifier functions for the %LifeTimePeriod
     * optional attribute.
     *
     * Given the timestamp of a measured METRIC value. The OPTIONAL ATTRIBUTE
     * LifeTimePeriod defines the duration after the measured METRIC value is
     * not useful anymore.
     * 
     * Example: a non-invasive blood pressure measured intermittently might
     * only be considered useful for 24 hours. Hence, LifeTimePeriod would be
     * "PT24H".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration LifeTimePeriodType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LifeTimePeriodType > LifeTimePeriodOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LifeTimePeriodType, char > LifeTimePeriodTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LifeTimePeriodOptional&
    getLifeTimePeriod () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    LifeTimePeriodOptional&
    getLifeTimePeriod ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setLifeTimePeriod (const LifeTimePeriodType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setLifeTimePeriod (const LifeTimePeriodOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLifeTimePeriod (::std::unique_ptr< LifeTimePeriodType > p);

    //@}

    /**
     * @name ActivationDuration
     *
     * @brief Accessor and modifier functions for the %ActivationDuration
     * optional attribute.
     *
     * ActivationDuration defines the maximum time period
     * pm:AbstractMetricState/@Activation is "On" before it changes to any
     * other state.
     * 
     * NOTE?ActivationDuration is used to indicate the time that a
     * measurement is performed after it has been activated. Example: if
     * automatically measured NIBP is limited to a certain time period only
     * in order to ensure that blood flow in the arm is ensured, then
     * ActivationDuration could have a value of, e.g., five minutes.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration ActivationDurationType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ActivationDurationType > ActivationDurationOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ActivationDurationType, char > ActivationDurationTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ActivationDurationOptional&
    getActivationDuration () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ActivationDurationOptional&
    getActivationDuration ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setActivationDuration (const ActivationDurationType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setActivationDuration (const ActivationDurationOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setActivationDuration (::std::unique_ptr< ActivationDurationType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AbstractMetricDescriptor (const HandleType&,
                              const UnitType&,
                              const MetricCategoryType&,
                              const MetricAvailabilityType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    AbstractMetricDescriptor (const HandleType&,
                              ::std::unique_ptr< UnitType >,
                              const MetricCategoryType&,
                              const MetricAvailabilityType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AbstractMetricDescriptor (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractMetricDescriptor (const AbstractMetricDescriptor& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AbstractMetricDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractMetricDescriptor&
    operator= (const AbstractMetricDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AbstractMetricDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< UnitType > Unit_;
    BodySiteSequence BodySite_;
    RelationSequence Relation_;
    ::xsd::cxx::tree::one< MetricCategoryType > MetricCategory_;
    DerivationMethodOptional DerivationMethod_;
    ::xsd::cxx::tree::one< MetricAvailabilityType > MetricAvailability_;
    MaxMeasurementTimeOptional MaxMeasurementTime_;
    MaxDelayTimeOptional MaxDelayTime_;
    DeterminationPeriodOptional DeterminationPeriod_;
    LifeTimePeriodOptional LifeTimePeriod_;
    ActivationDurationOptional ActivationDuration_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AbstractMetricState schema type.
   *
   * Abstract state of a METRIC.
   *
   * @nosubgrouping
   */
  class AbstractMetricState: public ::CDM::AbstractState
  {
    public:
    /**
     * @name BodySite
     *
     * @brief Accessor and modifier functions for the %BodySite
     * sequence element.
     *
     * OPTIONAL list of CODED VALUEs that describe the body sites where the
     * measurement is performed or where the setting is applied to.
     * This list of body sites MAY provide more details to location of the
     * measurement or setting that are be available at runtime only or that
     * changes at runtime of the POC MEDICAL DEVICE. It SHOULD NOT contradict
     * the location that has been listed in the descriptor.
     * 
     * Example: if in the descriptor the location "Upper Abdomen" is defined,
     * than the state's body site give more details to where the measurement
     * is performed like "Upper Right Quadrant" and "Liver".
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue BodySiteType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< BodySiteType > BodySiteSequence;

    /**
     * @brief Element iterator type.
     */
    typedef BodySiteSequence::iterator BodySiteIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef BodySiteSequence::const_iterator BodySiteConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BodySiteType, char > BodySiteTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const BodySiteSequence&
    getBodySite () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    BodySiteSequence&
    getBodySite ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setBodySite (const BodySiteSequence& s);

    //@}

    /**
     * @name PhysicalConnector
     *
     * @brief Accessor and modifier functions for the %PhysicalConnector
     * optional element.
     *
     * The physical connector number for this METRIC, see
     * pm:PhysicalConnectorInfo.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::PhysicalConnectorInfo PhysicalConnectorType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PhysicalConnectorType > PhysicalConnectorOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PhysicalConnectorType, char > PhysicalConnectorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PhysicalConnectorOptional&
    getPhysicalConnector () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PhysicalConnectorOptional&
    getPhysicalConnector ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPhysicalConnector (const PhysicalConnectorType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPhysicalConnector (const PhysicalConnectorOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPhysicalConnector (::std::unique_ptr< PhysicalConnectorType > p);

    //@}

    /**
     * @name ActivationState
     *
     * @brief Accessor and modifier functions for the %ActivationState
     * optional attribute.
     *
     * The activation state of a METRIC. The implied value SHALL be "On".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::ComponentActivation ActivationStateType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ActivationStateType > ActivationStateOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ActivationStateType, char > ActivationStateTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ActivationStateOptional&
    getActivationState () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ActivationStateOptional&
    getActivationState ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setActivationState (const ActivationStateType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setActivationState (const ActivationStateOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setActivationState (::std::unique_ptr< ActivationStateType > p);

    //@}

    /**
     * @name ActiveDeterminationPeriod
     *
     * @brief Accessor and modifier functions for the %ActiveDeterminationPeriod
     * optional attribute.
     *
     * OPTIONAL information of the currently active determination repetition
     * time if it is different from the default determination time that is
     * defined in the descriptive part. ActiveDeterminationPeriod is not
     * necessarily the same as the update period of the periodic event
     * service.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration ActiveDeterminationPeriodType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ActiveDeterminationPeriodType > ActiveDeterminationPeriodOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ActiveDeterminationPeriodType, char > ActiveDeterminationPeriodTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ActiveDeterminationPeriodOptional&
    getActiveDeterminationPeriod () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ActiveDeterminationPeriodOptional&
    getActiveDeterminationPeriod ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setActiveDeterminationPeriod (const ActiveDeterminationPeriodType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setActiveDeterminationPeriod (const ActiveDeterminationPeriodOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setActiveDeterminationPeriod (::std::unique_ptr< ActiveDeterminationPeriodType > p);

    //@}

    /**
     * @name LifeTimePeriod
     *
     * @brief Accessor and modifier functions for the %LifeTimePeriod
     * optional attribute.
     *
     * OPTIONAL currently active life-time period that supersedes
     * pm:AbstractMetricDescriptor/@LifeTimePeriod.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration LifeTimePeriodType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LifeTimePeriodType > LifeTimePeriodOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LifeTimePeriodType, char > LifeTimePeriodTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LifeTimePeriodOptional&
    getLifeTimePeriod () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    LifeTimePeriodOptional&
    getLifeTimePeriod ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setLifeTimePeriod (const LifeTimePeriodType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setLifeTimePeriod (const LifeTimePeriodOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLifeTimePeriod (::std::unique_ptr< LifeTimePeriodType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AbstractMetricState (const DescriptorHandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AbstractMetricState (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractMetricState (const AbstractMetricState& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AbstractMetricState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractMetricState&
    operator= (const AbstractMetricState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AbstractMetricState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    BodySiteSequence BodySite_;
    PhysicalConnectorOptional PhysicalConnector_;
    ActivationStateOptional ActivationState_;
    ActiveDeterminationPeriodOptional ActiveDeterminationPeriod_;
    LifeTimePeriodOptional LifeTimePeriod_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %NumericMetricDescriptor schema type.
   *
   * Specification of a METRIC descriptor type that represents a single
   * numerical measurement and status information. Example: a heart rate
   * measurement.
   *
   * @nosubgrouping
   */
  class NumericMetricDescriptor: public ::CDM::AbstractMetricDescriptor
  {
    public:
    /**
     * @name TechnicalRange
     *
     * @brief Accessor and modifier functions for the %TechnicalRange
     * sequence element.
     *
     * The technical possible range of determined values.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Range TechnicalRangeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TechnicalRangeType > TechnicalRangeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef TechnicalRangeSequence::iterator TechnicalRangeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef TechnicalRangeSequence::const_iterator TechnicalRangeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TechnicalRangeType, char > TechnicalRangeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TechnicalRangeSequence&
    getTechnicalRange () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TechnicalRangeSequence&
    getTechnicalRange ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTechnicalRange (const TechnicalRangeSequence& s);

    //@}

    /**
     * @name Resolution
     *
     * @brief Accessor and modifier functions for the %Resolution
     * required attribute.
     *
     * The resolution of the means to determine the METRIC's value. The
     * resolution is the minimum determinable difference between two
     * determined values.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Decimal ResolutionType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ResolutionType, char, ::xsd::cxx::tree::schema_type::decimal > ResolutionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ResolutionType&
    getResolution () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ResolutionType&
    getResolution ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setResolution (const ResolutionType& x);

    //@}

    /**
     * @name AveragingPeriod
     *
     * @brief Accessor and modifier functions for the %AveragingPeriod
     * optional attribute.
     *
     * Timespan from where the measured values are used to determine the
     * METRIC's value by averaging with some algorithm.
     * 
     * NOTE?The averaging period defined in the descriptor might be not the
     * currently active averaging period. The active averaging period is part
     * of pm:NumericMetricState.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration AveragingPeriodType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AveragingPeriodType > AveragingPeriodOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< AveragingPeriodType, char > AveragingPeriodTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AveragingPeriodOptional&
    getAveragingPeriod () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    AveragingPeriodOptional&
    getAveragingPeriod ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setAveragingPeriod (const AveragingPeriodType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setAveragingPeriod (const AveragingPeriodOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAveragingPeriod (::std::unique_ptr< AveragingPeriodType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NumericMetricDescriptor (const HandleType&,
                             const UnitType&,
                             const MetricCategoryType&,
                             const MetricAvailabilityType&,
                             const ResolutionType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    NumericMetricDescriptor (const HandleType&,
                             ::std::unique_ptr< UnitType >,
                             const MetricCategoryType&,
                             const MetricAvailabilityType&,
                             const ResolutionType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NumericMetricDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NumericMetricDescriptor (const NumericMetricDescriptor& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NumericMetricDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NumericMetricDescriptor&
    operator= (const NumericMetricDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NumericMetricDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TechnicalRangeSequence TechnicalRange_;
    ::xsd::cxx::tree::one< ResolutionType > Resolution_;
    AveragingPeriodOptional AveragingPeriod_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %NumericMetricState schema type.
   *
   * State of a numeric METRIC.
   *
   * @nosubgrouping
   */
  class NumericMetricState: public ::CDM::AbstractMetricState
  {
    public:
    /**
     * @name MetricValue
     *
     * @brief Accessor and modifier functions for the %MetricValue
     * optional element.
     *
     * OPTIONAL current value of the METRIC.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::NumericMetricValue MetricValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MetricValueType > MetricValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MetricValueType, char > MetricValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MetricValueOptional&
    getMetricValue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MetricValueOptional&
    getMetricValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMetricValue (const MetricValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMetricValue (const MetricValueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMetricValue (::std::unique_ptr< MetricValueType > p);

    //@}

    /**
     * @name PhysiologicalRange
     *
     * @brief Accessor and modifier functions for the %PhysiologicalRange
     * sequence element.
     *
     * The physiological reasonable range of determined values.
     * 
     * NOTE?This is not an alarming range.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Range PhysiologicalRangeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< PhysiologicalRangeType > PhysiologicalRangeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef PhysiologicalRangeSequence::iterator PhysiologicalRangeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef PhysiologicalRangeSequence::const_iterator PhysiologicalRangeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PhysiologicalRangeType, char > PhysiologicalRangeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const PhysiologicalRangeSequence&
    getPhysiologicalRange () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    PhysiologicalRangeSequence&
    getPhysiologicalRange ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setPhysiologicalRange (const PhysiologicalRangeSequence& s);

    //@}

    /**
     * @name ActiveAveragingPeriod
     *
     * @brief Accessor and modifier functions for the %ActiveAveragingPeriod
     * optional attribute.
     *
     * OPTIONAL information of the currently active time period used to
     * average values if it is different from the default value that is
     * defined in the descriptor.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration ActiveAveragingPeriodType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ActiveAveragingPeriodType > ActiveAveragingPeriodOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ActiveAveragingPeriodType, char > ActiveAveragingPeriodTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ActiveAveragingPeriodOptional&
    getActiveAveragingPeriod () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ActiveAveragingPeriodOptional&
    getActiveAveragingPeriod ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setActiveAveragingPeriod (const ActiveAveragingPeriodType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setActiveAveragingPeriod (const ActiveAveragingPeriodOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setActiveAveragingPeriod (::std::unique_ptr< ActiveAveragingPeriodType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NumericMetricState (const DescriptorHandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NumericMetricState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NumericMetricState (const NumericMetricState& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NumericMetricState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NumericMetricState&
    operator= (const NumericMetricState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NumericMetricState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MetricValueOptional MetricValue_;
    PhysiologicalRangeSequence PhysiologicalRange_;
    ActiveAveragingPeriodOptional ActiveAveragingPeriod_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %StringMetricDescriptor schema type.
   *
   * A string METRIC represents a textual status or annotation information.
   *
   * @nosubgrouping
   */
  class StringMetricDescriptor: public ::CDM::AbstractMetricDescriptor
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    StringMetricDescriptor (const HandleType&,
                            const UnitType&,
                            const MetricCategoryType&,
                            const MetricAvailabilityType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    StringMetricDescriptor (const HandleType&,
                            ::std::unique_ptr< UnitType >,
                            const MetricCategoryType&,
                            const MetricAvailabilityType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    StringMetricDescriptor (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    StringMetricDescriptor (const StringMetricDescriptor& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual StringMetricDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~StringMetricDescriptor ();
  };

  /**
   * @brief Class corresponding to the %StringMetricState schema type.
   *
   * State of a string METRIC.
   *
   * @nosubgrouping
   */
  class StringMetricState: public ::CDM::AbstractMetricState
  {
    public:
    /**
     * @name MetricValue
     *
     * @brief Accessor and modifier functions for the %MetricValue
     * optional element.
     *
     * OPTIONAL current value of the METRIC.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::StringMetricValue MetricValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MetricValueType > MetricValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MetricValueType, char > MetricValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MetricValueOptional&
    getMetricValue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MetricValueOptional&
    getMetricValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMetricValue (const MetricValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMetricValue (const MetricValueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMetricValue (::std::unique_ptr< MetricValueType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    StringMetricState (const DescriptorHandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    StringMetricState (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    StringMetricState (const StringMetricState& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual StringMetricState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    StringMetricState&
    operator= (const StringMetricState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~StringMetricState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MetricValueOptional MetricValue_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %EnumStringMetricDescriptor schema type.
   *
   * An enumerated string METRIC represents a textual status or annotation
   * information with a constrained set of possible values.
   * 
   * Example: a ventilation mode.
   *
   * @nosubgrouping
   */
  class EnumStringMetricDescriptor: public ::CDM::StringMetricDescriptor
  {
    public:
    /**
     * @name AllowedValue
     *
     * @brief Accessor and modifier functions for the %AllowedValue
     * sequence element.
     *
     * List of values that the enumerated string METRIC accepts as a valid
     * value.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::AllowedValue AllowedValueType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< AllowedValueType > AllowedValueSequence;

    /**
     * @brief Element iterator type.
     */
    typedef AllowedValueSequence::iterator AllowedValueIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef AllowedValueSequence::const_iterator AllowedValueConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AllowedValueType, char > AllowedValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const AllowedValueSequence&
    getAllowedValue () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    AllowedValueSequence&
    getAllowedValue ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setAllowedValue (const AllowedValueSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    EnumStringMetricDescriptor (const HandleType&,
                                const UnitType&,
                                const MetricCategoryType&,
                                const MetricAvailabilityType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    EnumStringMetricDescriptor (const HandleType&,
                                ::std::unique_ptr< UnitType >,
                                const MetricCategoryType&,
                                const MetricAvailabilityType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EnumStringMetricDescriptor (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EnumStringMetricDescriptor (const EnumStringMetricDescriptor& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual EnumStringMetricDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EnumStringMetricDescriptor&
    operator= (const EnumStringMetricDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~EnumStringMetricDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AllowedValueSequence AllowedValue_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %EnumStringMetricState schema type.
   *
   * State of an enumerated string METRIC.
   *
   * @nosubgrouping
   */
  class EnumStringMetricState: public ::CDM::StringMetricState
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    EnumStringMetricState (const DescriptorHandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EnumStringMetricState (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EnumStringMetricState (const EnumStringMetricState& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual EnumStringMetricState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~EnumStringMetricState ();
  };

  /**
   * @brief Class corresponding to the %RealTimeSampleArrayMetricDescriptor schema type.
   *
   * Declares a sample array that represents a real-time continuous
   * waveform. An example would be an electrocardiogram (ECG) real-time
   * wave.
   *
   * @nosubgrouping
   */
  class RealTimeSampleArrayMetricDescriptor: public ::CDM::AbstractMetricDescriptor
  {
    public:
    /**
     * @name TechnicalRange
     *
     * @brief Accessor and modifier functions for the %TechnicalRange
     * sequence element.
     *
     * The maximum range of the values of the real-time sample array.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Range TechnicalRangeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TechnicalRangeType > TechnicalRangeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef TechnicalRangeSequence::iterator TechnicalRangeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef TechnicalRangeSequence::const_iterator TechnicalRangeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TechnicalRangeType, char > TechnicalRangeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TechnicalRangeSequence&
    getTechnicalRange () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TechnicalRangeSequence&
    getTechnicalRange ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTechnicalRange (const TechnicalRangeSequence& s);

    //@}

    /**
     * @name Resolution
     *
     * @brief Accessor and modifier functions for the %Resolution
     * required attribute.
     *
     * The resolution of the means to determine the METRIC's value. The
     * Resolution is the minimum determinable difference between two
     * determined values.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Decimal ResolutionType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ResolutionType, char, ::xsd::cxx::tree::schema_type::decimal > ResolutionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ResolutionType&
    getResolution () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ResolutionType&
    getResolution ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setResolution (const ResolutionType& x);

    //@}

    /**
     * @name SamplePeriod
     *
     * @brief Accessor and modifier functions for the %SamplePeriod
     * required attribute.
     *
     * The sample period of the real-time sample array, i.e., how often
     * waveform samples are generated. SamplePeriod is always given as a
     * period between samples, e.g., 5 milliseconds.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration SamplePeriodType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SamplePeriodType, char > SamplePeriodTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const SamplePeriodType&
    getSamplePeriod () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    SamplePeriodType&
    getSamplePeriod ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSamplePeriod (const SamplePeriodType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSamplePeriod (::std::unique_ptr< SamplePeriodType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RealTimeSampleArrayMetricDescriptor (const HandleType&,
                                         const UnitType&,
                                         const MetricCategoryType&,
                                         const MetricAvailabilityType&,
                                         const ResolutionType&,
                                         const SamplePeriodType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    RealTimeSampleArrayMetricDescriptor (const HandleType&,
                                         ::std::unique_ptr< UnitType >,
                                         const MetricCategoryType&,
                                         const MetricAvailabilityType&,
                                         const ResolutionType&,
                                         const SamplePeriodType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RealTimeSampleArrayMetricDescriptor (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RealTimeSampleArrayMetricDescriptor (const RealTimeSampleArrayMetricDescriptor& x,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RealTimeSampleArrayMetricDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RealTimeSampleArrayMetricDescriptor&
    operator= (const RealTimeSampleArrayMetricDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RealTimeSampleArrayMetricDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TechnicalRangeSequence TechnicalRange_;
    ::xsd::cxx::tree::one< ResolutionType > Resolution_;
    ::xsd::cxx::tree::one< SamplePeriodType > SamplePeriod_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %RealTimeSampleArrayMetricState schema type.
   *
   * State of a stream METRIC descriptor. It contains a list of sample
   * values. This sample array is used to transport waveform stream
   * information.
   *
   * @nosubgrouping
   */
  class RealTimeSampleArrayMetricState: public ::CDM::AbstractMetricState
  {
    public:
    /**
     * @name MetricValue
     *
     * @brief Accessor and modifier functions for the %MetricValue
     * optional element.
     *
     * OPTIONAL current value of the METRIC.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::SampleArrayValue MetricValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MetricValueType > MetricValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MetricValueType, char > MetricValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MetricValueOptional&
    getMetricValue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MetricValueOptional&
    getMetricValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMetricValue (const MetricValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMetricValue (const MetricValueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMetricValue (::std::unique_ptr< MetricValueType > p);

    //@}

    /**
     * @name PhysiologicalRange
     *
     * @brief Accessor and modifier functions for the %PhysiologicalRange
     * sequence element.
     *
     * The physiological reasonable range of determined values.
     * 
     * NOTE?This is not an alarming range.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Range PhysiologicalRangeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< PhysiologicalRangeType > PhysiologicalRangeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef PhysiologicalRangeSequence::iterator PhysiologicalRangeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef PhysiologicalRangeSequence::const_iterator PhysiologicalRangeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PhysiologicalRangeType, char > PhysiologicalRangeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const PhysiologicalRangeSequence&
    getPhysiologicalRange () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    PhysiologicalRangeSequence&
    getPhysiologicalRange ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setPhysiologicalRange (const PhysiologicalRangeSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RealTimeSampleArrayMetricState (const DescriptorHandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RealTimeSampleArrayMetricState (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RealTimeSampleArrayMetricState (const RealTimeSampleArrayMetricState& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RealTimeSampleArrayMetricState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RealTimeSampleArrayMetricState&
    operator= (const RealTimeSampleArrayMetricState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RealTimeSampleArrayMetricState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MetricValueOptional MetricValue_;
    PhysiologicalRangeSequence PhysiologicalRange_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DistributionSampleArrayMetricDescriptor schema type.
   *
   * Declares a sample array that represents linear value distributions in
   * the form of arrays containing scaled sample values. In contrast to
   * real-time sample arrays, distribution sample arrays provide observed
   * spatial values, not time points.
   * 
   * NOTE?An example for a distribution sample array metric might be a
   * fourier-transformed electroencephalogram to derive frequency
   * distribution.
   *
   * @nosubgrouping
   */
  class DistributionSampleArrayMetricDescriptor: public ::CDM::AbstractMetricDescriptor
  {
    public:
    /**
     * @name TechnicalRange
     *
     * @brief Accessor and modifier functions for the %TechnicalRange
     * sequence element.
     *
     * The maximum range of the values of the distribution sample array.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Range TechnicalRangeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TechnicalRangeType > TechnicalRangeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef TechnicalRangeSequence::iterator TechnicalRangeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef TechnicalRangeSequence::const_iterator TechnicalRangeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TechnicalRangeType, char > TechnicalRangeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TechnicalRangeSequence&
    getTechnicalRange () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TechnicalRangeSequence&
    getTechnicalRange ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTechnicalRange (const TechnicalRangeSequence& s);

    //@}

    /**
     * @name DomainUnit
     *
     * @brief Accessor and modifier functions for the %DomainUnit
     * required element.
     *
     * The CODED VALUE that is used for domain values (x axis).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue DomainUnitType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DomainUnitType, char > DomainUnitTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DomainUnitType&
    getDomainUnit () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DomainUnitType&
    getDomainUnit ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDomainUnit (const DomainUnitType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDomainUnit (::std::unique_ptr< DomainUnitType > p);

    //@}

    /**
     * @name DistributionRange
     *
     * @brief Accessor and modifier functions for the %DistributionRange
     * required element.
     *
     * Minimum and maximum domain values. A linear scale is assumed unless a
     * step width is given.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Range DistributionRangeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DistributionRangeType, char > DistributionRangeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DistributionRangeType&
    getDistributionRange () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DistributionRangeType&
    getDistributionRange ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDistributionRange (const DistributionRangeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDistributionRange (::std::unique_ptr< DistributionRangeType > p);

    //@}

    /**
     * @name Resolution
     *
     * @brief Accessor and modifier functions for the %Resolution
     * required attribute.
     *
     * The resolution of the means to determine the METRIC's value.
     * Resolution is the minimum determinable difference between two
     * determined values.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Decimal ResolutionType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ResolutionType, char, ::xsd::cxx::tree::schema_type::decimal > ResolutionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ResolutionType&
    getResolution () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ResolutionType&
    getResolution ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setResolution (const ResolutionType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DistributionSampleArrayMetricDescriptor (const HandleType&,
                                             const UnitType&,
                                             const MetricCategoryType&,
                                             const MetricAvailabilityType&,
                                             const DomainUnitType&,
                                             const DistributionRangeType&,
                                             const ResolutionType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    DistributionSampleArrayMetricDescriptor (const HandleType&,
                                             ::std::unique_ptr< UnitType >,
                                             const MetricCategoryType&,
                                             const MetricAvailabilityType&,
                                             ::std::unique_ptr< DomainUnitType >,
                                             ::std::unique_ptr< DistributionRangeType >,
                                             const ResolutionType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DistributionSampleArrayMetricDescriptor (const ::xercesc::DOMElement& e,
                                             ::xml_schema::Flags f = 0,
                                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DistributionSampleArrayMetricDescriptor (const DistributionSampleArrayMetricDescriptor& x,
                                             ::xml_schema::Flags f = 0,
                                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DistributionSampleArrayMetricDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DistributionSampleArrayMetricDescriptor&
    operator= (const DistributionSampleArrayMetricDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DistributionSampleArrayMetricDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TechnicalRangeSequence TechnicalRange_;
    ::xsd::cxx::tree::one< DomainUnitType > DomainUnit_;
    ::xsd::cxx::tree::one< DistributionRangeType > DistributionRange_;
    ::xsd::cxx::tree::one< ResolutionType > Resolution_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DistributionSampleArrayMetricState schema type.
   *
   * State of a distribution sample array METRIC descriptor. It contains a
   * list of sample values. This sample array is used to transport spatial
   * range information.
   *
   * @nosubgrouping
   */
  class DistributionSampleArrayMetricState: public ::CDM::AbstractMetricState
  {
    public:
    /**
     * @name MetricValue
     *
     * @brief Accessor and modifier functions for the %MetricValue
     * optional element.
     *
     * OPTIONAL current value of the METRIC.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::SampleArrayValue MetricValueType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MetricValueType > MetricValueOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MetricValueType, char > MetricValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MetricValueOptional&
    getMetricValue () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MetricValueOptional&
    getMetricValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMetricValue (const MetricValueType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMetricValue (const MetricValueOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMetricValue (::std::unique_ptr< MetricValueType > p);

    //@}

    /**
     * @name PhysiologicalRange
     *
     * @brief Accessor and modifier functions for the %PhysiologicalRange
     * sequence element.
     *
     * The physiological reasonable range of determined values.
     * 
     * NOTE?This is not an alarming range.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Range PhysiologicalRangeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< PhysiologicalRangeType > PhysiologicalRangeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef PhysiologicalRangeSequence::iterator PhysiologicalRangeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef PhysiologicalRangeSequence::const_iterator PhysiologicalRangeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PhysiologicalRangeType, char > PhysiologicalRangeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const PhysiologicalRangeSequence&
    getPhysiologicalRange () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    PhysiologicalRangeSequence&
    getPhysiologicalRange ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setPhysiologicalRange (const PhysiologicalRangeSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DistributionSampleArrayMetricState (const DescriptorHandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DistributionSampleArrayMetricState (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DistributionSampleArrayMetricState (const DistributionSampleArrayMetricState& x,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DistributionSampleArrayMetricState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DistributionSampleArrayMetricState&
    operator= (const DistributionSampleArrayMetricState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DistributionSampleArrayMetricState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MetricValueOptional MetricValue_;
    PhysiologicalRangeSequence PhysiologicalRange_;

    //@endcond
  };

  /**
   * @brief List class corresponding to the %OperationRef
   * schema type.
   *
   * This class has an interface of a standard C++ sequence (e.g.,
   * std::vector).
   *
   * A list of operation handle references.
   */
  class OperationRef: public ::xml_schema::SimpleType,
    public ::xsd::cxx::tree::list< ::CDM::HandleRef, char >
  {
    public:
    /**
     * @brief Default constructor.
     *
     * Creates an empty list.
     */
    OperationRef ();

    /**
     * @brief Create a list with copies of the specified element.
     *
     * @param n A number of elements to copy.
     * @param x An element to copy.
     *
     * This constructor creates a list with @a n copies of @a x.
     */
    OperationRef (size_type n, const ::CDM::HandleRef& x);

    /**
     * @brief Create a list from an iterator range.
     *
     * @param begin An iterator pointing to the first element.
     * @param end An iterator pointing to the one past the last element.
     *
     * This constructor creates a list consisting of copies of the
     * elements in the range [begin,end).
     */
    template < typename I >
    OperationRef (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (begin, end, this)
    {
    }

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OperationRef (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OperationRef (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OperationRef (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OperationRef (const OperationRef& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OperationRef*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Destructor.
     */
    virtual 
    ~OperationRef ();
  };

  /**
   * @brief Class corresponding to the %ScoDescriptor schema type.
   *
   * ScoDescriptor describes the capabilities of the SCO.
   *
   * @nosubgrouping
   */
  class ScoDescriptor: public ::CDM::AbstractDeviceComponentDescriptor
  {
    public:
    /**
     * @name Operation
     *
     * @brief Accessor and modifier functions for the %Operation
     * sequence element.
     *
     * A list of operations that are provided by the SCO. The list is ordered
     * by the position of the operation in the list where the ELEMENT with a
     * lower list index has a higher clinical relevance than any entry with a
     * higher list index. The SERVICE PROVIDER defines the clinical relevance
     * and MAY reorder the list at any time.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::AbstractOperationDescriptor OperationType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< OperationType > OperationSequence;

    /**
     * @brief Element iterator type.
     */
    typedef OperationSequence::iterator OperationIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef OperationSequence::const_iterator OperationConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OperationType, char > OperationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const OperationSequence&
    getOperation () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    OperationSequence&
    getOperation ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setOperation (const OperationSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ScoDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ScoDescriptor (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ScoDescriptor (const ScoDescriptor& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ScoDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ScoDescriptor&
    operator= (const ScoDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ScoDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    OperationSequence Operation_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ScoState schema type.
   *
   * Corresponding state of pm:ScoDescriptor.
   *
   * @nosubgrouping
   */
  class ScoState: public ::CDM::AbstractDeviceComponentState
  {
    public:
    /**
     * @name OperationGroup
     *
     * @brief Accessor and modifier functions for the %OperationGroup
     * sequence element.
     *
     * OperationGroup defines groups of operations in order to allow clinical
     * grouping and prioritization of operations.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::OperationGroup OperationGroupType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< OperationGroupType > OperationGroupSequence;

    /**
     * @brief Element iterator type.
     */
    typedef OperationGroupSequence::iterator OperationGroupIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef OperationGroupSequence::const_iterator OperationGroupConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OperationGroupType, char > OperationGroupTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const OperationGroupSequence&
    getOperationGroup () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    OperationGroupSequence&
    getOperationGroup ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setOperationGroup (const OperationGroupSequence& s);

    //@}

    /**
     * @name InvocationRequested
     *
     * @brief Accessor and modifier functions for the %InvocationRequested
     * optional attribute.
     *
     * Prioritized list of operations that are requested to be invoked by a
     * SERVICE CONSUMER.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::OperationRef InvocationRequestedType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< InvocationRequestedType > InvocationRequestedOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InvocationRequestedType, char > InvocationRequestedTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const InvocationRequestedOptional&
    getInvocationRequested () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    InvocationRequestedOptional&
    getInvocationRequested ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInvocationRequested (const InvocationRequestedType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setInvocationRequested (const InvocationRequestedOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setInvocationRequested (::std::unique_ptr< InvocationRequestedType > p);

    //@}

    /**
     * @name InvocationRequired
     *
     * @brief Accessor and modifier functions for the %InvocationRequired
     * optional attribute.
     *
     * Prioritized list of operations that are required to be invoked by a
     * SERVICE CONSUMER.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::OperationRef InvocationRequiredType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< InvocationRequiredType > InvocationRequiredOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InvocationRequiredType, char > InvocationRequiredTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const InvocationRequiredOptional&
    getInvocationRequired () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    InvocationRequiredOptional&
    getInvocationRequired ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInvocationRequired (const InvocationRequiredType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setInvocationRequired (const InvocationRequiredOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setInvocationRequired (::std::unique_ptr< InvocationRequiredType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ScoState (const DescriptorHandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ScoState (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ScoState (const ScoState& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ScoState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ScoState&
    operator= (const ScoState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ScoState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    OperationGroupSequence OperationGroup_;
    InvocationRequestedOptional InvocationRequested_;
    InvocationRequiredOptional InvocationRequired_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AbstractOperationDescriptor schema type.
   *
   * Abstract description of an operation that is exposed on the SCO.
   *
   * @nosubgrouping
   */
  class AbstractOperationDescriptor: public ::CDM::AbstractDescriptor
  {
    public:
    /**
     * @name OperationTarget
     *
     * @brief Accessor and modifier functions for the %OperationTarget
     * required attribute.
     *
     * A HANDLE reference this operation is targeted to. In case of a single
     * state this is the HANDLE of the descriptor. In case that multiple
     * states may belong to one descriptor (pm:AbstractMultiState),
     * OperationTarget is the HANDLE of one of the state instances (if the
     * state is modified by the operation).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::HandleRef OperationTargetType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< OperationTargetType, char > OperationTargetTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const OperationTargetType&
    getOperationTarget () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    OperationTargetType&
    getOperationTarget ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setOperationTarget (const OperationTargetType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOperationTarget (::std::unique_ptr< OperationTargetType > p);

    //@}

    /**
     * @name MaxTimeToFinish
     *
     * @brief Accessor and modifier functions for the %MaxTimeToFinish
     * optional attribute.
     *
     * MaxTimeToFinish defines the maximum time an operation takes to get
     * from the initial receiving of the command to a successful end.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration MaxTimeToFinishType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxTimeToFinishType > MaxTimeToFinishOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxTimeToFinishType, char > MaxTimeToFinishTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxTimeToFinishOptional&
    getMaxTimeToFinish () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxTimeToFinishOptional&
    getMaxTimeToFinish ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxTimeToFinish (const MaxTimeToFinishType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxTimeToFinish (const MaxTimeToFinishOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMaxTimeToFinish (::std::unique_ptr< MaxTimeToFinishType > p);

    //@}

    /**
     * @name InvocationEffectiveTimeout
     *
     * @brief Accessor and modifier functions for the %InvocationEffectiveTimeout
     * optional attribute.
     *
     * InvocationEffectiveTimeout defines a time period in which the result
     * of an invocation is effective after it has been successfully finished.
     * When the time is up and the operation has not been retriggered, then
     * the SERVICE PROVIDER MAY revert the operation target to another state.
     * 
     * NOTE?Example: if an arbitrary client remotely controls the cutter of a
     * high frequency cutting device, due to safety reasons the cutter
     * trigger might have a timeout until it stops automatically. To enable
     * continuous activation, the client has to send repeated triggers within
     * the given InvocationEffectiveTimeout duration.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration InvocationEffectiveTimeoutType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< InvocationEffectiveTimeoutType > InvocationEffectiveTimeoutOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InvocationEffectiveTimeoutType, char > InvocationEffectiveTimeoutTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const InvocationEffectiveTimeoutOptional&
    getInvocationEffectiveTimeout () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    InvocationEffectiveTimeoutOptional&
    getInvocationEffectiveTimeout ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInvocationEffectiveTimeout (const InvocationEffectiveTimeoutType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setInvocationEffectiveTimeout (const InvocationEffectiveTimeoutOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setInvocationEffectiveTimeout (::std::unique_ptr< InvocationEffectiveTimeoutType > p);

    //@}

    /**
     * @name Retriggerable
     *
     * @brief Accessor and modifier functions for the %Retriggerable
     * optional attribute.
     *
     * Retriggerable is only applicable if ./@InvocationEffectiveTimeout is
     * set. If set to "true", then Retriggerable indicates that a call to the
     * activate operation resets the current ./@InvocationEffectiveTimeout,
     * otherwise it will be left as it is until ./@InvocationEffectiveTimeout
     * times out.
     * 
     * The implied value SHALL be "true".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean RetriggerableType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RetriggerableType > RetriggerableOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RetriggerableType, char > RetriggerableTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RetriggerableOptional&
    getRetriggerable () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    RetriggerableOptional&
    getRetriggerable ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRetriggerable (const RetriggerableType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setRetriggerable (const RetriggerableOptional& x);

    //@}

    /**
     * @name AccessLevel
     *
     * @brief Accessor and modifier functions for the %AccessLevel
     * optional attribute.
     *
     * AccessLevel defines a user group to whom access to the operation is
     * granted. The implied value SHALL be "Usr".
     * 
     * __R5054: Access to the invocation of the operation SHALL be restricted
     * to the defined user group by a SERVICE CONSUMER.__
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::AccessLevel AccessLevelType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AccessLevelType > AccessLevelOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< AccessLevelType, char > AccessLevelTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AccessLevelOptional&
    getAccessLevel () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    AccessLevelOptional&
    getAccessLevel ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setAccessLevel (const AccessLevelType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setAccessLevel (const AccessLevelOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAccessLevel (::std::unique_ptr< AccessLevelType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AbstractOperationDescriptor (const HandleType&,
                                 const OperationTargetType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AbstractOperationDescriptor (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractOperationDescriptor (const AbstractOperationDescriptor& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AbstractOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractOperationDescriptor&
    operator= (const AbstractOperationDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AbstractOperationDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< OperationTargetType > OperationTarget_;
    MaxTimeToFinishOptional MaxTimeToFinish_;
    InvocationEffectiveTimeoutOptional InvocationEffectiveTimeout_;
    RetriggerableOptional Retriggerable_;
    AccessLevelOptional AccessLevel_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AbstractSetStateOperationDescriptor schema type.
   *
   * Abstract description of an operation that is exposed on the SCO and is
   * intended to be used to set a complete state.
   *
   * @nosubgrouping
   */
  class AbstractSetStateOperationDescriptor: public ::CDM::AbstractOperationDescriptor
  {
    public:
    /**
     * @name ModifiableData
     *
     * @brief Accessor and modifier functions for the %ModifiableData
     * sequence element.
     *
     * ModifiableData describes a list of ATTRIBUTEs and ELEMENTs the
     * underlying operation modifies on invocation by means of XPath
     * expressions.
     * 
     * __R5010: If the ModifiableData list is empty, then all
     * ELEMENTs/ATTRIBUTEs SHALL be modifiable except for
     * pm:AbstractMultiState/@Handle, pm:AbstractState/@DescriptorHandle,
     * pm:AbstractState/@StateVersion, and
     * pm:AbstractState/@DescriptorVersion.__
     * 
     * __R5011: The root ELEMENT of the XPath expressions SHALL be the state
     * of the CONTAINMENT TREE ENTRY referenced by
     * pm:AbstractOperationDescriptor/@OperationTarget.__
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String ModifiableDataType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ModifiableDataType > ModifiableDataSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ModifiableDataSequence::iterator ModifiableDataIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ModifiableDataSequence::const_iterator ModifiableDataConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ModifiableDataType, char > ModifiableDataTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ModifiableDataSequence&
    getModifiableData () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ModifiableDataSequence&
    getModifiableData ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setModifiableData (const ModifiableDataSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AbstractSetStateOperationDescriptor (const HandleType&,
                                         const OperationTargetType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AbstractSetStateOperationDescriptor (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractSetStateOperationDescriptor (const AbstractSetStateOperationDescriptor& x,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AbstractSetStateOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractSetStateOperationDescriptor&
    operator= (const AbstractSetStateOperationDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AbstractSetStateOperationDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ModifiableDataSequence ModifiableData_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %OperatingMode
   * schema type.
   *
   * Mode of an operation state.
   */
  class OperatingMode: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Dis = Disabled. Object is disabled.
       */
      Dis,
      /**
       * En = Enabled. Object is enabled
       */
      En,
      /**
       * NA = Not Available. Object is not available for interaction. This
       * means that it is defined but currently not in a mode so that it can be
       * interacted with.
       */
      NA
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    OperatingMode (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    OperatingMode (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    OperatingMode (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    OperatingMode (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OperatingMode (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OperatingMode (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OperatingMode (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OperatingMode (const OperatingMode& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OperatingMode*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    OperatingMode&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_OperatingMode_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_OperatingMode_convert () const;

    public:
    static const char* const _xsd_OperatingMode_literals_[3];
    static const Value _xsd_OperatingMode_indexes_[3];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AbstractOperationState schema type.
   *
   * State of an operation that is exposed on the SCO.
   *
   * @nosubgrouping
   */
  class AbstractOperationState: public ::CDM::AbstractState
  {
    public:
    /**
     * @name OperatingMode
     *
     * @brief Accessor and modifier functions for the %OperatingMode
     * required attribute.
     *
     * Operating mode that defines if the operation is accessible.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::OperatingMode OperatingModeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< OperatingModeType, char > OperatingModeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const OperatingModeType&
    getOperatingMode () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    OperatingModeType&
    getOperatingMode ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setOperatingMode (const OperatingModeType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setOperatingMode (::std::unique_ptr< OperatingModeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AbstractOperationState (const DescriptorHandleType&,
                            const OperatingModeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AbstractOperationState (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractOperationState (const AbstractOperationState& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AbstractOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractOperationState&
    operator= (const AbstractOperationState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AbstractOperationState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< OperatingModeType > OperatingMode_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SetValueOperationDescriptor schema type.
   *
   * Describes a numeric set operation for a specific object state in the
   * MDIB that is exposed on the SCO.
   *
   * @nosubgrouping
   */
  class SetValueOperationDescriptor: public ::CDM::AbstractOperationDescriptor
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SetValueOperationDescriptor (const HandleType&,
                                 const OperationTargetType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SetValueOperationDescriptor (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SetValueOperationDescriptor (const SetValueOperationDescriptor& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SetValueOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SetValueOperationDescriptor ();
  };

  /**
   * @brief Class corresponding to the %SetValueOperationState schema type.
   *
   * State of a numeric set operation that is exposed on the SCO.
   *
   * @nosubgrouping
   */
  class SetValueOperationState: public ::CDM::AbstractOperationState
  {
    public:
    /**
     * @name AllowedRange
     *
     * @brief Accessor and modifier functions for the %AllowedRange
     * sequence element.
     *
     * The currently allowed ranges that can be requested.
     * 
     * NOTE?The given ranges need to be a (strict or non-strict) subset of
     * the technical range of the referenced descriptor.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Range AllowedRangeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< AllowedRangeType > AllowedRangeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef AllowedRangeSequence::iterator AllowedRangeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef AllowedRangeSequence::const_iterator AllowedRangeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AllowedRangeType, char > AllowedRangeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const AllowedRangeSequence&
    getAllowedRange () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    AllowedRangeSequence&
    getAllowedRange ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setAllowedRange (const AllowedRangeSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SetValueOperationState (const DescriptorHandleType&,
                            const OperatingModeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SetValueOperationState (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SetValueOperationState (const SetValueOperationState& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SetValueOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SetValueOperationState&
    operator= (const SetValueOperationState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SetValueOperationState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AllowedRangeSequence AllowedRange_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SetStringOperationDescriptor schema type.
   *
   * Describes a string set operation for a specific object state in the
   * MDIB that is exposed on the SCO.
   *
   * @nosubgrouping
   */
  class SetStringOperationDescriptor: public ::CDM::AbstractOperationDescriptor
  {
    public:
    /**
     * @name MaxLength
     *
     * @brief Accessor and modifier functions for the %MaxLength
     * optional attribute.
     *
     * An optional parameter that gives the maximum length of the input
     * string that is supported by the operation.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::UnsignedLong MaxLengthType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxLengthType > MaxLengthOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxLengthType, char > MaxLengthTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxLengthOptional&
    getMaxLength () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxLengthOptional&
    getMaxLength ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxLength (const MaxLengthType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxLength (const MaxLengthOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SetStringOperationDescriptor (const HandleType&,
                                  const OperationTargetType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SetStringOperationDescriptor (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SetStringOperationDescriptor (const SetStringOperationDescriptor& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SetStringOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SetStringOperationDescriptor&
    operator= (const SetStringOperationDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SetStringOperationDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MaxLengthOptional MaxLength_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SetStringOperationState schema type.
   *
   * State of a string set operation that is exposed on the SCO.
   *
   * @nosubgrouping
   */
  class SetStringOperationState: public ::CDM::AbstractOperationState
  {
    public:
    /**
     * @name AllowedValues
     *
     * @brief Accessor and modifier functions for the %AllowedValues
     * optional element.
     *
     * An OPTIONAL list of currently allowed string values that can be
     * requested. If the list is empty, then there is not limitation.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::AllowedValues AllowedValuesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AllowedValuesType > AllowedValuesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AllowedValuesType, char > AllowedValuesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AllowedValuesOptional&
    getAllowedValues () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AllowedValuesOptional&
    getAllowedValues ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAllowedValues (const AllowedValuesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAllowedValues (const AllowedValuesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAllowedValues (::std::unique_ptr< AllowedValuesType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SetStringOperationState (const DescriptorHandleType&,
                             const OperatingModeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SetStringOperationState (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SetStringOperationState (const SetStringOperationState& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SetStringOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SetStringOperationState&
    operator= (const SetStringOperationState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SetStringOperationState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AllowedValuesOptional AllowedValues_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ActivateOperationDescriptor schema type.
   *
   * Describes an activate operation that is exposed on the SCO. Activate
   * operations are any parameterized operations that trigger an arbitrary
   * action. The action that is triggered SHALL be defined by the
   * pm:AbstractDescriptor/pm:Type ELEMENT.
   *
   * @nosubgrouping
   */
  class ActivateOperationDescriptor: public ::CDM::AbstractSetStateOperationDescriptor
  {
    public:
    /**
     * @name Argument
     *
     * @brief Accessor and modifier functions for the %Argument
     * sequence element.
     *
     * Argument description for an activate operation.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Argument ArgumentType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ArgumentType > ArgumentSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ArgumentSequence::iterator ArgumentIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ArgumentSequence::const_iterator ArgumentConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ArgumentType, char > ArgumentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ArgumentSequence&
    getArgument () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ArgumentSequence&
    getArgument ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setArgument (const ArgumentSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ActivateOperationDescriptor (const HandleType&,
                                 const OperationTargetType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ActivateOperationDescriptor (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ActivateOperationDescriptor (const ActivateOperationDescriptor& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ActivateOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ActivateOperationDescriptor&
    operator= (const ActivateOperationDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ActivateOperationDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ArgumentSequence Argument_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ActivateOperationState schema type.
   *
   * State of an activate operation that is exposed on the SCO.
   *
   * @nosubgrouping
   */
  class ActivateOperationState: public ::CDM::AbstractOperationState
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ActivateOperationState (const DescriptorHandleType&,
                            const OperatingModeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ActivateOperationState (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ActivateOperationState (const ActivateOperationState& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ActivateOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ActivateOperationState ();
  };

  /**
   * @brief Class corresponding to the %SetContextStateOperationDescriptor schema type.
   *
   * Describes a context state set operation for a specific context state
   * in the MDIB that is exposed on SCO.
   *
   * @nosubgrouping
   */
  class SetContextStateOperationDescriptor: public ::CDM::AbstractSetStateOperationDescriptor
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SetContextStateOperationDescriptor (const HandleType&,
                                        const OperationTargetType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SetContextStateOperationDescriptor (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SetContextStateOperationDescriptor (const SetContextStateOperationDescriptor& x,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SetContextStateOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SetContextStateOperationDescriptor ();
  };

  /**
   * @brief Class corresponding to the %SetContextStateOperationState schema type.
   *
   * State of a context state set operation that is exposed on the SCO.
   *
   * @nosubgrouping
   */
  class SetContextStateOperationState: public ::CDM::AbstractOperationState
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SetContextStateOperationState (const DescriptorHandleType&,
                                   const OperatingModeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SetContextStateOperationState (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SetContextStateOperationState (const SetContextStateOperationState& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SetContextStateOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SetContextStateOperationState ();
  };

  /**
   * @brief Class corresponding to the %SetMetricStateOperationDescriptor schema type.
   *
   * Describes a METRIC state set operation for a specific METRIC state in
   * the MDIB that is exposed on the SCO.
   *
   * @nosubgrouping
   */
  class SetMetricStateOperationDescriptor: public ::CDM::AbstractSetStateOperationDescriptor
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SetMetricStateOperationDescriptor (const HandleType&,
                                       const OperationTargetType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SetMetricStateOperationDescriptor (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SetMetricStateOperationDescriptor (const SetMetricStateOperationDescriptor& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SetMetricStateOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SetMetricStateOperationDescriptor ();
  };

  /**
   * @brief Class corresponding to the %SetMetricStateOperationState schema type.
   *
   * State of a METRIC state set operation that is exposed on the SCO.
   *
   * @nosubgrouping
   */
  class SetMetricStateOperationState: public ::CDM::AbstractOperationState
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SetMetricStateOperationState (const DescriptorHandleType&,
                                  const OperatingModeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SetMetricStateOperationState (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SetMetricStateOperationState (const SetMetricStateOperationState& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SetMetricStateOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SetMetricStateOperationState ();
  };

  /**
   * @brief Class corresponding to the %SetComponentStateOperationDescriptor schema type.
   *
   * Describes a component state set operation for a specific component
   * state in the MDIB that is exposed on the SCO.
   *
   * @nosubgrouping
   */
  class SetComponentStateOperationDescriptor: public ::CDM::AbstractSetStateOperationDescriptor
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SetComponentStateOperationDescriptor (const HandleType&,
                                          const OperationTargetType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SetComponentStateOperationDescriptor (const ::xercesc::DOMElement& e,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SetComponentStateOperationDescriptor (const SetComponentStateOperationDescriptor& x,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SetComponentStateOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SetComponentStateOperationDescriptor ();
  };

  /**
   * @brief Class corresponding to the %SetComponentStateOperationState schema type.
   *
   * State of a component state set operation that is exposed on the SCO.
   *
   * @nosubgrouping
   */
  class SetComponentStateOperationState: public ::CDM::AbstractOperationState
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SetComponentStateOperationState (const DescriptorHandleType&,
                                     const OperatingModeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SetComponentStateOperationState (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SetComponentStateOperationState (const SetComponentStateOperationState& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SetComponentStateOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SetComponentStateOperationState ();
  };

  /**
   * @brief Class corresponding to the %SetAlertStateOperationDescriptor schema type.
   *
   * Describes an alert state set operation for a specific alert state in
   * the MDIB that is exposed on the SCO.
   *
   * @nosubgrouping
   */
  class SetAlertStateOperationDescriptor: public ::CDM::AbstractSetStateOperationDescriptor
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SetAlertStateOperationDescriptor (const HandleType&,
                                      const OperationTargetType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SetAlertStateOperationDescriptor (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SetAlertStateOperationDescriptor (const SetAlertStateOperationDescriptor& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SetAlertStateOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SetAlertStateOperationDescriptor ();
  };

  /**
   * @brief Class corresponding to the %SetAlertStateOperationState schema type.
   *
   * State of an alert state set operation that is exposed on the SCO.
   *
   * @nosubgrouping
   */
  class SetAlertStateOperationState: public ::CDM::AbstractOperationState
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SetAlertStateOperationState (const DescriptorHandleType&,
                                 const OperatingModeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SetAlertStateOperationState (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SetAlertStateOperationState (const SetAlertStateOperationState& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SetAlertStateOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SetAlertStateOperationState ();
  };

  /**
   * @brief Class corresponding to the %TimeZone schema type.
   *
   * TimeZone describes the time zone and DST setting of a clock in POSIX
   * format (ISO/IEC/IEEE 9945).
   * 
   * Example: CST6CDT,M3.2.0/2:00:00,M11.1.0/2:00:00, which would effect a
   * change to daylight saving time at 2:00 AM on the second Sunday in
   * March and change back at 2:00 AM on the first Sunday in November, and
   * keep 6 hours time offset from GMT every year.
   *
   * @nosubgrouping
   */
  class TimeZone: public ::xml_schema::String
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    TimeZone ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    TimeZone (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    TimeZone (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimeZone (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeZone (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeZone (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimeZone (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimeZone (const TimeZone& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimeZone*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimeZone ();
  };

  /**
   * @brief Class corresponding to the %ClockDescriptor schema type.
   *
   * ClockDescriptor describes the capabilities of an MDS regarding
   * date/time handling and synchronization. The presense of a
   * ClockDescriptor does not imply any specific hardware or software
   * support.
   *
   * @nosubgrouping
   */
  class ClockDescriptor: public ::CDM::AbstractDeviceComponentDescriptor
  {
    public:
    /**
     * @name TimeProtocol
     *
     * @brief Accessor and modifier functions for the %TimeProtocol
     * sequence element.
     *
     * OPTIONAL list of protocols that can be used to set the POC MEDICAL
     * DEVICE's clock. An empty list implies that the clock cannot be set and
     * is therefore uncalibrated and unsynchronized (e.g., equal to
     * MDC:MDC_TIME_SYNC_NONE).   
     * Example: {MDC:MDC_TIME_SYNC_EBWW, MDC:MDC_TIME_SYNC_SNTPV4,
     * MDC:MDC_TIME_SYNC_NTPV3} if the clock supports synchronization using
     * manually setting on the POC MEDICAL DEVICE, SNTP v4.0 (RFC 2030) and
     * NTP v3.0 (RFC 1305).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue TimeProtocolType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TimeProtocolType > TimeProtocolSequence;

    /**
     * @brief Element iterator type.
     */
    typedef TimeProtocolSequence::iterator TimeProtocolIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef TimeProtocolSequence::const_iterator TimeProtocolConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeProtocolType, char > TimeProtocolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TimeProtocolSequence&
    getTimeProtocol () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TimeProtocolSequence&
    getTimeProtocol ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTimeProtocol (const TimeProtocolSequence& s);

    //@}

    /**
     * @name Resolution
     *
     * @brief Accessor and modifier functions for the %Resolution
     * optional attribute.
     *
     * Time between actual ticks of the clock in microseconds. If none is
     * given, the resolution is unknown.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Duration ResolutionType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ResolutionType > ResolutionOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ResolutionType, char > ResolutionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ResolutionOptional&
    getResolution () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ResolutionOptional&
    getResolution ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setResolution (const ResolutionType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setResolution (const ResolutionOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setResolution (::std::unique_ptr< ResolutionType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ClockDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ClockDescriptor (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ClockDescriptor (const ClockDescriptor& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ClockDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ClockDescriptor&
    operator= (const ClockDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ClockDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TimeProtocolSequence TimeProtocol_;
    ResolutionOptional Resolution_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ClockState schema type.
   *
   * State of a clock of an MDS.
   *
   * @nosubgrouping
   */
  class ClockState: public ::CDM::AbstractDeviceComponentState
  {
    public:
    /**
     * @name ActiveSyncProtocol
     *
     * @brief Accessor and modifier functions for the %ActiveSyncProtocol
     * optional element.
     *
     * Protocol that is actively being used for time sync.
     * 
     * Examples: MDC:MDC_TIME_SYNC_NTPV3 if the clock is synchronized using
     * NTP v3.0 (RFC 1305) or MDC:MDC_TIME_SYNC_NONE if the clock is not
     * synchronized.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue ActiveSyncProtocolType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ActiveSyncProtocolType > ActiveSyncProtocolOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ActiveSyncProtocolType, char > ActiveSyncProtocolTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ActiveSyncProtocolOptional&
    getActiveSyncProtocol () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ActiveSyncProtocolOptional&
    getActiveSyncProtocol ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setActiveSyncProtocol (const ActiveSyncProtocolType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setActiveSyncProtocol (const ActiveSyncProtocolOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setActiveSyncProtocol (::std::unique_ptr< ActiveSyncProtocolType > p);

    //@}

    /**
     * @name ReferenceSource
     *
     * @brief Accessor and modifier functions for the %ReferenceSource
     * sequence element.
     *
     * Identifies the clock's external reference source(s), e.g., NTP server
     * addresses.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String ReferenceSourceType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ReferenceSourceType > ReferenceSourceSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ReferenceSourceSequence::iterator ReferenceSourceIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ReferenceSourceSequence::const_iterator ReferenceSourceConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReferenceSourceType, char > ReferenceSourceTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ReferenceSourceSequence&
    getReferenceSource () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ReferenceSourceSequence&
    getReferenceSource ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setReferenceSource (const ReferenceSourceSequence& s);

    //@}

    /**
     * @name DateAndTime
     *
     * @brief Accessor and modifier functions for the %DateAndTime
     * optional attribute.
     *
     * Current date/time setting. As the current date/time changes at a high
     * frequency, a change of this value SHALL NOT cause an update of the
     * state version unless it has been synchronized either remotely or
     * manually.
     * 
     * NOTE?DateAndTime could be filled when the clock is explicitly
     * requested.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::Timestamp DateAndTimeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DateAndTimeType > DateAndTimeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DateAndTimeType, char > DateAndTimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DateAndTimeOptional&
    getDateAndTime () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    DateAndTimeOptional&
    getDateAndTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDateAndTime (const DateAndTimeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setDateAndTime (const DateAndTimeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDateAndTime (::std::unique_ptr< DateAndTimeType > p);

    //@}

    /**
     * @name RemoteSync
     *
     * @brief Accessor and modifier functions for the %RemoteSync
     * required attribute.
     *
     * Indicates if the time is synchronized to an external source or set by
     * an operator.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean RemoteSyncType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RemoteSyncType, char > RemoteSyncTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RemoteSyncType&
    getRemoteSync () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RemoteSyncType&
    getRemoteSync ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRemoteSync (const RemoteSyncType& x);

    //@}

    /**
     * @name Accuracy
     *
     * @brief Accessor and modifier functions for the %Accuracy
     * optional attribute.
     *
     * Accuracy is a decimal number indicating the maximum error in seconds
     * of the absolute time relative to a primary reference clock source.
     * 
     * In systems where time synchronization is not used and the clock is set
     * manually by "eyeball and wristwatch" (EBWW), this SHALL be initialized
     * to three minutes when the clock time is set. If NTP is used, this is
     * equivalent to Root Dispersion + 1?2 Root Delay.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Decimal AccuracyType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AccuracyType > AccuracyOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< AccuracyType, char, ::xsd::cxx::tree::schema_type::decimal > AccuracyTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AccuracyOptional&
    getAccuracy () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    AccuracyOptional&
    getAccuracy ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setAccuracy (const AccuracyType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setAccuracy (const AccuracyOptional& x);

    //@}

    /**
     * @name LastSet
     *
     * @brief Accessor and modifier functions for the %LastSet
     * optional attribute.
     *
     * Time point when the absolute time was set or synchronized.
     * 
     * NOTE 1?If a time synchronization protocol is used that "changes" the
     * time and date at a high frequency, it is proposed to update this value
     * at a lower periodicity (e.g., once every 10 minutes or once an hour),
     * so as not to consume communications bandwidth unnecessarily.
     * NOTE 2?Synchronization might be achieved by slewing the time. This
     * means that the virtual frequency of the software clock is adjusted to
     * make the clock go faster or slower until it is corrected.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::Timestamp LastSetType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LastSetType > LastSetOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LastSetType, char > LastSetTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LastSetOptional&
    getLastSet () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    LastSetOptional&
    getLastSet ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setLastSet (const LastSetType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setLastSet (const LastSetOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLastSet (::std::unique_ptr< LastSetType > p);

    //@}

    /**
     * @name TimeZone
     *
     * @brief Accessor and modifier functions for the %TimeZone
     * optional attribute.
     *
     * Identifies the time zone and DST of the clock.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::TimeZone TimeZoneType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TimeZoneType > TimeZoneOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeZoneType, char > TimeZoneTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TimeZoneOptional&
    getTimeZone () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    TimeZoneOptional&
    getTimeZone ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setTimeZone (const TimeZoneType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setTimeZone (const TimeZoneOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTimeZone (::std::unique_ptr< TimeZoneType > p);

    //@}

    /**
     * @name CriticalUse
     *
     * @brief Accessor and modifier functions for the %CriticalUse
     * optional attribute.
     *
     * Identifies that the clock information is actively being used in care
     * delivery algorithms/protocols. The implied value SHALL be "false".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean CriticalUseType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CriticalUseType > CriticalUseOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< CriticalUseType, char > CriticalUseTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CriticalUseOptional&
    getCriticalUse () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    CriticalUseOptional&
    getCriticalUse ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setCriticalUse (const CriticalUseType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setCriticalUse (const CriticalUseOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ClockState (const DescriptorHandleType&,
                const RemoteSyncType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ClockState (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ClockState (const ClockState& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ClockState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ClockState&
    operator= (const ClockState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ClockState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ActiveSyncProtocolOptional ActiveSyncProtocol_;
    ReferenceSourceSequence ReferenceSource_;
    DateAndTimeOptional DateAndTime_;
    ::xsd::cxx::tree::one< RemoteSyncType > RemoteSync_;
    AccuracyOptional Accuracy_;
    LastSetOptional LastSet_;
    TimeZoneOptional TimeZone_;
    CriticalUseOptional CriticalUse_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BatteryDescriptor schema type.
   *
   * For battery-powered devices, battery information can be contained in
   * this object.
   *
   * @nosubgrouping
   */
  class BatteryDescriptor: public ::CDM::AbstractDeviceComponentDescriptor
  {
    public:
    /**
     * @name CapacityFullCharge
     *
     * @brief Accessor and modifier functions for the %CapacityFullCharge
     * optional element.
     *
     * Current battery capacity after a full charge.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Measurement CapacityFullChargeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CapacityFullChargeType > CapacityFullChargeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CapacityFullChargeType, char > CapacityFullChargeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CapacityFullChargeOptional&
    getCapacityFullCharge () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CapacityFullChargeOptional&
    getCapacityFullCharge ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCapacityFullCharge (const CapacityFullChargeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCapacityFullCharge (const CapacityFullChargeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCapacityFullCharge (::std::unique_ptr< CapacityFullChargeType > p);

    //@}

    /**
     * @name CapacitySpecified
     *
     * @brief Accessor and modifier functions for the %CapacitySpecified
     * optional element.
     *
     * Rated capacity the manufacturer claims for the battery.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Measurement CapacitySpecifiedType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CapacitySpecifiedType > CapacitySpecifiedOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CapacitySpecifiedType, char > CapacitySpecifiedTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CapacitySpecifiedOptional&
    getCapacitySpecified () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CapacitySpecifiedOptional&
    getCapacitySpecified ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCapacitySpecified (const CapacitySpecifiedType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCapacitySpecified (const CapacitySpecifiedOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCapacitySpecified (::std::unique_ptr< CapacitySpecifiedType > p);

    //@}

    /**
     * @name VoltageSpecified
     *
     * @brief Accessor and modifier functions for the %VoltageSpecified
     * optional element.
     *
     * Specified battery voltage.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Measurement VoltageSpecifiedType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< VoltageSpecifiedType > VoltageSpecifiedOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VoltageSpecifiedType, char > VoltageSpecifiedTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const VoltageSpecifiedOptional&
    getVoltageSpecified () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    VoltageSpecifiedOptional&
    getVoltageSpecified ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setVoltageSpecified (const VoltageSpecifiedType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setVoltageSpecified (const VoltageSpecifiedOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setVoltageSpecified (::std::unique_ptr< VoltageSpecifiedType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BatteryDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BatteryDescriptor (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BatteryDescriptor (const BatteryDescriptor& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BatteryDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BatteryDescriptor&
    operator= (const BatteryDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BatteryDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CapacityFullChargeOptional CapacityFullCharge_;
    CapacitySpecifiedOptional CapacitySpecified_;
    VoltageSpecifiedOptional VoltageSpecified_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BatteryState schema type.
   *
   * State of a battery of an MDS.
   * 
   * The current power source is designated by ./@ActivationState:
   * 
   * - If ./@ActivationState equals "On", the device is running on battery
   * - If ./@ActivationState equals "Off", the device is in mains operation
   * and currently not able to be run on battery
   * - If ./@ActivationState equals "StndBy", the device is in mains
   * operation and can be switched to run on battery
   * - If ./@ActivationState equals "Fail", the battery has a malfunction.
   * Detailed error information SHOULD be communicated by using an ALERT
   * SYSTEM.
   * 
   * Enumerations "Shtdn" and "NotRdy" are undefined for BatteryState.
   *
   * @nosubgrouping
   */
  class BatteryState: public ::CDM::AbstractDeviceComponentState
  {
    public:
    /**
     * @name CapacityRemaining
     *
     * @brief Accessor and modifier functions for the %CapacityRemaining
     * optional element.
     *
     * Remaining capacity at current load.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Measurement CapacityRemainingType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CapacityRemainingType > CapacityRemainingOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CapacityRemainingType, char > CapacityRemainingTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CapacityRemainingOptional&
    getCapacityRemaining () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CapacityRemainingOptional&
    getCapacityRemaining ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCapacityRemaining (const CapacityRemainingType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCapacityRemaining (const CapacityRemainingOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCapacityRemaining (::std::unique_ptr< CapacityRemainingType > p);

    //@}

    /**
     * @name Voltage
     *
     * @brief Accessor and modifier functions for the %Voltage
     * optional element.
     *
     * Voltage between the terminals of a cell or battery when being
     * discharged. See also IEC 60050-482 International Electrotechnical
     * Vocabulary, 482-03-28.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Measurement VoltageType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< VoltageType > VoltageOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VoltageType, char > VoltageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const VoltageOptional&
    getVoltage () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    VoltageOptional&
    getVoltage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setVoltage (const VoltageType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setVoltage (const VoltageOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setVoltage (::std::unique_ptr< VoltageType > p);

    //@}

    /**
     * @name Current
     *
     * @brief Accessor and modifier functions for the %Current
     * optional element.
     *
     * Electric current delivered by a battery during its discharge; negative
     * if battery is charge. See also IEC 60050-482 International
     * Electrotechnical Vocabulary, 482-03-24.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Measurement CurrentType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CurrentType > CurrentOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CurrentType, char > CurrentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CurrentOptional&
    getCurrent () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CurrentOptional&
    getCurrent ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCurrent (const CurrentType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCurrent (const CurrentOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCurrent (::std::unique_ptr< CurrentType > p);

    //@}

    /**
     * @name Temperature
     *
     * @brief Accessor and modifier functions for the %Temperature
     * optional element.
     *
     * Current battery temperature.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Measurement TemperatureType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TemperatureType > TemperatureOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TemperatureType, char > TemperatureTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TemperatureOptional&
    getTemperature () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TemperatureOptional&
    getTemperature ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTemperature (const TemperatureType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTemperature (const TemperatureOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTemperature (::std::unique_ptr< TemperatureType > p);

    //@}

    /**
     * @name RemainingBatteryTime
     *
     * @brief Accessor and modifier functions for the %RemainingBatteryTime
     * optional element.
     *
     * Current remaining time until battery is discharged.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Measurement RemainingBatteryTimeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RemainingBatteryTimeType > RemainingBatteryTimeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RemainingBatteryTimeType, char > RemainingBatteryTimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RemainingBatteryTimeOptional&
    getRemainingBatteryTime () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RemainingBatteryTimeOptional&
    getRemainingBatteryTime ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRemainingBatteryTime (const RemainingBatteryTimeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRemainingBatteryTime (const RemainingBatteryTimeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRemainingBatteryTime (::std::unique_ptr< RemainingBatteryTimeType > p);

    //@}

    /**
     * @name ChargeStatus
     *
     * @brief Accessor and modifier functions for the %ChargeStatus
     * optional attribute.
     *
     * Current charge status of the battery.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::ChargeStatus ChargeStatusType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ChargeStatusType > ChargeStatusOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ChargeStatusType, char > ChargeStatusTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ChargeStatusOptional&
    getChargeStatus () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ChargeStatusOptional&
    getChargeStatus ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setChargeStatus (const ChargeStatusType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setChargeStatus (const ChargeStatusOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setChargeStatus (::std::unique_ptr< ChargeStatusType > p);

    //@}

    /**
     * @name ChargeCycles
     *
     * @brief Accessor and modifier functions for the %ChargeCycles
     * optional attribute.
     *
     * Number of charge/discharge cycles.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::UnsignedInt ChargeCyclesType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ChargeCyclesType > ChargeCyclesOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ChargeCyclesType, char > ChargeCyclesTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ChargeCyclesOptional&
    getChargeCycles () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ChargeCyclesOptional&
    getChargeCycles ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setChargeCycles (const ChargeCyclesType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setChargeCycles (const ChargeCyclesOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BatteryState (const DescriptorHandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BatteryState (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BatteryState (const BatteryState& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BatteryState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BatteryState&
    operator= (const BatteryState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BatteryState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CapacityRemainingOptional CapacityRemaining_;
    VoltageOptional Voltage_;
    CurrentOptional Current_;
    TemperatureOptional Temperature_;
    RemainingBatteryTimeOptional RemainingBatteryTime_;
    ChargeStatusOptional ChargeStatus_;
    ChargeCyclesOptional ChargeCycles_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SystemContextDescriptor schema type.
   *
   * The context of an MDS that lists the possible relationship of a POC
   * MEDICAL DEVICE into its usage environment by means of context
   * descriptors. Context descriptors do not contain any stateful
   * information. They only assert that the underlying MDS can provide
   * corresponding context state information.
   *
   * @nosubgrouping
   */
  class SystemContextDescriptor: public ::CDM::AbstractDeviceComponentDescriptor
  {
    public:
    /**
     * @name PatientContext
     *
     * @brief Accessor and modifier functions for the %PatientContext
     * optional element.
     *
     * The patient context indicates that the POC MEDICAL DEVICE is able to
     * process information about the patient that it is associated with.
     * 
     * A SERVICE PROVIDER SHALL NOT insert or delete the context descriptor
     * ELEMENT during runtime, except when the whole MDS appears/disappears.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::PatientContextDescriptor PatientContextType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PatientContextType > PatientContextOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PatientContextType, char > PatientContextTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PatientContextOptional&
    getPatientContext () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PatientContextOptional&
    getPatientContext ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPatientContext (const PatientContextType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPatientContext (const PatientContextOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPatientContext (::std::unique_ptr< PatientContextType > p);

    //@}

    /**
     * @name LocationContext
     *
     * @brief Accessor and modifier functions for the %LocationContext
     * optional element.
     *
     * The location context indicates that the POC MEDICAL DEVICE can provide
     * information about the location(s) that it is associated with.
     * 
     * A SERVICE PROVIDER SHALL NOT insert or delete the context descriptor
     * ELEMENT during runtime, except when the whole MDS appears/disappears.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::LocationContextDescriptor LocationContextType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LocationContextType > LocationContextOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LocationContextType, char > LocationContextTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LocationContextOptional&
    getLocationContext () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LocationContextOptional&
    getLocationContext ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLocationContext (const LocationContextType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLocationContext (const LocationContextOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLocationContext (::std::unique_ptr< LocationContextType > p);

    //@}

    /**
     * @name EnsembleContext
     *
     * @brief Accessor and modifier functions for the %EnsembleContext
     * sequence element.
     *
     * The ensemble context indicates that the POC MEDICAL DEVICE can provide
     * information about the ensemble(s) that it is associated with. An
     * ensemble represents an arbitrary grouping of POC MEDICAL DEVICE. The
     * semantics depend on the ensemble itself.
     * 
     * A SERVICE PROVIDER SHALL NOT insert or delete the context descriptor
     * ELEMENT during runtime, except when the whole MDS appears/disappears.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::EnsembleContextDescriptor EnsembleContextType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< EnsembleContextType > EnsembleContextSequence;

    /**
     * @brief Element iterator type.
     */
    typedef EnsembleContextSequence::iterator EnsembleContextIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef EnsembleContextSequence::const_iterator EnsembleContextConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EnsembleContextType, char > EnsembleContextTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const EnsembleContextSequence&
    getEnsembleContext () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    EnsembleContextSequence&
    getEnsembleContext ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setEnsembleContext (const EnsembleContextSequence& s);

    //@}

    /**
     * @name OperatorContext
     *
     * @brief Accessor and modifier functions for the %OperatorContext
     * sequence element.
     *
     * The operator context indicates that the POC MEDICAL DEVICE can provide
     * information about the operator(s) that it is associated with.
     * 
     * A SERVICE PROVIDER SHALL NOT insert or delete the context descriptor
     * ELEMENT during runtime, except when the whole MDS appears/disappears.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::OperatorContextDescriptor OperatorContextType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< OperatorContextType > OperatorContextSequence;

    /**
     * @brief Element iterator type.
     */
    typedef OperatorContextSequence::iterator OperatorContextIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef OperatorContextSequence::const_iterator OperatorContextConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OperatorContextType, char > OperatorContextTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const OperatorContextSequence&
    getOperatorContext () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    OperatorContextSequence&
    getOperatorContext ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setOperatorContext (const OperatorContextSequence& s);

    //@}

    /**
     * @name WorkflowContext
     *
     * @brief Accessor and modifier functions for the %WorkflowContext
     * sequence element.
     *
     * The workflow context indicates that the POC MEDICAL DEVICE can provide
     * information about the workflow step(s) that it is associated with.
     * 
     * A SERVICE PROVIDER SHALL NOT insert or delete the context descriptor
     * ELEMENT during runtime, except when the whole MDS appears/disappears.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::WorkflowContextDescriptor WorkflowContextType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< WorkflowContextType > WorkflowContextSequence;

    /**
     * @brief Element iterator type.
     */
    typedef WorkflowContextSequence::iterator WorkflowContextIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef WorkflowContextSequence::const_iterator WorkflowContextConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WorkflowContextType, char > WorkflowContextTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const WorkflowContextSequence&
    getWorkflowContext () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    WorkflowContextSequence&
    getWorkflowContext ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setWorkflowContext (const WorkflowContextSequence& s);

    //@}

    /**
     * @name MeansContext
     *
     * @brief Accessor and modifier functions for the %MeansContext
     * sequence element.
     *
     * The means context indicates that the POC MEDICAL DEVICE can provide
     * information about utilized means.
     * 
     * A SERVICE PROVIDER SHALL NOT insert or delete the context descriptor
     * ELEMENT during runtime, except when the whole MDS appears/disappears.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::MeansContextDescriptor MeansContextType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< MeansContextType > MeansContextSequence;

    /**
     * @brief Element iterator type.
     */
    typedef MeansContextSequence::iterator MeansContextIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef MeansContextSequence::const_iterator MeansContextConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MeansContextType, char > MeansContextTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const MeansContextSequence&
    getMeansContext () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    MeansContextSequence&
    getMeansContext ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setMeansContext (const MeansContextSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SystemContextDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SystemContextDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SystemContextDescriptor (const SystemContextDescriptor& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SystemContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SystemContextDescriptor&
    operator= (const SystemContextDescriptor& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SystemContextDescriptor ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    PatientContextOptional PatientContext_;
    LocationContextOptional LocationContext_;
    EnsembleContextSequence EnsembleContext_;
    OperatorContextSequence OperatorContext_;
    WorkflowContextSequence WorkflowContext_;
    MeansContextSequence MeansContext_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SystemContextState schema type.
   *
   * Corresponding state of pm:SystemContextDescriptor. This state comes
   * with no additional attributes.
   *
   * @nosubgrouping
   */
  class SystemContextState: public ::CDM::AbstractDeviceComponentState
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SystemContextState (const DescriptorHandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SystemContextState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SystemContextState (const SystemContextState& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SystemContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SystemContextState ();
  };

  /**
   * @brief Class corresponding to the %AbstractContextDescriptor schema type.
   *
   * Abstract base class for objects that specify that the MDS is able to
   * provide context information that MAY be of relevance for the state
   * data that is present at the communication interface at a certain point
   * of time or time period.
   *
   * @nosubgrouping
   */
  class AbstractContextDescriptor: public ::CDM::AbstractDescriptor
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AbstractContextDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AbstractContextDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractContextDescriptor (const AbstractContextDescriptor& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AbstractContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AbstractContextDescriptor ();
  };

  /**
   * @brief Enumeration class corresponding to the %ContextAssociation
   * schema type.
   *
   * Defines an association between an arbitrary context and an MDS.
   */
  class ContextAssociation: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * No = Not Associated. There is currently no context information
       * associated, such that there cannot be made any assumptions on the
       * encompassing context.
       */
      No,
      /**
       * Pre = Pre-Associated. Context information is in a pre-association
       * state.
       */
      Pre,
      /**
       * Assoc = Associated. Context information is associated.
       */
      Assoc,
      /**
       * Dis = Disassociated. Context information is no longer associated.
       */
      Dis
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    ContextAssociation (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    ContextAssociation (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    ContextAssociation (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    ContextAssociation (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ContextAssociation (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ContextAssociation (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ContextAssociation (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ContextAssociation (const ContextAssociation& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ContextAssociation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    ContextAssociation&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_ContextAssociation_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_ContextAssociation_convert () const;

    public:
    static const char* const _xsd_ContextAssociation_literals_[4];
    static const Value _xsd_ContextAssociation_indexes_[4];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AbstractContextState schema type.
   *
   * Base type of a context state. Every context state can be identified as
   * valid by a validator instance. Moreover, a context state's lifecycle
   * is determined by a start and end. AbstractContextState bundles these
   * information.
   *
   * @nosubgrouping
   */
  class AbstractContextState: public ::CDM::AbstractMultiState
  {
    public:
    /**
     * @name Validator
     *
     * @brief Accessor and modifier functions for the %Validator
     * sequence element.
     *
     * OPTIONAL list of actors (e.g., persons, devices or any identifiable
     * systems) which have confirmed that a binding of a context state to an
     * MDS is correct.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::InstanceIdentifier ValidatorType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ValidatorType > ValidatorSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ValidatorSequence::iterator ValidatorIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ValidatorSequence::const_iterator ValidatorConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValidatorType, char > ValidatorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ValidatorSequence&
    getValidator () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ValidatorSequence&
    getValidator ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setValidator (const ValidatorSequence& s);

    //@}

    /**
     * @name Identification
     *
     * @brief Accessor and modifier functions for the %Identification
     * sequence element.
     *
     * OPTIONAL ordered list of identifiers for the context. The list is
     * ordered by the position of the identifiers in the list where the
     * ELEMENT with the lower list index has a higher relevance than any
     * entry with a higher list index. The SERVICE PROVIDER defines the
     * relevance and MAY reorder the list at any time.
     * 
     * NOTE 1?Identification can be used to span a communication context
     * between SERVICE PROVIDERs and SERVICE CONSUMERs.
     * NOTE 2?Identification can be empty, e.g., if
     * pm:AbstractContextState/@ContextAssociation is "No".
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::InstanceIdentifier IdentificationType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< IdentificationType > IdentificationSequence;

    /**
     * @brief Element iterator type.
     */
    typedef IdentificationSequence::iterator IdentificationIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef IdentificationSequence::const_iterator IdentificationConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdentificationType, char > IdentificationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const IdentificationSequence&
    getIdentification () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    IdentificationSequence&
    getIdentification ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setIdentification (const IdentificationSequence& s);

    //@}

    /**
     * @name ContextAssociation
     *
     * @brief Accessor and modifier functions for the %ContextAssociation
     * optional attribute.
     *
     * Association of a context. The implied value SHALL be "No".
     * 
     * __R5027: Before a SERVICE PROVIDER decides to remove a specific
     * context state from its MDIB, it SHALL change the context association
     * of that context state to "No".__
     * 
     * NOTE?BICEPS supports no special state removal flag. Therefore, a
     * SERVICE CONSUMER has to rely on the context association in order to
     * decide if a context state can be kept in memory or removed from
    memory. */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::ContextAssociation ContextAssociationType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ContextAssociationType > ContextAssociationOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ContextAssociationType, char > ContextAssociationTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ContextAssociationOptional&
    getContextAssociation () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ContextAssociationOptional&
    getContextAssociation ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setContextAssociation (const ContextAssociationType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setContextAssociation (const ContextAssociationOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setContextAssociation (::std::unique_ptr< ContextAssociationType > p);

    //@}

    /**
     * @name BindingMdibVersion
     *
     * @brief Accessor and modifier functions for the %BindingMdibVersion
     * optional attribute.
     *
     * BindingMdibVersion points to the version of an MDIB when a binding of
     * the context state to an MDS starts.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::ReferencedVersion BindingMdibVersionType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< BindingMdibVersionType > BindingMdibVersionOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< BindingMdibVersionType, char > BindingMdibVersionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const BindingMdibVersionOptional&
    getBindingMdibVersion () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    BindingMdibVersionOptional&
    getBindingMdibVersion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setBindingMdibVersion (const BindingMdibVersionType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setBindingMdibVersion (const BindingMdibVersionOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setBindingMdibVersion (::std::unique_ptr< BindingMdibVersionType > p);

    //@}

    /**
     * @name UnbindingMdibVersion
     *
     * @brief Accessor and modifier functions for the %UnbindingMdibVersion
     * optional attribute.
     *
     * UnbindingMdibVersion points to the version of an MDIB when a binding
     * of a context state to an MDS ends (i.e., the version where the context
     * association was disassociated the first time).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::ReferencedVersion UnbindingMdibVersionType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UnbindingMdibVersionType > UnbindingMdibVersionOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< UnbindingMdibVersionType, char > UnbindingMdibVersionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UnbindingMdibVersionOptional&
    getUnbindingMdibVersion () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    UnbindingMdibVersionOptional&
    getUnbindingMdibVersion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setUnbindingMdibVersion (const UnbindingMdibVersionType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setUnbindingMdibVersion (const UnbindingMdibVersionOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUnbindingMdibVersion (::std::unique_ptr< UnbindingMdibVersionType > p);

    //@}

    /**
     * @name BindingStartTime
     *
     * @brief Accessor and modifier functions for the %BindingStartTime
     * optional attribute.
     *
     * Point in time when a binding of a context state to an MDS starts.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::Timestamp BindingStartTimeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< BindingStartTimeType > BindingStartTimeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< BindingStartTimeType, char > BindingStartTimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const BindingStartTimeOptional&
    getBindingStartTime () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    BindingStartTimeOptional&
    getBindingStartTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setBindingStartTime (const BindingStartTimeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setBindingStartTime (const BindingStartTimeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setBindingStartTime (::std::unique_ptr< BindingStartTimeType > p);

    //@}

    /**
     * @name BindingEndTime
     *
     * @brief Accessor and modifier functions for the %BindingEndTime
     * optional attribute.
     *
     * Point in time when a binding of a context state to an MDS ends.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::Timestamp BindingEndTimeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< BindingEndTimeType > BindingEndTimeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< BindingEndTimeType, char > BindingEndTimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const BindingEndTimeOptional&
    getBindingEndTime () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    BindingEndTimeOptional&
    getBindingEndTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setBindingEndTime (const BindingEndTimeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setBindingEndTime (const BindingEndTimeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setBindingEndTime (::std::unique_ptr< BindingEndTimeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AbstractContextState (const DescriptorHandleType&,
                          const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AbstractContextState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractContextState (const AbstractContextState& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AbstractContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AbstractContextState&
    operator= (const AbstractContextState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AbstractContextState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ValidatorSequence Validator_;
    IdentificationSequence Identification_;
    ContextAssociationOptional ContextAssociation_;
    BindingMdibVersionOptional BindingMdibVersion_;
    UnbindingMdibVersionOptional UnbindingMdibVersion_;
    BindingStartTimeOptional BindingStartTime_;
    BindingEndTimeOptional BindingEndTime_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BaseDemographics schema type.
   *
   * Definition of basic demographic information.
   *
   * @nosubgrouping
   */
  class BaseDemographics: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Givenname
     *
     * @brief Accessor and modifier functions for the %Givenname
     * optional element.
     *
     * Given name of a person.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String GivennameType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< GivennameType > GivennameOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< GivennameType, char > GivennameTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const GivennameOptional&
    getGivenname () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    GivennameOptional&
    getGivenname ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setGivenname (const GivennameType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setGivenname (const GivennameOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setGivenname (::std::unique_ptr< GivennameType > p);

    //@}

    /**
     * @name Middlename
     *
     * @brief Accessor and modifier functions for the %Middlename
     * sequence element.
     *
     * Middle name of a person.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String MiddlenameType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< MiddlenameType > MiddlenameSequence;

    /**
     * @brief Element iterator type.
     */
    typedef MiddlenameSequence::iterator MiddlenameIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef MiddlenameSequence::const_iterator MiddlenameConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MiddlenameType, char > MiddlenameTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const MiddlenameSequence&
    getMiddlename () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    MiddlenameSequence&
    getMiddlename ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setMiddlename (const MiddlenameSequence& s);

    //@}

    /**
     * @name Familyname
     *
     * @brief Accessor and modifier functions for the %Familyname
     * optional element.
     *
     * Family name of a person.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String FamilynameType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FamilynameType > FamilynameOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FamilynameType, char > FamilynameTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FamilynameOptional&
    getFamilyname () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FamilynameOptional&
    getFamilyname ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFamilyname (const FamilynameType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFamilyname (const FamilynameOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFamilyname (::std::unique_ptr< FamilynameType > p);

    //@}

    /**
     * @name Birthname
     *
     * @brief Accessor and modifier functions for the %Birthname
     * optional element.
     *
     * Birth name of a person.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String BirthnameType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< BirthnameType > BirthnameOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BirthnameType, char > BirthnameTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const BirthnameOptional&
    getBirthname () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    BirthnameOptional&
    getBirthname ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBirthname (const BirthnameType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setBirthname (const BirthnameOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setBirthname (::std::unique_ptr< BirthnameType > p);

    //@}

    /**
     * @name Title
     *
     * @brief Accessor and modifier functions for the %Title
     * optional element.
     *
     * Title of a person.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String TitleType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TitleType > TitleOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TitleType, char > TitleTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TitleOptional&
    getTitle () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TitleOptional&
    getTitle ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTitle (const TitleType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTitle (const TitleOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTitle (::std::unique_ptr< TitleType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BaseDemographics ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BaseDemographics (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseDemographics (const BaseDemographics& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BaseDemographics*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BaseDemographics&
    operator= (const BaseDemographics& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BaseDemographics ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    GivennameOptional Givenname_;
    MiddlenameSequence Middlename_;
    FamilynameOptional Familyname_;
    BirthnameOptional Birthname_;
    TitleOptional Title_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PersonReference schema type.
   *
   * A reference to an identifiable person with a name.
   *
   * @nosubgrouping
   */
  class PersonReference: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Identification
     *
     * @brief Accessor and modifier functions for the %Identification
     * sequence element.
     *
     * The list of identifiers for the person.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::InstanceIdentifier IdentificationType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< IdentificationType > IdentificationSequence;

    /**
     * @brief Element iterator type.
     */
    typedef IdentificationSequence::iterator IdentificationIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef IdentificationSequence::const_iterator IdentificationConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdentificationType, char > IdentificationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const IdentificationSequence&
    getIdentification () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    IdentificationSequence&
    getIdentification ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setIdentification (const IdentificationSequence& s);

    //@}

    /**
     * @name Name
     *
     * @brief Accessor and modifier functions for the %Name
     * optional element.
     *
     * The name of the person.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::BaseDemographics NameType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PersonReference ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PersonReference (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PersonReference (const PersonReference& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PersonReference*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PersonReference&
    operator= (const PersonReference& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PersonReference ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    IdentificationSequence Identification_;
    NameOptional Name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LocationDetail schema type.
   *
   * Details about a location. This information is derived from the HL7
   * PV1-3 PL.
   *
   * @nosubgrouping
   */
  class LocationDetail: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name PoC
     *
     * @brief Accessor and modifier functions for the %PoC
     * optional attribute.
     *
     * Name of a point of care unit, e.g., nursing unit, department, or
     * clinic.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String PoCType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PoCType > PoCOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< PoCType, char > PoCTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PoCOptional&
    getPoC () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    PoCOptional&
    getPoC ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setPoC (const PoCType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setPoC (const PoCOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPoC (::std::unique_ptr< PoCType > p);

    //@}

    /**
     * @name Room
     *
     * @brief Accessor and modifier functions for the %Room
     * optional attribute.
     *
     * Name of the room of a location.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String RoomType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RoomType > RoomOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RoomType, char > RoomTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RoomOptional&
    getRoom () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    RoomOptional&
    getRoom ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRoom (const RoomType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setRoom (const RoomOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRoom (::std::unique_ptr< RoomType > p);

    //@}

    /**
     * @name Bed
     *
     * @brief Accessor and modifier functions for the %Bed
     * optional attribute.
     *
     * Name of the bed of a location.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String BedType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< BedType > BedOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< BedType, char > BedTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const BedOptional&
    getBed () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    BedOptional&
    getBed ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setBed (const BedType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setBed (const BedOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setBed (::std::unique_ptr< BedType > p);

    //@}

    /**
     * @name Facility
     *
     * @brief Accessor and modifier functions for the %Facility
     * optional attribute.
     *
     * Name of the facility of a location.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String FacilityType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FacilityType > FacilityOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< FacilityType, char > FacilityTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FacilityOptional&
    getFacility () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    FacilityOptional&
    getFacility ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setFacility (const FacilityType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setFacility (const FacilityOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFacility (::std::unique_ptr< FacilityType > p);

    //@}

    /**
     * @name Building
     *
     * @brief Accessor and modifier functions for the %Building
     * optional attribute.
     *
     * Name of the building of a location.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String BuildingType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< BuildingType > BuildingOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< BuildingType, char > BuildingTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const BuildingOptional&
    getBuilding () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    BuildingOptional&
    getBuilding ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setBuilding (const BuildingType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setBuilding (const BuildingOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setBuilding (::std::unique_ptr< BuildingType > p);

    //@}

    /**
     * @name Floor
     *
     * @brief Accessor and modifier functions for the %Floor
     * optional attribute.
     *
     * Name of the floor of a building.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String FloorType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FloorType > FloorOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< FloorType, char > FloorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FloorOptional&
    getFloor () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    FloorOptional&
    getFloor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setFloor (const FloorType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setFloor (const FloorOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFloor (::std::unique_ptr< FloorType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LocationDetail ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LocationDetail (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LocationDetail (const LocationDetail& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LocationDetail*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LocationDetail&
    operator= (const LocationDetail& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LocationDetail ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    PoCOptional PoC_;
    RoomOptional Room_;
    BedOptional Bed_;
    FacilityOptional Facility_;
    BuildingOptional Building_;
    FloorOptional Floor_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PatientContextDescriptor schema type.
   *
   * Context descriptor to specify that the MDS possesses a patient-device
   * association.
   *
   * @nosubgrouping
   */
  class PatientContextDescriptor: public ::CDM::AbstractContextDescriptor
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PatientContextDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PatientContextDescriptor (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PatientContextDescriptor (const PatientContextDescriptor& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PatientContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PatientContextDescriptor ();
  };

  /**
   * @brief Enumeration class corresponding to the %Sex
   * schema type.
   *
   * Sex of a human. 
   * 
   * "Sex" refers to the biological and physiological characteristics that
   * define men and women, while "Gender" refers to the socially
   * constructed roles, behaviors, activities, and attributes that a given
   * society considers appropriate for men and women. See
   * http://www.who.int/gender/whatisgender/en/index.html.
   * 
   * NOTE?ISO/IEC 5218:2004 defines four CODEs that represent human sexes.
   */
  class Sex: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Unspec = Unspecified. Sex is not designated.
       */
      Unspec,
      /**
       * M = Male. Indicates a male patient.
       */
      M,
      /**
       * F = Female. Indicates a female patient.
       */
      F,
      /**
       * Unkn = Unknown. Indicates that the sex is unknown for different
       * reasons.
       */
      Unkn
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Sex (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Sex (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Sex (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Sex (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Sex (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Sex (const ::xercesc::DOMAttr& a,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Sex (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Sex (const Sex& x,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Sex*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Sex&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Sex_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Sex_convert () const;

    public:
    static const char* const _xsd_Sex_literals_[4];
    static const Value _xsd_Sex_indexes_[4];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %PatientType
   * schema type.
   *
   * Type of a patient.
   */
  class PatientType: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Unspec = Unspecified. Unspecified type.
       */
      Unspec,
      /**
       * Ad = Adult. Indicates an adult patient.
       */
      Ad,
      /**
       * Ado = Adolescent. Indicates an adolescent patient with approximate age
       * range of 12 years to 21 years.
       */
      Ado,
      /**
       * Ped = Pediatric. Indicates a pediatric patient with approximate age
       * range of 2 years to 12 years.
       */
      Ped,
      /**
       * Inf = Infant. Indicates an infant patient with approximate age range
       * of 1 month to 2 years.
       */
      Inf,
      /**
       * Neo = Neonatal. Indicates a neonatal patient with approximate age
       * range of birth to 1 month.
       */
      Neo,
      /**
       * Oth = Other. The patient type is designated by some other means.
       */
      Oth
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    PatientType (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    PatientType (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    PatientType (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    PatientType (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PatientType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PatientType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PatientType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PatientType (const PatientType& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PatientType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    PatientType&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_PatientType_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_PatientType_convert () const;

    public:
    static const char* const _xsd_PatientType_literals_[7];
    static const Value _xsd_PatientType_indexes_[7];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PatientDemographicsCoreData schema type.
   *
   * The patient demographics data as defined in ISO/IEEE 11073-10201:2004
   * (6.10.1 Patient Demographics object).
   * 
   * __R5012: If the POC MEDICAL DEVICE itself has patient-related
   * observations (e.g., weight, height, etc.) as in- or output, these
   * SHOULD be modelled as METRICs.__
   * 
   * NOTE?In contrast to PatientDemographicsCoreData, METRICs provide a
   * sophisticated observation description, e.g., regarding quality and
   * time-related attributes.
   * 
   * __R5013: The pm:PatientDemographicsCoreData type is intended to be
   * used for information purposes only. Whenever a value is available, it
   * is considered as valid. Invalid values SHALL not be transmitted.__
   *
   * @nosubgrouping
   */
  class PatientDemographicsCoreData: public ::CDM::BaseDemographics
  {
    public:
    /**
     * @name Sex
     *
     * @brief Accessor and modifier functions for the %Sex
     * optional element.
     *
     * Sex of the patient.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Sex SexType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SexType > SexOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SexType, char > SexTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SexOptional&
    getSex () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SexOptional&
    getSex ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSex (const SexType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSex (const SexOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSex (::std::unique_ptr< SexType > p);

    //@}

    /**
     * @name PatientType
     *
     * @brief Accessor and modifier functions for the %PatientType
     * optional element.
     *
     * Category of the patient. It refers to the ISO/IEEE 11073-10201:2004
     * PatientType.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::PatientType PatientTypeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PatientTypeType > PatientTypeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PatientTypeType, char > PatientTypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PatientTypeOptional&
    getPatientType () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PatientTypeOptional&
    getPatientType ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPatientType (const PatientTypeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPatientType (const PatientTypeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPatientType (::std::unique_ptr< PatientTypeType > p);

    //@}

    /**
     * @name DateOfBirth
     *
     * @brief Accessor and modifier functions for the %DateOfBirth
     * optional element.
     *
     * Date of birth of the patient.
     * 
     * If the timepoint of birth matters, the value SHALL be populated with a
     * time zone.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::DateOfBirth DateOfBirthType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DateOfBirthType > DateOfBirthOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DateOfBirthType, char > DateOfBirthTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DateOfBirthOptional&
    getDateOfBirth () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DateOfBirthOptional&
    getDateOfBirth ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDateOfBirth (const DateOfBirthType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDateOfBirth (const DateOfBirthOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDateOfBirth (::std::unique_ptr< DateOfBirthType > p);

    //@}

    /**
     * @name Height
     *
     * @brief Accessor and modifier functions for the %Height
     * optional element.
     *
     * Height of the patient.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Measurement HeightType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< HeightType > HeightOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HeightType, char > HeightTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const HeightOptional&
    getHeight () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    HeightOptional&
    getHeight ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHeight (const HeightType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setHeight (const HeightOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setHeight (::std::unique_ptr< HeightType > p);

    //@}

    /**
     * @name Weight
     *
     * @brief Accessor and modifier functions for the %Weight
     * optional element.
     *
     * Weight of the patient.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Measurement WeightType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< WeightType > WeightOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeightType, char > WeightTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const WeightOptional&
    getWeight () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    WeightOptional&
    getWeight ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWeight (const WeightType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWeight (const WeightOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setWeight (::std::unique_ptr< WeightType > p);

    //@}

    /**
     * @name Race
     *
     * @brief Accessor and modifier functions for the %Race
     * optional element.
     *
     * Race of the patient.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue RaceType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RaceType > RaceOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RaceType, char > RaceTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RaceOptional&
    getRace () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RaceOptional&
    getRace ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRace (const RaceType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRace (const RaceOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRace (::std::unique_ptr< RaceType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PatientDemographicsCoreData ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PatientDemographicsCoreData (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PatientDemographicsCoreData (const PatientDemographicsCoreData& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PatientDemographicsCoreData*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PatientDemographicsCoreData&
    operator= (const PatientDemographicsCoreData& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PatientDemographicsCoreData ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SexOptional Sex_;
    PatientTypeOptional PatientType_;
    DateOfBirthOptional DateOfBirth_;
    HeightOptional Height_;
    WeightOptional Weight_;
    RaceOptional Race_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %NeonatalPatientDemographicsCoreData schema type.
   *
   * NeonatalPatientDemographicsCoreData constitutes patient demographics
   * for neonates.
   *
   * @nosubgrouping
   */
  class NeonatalPatientDemographicsCoreData: public ::CDM::PatientDemographicsCoreData
  {
    public:
    /**
     * @name GestationalAge
     *
     * @brief Accessor and modifier functions for the %GestationalAge
     * optional element.
     *
     * Gestational age.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Measurement GestationalAgeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< GestationalAgeType > GestationalAgeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< GestationalAgeType, char > GestationalAgeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const GestationalAgeOptional&
    getGestationalAge () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    GestationalAgeOptional&
    getGestationalAge ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setGestationalAge (const GestationalAgeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setGestationalAge (const GestationalAgeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setGestationalAge (::std::unique_ptr< GestationalAgeType > p);

    //@}

    /**
     * @name BirthLength
     *
     * @brief Accessor and modifier functions for the %BirthLength
     * optional element.
     *
     * Patient length at birth time.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Measurement BirthLengthType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< BirthLengthType > BirthLengthOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BirthLengthType, char > BirthLengthTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const BirthLengthOptional&
    getBirthLength () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    BirthLengthOptional&
    getBirthLength ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBirthLength (const BirthLengthType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setBirthLength (const BirthLengthOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setBirthLength (::std::unique_ptr< BirthLengthType > p);

    //@}

    /**
     * @name BirthWeight
     *
     * @brief Accessor and modifier functions for the %BirthWeight
     * optional element.
     *
     * Patient weight at birth time.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Measurement BirthWeightType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< BirthWeightType > BirthWeightOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BirthWeightType, char > BirthWeightTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const BirthWeightOptional&
    getBirthWeight () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    BirthWeightOptional&
    getBirthWeight ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBirthWeight (const BirthWeightType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setBirthWeight (const BirthWeightOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setBirthWeight (::std::unique_ptr< BirthWeightType > p);

    //@}

    /**
     * @name HeadCircumference
     *
     * @brief Accessor and modifier functions for the %HeadCircumference
     * optional element.
     *
     * Head circumference at birth time.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Measurement HeadCircumferenceType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< HeadCircumferenceType > HeadCircumferenceOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HeadCircumferenceType, char > HeadCircumferenceTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const HeadCircumferenceOptional&
    getHeadCircumference () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    HeadCircumferenceOptional&
    getHeadCircumference ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHeadCircumference (const HeadCircumferenceType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setHeadCircumference (const HeadCircumferenceOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setHeadCircumference (::std::unique_ptr< HeadCircumferenceType > p);

    //@}

    /**
     * @name Mother
     *
     * @brief Accessor and modifier functions for the %Mother
     * optional element.
     *
     * Information about the mother of the neonate.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::PersonReference MotherType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MotherType > MotherOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MotherType, char > MotherTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MotherOptional&
    getMother () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MotherOptional&
    getMother ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMother (const MotherType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMother (const MotherOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMother (::std::unique_ptr< MotherType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NeonatalPatientDemographicsCoreData ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NeonatalPatientDemographicsCoreData (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NeonatalPatientDemographicsCoreData (const NeonatalPatientDemographicsCoreData& x,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NeonatalPatientDemographicsCoreData*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NeonatalPatientDemographicsCoreData&
    operator= (const NeonatalPatientDemographicsCoreData& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NeonatalPatientDemographicsCoreData ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    GestationalAgeOptional GestationalAge_;
    BirthLengthOptional BirthLength_;
    BirthWeightOptional BirthWeight_;
    HeadCircumferenceOptional HeadCircumference_;
    MotherOptional Mother_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PatientContextState schema type.
   *
   * Observed information about a patient, e.g., demographics.
   * 
   * NOTE?PatientContextState contains information that is typical for a
   * header in an anamnesis questionnaire.
   *
   * @nosubgrouping
   */
  class PatientContextState: public ::CDM::AbstractContextState
  {
    public:
    /**
     * @name CoreData
     *
     * @brief Accessor and modifier functions for the %CoreData
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::PatientDemographicsCoreData CoreDataType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CoreDataType > CoreDataOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CoreDataType, char > CoreDataTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CoreDataOptional&
    getCoreData () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CoreDataOptional&
    getCoreData ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCoreData (const CoreDataType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCoreData (const CoreDataOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCoreData (::std::unique_ptr< CoreDataType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PatientContextState (const DescriptorHandleType&,
                         const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PatientContextState (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PatientContextState (const PatientContextState& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PatientContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PatientContextState&
    operator= (const PatientContextState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PatientContextState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CoreDataOptional CoreData_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LocationContextDescriptor schema type.
   *
   * Context descriptor to specify that the MDS is able to provide
   * information regarding the current spatial position.
   *
   * @nosubgrouping
   */
  class LocationContextDescriptor: public ::CDM::AbstractContextDescriptor
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LocationContextDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LocationContextDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LocationContextDescriptor (const LocationContextDescriptor& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LocationContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LocationContextDescriptor ();
  };

  /**
   * @brief Class corresponding to the %LocationContextState schema type.
   *
   * A context state that identifies a location in a hospital.
   *
   * @nosubgrouping
   */
  class LocationContextState: public ::CDM::AbstractContextState
  {
    public:
    /**
     * @name LocationDetail
     *
     * @brief Accessor and modifier functions for the %LocationDetail
     * optional element.
     *
     * LocationDetail provides human-readable detailed location information.
     * LocationDetail SHOULD NOT be used to form location-based logical
     * systems of devices.
     * 
     * NOTE?Instead, pm:AbstractContextState/pm:Identification can be used to
     * build logical groupings.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::LocationDetail LocationDetailType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LocationDetailType > LocationDetailOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LocationDetailType, char > LocationDetailTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LocationDetailOptional&
    getLocationDetail () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LocationDetailOptional&
    getLocationDetail ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLocationDetail (const LocationDetailType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLocationDetail (const LocationDetailOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLocationDetail (::std::unique_ptr< LocationDetailType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LocationContextState (const DescriptorHandleType&,
                          const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LocationContextState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LocationContextState (const LocationContextState& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LocationContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LocationContextState&
    operator= (const LocationContextState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LocationContextState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    LocationDetailOptional LocationDetail_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %WorkflowContextDescriptor schema type.
   *
   * Context descriptor to specify that the MDS is able to provide workflow
   * information.
   *
   * @nosubgrouping
   */
  class WorkflowContextDescriptor: public ::CDM::AbstractContextDescriptor
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    WorkflowContextDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    WorkflowContextDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    WorkflowContextDescriptor (const WorkflowContextDescriptor& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual WorkflowContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~WorkflowContextDescriptor ();
  };

  /**
   * @brief Class corresponding to the %ClinicalInfo schema type.
   *
   * This type describes a minimal clinical observation.
   *
   * @nosubgrouping
   */
  class ClinicalInfo: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Type
     *
     * @brief Accessor and modifier functions for the %Type
     * optional element.
     *
     * Type of clinical information, e.g., allergy, intolerance, clinical
     * condition, diagnosis, problem, etc.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue TypeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TypeOptional&
    getType () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TypeOptional&
    getType ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setType (const TypeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setType (const TypeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setType (::std::unique_ptr< TypeType > p);

    //@}

    /**
     * @name Code
     *
     * @brief Accessor and modifier functions for the %Code
     * optional element.
     *
     * Code that specifies the kind of the type of observation, e.g., a
     * specific allergy or a specific diagnosis.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue CodeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CodeType > CodeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CodeType, char > CodeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CodeOptional&
    getCode () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CodeOptional&
    getCode ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCode (const CodeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCode (const CodeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCode (::std::unique_ptr< CodeType > p);

    //@}

    /**
     * @name Criticality
     *
     * @brief Accessor and modifier functions for the %Criticality
     * optional element.
     *
     * Potential clinical harm if this clinical information is not considered
     * while treating the patient. The implied value SHALL be "Lo".
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Criticality CriticalityType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CriticalityType > CriticalityOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CriticalityType, char > CriticalityTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CriticalityOptional&
    getCriticality () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CriticalityOptional&
    getCriticality ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCriticality (const CriticalityType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCriticality (const CriticalityOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCriticality (::std::unique_ptr< CriticalityType > p);

    //@}

    /**
     * @name Description
     *
     * @brief Accessor and modifier functions for the %Description
     * sequence element.
     *
     * List of possible (localized) free text descriptions of the clinical
     * information.
     * 
     * If a pm:CodedValue for this clinical information is available, it is
     * encouraged to be set as pm:ClinicalInfo/pm:Code.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::LocalizedText DescriptionType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DescriptionType > DescriptionSequence;

    /**
     * @brief Element iterator type.
     */
    typedef DescriptionSequence::iterator DescriptionIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef DescriptionSequence::const_iterator DescriptionConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DescriptionType, char > DescriptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DescriptionSequence&
    getDescription () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DescriptionSequence&
    getDescription ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDescription (const DescriptionSequence& s);

    //@}

    /**
     * @name RelatedMeasurement
     *
     * @brief Accessor and modifier functions for the %RelatedMeasurement
     * sequence element.
     *
     * Related measurements for this clinical observation if applicable.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::RelatedMeasurement RelatedMeasurementType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< RelatedMeasurementType > RelatedMeasurementSequence;

    /**
     * @brief Element iterator type.
     */
    typedef RelatedMeasurementSequence::iterator RelatedMeasurementIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef RelatedMeasurementSequence::const_iterator RelatedMeasurementConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RelatedMeasurementType, char > RelatedMeasurementTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const RelatedMeasurementSequence&
    getRelatedMeasurement () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    RelatedMeasurementSequence&
    getRelatedMeasurement ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setRelatedMeasurement (const RelatedMeasurementSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ClinicalInfo ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ClinicalInfo (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ClinicalInfo (const ClinicalInfo& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ClinicalInfo*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ClinicalInfo&
    operator= (const ClinicalInfo& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ClinicalInfo ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    TypeOptional Type_;
    CodeOptional Code_;
    CriticalityOptional Criticality_;
    DescriptionSequence Description_;
    RelatedMeasurementSequence RelatedMeasurement_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ImagingProcedure schema type.
   *
   * ImagingProcedure provides identifiers used by the DICOM and HL7
   * standard to identify the requested imaging procedures resulting from
   * an order in a the hospital. Often these identifiers are
   * created/assigned by the main hospital information system or
   * departmental information systems and are taken over into any medical
   * images by DICOM equipment in the context of this procedure.
   * The listed ELEMENTs have been taken over from the IHE Radiology
   * Technical Framework's RAD-4 transaction ("Procedure Scheduled") and
   * re-uses the identifiers listed for the HL7 Version 2.5.1 IPC segment
   * group of the OBR segment. Therefore, it is recommended to comply to
   * the underlying HL7 and DICOM data types in order to have seamless
   * integration with other clinical IT such as DICOM modalities or image
   * archives (PACS).
   * 
   * In order to comply to the hierarchy behind the given identifiers, the
   * following rules (taken from IHE) SHALL apply: if a Requested Procedure
   * is comprised of multiple Scheduled Procedure Steps and/or if a
   * Scheduled Procedure Step is comprised of multiple Protocol Codes, each
   * applicable Scheduled Procedure Step / Protocol Code combination is
   * included as a separate ProcedureDetails structure, i.e., the complex
   * type "ProcedureDetails" occurs the same amount of times as there are
   * different Scheduled Procedure Step IDs plus the amount of different
   * Scheduled Procedure Step / Protocol Code combinations.
   *
   * @nosubgrouping
   */
  class ImagingProcedure: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name AccessionIdentifier
     *
     * @brief Accessor and modifier functions for the %AccessionIdentifier
     * required element.
     *
     * The Accession Identifier (in DICOM "Accession ID") is an identifier of
     * an "Imaging Service Request", and is (in this ProcedureDetails
     * context) at the top of the hierarchy. A limit of sixteen (16)
     * characters is required to allow compatibility with DICOM.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::InstanceIdentifier AccessionIdentifierType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AccessionIdentifierType, char > AccessionIdentifierTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AccessionIdentifierType&
    getAccessionIdentifier () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AccessionIdentifierType&
    getAccessionIdentifier ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAccessionIdentifier (const AccessionIdentifierType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setAccessionIdentifier (::std::unique_ptr< AccessionIdentifierType > p);

    //@}

    /**
     * @name RequestedProcedureId
     *
     * @brief Accessor and modifier functions for the %RequestedProcedureId
     * required element.
     *
     * An pm:ImagingProcedure/pm:AccessionIdentifier can result in various
     * Requested Procedures, each identified uniquely (within the context of
     * the pm:ImagingProcedure/pm:AccessionIdentifier) through a
     * RequestedProcedureID. A limit of sixteen (16) characters is required
     * to allow compatibility with DICOM.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::InstanceIdentifier RequestedProcedureIdType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RequestedProcedureIdType, char > RequestedProcedureIdTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const RequestedProcedureIdType&
    getRequestedProcedureId () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    RequestedProcedureIdType&
    getRequestedProcedureId ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRequestedProcedureId (const RequestedProcedureIdType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRequestedProcedureId (::std::unique_ptr< RequestedProcedureIdType > p);

    //@}

    /**
     * @name StudyInstanceUid
     *
     * @brief Accessor and modifier functions for the %StudyInstanceUid
     * required element.
     *
     * The Study Instance UID is a world-wide unique identifier used by DICOM
     * modalities to group together images in a so-called Study. This
     * grouping is REQUIRED. Under the Study, the modality creates one or
     * more so-called Series which again contain the images. The Series
     * identification ("Series Instance UID") is part of the Procedure
     * Details which refer to a planning process, since a modality is
     * responsible to decide how many Series are created and how their
     * identifiers should look like.
     * A limit of sixty-four (64) characters is required to allow
     * compatibility with DICOM, with only numbers and dot characters
     * permitted (e.g. 1.2.134124.4.12.34).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::InstanceIdentifier StudyInstanceUidType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StudyInstanceUidType, char > StudyInstanceUidTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const StudyInstanceUidType&
    getStudyInstanceUid () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    StudyInstanceUidType&
    getStudyInstanceUid ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStudyInstanceUid (const StudyInstanceUidType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStudyInstanceUid (::std::unique_ptr< StudyInstanceUidType > p);

    //@}

    /**
     * @name ScheduledProcedureStepId
     *
     * @brief Accessor and modifier functions for the %ScheduledProcedureStepId
     * required element.
     *
     * Under a Study (i.e. a Study Instance UID), a Procedure reflected by
     * these ProcedureDetails can be planned in a finer granularity by
     * scheduling different steps that should be performed (usually at a
     * DICOM modality), the so-called "Scheduled Procedure Step"s. Each of
     * these steps is identified by a Scheduled Procedure Step ID. A limit of
     * sixteen (16) characters is required to allow compatibility with DICOM.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::InstanceIdentifier ScheduledProcedureStepIdType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ScheduledProcedureStepIdType, char > ScheduledProcedureStepIdTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ScheduledProcedureStepIdType&
    getScheduledProcedureStepId () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ScheduledProcedureStepIdType&
    getScheduledProcedureStepId ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setScheduledProcedureStepId (const ScheduledProcedureStepIdType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setScheduledProcedureStepId (::std::unique_ptr< ScheduledProcedureStepIdType > p);

    //@}

    /**
     * @name Modality
     *
     * @brief Accessor and modifier functions for the %Modality
     * optional element.
     *
     * The field modality describes the type of equipment (usually DICOM
     * equipment) used. DICOM offers a list of short identifiers for
     * different device categories, e.g. CT for "Computer Tomography" or US
     * for "Ultrasound". It is advised to follow the list of terms defined in
     * the DICOM standard part 3. A limit of sixteen (16) characters for the
     * first component is required to allow compatibility with DICOM.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue ModalityType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ModalityType > ModalityOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ModalityType, char > ModalityTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ModalityOptional&
    getModality () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ModalityOptional&
    getModality ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setModality (const ModalityType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setModality (const ModalityOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setModality (::std::unique_ptr< ModalityType > p);

    //@}

    /**
     * @name ProtocolCode
     *
     * @brief Accessor and modifier functions for the %ProtocolCode
     * optional element.
     *
     * Below each Scheduled Procedure Step the work can be defined in more
     * detail by defining one or more Protocol Codes under it. A limit of
     * sixteen (16) characters for the first component and sixty-four (64)
     * characters for the second component is required to allow compatibility
     * with DICOM.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue ProtocolCodeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ProtocolCodeType > ProtocolCodeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ProtocolCodeType, char > ProtocolCodeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ProtocolCodeOptional&
    getProtocolCode () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ProtocolCodeOptional&
    getProtocolCode ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setProtocolCode (const ProtocolCodeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setProtocolCode (const ProtocolCodeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setProtocolCode (::std::unique_ptr< ProtocolCodeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ImagingProcedure (const AccessionIdentifierType&,
                      const RequestedProcedureIdType&,
                      const StudyInstanceUidType&,
                      const ScheduledProcedureStepIdType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ImagingProcedure (::std::unique_ptr< AccessionIdentifierType >,
                      ::std::unique_ptr< RequestedProcedureIdType >,
                      ::std::unique_ptr< StudyInstanceUidType >,
                      ::std::unique_ptr< ScheduledProcedureStepIdType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ImagingProcedure (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ImagingProcedure (const ImagingProcedure& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ImagingProcedure*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ImagingProcedure&
    operator= (const ImagingProcedure& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ImagingProcedure ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< AccessionIdentifierType > AccessionIdentifier_;
    ::xsd::cxx::tree::one< RequestedProcedureIdType > RequestedProcedureId_;
    ::xsd::cxx::tree::one< StudyInstanceUidType > StudyInstanceUid_;
    ::xsd::cxx::tree::one< ScheduledProcedureStepIdType > ScheduledProcedureStepId_;
    ModalityOptional Modality_;
    ProtocolCodeOptional ProtocolCode_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LocationReference schema type.
   *
   * A reference to an identifiable location with human readable location
   * details.
   *
   * @nosubgrouping
   */
  class LocationReference: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Identification
     *
     * @brief Accessor and modifier functions for the %Identification
     * sequence element.
     *
     * The list of identifiers for the location.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::InstanceIdentifier IdentificationType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< IdentificationType > IdentificationSequence;

    /**
     * @brief Element iterator type.
     */
    typedef IdentificationSequence::iterator IdentificationIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef IdentificationSequence::const_iterator IdentificationConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdentificationType, char > IdentificationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const IdentificationSequence&
    getIdentification () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    IdentificationSequence&
    getIdentification ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setIdentification (const IdentificationSequence& s);

    //@}

    /**
     * @name LocationDetail
     *
     * @brief Accessor and modifier functions for the %LocationDetail
     * optional element.
     *
     * Human readable location details which are intended for information
     * purposes only.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::LocationDetail LocationDetailType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LocationDetailType > LocationDetailOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LocationDetailType, char > LocationDetailTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LocationDetailOptional&
    getLocationDetail () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LocationDetailOptional&
    getLocationDetail ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLocationDetail (const LocationDetailType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLocationDetail (const LocationDetailOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLocationDetail (::std::unique_ptr< LocationDetailType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LocationReference ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LocationReference (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LocationReference (const LocationReference& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LocationReference*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LocationReference&
    operator= (const LocationReference& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LocationReference ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    IdentificationSequence Identification_;
    LocationDetailOptional LocationDetail_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OrderDetail schema type.
   *
   * Details of an order that will be performed or that has been performed.
   *
   * @nosubgrouping
   */
  class OrderDetail: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Start
     *
     * @brief Accessor and modifier functions for the %Start
     * optional element.
     *
     * Data for start of requested/performed procedure.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::DateTime StartType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StartType > StartOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StartType, char > StartTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StartOptional&
    getStart () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    StartOptional&
    getStart ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStart (const StartType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setStart (const StartOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStart (::std::unique_ptr< StartType > p);

    //@}

    /**
     * @name End
     *
     * @brief Accessor and modifier functions for the %End
     * optional element.
     *
     * Data for end of requested/performed procedure.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::DateTime EndType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< EndType > EndOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EndType, char > EndTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const EndOptional&
    getEnd () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    EndOptional&
    getEnd ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEnd (const EndType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setEnd (const EndOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setEnd (::std::unique_ptr< EndType > p);

    //@}

    /**
     * @name Performer
     *
     * @brief Accessor and modifier functions for the %Performer
     * sequence element.
     *
     * Names with roles of attending staff.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::PersonParticipation PerformerType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< PerformerType > PerformerSequence;

    /**
     * @brief Element iterator type.
     */
    typedef PerformerSequence::iterator PerformerIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef PerformerSequence::const_iterator PerformerConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PerformerType, char > PerformerTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const PerformerSequence&
    getPerformer () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    PerformerSequence&
    getPerformer ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setPerformer (const PerformerSequence& s);

    //@}

    /**
     * @name Service
     *
     * @brief Accessor and modifier functions for the %Service
     * sequence element.
     *
     * Identifier and textual descriptions of requested/performed procedures
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue ServiceType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ServiceType > ServiceSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ServiceSequence::iterator ServiceIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ServiceSequence::const_iterator ServiceConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ServiceType, char > ServiceTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ServiceSequence&
    getService () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ServiceSequence&
    getService ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setService (const ServiceSequence& s);

    //@}

    /**
     * @name ImagingProcedure
     *
     * @brief Accessor and modifier functions for the %ImagingProcedure
     * sequence element.
     *
     * ImagingProcedure provide identifiers used by the DICOM and HL7
     * standard to identify the requested imaging procedures resulting from
     * an order in a the hospital.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::ImagingProcedure ImagingProcedureType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ImagingProcedureType > ImagingProcedureSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ImagingProcedureSequence::iterator ImagingProcedureIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ImagingProcedureSequence::const_iterator ImagingProcedureConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ImagingProcedureType, char > ImagingProcedureTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ImagingProcedureSequence&
    getImagingProcedure () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ImagingProcedureSequence&
    getImagingProcedure ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setImagingProcedure (const ImagingProcedureSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OrderDetail ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OrderDetail (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OrderDetail (const OrderDetail& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OrderDetail*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OrderDetail&
    operator= (const OrderDetail& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OrderDetail ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    StartOptional Start_;
    EndOptional End_;
    PerformerSequence Performer_;
    ServiceSequence Service_;
    ImagingProcedureSequence ImagingProcedure_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PersonParticipation schema type.
   *
   * A reference to an identifiable person with a name that participates in
   * a role.
   *
   * @nosubgrouping
   */
  class PersonParticipation: public ::CDM::PersonReference
  {
    public:
    /**
     * @name Role
     *
     * @brief Accessor and modifier functions for the %Role
     * sequence element.
     *
     * Roles the referenced person acts in the relationship.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue RoleType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< RoleType > RoleSequence;

    /**
     * @brief Element iterator type.
     */
    typedef RoleSequence::iterator RoleIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef RoleSequence::const_iterator RoleConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RoleType, char > RoleTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const RoleSequence&
    getRole () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    RoleSequence&
    getRole ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setRole (const RoleSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PersonParticipation ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PersonParticipation (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PersonParticipation (const PersonParticipation& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PersonParticipation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PersonParticipation&
    operator= (const PersonParticipation& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PersonParticipation ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    RoleSequence Role_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %WorkflowContextState schema type.
   *
   * A context state to identify a step in a clinical workflow.
   *
   * @nosubgrouping
   */
  class WorkflowContextState: public ::CDM::AbstractContextState
  {
    public:
    /**
     * @name WorkflowDetail
     *
     * @brief Accessor and modifier functions for the %WorkflowDetail
     * optional element.
     *
     * A workflow step for a clinical treatment or diagnostic procedure or
     * monitoring procedure.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::WorkflowDetail WorkflowDetailType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< WorkflowDetailType > WorkflowDetailOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WorkflowDetailType, char > WorkflowDetailTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const WorkflowDetailOptional&
    getWorkflowDetail () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    WorkflowDetailOptional&
    getWorkflowDetail ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWorkflowDetail (const WorkflowDetailType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWorkflowDetail (const WorkflowDetailOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setWorkflowDetail (::std::unique_ptr< WorkflowDetailType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    WorkflowContextState (const DescriptorHandleType&,
                          const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    WorkflowContextState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    WorkflowContextState (const WorkflowContextState& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual WorkflowContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    WorkflowContextState&
    operator= (const WorkflowContextState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~WorkflowContextState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    WorkflowDetailOptional WorkflowDetail_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OperatorContextDescriptor schema type.
   *
   * Context descriptor to specify that the MDS is able to provide operator
   * information.
   *
   * @nosubgrouping
   */
  class OperatorContextDescriptor: public ::CDM::AbstractContextDescriptor
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OperatorContextDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OperatorContextDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OperatorContextDescriptor (const OperatorContextDescriptor& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OperatorContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OperatorContextDescriptor ();
  };

  /**
   * @brief Class corresponding to the %OperatorContextState schema type.
   *
   * A context state that identifies an operator of an MDS or a part of it.
   *
   * @nosubgrouping
   */
  class OperatorContextState: public ::CDM::AbstractContextState
  {
    public:
    /**
     * @name OperatorDetails
     *
     * @brief Accessor and modifier functions for the %OperatorDetails
     * optional element.
     *
     * Human-readable details (i.e., name) about the operator.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::BaseDemographics OperatorDetailsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OperatorDetailsType > OperatorDetailsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OperatorDetailsType, char > OperatorDetailsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OperatorDetailsOptional&
    getOperatorDetails () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    OperatorDetailsOptional&
    getOperatorDetails ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setOperatorDetails (const OperatorDetailsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setOperatorDetails (const OperatorDetailsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setOperatorDetails (::std::unique_ptr< OperatorDetailsType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OperatorContextState (const DescriptorHandleType&,
                          const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OperatorContextState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OperatorContextState (const OperatorContextState& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OperatorContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OperatorContextState&
    operator= (const OperatorContextState& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OperatorContextState ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    OperatorDetailsOptional OperatorDetails_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MeansContextDescriptor schema type.
   *
   * Context descriptor to specify that the MDS is able to provide
   * information about utilized means.
   *
   * @nosubgrouping
   */
  class MeansContextDescriptor: public ::CDM::AbstractContextDescriptor
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MeansContextDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MeansContextDescriptor (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MeansContextDescriptor (const MeansContextDescriptor& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MeansContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MeansContextDescriptor ();
  };

  /**
   * @brief Class corresponding to the %MeansContextState schema type.
   *
   * A context state to identify a means that is utilized by an MDS or a
   * part of it.
   *
   * @nosubgrouping
   */
  class MeansContextState: public ::CDM::AbstractContextState
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MeansContextState (const DescriptorHandleType&,
                       const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MeansContextState (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MeansContextState (const MeansContextState& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MeansContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MeansContextState ();
  };

  /**
   * @brief Class corresponding to the %EnsembleContextDescriptor schema type.
   *
   * Context descriptor to specify that the MDS is able to provide ensemble
   * information.
   *
   * @nosubgrouping
   */
  class EnsembleContextDescriptor: public ::CDM::AbstractContextDescriptor
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    EnsembleContextDescriptor (const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EnsembleContextDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EnsembleContextDescriptor (const EnsembleContextDescriptor& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual EnsembleContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~EnsembleContextDescriptor ();
  };

  /**
   * @brief Class corresponding to the %EnsembleContextState schema type.
   *
   * A context state that identifies an ensemble of POC MEDICAL DEVICEs.
   * How the ensemble is grouped and what meaning is conveyed by the
   * ensemble, is determined by other means.
   *
   * @nosubgrouping
   */
  class EnsembleContextState: public ::CDM::AbstractContextState
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    EnsembleContextState (const DescriptorHandleType&,
                          const HandleType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EnsembleContextState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EnsembleContextState (const EnsembleContextState& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual EnsembleContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~EnsembleContextState ();
  };

  /**
   * @brief Class corresponding to the %ContainmentTree schema type.
   *
   * CONTAINMENT TREE part of an ELEMENT of an MDS CONTAINMENT TREE.
   *
   * @nosubgrouping
   */
  class ContainmentTree: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Entry
     *
     * @brief Accessor and modifier functions for the %Entry
     * sequence element.
     *
     * An entry of a CONTAINMENT TREE ENTRY.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::ContainmentTreeEntry EntryType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< EntryType > EntrySequence;

    /**
     * @brief Element iterator type.
     */
    typedef EntrySequence::iterator EntryIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef EntrySequence::const_iterator EntryConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EntryType, char > EntryTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const EntrySequence&
    getEntry () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    EntrySequence&
    getEntry ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setEntry (const EntrySequence& s);

    //@}

    /**
     * @name HandleRef
     *
     * @brief Accessor and modifier functions for the %HandleRef
     * optional attribute.
     *
     * Handle reference to the descriptor that the CONTAINMENT TREE entry
     * represents.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::HandleRef HandleRefType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< HandleRefType > HandleRefOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< HandleRefType, char > HandleRefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const HandleRefOptional&
    getHandleRef () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    HandleRefOptional&
    getHandleRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHandleRef (const HandleRefType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHandleRef (const HandleRefOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setHandleRef (::std::unique_ptr< HandleRefType > p);

    //@}

    /**
     * @name ParentHandleRef
     *
     * @brief Accessor and modifier functions for the %ParentHandleRef
     * optional attribute.
     *
     * Handle reference to the parent descriptor of the descriptor that this
     * CONTAINMENT TREE entry represents.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::HandleRef ParentHandleRefType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ParentHandleRefType > ParentHandleRefOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParentHandleRefType, char > ParentHandleRefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ParentHandleRefOptional&
    getParentHandleRef () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ParentHandleRefOptional&
    getParentHandleRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setParentHandleRef (const ParentHandleRefType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setParentHandleRef (const ParentHandleRefOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setParentHandleRef (::std::unique_ptr< ParentHandleRefType > p);

    //@}

    /**
     * @name EntryType
     *
     * @brief Accessor and modifier functions for the %EntryType
     * optional attribute.
     *
     * Qualified name of the descriptor that the CONTAINMENT TREE entry
     * represents.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Qname EntryTypeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< EntryTypeType > EntryTypeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< EntryTypeType, char > EntryTypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const EntryTypeOptional&
    getEntryType () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    EntryTypeOptional&
    getEntryType ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEntryType (const EntryTypeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEntryType (const EntryTypeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setEntryType (::std::unique_ptr< EntryTypeType > p);

    //@}

    /**
     * @name ChildrenCount
     *
     * @brief Accessor and modifier functions for the %ChildrenCount
     * optional attribute.
     *
     * Number of child ELEMENTs that the CONTAINMENT TREE entry possesses.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int ChildrenCountType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ChildrenCountType > ChildrenCountOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ChildrenCountType, char > ChildrenCountTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ChildrenCountOptional&
    getChildrenCount () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ChildrenCountOptional&
    getChildrenCount ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setChildrenCount (const ChildrenCountType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setChildrenCount (const ChildrenCountOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ContainmentTree ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ContainmentTree (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ContainmentTree (const ContainmentTree& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ContainmentTree*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ContainmentTree&
    operator= (const ContainmentTree& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ContainmentTree ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    EntrySequence Entry_;
    HandleRefOptional HandleRef_;
    ParentHandleRefOptional ParentHandleRef_;
    EntryTypeOptional EntryType_;
    ChildrenCountOptional ChildrenCount_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ContainmentTreeEntry schema type.
   *
   * An entry in a CONTAINMENT TREE.
   *
   * @nosubgrouping
   */
  class ContainmentTreeEntry: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Type
     *
     * @brief Accessor and modifier functions for the %Type
     * optional element.
     *
     * If given, pm:AbstractDescriptor/pm:Type of the descriptor that is
     * conveyed with the CONTAINMENT TREE entry.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue TypeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TypeOptional&
    getType () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TypeOptional&
    getType ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setType (const TypeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setType (const TypeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setType (::std::unique_ptr< TypeType > p);

    //@}

    /**
     * @name HandleRef
     *
     * @brief Accessor and modifier functions for the %HandleRef
     * optional attribute.
     *
     * Handle reference to the descriptor that the CONTAINMENT TREE entry
     * represents.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::HandleRef HandleRefType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< HandleRefType > HandleRefOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< HandleRefType, char > HandleRefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const HandleRefOptional&
    getHandleRef () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    HandleRefOptional&
    getHandleRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHandleRef (const HandleRefType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setHandleRef (const HandleRefOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setHandleRef (::std::unique_ptr< HandleRefType > p);

    //@}

    /**
     * @name ParentHandleRef
     *
     * @brief Accessor and modifier functions for the %ParentHandleRef
     * optional attribute.
     *
     * Handle reference to the parent descriptor of the descriptor that this
     * CONTAINMENT TREE entry represents.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::HandleRef ParentHandleRefType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ParentHandleRefType > ParentHandleRefOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParentHandleRefType, char > ParentHandleRefTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ParentHandleRefOptional&
    getParentHandleRef () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ParentHandleRefOptional&
    getParentHandleRef ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setParentHandleRef (const ParentHandleRefType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setParentHandleRef (const ParentHandleRefOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setParentHandleRef (::std::unique_ptr< ParentHandleRefType > p);

    //@}

    /**
     * @name EntryType
     *
     * @brief Accessor and modifier functions for the %EntryType
     * optional attribute.
     *
     * Qualified name of the descriptor that the CONTAINMENT TREE entry
     * represents.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Qname EntryTypeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< EntryTypeType > EntryTypeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< EntryTypeType, char > EntryTypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const EntryTypeOptional&
    getEntryType () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    EntryTypeOptional&
    getEntryType ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEntryType (const EntryTypeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEntryType (const EntryTypeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setEntryType (::std::unique_ptr< EntryTypeType > p);

    //@}

    /**
     * @name ChildrenCount
     *
     * @brief Accessor and modifier functions for the %ChildrenCount
     * optional attribute.
     *
     * Number of child ELEMENTs that the CONTAINMENT TREE entry possesses.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int ChildrenCountType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ChildrenCountType > ChildrenCountOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ChildrenCountType, char > ChildrenCountTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ChildrenCountOptional&
    getChildrenCount () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ChildrenCountOptional&
    getChildrenCount ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setChildrenCount (const ChildrenCountType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setChildrenCount (const ChildrenCountOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ContainmentTreeEntry ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ContainmentTreeEntry (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ContainmentTreeEntry (const ContainmentTreeEntry& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ContainmentTreeEntry*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ContainmentTreeEntry&
    operator= (const ContainmentTreeEntry& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ContainmentTreeEntry ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    TypeOptional Type_;
    HandleRefOptional HandleRef_;
    ParentHandleRefOptional ParentHandleRef_;
    EntryTypeOptional EntryType_;
    ChildrenCountOptional ChildrenCount_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Translation schema type.
   *
   * @nosubgrouping
   */
  class Translation: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Code
     *
     * @brief Accessor and modifier functions for the %Code
     * required attribute.
     *
     * A code as defined by pm:CodedValue/@Code.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::CodeIdentifier CodeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< CodeType, char > CodeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const CodeType&
    getCode () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    CodeType&
    getCode ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setCode (const CodeType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCode (::std::unique_ptr< CodeType > p);

    //@}

    /**
     * @name CodingSystem
     *
     * @brief Accessor and modifier functions for the %CodingSystem
     * optional attribute.
     *
     * A coding system as defined by pm:CodedValue/@CodingSystem.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Uri CodingSystemType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CodingSystemType > CodingSystemOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< CodingSystemType, char > CodingSystemTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CodingSystemOptional&
    getCodingSystem () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    CodingSystemOptional&
    getCodingSystem ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setCodingSystem (const CodingSystemType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setCodingSystem (const CodingSystemOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCodingSystem (::std::unique_ptr< CodingSystemType > p);

    //@}

    /**
     * @name CodingSystemVersion
     *
     * @brief Accessor and modifier functions for the %CodingSystemVersion
     * optional attribute.
     *
     * A coding system version as defined by
     * pm:CodedValue/@CodingSystemVersion.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String CodingSystemVersionType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CodingSystemVersionType > CodingSystemVersionOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< CodingSystemVersionType, char > CodingSystemVersionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CodingSystemVersionOptional&
    getCodingSystemVersion () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    CodingSystemVersionOptional&
    getCodingSystemVersion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setCodingSystemVersion (const CodingSystemVersionType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setCodingSystemVersion (const CodingSystemVersionOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCodingSystemVersion (::std::unique_ptr< CodingSystemVersionType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Translation (const CodeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Translation (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Translation (const Translation& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Translation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Translation&
    operator= (const Translation& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Translation ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< CodeType > Code_;
    CodingSystemOptional CodingSystem_;
    CodingSystemVersionOptional CodingSystemVersion_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Root schema type.
   *
   * @nosubgrouping
   */
  class Root: public ::xml_schema::Uri
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Root (const ::xml_schema::Uri&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Root (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Root (const ::xercesc::DOMAttr& a,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Root (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Root (const Root& x,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Root*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Root ();
  };

  /**
   * @brief Class corresponding to the %Extension schema type.
   *
   * @nosubgrouping
   */
  class Extension: public ::xml_schema::String
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    Extension ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    Extension (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    Extension (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Extension (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Extension (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Extension (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Extension (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Extension (const Extension& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Extension*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Extension ();
  };

  /**
   * @brief Class corresponding to the %ProductionSpecification schema type.
   *
   * @nosubgrouping
   */
  class ProductionSpecification: public ::xml_schema::Type
  {
    public:
    /**
     * @name SpecType
     *
     * @brief Accessor and modifier functions for the %SpecType
     * required element.
     *
     * SpecType is the specification type, such as serial number, part
     * number, hardware revision, software revision, etc.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue SpecTypeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SpecTypeType, char > SpecTypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SpecTypeType&
    getSpecType () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SpecTypeType&
    getSpecType ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSpecType (const SpecTypeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSpecType (::std::unique_ptr< SpecTypeType > p);

    //@}

    /**
     * @name ProductionSpec
     *
     * @brief Accessor and modifier functions for the %ProductionSpec
     * required element.
     *
     * ProductionSpec describes the printable string of the production
     * specification ELEMENT.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String ProductionSpecType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ProductionSpecType, char > ProductionSpecTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ProductionSpecType&
    getProductionSpec () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ProductionSpecType&
    getProductionSpec ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setProductionSpec (const ProductionSpecType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setProductionSpec (::std::unique_ptr< ProductionSpecType > p);

    //@}

    /**
     * @name ComponentId
     *
     * @brief Accessor and modifier functions for the %ComponentId
     * optional element.
     *
     * Describes the internal component unique identification. This is a
     * provision for manufacturer specific standard components using a
     * private object identifier (OID).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::InstanceIdentifier ComponentIdType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ComponentIdType > ComponentIdOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComponentIdType, char > ComponentIdTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ComponentIdOptional&
    getComponentId () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ComponentIdOptional&
    getComponentId ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setComponentId (const ComponentIdType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setComponentId (const ComponentIdOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setComponentId (::std::unique_ptr< ComponentIdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ProductionSpecification (const SpecTypeType&,
                             const ProductionSpecType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ProductionSpecification (::std::unique_ptr< SpecTypeType >,
                             const ProductionSpecType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ProductionSpecification (::std::unique_ptr< SpecTypeType >,
                             ::std::unique_ptr< ProductionSpecType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ProductionSpecification (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ProductionSpecification (const ProductionSpecification& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ProductionSpecification*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ProductionSpecification&
    operator= (const ProductionSpecification& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ProductionSpecification ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< SpecTypeType > SpecType_;
    ::xsd::cxx::tree::one< ProductionSpecType > ProductionSpec_;
    ComponentIdOptional ComponentId_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %CalibrationDocumentation schema type.
   *
   * @nosubgrouping
   */
  class CalibrationDocumentation: public ::xml_schema::Type
  {
    public:
    /**
     * @name Documentation
     *
     * @brief Accessor and modifier functions for the %Documentation
     * sequence element.
     *
     * Human-readable documentation of a CalibrationDocumentation entry.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::LocalizedText DocumentationType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DocumentationType > DocumentationSequence;

    /**
     * @brief Element iterator type.
     */
    typedef DocumentationSequence::iterator DocumentationIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef DocumentationSequence::const_iterator DocumentationConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DocumentationType, char > DocumentationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DocumentationSequence&
    getDocumentation () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DocumentationSequence&
    getDocumentation ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDocumentation (const DocumentationSequence& s);

    //@}

    /**
     * @name CalibrationResult
     *
     * @brief Accessor and modifier functions for the %CalibrationResult
     * sequence element.
     *
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CalibrationResult CalibrationResultType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< CalibrationResultType > CalibrationResultSequence;

    /**
     * @brief Element iterator type.
     */
    typedef CalibrationResultSequence::iterator CalibrationResultIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef CalibrationResultSequence::const_iterator CalibrationResultConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CalibrationResultType, char > CalibrationResultTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const CalibrationResultSequence&
    getCalibrationResult () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    CalibrationResultSequence&
    getCalibrationResult ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setCalibrationResult (const CalibrationResultSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    CalibrationDocumentation ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CalibrationDocumentation (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CalibrationDocumentation (const CalibrationDocumentation& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CalibrationDocumentation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CalibrationDocumentation&
    operator= (const CalibrationDocumentation& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~CalibrationDocumentation ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DocumentationSequence Documentation_;
    CalibrationResultSequence CalibrationResult_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MetaData schema type.
   *
   * @nosubgrouping
   */
  class MetaData: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Udi
     *
     * @brief Accessor and modifier functions for the %Udi
     * sequence element.
     *
     * UDI fragments as defined by the FDA.
     * 
     * NOTE 1?The amount of ELEMENTs is unbounded in order to support the
     * provision of UDIs from different jurisdictions.
     * NOTE 2?If needed, the UDI's distinct identification code can be
     * inserted as an extension to the MetaData object.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Udi UdiType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< UdiType > UdiSequence;

    /**
     * @brief Element iterator type.
     */
    typedef UdiSequence::iterator UdiIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef UdiSequence::const_iterator UdiConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UdiType, char > UdiTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const UdiSequence&
    getUdi () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    UdiSequence&
    getUdi ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setUdi (const UdiSequence& s);

    //@}

    /**
     * @name LotNumber
     *
     * @brief Accessor and modifier functions for the %LotNumber
     * optional element.
     *
     * OPTIONAL lot number of manufacturer.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String LotNumberType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LotNumberType > LotNumberOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LotNumberType, char > LotNumberTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LotNumberOptional&
    getLotNumber () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LotNumberOptional&
    getLotNumber ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLotNumber (const LotNumberType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLotNumber (const LotNumberOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLotNumber (::std::unique_ptr< LotNumberType > p);

    //@}

    /**
     * @name Manufacturer
     *
     * @brief Accessor and modifier functions for the %Manufacturer
     * sequence element.
     *
     * OPTIONAL texts that describe the manufacturer name.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::LocalizedText ManufacturerType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ManufacturerType > ManufacturerSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ManufacturerSequence::iterator ManufacturerIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ManufacturerSequence::const_iterator ManufacturerConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ManufacturerType, char > ManufacturerTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ManufacturerSequence&
    getManufacturer () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ManufacturerSequence&
    getManufacturer ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setManufacturer (const ManufacturerSequence& s);

    //@}

    /**
     * @name ManufactureDate
     *
     * @brief Accessor and modifier functions for the %ManufactureDate
     * optional element.
     *
     * OPTIONAL date when the device was made.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::DateTime ManufactureDateType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ManufactureDateType > ManufactureDateOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ManufactureDateType, char > ManufactureDateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ManufactureDateOptional&
    getManufactureDate () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ManufactureDateOptional&
    getManufactureDate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setManufactureDate (const ManufactureDateType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setManufactureDate (const ManufactureDateOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setManufactureDate (::std::unique_ptr< ManufactureDateType > p);

    //@}

    /**
     * @name ExpirationDate
     *
     * @brief Accessor and modifier functions for the %ExpirationDate
     * optional element.
     *
     * OPTIONAL date and time of expiry of the device (if applicable).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::DateTime ExpirationDateType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExpirationDateType > ExpirationDateOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExpirationDateType, char > ExpirationDateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExpirationDateOptional&
    getExpirationDate () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExpirationDateOptional&
    getExpirationDate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExpirationDate (const ExpirationDateType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExpirationDate (const ExpirationDateOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExpirationDate (::std::unique_ptr< ExpirationDateType > p);

    //@}

    /**
     * @name ModelName
     *
     * @brief Accessor and modifier functions for the %ModelName
     * sequence element.
     *
     * OPTIONAL texts that describe the model name.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::LocalizedText ModelNameType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ModelNameType > ModelNameSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ModelNameSequence::iterator ModelNameIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ModelNameSequence::const_iterator ModelNameConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ModelNameType, char > ModelNameTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ModelNameSequence&
    getModelName () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ModelNameSequence&
    getModelName ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setModelName (const ModelNameSequence& s);

    //@}

    /**
     * @name ModelNumber
     *
     * @brief Accessor and modifier functions for the %ModelNumber
     * optional element.
     *
     * OPTIONAL model number of the MDS.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String ModelNumberType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ModelNumberType > ModelNumberOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ModelNumberType, char > ModelNumberTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ModelNumberOptional&
    getModelNumber () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ModelNumberOptional&
    getModelNumber ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setModelNumber (const ModelNumberType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setModelNumber (const ModelNumberOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setModelNumber (::std::unique_ptr< ModelNumberType > p);

    //@}

    /**
     * @name SerialNumber
     *
     * @brief Accessor and modifier functions for the %SerialNumber
     * sequence element.
     *
     * OPTIONAL serial numbers of the system.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String SerialNumberType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< SerialNumberType > SerialNumberSequence;

    /**
     * @brief Element iterator type.
     */
    typedef SerialNumberSequence::iterator SerialNumberIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef SerialNumberSequence::const_iterator SerialNumberConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SerialNumberType, char > SerialNumberTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const SerialNumberSequence&
    getSerialNumber () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    SerialNumberSequence&
    getSerialNumber ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setSerialNumber (const SerialNumberSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MetaData ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MetaData (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MetaData (const MetaData& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MetaData*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MetaData&
    operator= (const MetaData& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MetaData ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    UdiSequence Udi_;
    LotNumberOptional LotNumber_;
    ManufacturerSequence Manufacturer_;
    ManufactureDateOptional ManufactureDate_;
    ExpirationDateOptional ExpirationDate_;
    ModelNameSequence ModelName_;
    ModelNumberOptional ModelNumber_;
    SerialNumberSequence SerialNumber_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %CanEscalate
   * schema type.
   */
  class CanEscalate: public ::CDM::AlertConditionPriority
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    typedef ::CDM::AlertConditionPriority::Value Value;

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    CanEscalate (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    CanEscalate (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    CanEscalate (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    CanEscalate (const ::CDM::AlertConditionPriority& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CanEscalate (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CanEscalate (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CanEscalate (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CanEscalate (const CanEscalate& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CanEscalate*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    CanEscalate&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_CanEscalate_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_CanEscalate_convert () const;

    public:
    static const char* const* _xsd_CanEscalate_literals_;
    static const Value _xsd_CanEscalate_indexes_[3];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %CanDeescalate
   * schema type.
   */
  class CanDeescalate: public ::CDM::AlertConditionPriority
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    typedef ::CDM::AlertConditionPriority::Value Value;

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    CanDeescalate (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    CanDeescalate (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    CanDeescalate (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    CanDeescalate (const ::CDM::AlertConditionPriority& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CanDeescalate (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CanDeescalate (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CanDeescalate (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CanDeescalate (const CanDeescalate& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CanDeescalate*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    CanDeescalate&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_CanDeescalate_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_CanDeescalate_convert () const;

    public:
    static const char* const* _xsd_CanDeescalate_literals_;
    static const Value _xsd_CanDeescalate_indexes_[3];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MetricQuality schema type.
   *
   * @nosubgrouping
   */
  class MetricQuality: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Validity
     *
     * @brief Accessor and modifier functions for the %Validity
     * required attribute.
     *
     * While Validity is "Ong" or "NA", the enclosing METRIC value SHALL not
     * possess a determined value. See also pm:MeasurementValidity.
     * 
     * NOTE?In case of other values the enclosing METRIC is allowed to
     * possess a determined value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::MeasurementValidity ValidityType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValidityType, char > ValidityTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ValidityType&
    getValidity () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ValidityType&
    getValidity ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setValidity (const ValidityType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setValidity (::std::unique_ptr< ValidityType > p);

    //@}

    /**
     * @name Mode
     *
     * @brief Accessor and modifier functions for the %Mode
     * optional attribute.
     *
     * Describes whether data is generated by a real METRIC source or is part
     * of any test or demo data. The implied value SHALL be "Real".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::GenerationMode ModeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ModeType > ModeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ModeType, char > ModeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ModeOptional&
    getMode () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ModeOptional&
    getMode ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMode (const ModeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMode (const ModeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMode (::std::unique_ptr< ModeType > p);

    //@}

    /**
     * @name Qi
     *
     * @brief Accessor and modifier functions for the %Qi
     * optional attribute.
     *
     * See pm:QualityIndicator. The implied value SHALL be "1".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::QualityIndicator QiType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< QiType > QiOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< QiType, char > QiTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const QiOptional&
    getQi () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    QiOptional&
    getQi ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setQi (const QiType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setQi (const QiOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setQi (::std::unique_ptr< QiType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MetricQuality (const ValidityType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MetricQuality (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MetricQuality (const MetricQuality& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MetricQuality*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MetricQuality&
    operator= (const MetricQuality& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MetricQuality ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< ValidityType > Validity_;
    ModeOptional Mode_;
    QiOptional Qi_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Annotation schema type.
   *
   * @nosubgrouping
   */
  class Annotation: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Type
     *
     * @brief Accessor and modifier functions for the %Type
     * required element.
     *
     * The CODED VALUE that describes the annotation of the ELEMENT.
     * 
     * Example: attach triggers in waveform curves.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue TypeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TypeType&
    getType () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TypeType&
    getType ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setType (const TypeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setType (::std::unique_ptr< TypeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Annotation (const TypeType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    Annotation (::std::unique_ptr< TypeType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Annotation (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Annotation (const Annotation& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Annotation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Annotation&
    operator= (const Annotation& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Annotation ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< TypeType > Type_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ApplyAnnotation schema type.
   *
   * @nosubgrouping
   */
  class ApplyAnnotation: public ::xml_schema::Type
  {
    public:
    /**
     * @name AnnotationIndex
     *
     * @brief Accessor and modifier functions for the %AnnotationIndex
     * required attribute.
     *
     * Index number of the annotation that is addressed by the
     * ApplyAnnotation ELEMENT. The index number refers to the (n+1)-nth
     * pm:AbstractMetricValue/pm:Annotation ELEMENT. Hence, numbering is
     * zero-based.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::UnsignedInt AnnotationIndexType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< AnnotationIndexType, char > AnnotationIndexTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const AnnotationIndexType&
    getAnnotationIndex () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    AnnotationIndexType&
    getAnnotationIndex ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setAnnotationIndex (const AnnotationIndexType& x);

    //@}

    /**
     * @name SampleIndex
     *
     * @brief Accessor and modifier functions for the %SampleIndex
     * required attribute.
     *
     * Index number of the sample the defined annotation refers to. The index
     * number addresses the (n+1)-nth number in the
     * pm:RealTimeSampleArrayValue/pm:Samples ATTRIBUTE. Hence, numbering is
     * zero-based.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::UnsignedInt SampleIndexType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SampleIndexType, char > SampleIndexTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const SampleIndexType&
    getSampleIndex () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    SampleIndexType&
    getSampleIndex ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSampleIndex (const SampleIndexType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ApplyAnnotation (const AnnotationIndexType&,
                     const SampleIndexType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ApplyAnnotation (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ApplyAnnotation (const ApplyAnnotation& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ApplyAnnotation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ApplyAnnotation&
    operator= (const ApplyAnnotation& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ApplyAnnotation ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< AnnotationIndexType > AnnotationIndex_;
    ::xsd::cxx::tree::one< SampleIndexType > SampleIndex_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Relation schema type.
   *
   * @nosubgrouping
   */
  class Relation: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Code
     *
     * @brief Accessor and modifier functions for the %Code
     * optional element.
     *
     * Code allows to semantically describe the relationship between the
     * METRIC and the list of related containment tree entries defined in
     * ./pm:Relation/@Entries.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue CodeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CodeType > CodeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CodeType, char > CodeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CodeOptional&
    getCode () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CodeOptional&
    getCode ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCode (const CodeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCode (const CodeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCode (::std::unique_ptr< CodeType > p);

    //@}

    /**
     * @name Identification
     *
     * @brief Accessor and modifier functions for the %Identification
     * optional element.
     *
     * Identification allow relations to be grouped by instance identifiers.
     * 
     * NOTE?By that a SERVICE PROVIDER can, e.g., group sets of
     * recommendations or presettings in order to allow easy identification.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::InstanceIdentifier IdentificationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< IdentificationType > IdentificationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdentificationType, char > IdentificationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const IdentificationOptional&
    getIdentification () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    IdentificationOptional&
    getIdentification ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setIdentification (const IdentificationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setIdentification (const IdentificationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setIdentification (::std::unique_ptr< IdentificationType > p);

    //@}

    /**
     * @name Kind
     *
     * @brief Accessor and modifier functions for the %Kind
     * required attribute.
     *
     * Kind specifies the relationship between the METRIC and referenced
     * containment tree entries. Referenced containment tree entries are
     * defined in ./pm:Relation/@Entries.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::Kind KindType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< KindType, char > KindTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const KindType&
    getKind () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    KindType&
    getKind ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setKind (const KindType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setKind (::std::unique_ptr< KindType > p);

    //@}

    /**
     * @name Entries
     *
     * @brief Accessor and modifier functions for the %Entries
     * required attribute.
     *
     * List of HANDLE references that relate to the METRIC. The relationship
     * flavor is defined in ./pm:Relation/@Kind.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::EntryRef EntriesType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< EntriesType, char > EntriesTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const EntriesType&
    getEntries () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    EntriesType&
    getEntries ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEntries (const EntriesType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEntries (::std::unique_ptr< EntriesType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Relation (const KindType&,
              const EntriesType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Relation (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Relation (const Relation& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Relation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Relation&
    operator= (const Relation& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Relation ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    CodeOptional Code_;
    IdentificationOptional Identification_;
    ::xsd::cxx::tree::one< KindType > Kind_;
    ::xsd::cxx::tree::one< EntriesType > Entries_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AllowedValue schema type.
   *
   * @nosubgrouping
   */
  class AllowedValue: public ::xml_schema::Type
  {
    public:
    /**
     * @name Value
     *
     * @brief Accessor and modifier functions for the %Value
     * required element.
     *
     * Accepted string value.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String ValueType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ValueType&
    getValue () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ValueType&
    getValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setValue (const ValueType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setValue (::std::unique_ptr< ValueType > p);

    //@}

    /**
     * @name Type
     *
     * @brief Accessor and modifier functions for the %Type
     * optional element.
     *
     * OPTIONAL pm:CodedValue to semantically describe the allowed value.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue TypeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TypeOptional&
    getType () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TypeOptional&
    getType ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setType (const TypeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setType (const TypeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setType (::std::unique_ptr< TypeType > p);

    //@}

    /**
     * @name Identification
     *
     * @brief Accessor and modifier functions for the %Identification
     * optional element.
     *
     * OPTIONAL identification to apply instance identifiers to each allowed
     * value.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::InstanceIdentifier IdentificationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< IdentificationType > IdentificationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdentificationType, char > IdentificationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const IdentificationOptional&
    getIdentification () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    IdentificationOptional&
    getIdentification ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setIdentification (const IdentificationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setIdentification (const IdentificationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setIdentification (::std::unique_ptr< IdentificationType > p);

    //@}

    /**
     * @name Characteristic
     *
     * @brief Accessor and modifier functions for the %Characteristic
     * optional element.
     *
     * OPTIONAL field to attach a dimensional measurement to each allowed
     * value.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Measurement CharacteristicType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CharacteristicType > CharacteristicOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CharacteristicType, char > CharacteristicTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CharacteristicOptional&
    getCharacteristic () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CharacteristicOptional&
    getCharacteristic ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCharacteristic (const CharacteristicType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCharacteristic (const CharacteristicOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCharacteristic (::std::unique_ptr< CharacteristicType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AllowedValue (const ValueType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    AllowedValue (::std::unique_ptr< ValueType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AllowedValue (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AllowedValue (const AllowedValue& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AllowedValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AllowedValue&
    operator= (const AllowedValue& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AllowedValue ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ValueType > Value_;
    TypeOptional Type_;
    IdentificationOptional Identification_;
    CharacteristicOptional Characteristic_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OperationGroup schema type.
   *
   * @nosubgrouping
   */
  class OperationGroup: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Type
     *
     * @brief Accessor and modifier functions for the %Type
     * required element.
     *
     * Type sematically describes the operation group.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue TypeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TypeType&
    getType () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TypeType&
    getType ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setType (const TypeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setType (::std::unique_ptr< TypeType > p);

    //@}

    /**
     * @name OperatingMode
     *
     * @brief Accessor and modifier functions for the %OperatingMode
     * optional attribute.
     *
     * OperatingMode defines the operating mode of the whole operation group,
     * see also pm:OperatingMode.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::OperatingMode OperatingModeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OperatingModeType > OperatingModeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< OperatingModeType, char > OperatingModeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OperatingModeOptional&
    getOperatingMode () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    OperatingModeOptional&
    getOperatingMode ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setOperatingMode (const OperatingModeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setOperatingMode (const OperatingModeOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setOperatingMode (::std::unique_ptr< OperatingModeType > p);

    //@}

    /**
     * @name Operations
     *
     * @brief Accessor and modifier functions for the %Operations
     * optional attribute.
     *
     * Handle references to all operations enclosed by the operation group.
     * The list is ordered such that the entry with a lower list index has a
     * higher clinical relevance than any entry with a higher list index. The
     * SERVICE PROVIDER defines the clinical relevance and MAY reorder the
     * list at any time.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::OperationRef OperationsType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OperationsType > OperationsOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< OperationsType, char > OperationsTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OperationsOptional&
    getOperations () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    OperationsOptional&
    getOperations ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setOperations (const OperationsType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setOperations (const OperationsOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setOperations (::std::unique_ptr< OperationsType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OperationGroup (const TypeType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    OperationGroup (::std::unique_ptr< TypeType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OperationGroup (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OperationGroup (const OperationGroup& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OperationGroup*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OperationGroup&
    operator= (const OperationGroup& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OperationGroup ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< TypeType > Type_;
    OperatingModeOptional OperatingMode_;
    OperationsOptional Operations_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %AccessLevel
   * schema type.
   */
  class AccessLevel: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Usr = User. Any person interacting with (i.e., operating or handling)
       * the POC MEDICAL DEVICE.
       */
      Usr,
      /**
       * CSUsr = Clinical Super User. Individuals or entity accountable to the
       * RESPONSIBLE ORGANIZATION that configure clinical relevant settings of
       * a POC MEDICAL DEVICE.
       */
      CSUsr,
      /**
       * RO = Responsible Organization. Access is restricted to a RESPONSIBLE
       * ORGANIZATION.
       */
      RO,
      /**
       * SP = Service Personnel. Access is restricted to SERVICE PERSONNEL.
       */
      SP,
      /**
       * Oth = Other. Access is restricted by other means (e.g., an extension).
       */
      Oth
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    AccessLevel (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    AccessLevel (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    AccessLevel (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    AccessLevel (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AccessLevel (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AccessLevel (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AccessLevel (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AccessLevel (const AccessLevel& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AccessLevel*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    AccessLevel&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_AccessLevel_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_AccessLevel_convert () const;

    public:
    static const char* const _xsd_AccessLevel_literals_[5];
    static const Value _xsd_AccessLevel_indexes_[5];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AllowedValues schema type.
   *
   * @nosubgrouping
   */
  class AllowedValues: public ::xml_schema::Type
  {
    public:
    /**
     * @name Value
     *
     * @brief Accessor and modifier functions for the %Value
     * sequence element.
     *
     * A single allowed value that can be requested.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String ValueType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ValueType > ValueSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ValueSequence::iterator ValueIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ValueSequence::const_iterator ValueConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ValueSequence&
    getValue () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ValueSequence&
    getValue ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setValue (const ValueSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AllowedValues ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AllowedValues (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AllowedValues (const AllowedValues& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AllowedValues*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AllowedValues&
    operator= (const AllowedValues& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AllowedValues ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ValueSequence Value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Argument schema type.
   *
   * @nosubgrouping
   */
  class Argument: public ::xml_schema::Type
  {
    public:
    /**
     * @name ArgName
     *
     * @brief Accessor and modifier functions for the %ArgName
     * required element.
     *
     * CODED VALUE that describes this argument.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue ArgNameType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ArgNameType, char > ArgNameTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ArgNameType&
    getArgName () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ArgNameType&
    getArgName ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setArgName (const ArgNameType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setArgName (::std::unique_ptr< ArgNameType > p);

    //@}

    /**
     * @name Arg
     *
     * @brief Accessor and modifier functions for the %Arg
     * required element.
     *
     * Data type of the argument, defined by a qualified name.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Qname ArgType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ArgType, char > ArgTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ArgType&
    getArg () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ArgType&
    getArg ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setArg (const ArgType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setArg (::std::unique_ptr< ArgType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Argument (const ArgNameType&,
              const ArgType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    Argument (::std::unique_ptr< ArgNameType >,
              const ArgType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    Argument (::std::unique_ptr< ArgNameType >,
              ::std::unique_ptr< ArgType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Argument (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Argument (const Argument& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Argument*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Argument&
    operator= (const Argument& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Argument ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ArgNameType > ArgName_;
    ::xsd::cxx::tree::one< ArgType > Arg_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %ChargeStatus
   * schema type.
   */
  class ChargeStatus: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Ful = Full. All available active material is in a state such that the
       * charging under the selected conditions produces no significant
       * increase of capacity. See also IEC 60050-482 International
       * Electrotechnical Vocabulary, 482-05-42.
       */
      Ful,
      /**
       * ChB = Charging Battery. Battery is currently supplied with electric
       * energy from an external circuit. See also IEC 60050-482 International
       * Electrotechnical Vocabulary, 482-05-27.
       */
      ChB,
      /**
       * DisChB = Discharging Battery. Battery delivers, to an external
       * electric circuit and under specified conditions, electric energy
       * produced in the cells. See also IEC 60050-482 International
       * Electrotechnical Vocabulary, 482-03-23
       */
      DisChB,
      /**
       * DEB = Discharged Empty Battery. Discharged secondary battery. See also
       * IEC 60050-482 International Electrotechnical Vocabulary, 482-05-31.
       */
      DEB
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    ChargeStatus (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    ChargeStatus (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    ChargeStatus (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    ChargeStatus (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChargeStatus (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChargeStatus (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChargeStatus (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChargeStatus (const ChargeStatus& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ChargeStatus*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    ChargeStatus&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_ChargeStatus_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_ChargeStatus_convert () const;

    public:
    static const char* const _xsd_ChargeStatus_literals_[4];
    static const Value _xsd_ChargeStatus_indexes_[4];

    //@endcond
  };

  /**
   * @brief Union class corresponding to the %DateOfBirth
   * schema type.
   *
   * The mapping represents unions as strings.
   */
  class DateOfBirth: public ::xml_schema::String
  {
    public:

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    DateOfBirth (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    DateOfBirth (const ::std::string& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DateOfBirth (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DateOfBirth (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DateOfBirth (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DateOfBirth (const DateOfBirth& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DateOfBirth*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;
  };

  /**
   * @brief Enumeration class corresponding to the %Criticality
   * schema type.
   */
  class Criticality: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Lo = Low. Non-compliance does not result in a severe,
       * life-threatening, or fatal situation.
       */
      Lo,
      /**
       * Hi = High. Non-compliance might result in a severe, life-threatening,
       * or fatal situation.
       */
      Hi
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Criticality (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Criticality (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Criticality (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Criticality (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Criticality (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Criticality (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Criticality (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Criticality (const Criticality& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Criticality*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Criticality&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Criticality_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Criticality_convert () const;

    public:
    static const char* const _xsd_Criticality_literals_[2];
    static const Value _xsd_Criticality_indexes_[2];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %RelatedMeasurement schema type.
   *
   * @nosubgrouping
   */
  class RelatedMeasurement: public ::xml_schema::Type
  {
    public:
    /**
     * @name Value
     *
     * @brief Accessor and modifier functions for the %Value
     * required element.
     *
     * The related measurement's value.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Measurement ValueType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ValueType&
    getValue () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ValueType&
    getValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setValue (const ValueType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setValue (::std::unique_ptr< ValueType > p);

    //@}

    /**
     * @name ReferenceRange
     *
     * @brief Accessor and modifier functions for the %ReferenceRange
     * sequence element.
     *
     * Representation of the normal or abnormal reference range for the
     * measurement.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::ReferenceRange ReferenceRangeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ReferenceRangeType > ReferenceRangeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ReferenceRangeSequence::iterator ReferenceRangeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ReferenceRangeSequence::const_iterator ReferenceRangeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReferenceRangeType, char > ReferenceRangeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ReferenceRangeSequence&
    getReferenceRange () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ReferenceRangeSequence&
    getReferenceRange ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setReferenceRange (const ReferenceRangeSequence& s);

    //@}

    /**
     * @name Validity
     *
     * @brief Accessor and modifier functions for the %Validity
     * optional attribute.
     *
     * Validity of the related measurement. See also pm:MeasurementValidity.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::CDM::MeasurementValidity ValidityType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ValidityType > ValidityOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValidityType, char > ValidityTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ValidityOptional&
    getValidity () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ValidityOptional&
    getValidity ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setValidity (const ValidityType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setValidity (const ValidityOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setValidity (::std::unique_ptr< ValidityType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RelatedMeasurement (const ValueType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    RelatedMeasurement (::std::unique_ptr< ValueType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RelatedMeasurement (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RelatedMeasurement (const RelatedMeasurement& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RelatedMeasurement*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RelatedMeasurement&
    operator= (const RelatedMeasurement& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RelatedMeasurement ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ValueType > Value_;
    ReferenceRangeSequence ReferenceRange_;
    ValidityOptional Validity_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %WorkflowDetail schema type.
   *
   * @nosubgrouping
   */
  class WorkflowDetail: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name Patient
     *
     * @brief Accessor and modifier functions for the %Patient
     * required element.
     *
     * Subject of the order.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::PersonReference PatientType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PatientType, char > PatientTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PatientType&
    getPatient () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PatientType&
    getPatient ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPatient (const PatientType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPatient (::std::unique_ptr< PatientType > p);

    //@}

    /**
     * @name AssignedLocation
     *
     * @brief Accessor and modifier functions for the %AssignedLocation
     * optional element.
     *
     * Location the order assigned to.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::LocationReference AssignedLocationType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AssignedLocationType > AssignedLocationOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AssignedLocationType, char > AssignedLocationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AssignedLocationOptional&
    getAssignedLocation () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AssignedLocationOptional&
    getAssignedLocation ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAssignedLocation (const AssignedLocationType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAssignedLocation (const AssignedLocationOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAssignedLocation (::std::unique_ptr< AssignedLocationType > p);

    //@}

    /**
     * @name VisitNumber
     *
     * @brief Accessor and modifier functions for the %VisitNumber
     * optional element.
     *
     * Reference key of inpatient stay or outpatient visit of the patient
     * administration system.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::InstanceIdentifier VisitNumberType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< VisitNumberType > VisitNumberOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VisitNumberType, char > VisitNumberTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const VisitNumberOptional&
    getVisitNumber () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    VisitNumberOptional&
    getVisitNumber ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setVisitNumber (const VisitNumberType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setVisitNumber (const VisitNumberOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setVisitNumber (::std::unique_ptr< VisitNumberType > p);

    //@}

    /**
     * @name DangerCode
     *
     * @brief Accessor and modifier functions for the %DangerCode
     * sequence element.
     *
     * Identifier and textual descriptions of patient immanent risks, e.g.,
     * infectious diseases.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue DangerCodeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DangerCodeType > DangerCodeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef DangerCodeSequence::iterator DangerCodeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef DangerCodeSequence::const_iterator DangerCodeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DangerCodeType, char > DangerCodeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DangerCodeSequence&
    getDangerCode () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DangerCodeSequence&
    getDangerCode ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDangerCode (const DangerCodeSequence& s);

    //@}

    /**
     * @name RelevantClinicalInfo
     *
     * @brief Accessor and modifier functions for the %RelevantClinicalInfo
     * sequence element.
     *
     * Clinical information that is relevant for the order.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::ClinicalInfo RelevantClinicalInfoType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< RelevantClinicalInfoType > RelevantClinicalInfoSequence;

    /**
     * @brief Element iterator type.
     */
    typedef RelevantClinicalInfoSequence::iterator RelevantClinicalInfoIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef RelevantClinicalInfoSequence::const_iterator RelevantClinicalInfoConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RelevantClinicalInfoType, char > RelevantClinicalInfoTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const RelevantClinicalInfoSequence&
    getRelevantClinicalInfo () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    RelevantClinicalInfoSequence&
    getRelevantClinicalInfo ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setRelevantClinicalInfo (const RelevantClinicalInfoSequence& s);

    //@}

    /**
     * @name RequestedOrderDetail
     *
     * @brief Accessor and modifier functions for the %RequestedOrderDetail
     * optional element.
     *
     * Initial order details at the time of order release.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::RequestedOrderDetail RequestedOrderDetailType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RequestedOrderDetailType > RequestedOrderDetailOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RequestedOrderDetailType, char > RequestedOrderDetailTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RequestedOrderDetailOptional&
    getRequestedOrderDetail () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RequestedOrderDetailOptional&
    getRequestedOrderDetail ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRequestedOrderDetail (const RequestedOrderDetailType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRequestedOrderDetail (const RequestedOrderDetailOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRequestedOrderDetail (::std::unique_ptr< RequestedOrderDetailType > p);

    //@}

    /**
     * @name PerformedOrderDetail
     *
     * @brief Accessor and modifier functions for the %PerformedOrderDetail
     * optional element.
     *
     * Recent state of order details after order has been performed.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::PerformedOrderDetail PerformedOrderDetailType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PerformedOrderDetailType > PerformedOrderDetailOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PerformedOrderDetailType, char > PerformedOrderDetailTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PerformedOrderDetailOptional&
    getPerformedOrderDetail () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PerformedOrderDetailOptional&
    getPerformedOrderDetail ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPerformedOrderDetail (const PerformedOrderDetailType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPerformedOrderDetail (const PerformedOrderDetailOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPerformedOrderDetail (::std::unique_ptr< PerformedOrderDetailType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    WorkflowDetail (const PatientType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    WorkflowDetail (::std::unique_ptr< PatientType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    WorkflowDetail (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    WorkflowDetail (const WorkflowDetail& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual WorkflowDetail*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    WorkflowDetail&
    operator= (const WorkflowDetail& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~WorkflowDetail ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< PatientType > Patient_;
    AssignedLocationOptional AssignedLocation_;
    VisitNumberOptional VisitNumber_;
    DangerCodeSequence DangerCode_;
    RelevantClinicalInfoSequence RelevantClinicalInfo_;
    RequestedOrderDetailOptional RequestedOrderDetail_;
    PerformedOrderDetailOptional PerformedOrderDetail_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %CalibrationResult schema type.
   *
   * @nosubgrouping
   */
  class CalibrationResult: public ::xml_schema::Type
  {
    public:
    /**
     * @name Code
     *
     * @brief Accessor and modifier functions for the %Code
     * required element.
     *
     * Code that semantically describes the calibration result.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue CodeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CodeType, char > CodeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CodeType&
    getCode () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CodeType&
    getCode ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCode (const CodeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCode (::std::unique_ptr< CodeType > p);

    //@}

    /**
     * @name Value
     *
     * @brief Accessor and modifier functions for the %Value
     * required element.
     *
     * Measurement that represents the value related to that specific
     * calibration result.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Measurement ValueType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ValueType&
    getValue () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ValueType&
    getValue ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setValue (const ValueType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setValue (::std::unique_ptr< ValueType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    CalibrationResult (const CodeType&,
                       const ValueType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    CalibrationResult (::std::unique_ptr< CodeType >,
                       ::std::unique_ptr< ValueType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CalibrationResult (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CalibrationResult (const CalibrationResult& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CalibrationResult*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CalibrationResult&
    operator= (const CalibrationResult& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~CalibrationResult ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< CodeType > Code_;
    ::xsd::cxx::tree::one< ValueType > Value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Udi schema type.
   *
   * @nosubgrouping
   */
  class Udi: public ::xml_schema::Type
  {
    public:
    /**
     * @name Extension
     *
     * @brief Accessor and modifier functions for the %Extension
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::EXT::ExtensionType ExtensionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ExtensionOptional&
    getExtension () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ExtensionOptional&
    getExtension ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setExtension (const ExtensionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setExtension (const ExtensionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setExtension (::std::unique_ptr< ExtensionType > p);

    //@}

    /**
     * @name DeviceIdentifier
     *
     * @brief Accessor and modifier functions for the %DeviceIdentifier
     * required element.
     *
     * A mandatory, fixed portion of a UDI that identifies the labeler and
     * the specific version or model of a device.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String DeviceIdentifierType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeviceIdentifierType, char > DeviceIdentifierTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DeviceIdentifierType&
    getDeviceIdentifier () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DeviceIdentifierType&
    getDeviceIdentifier ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDeviceIdentifier (const DeviceIdentifierType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDeviceIdentifier (::std::unique_ptr< DeviceIdentifierType > p);

    //@}

    /**
     * @name HumanReadableForm
     *
     * @brief Accessor and modifier functions for the %HumanReadableForm
     * required element.
     *
     * UDI human readable form as printed on the barcode.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::String HumanReadableFormType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HumanReadableFormType, char > HumanReadableFormTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HumanReadableFormType&
    getHumanReadableForm () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HumanReadableFormType&
    getHumanReadableForm ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHumanReadableForm (const HumanReadableFormType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHumanReadableForm (::std::unique_ptr< HumanReadableFormType > p);

    //@}

    /**
     * @name Issuer
     *
     * @brief Accessor and modifier functions for the %Issuer
     * required element.
     *
     * Organization that has issued the UDI.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::InstanceIdentifier IssuerType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IssuerType, char > IssuerTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const IssuerType&
    getIssuer () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    IssuerType&
    getIssuer ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setIssuer (const IssuerType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setIssuer (::std::unique_ptr< IssuerType > p);

    //@}

    /**
     * @name Jurisdiction
     *
     * @brief Accessor and modifier functions for the %Jurisdiction
     * optional element.
     *
     * Jurisdiction that the UDI is valid for. If no value is defined, then
     * the UDI is not bound to a specific jurisdiction.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::InstanceIdentifier JurisdictionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< JurisdictionType > JurisdictionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< JurisdictionType, char > JurisdictionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const JurisdictionOptional&
    getJurisdiction () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    JurisdictionOptional&
    getJurisdiction ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setJurisdiction (const JurisdictionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setJurisdiction (const JurisdictionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setJurisdiction (::std::unique_ptr< JurisdictionType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Udi (const DeviceIdentifierType&,
         const HumanReadableFormType&,
         const IssuerType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    Udi (const DeviceIdentifierType&,
         const HumanReadableFormType&,
         ::std::unique_ptr< IssuerType >);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    Udi (::std::unique_ptr< DeviceIdentifierType >,
         ::std::unique_ptr< HumanReadableFormType >,
         ::std::unique_ptr< IssuerType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Udi (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Udi (const Udi& x,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Udi*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Udi&
    operator= (const Udi& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Udi ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< DeviceIdentifierType > DeviceIdentifier_;
    ::xsd::cxx::tree::one< HumanReadableFormType > HumanReadableForm_;
    ::xsd::cxx::tree::one< IssuerType > Issuer_;
    JurisdictionOptional Jurisdiction_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %Kind
   * schema type.
   */
  class Kind: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      /**
       * Rcm = Recommendation. The METRIC is a recommendation for the
       * containment tree entries defined in ./pm:Relation/@Entries.
       */
      Rcm,
      /**
       * PS = Pre-setting. This METRIC is a pre-setting for the containment
       * tree entries defined in ./pm:Relation/@Entries.
       */
      PS,
      /**
       * SST = Set of summary statistics. The METRIC is part of a set of
       * summary statistics for a sample where other METRICs that belong to the
       * summary statistics are defined in ./pm:Relation/@Entries.
       */
      SST,
      /**
       * ECE = Effect on containment tree entries. When changed, the METRIC has
       * an effect on the containment tree entries defined in
       * ./pm:Relation/@Entries. If Kind is "ECE", ./pm:Relation/pm:Code SHOULD
       * be set to classify the effect.
       */
      ECE,
      /**
       * DCE = Derived from containment tree entries. The METRIC is derived
       * from the containment tree entries defined in ./pm:Relation/@Entries.
       * If Kind is "DCE", ./pm:Relation/pm:Code MAY be set to classify the
       * form of derivation.
       */
      DCE,
      /**
       * Oth = Other. Relation is specified by other means, e.g.,
       * ./pm:Relation/pm:Code or extension element.
       */
      Oth
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Kind (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Kind (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Kind (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Kind (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Kind (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Kind (const ::xercesc::DOMAttr& a,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Kind (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Kind (const Kind& x,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Kind*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Kind&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Kind_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Kind_convert () const;

    public:
    static const char* const _xsd_Kind_literals_[6];
    static const Value _xsd_Kind_indexes_[6];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ReferenceRange schema type.
   *
   * @nosubgrouping
   */
  class ReferenceRange: public ::xml_schema::Type
  {
    public:
    /**
     * @name Range
     *
     * @brief Accessor and modifier functions for the %Range
     * required element.
     *
     * Range that SHALL be populated at least with ./@Lower or ./@Upper.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::Range RangeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RangeType, char > RangeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const RangeType&
    getRange () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    RangeType&
    getRange ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRange (const RangeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRange (::std::unique_ptr< RangeType > p);

    //@}

    /**
     * @name Meaning
     *
     * @brief Accessor and modifier functions for the %Meaning
     * optional element.
     *
     * Indicates the meaning of the reference range.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::CodedValue MeaningType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MeaningType > MeaningOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MeaningType, char > MeaningTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MeaningOptional&
    getMeaning () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MeaningOptional&
    getMeaning ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMeaning (const MeaningType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMeaning (const MeaningOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMeaning (::std::unique_ptr< MeaningType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ReferenceRange (const RangeType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ReferenceRange (::std::unique_ptr< RangeType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ReferenceRange (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReferenceRange (const ReferenceRange& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ReferenceRange*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ReferenceRange&
    operator= (const ReferenceRange& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ReferenceRange ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RangeType > Range_;
    MeaningOptional Meaning_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %RequestedOrderDetail schema type.
   *
   * @nosubgrouping
   */
  class RequestedOrderDetail: public ::CDM::OrderDetail
  {
    public:
    /**
     * @name ReferringPhysician
     *
     * @brief Accessor and modifier functions for the %ReferringPhysician
     * optional element.
     *
     * Physician as the initiator of the clinical process, e.g. the general
     * practitioner.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::PersonReference ReferringPhysicianType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ReferringPhysicianType > ReferringPhysicianOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReferringPhysicianType, char > ReferringPhysicianTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ReferringPhysicianOptional&
    getReferringPhysician () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ReferringPhysicianOptional&
    getReferringPhysician ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setReferringPhysician (const ReferringPhysicianType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setReferringPhysician (const ReferringPhysicianOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setReferringPhysician (::std::unique_ptr< ReferringPhysicianType > p);

    //@}

    /**
     * @name RequestingPhysician
     *
     * @brief Accessor and modifier functions for the %RequestingPhysician
     * optional element.
     *
     * Source that initiated the order.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::PersonReference RequestingPhysicianType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RequestingPhysicianType > RequestingPhysicianOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RequestingPhysicianType, char > RequestingPhysicianTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RequestingPhysicianOptional&
    getRequestingPhysician () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RequestingPhysicianOptional&
    getRequestingPhysician ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRequestingPhysician (const RequestingPhysicianType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRequestingPhysician (const RequestingPhysicianOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRequestingPhysician (::std::unique_ptr< RequestingPhysicianType > p);

    //@}

    /**
     * @name PlacerOrderNumber
     *
     * @brief Accessor and modifier functions for the %PlacerOrderNumber
     * required element.
     *
     * Reference key of the order generating system.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::InstanceIdentifier PlacerOrderNumberType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PlacerOrderNumberType, char > PlacerOrderNumberTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PlacerOrderNumberType&
    getPlacerOrderNumber () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PlacerOrderNumberType&
    getPlacerOrderNumber ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPlacerOrderNumber (const PlacerOrderNumberType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPlacerOrderNumber (::std::unique_ptr< PlacerOrderNumberType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RequestedOrderDetail (const PlacerOrderNumberType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    RequestedOrderDetail (::std::unique_ptr< PlacerOrderNumberType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RequestedOrderDetail (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RequestedOrderDetail (const RequestedOrderDetail& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RequestedOrderDetail*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RequestedOrderDetail&
    operator= (const RequestedOrderDetail& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RequestedOrderDetail ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ReferringPhysicianOptional ReferringPhysician_;
    RequestingPhysicianOptional RequestingPhysician_;
    ::xsd::cxx::tree::one< PlacerOrderNumberType > PlacerOrderNumber_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %PerformedOrderDetail schema type.
   *
   * @nosubgrouping
   */
  class PerformedOrderDetail: public ::CDM::OrderDetail
  {
    public:
    /**
     * @name FillerOrderNumber
     *
     * @brief Accessor and modifier functions for the %FillerOrderNumber
     * optional element.
     *
     * Reference key of the order filler system/ departmental system
     * completing or changing order details.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::InstanceIdentifier FillerOrderNumberType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FillerOrderNumberType > FillerOrderNumberOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FillerOrderNumberType, char > FillerOrderNumberTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FillerOrderNumberOptional&
    getFillerOrderNumber () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FillerOrderNumberOptional&
    getFillerOrderNumber ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFillerOrderNumber (const FillerOrderNumberType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFillerOrderNumber (const FillerOrderNumberOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFillerOrderNumber (::std::unique_ptr< FillerOrderNumberType > p);

    //@}

    /**
     * @name ResultingClinicalInfo
     *
     * @brief Accessor and modifier functions for the %ResultingClinicalInfo
     * sequence element.
     *
     * Clinical information resulting from the service.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::CDM::ClinicalInfo ResultingClinicalInfoType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ResultingClinicalInfoType > ResultingClinicalInfoSequence;

    /**
     * @brief Element iterator type.
     */
    typedef ResultingClinicalInfoSequence::iterator ResultingClinicalInfoIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef ResultingClinicalInfoSequence::const_iterator ResultingClinicalInfoConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ResultingClinicalInfoType, char > ResultingClinicalInfoTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ResultingClinicalInfoSequence&
    getResultingClinicalInfo () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ResultingClinicalInfoSequence&
    getResultingClinicalInfo ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setResultingClinicalInfo (const ResultingClinicalInfoSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    PerformedOrderDetail ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    PerformedOrderDetail (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PerformedOrderDetail (const PerformedOrderDetail& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual PerformedOrderDetail*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    PerformedOrderDetail&
    operator= (const PerformedOrderDetail& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~PerformedOrderDetail ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    FillerOrderNumberOptional FillerOrderNumber_;
    ResultingClinicalInfoSequence ResultingClinicalInfo_;

    //@endcond
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace CDM
{
  /**
   * @name Parsing functions for the %MdibContainer document root.
   */
  //@{

  /**
   * @brief Parse a URI or a local file.
   *
   * @param uri A URI or a local file name.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::CDM::Mdib >
  parseMdibContainer (const ::std::string& uri,
                      ::xml_schema::Flags f = 0,
                      const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a URI or a local file with an error handler.
   *
   * @param uri A URI or a local file name.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::CDM::Mdib >
  parseMdibContainer (const ::std::string& uri,
                      ::xml_schema::ErrorHandler& eh,
                      ::xml_schema::Flags f = 0,
                      const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a URI or a local file with a Xerces-C++ DOM error
   * handler.
   *
   * @param uri A URI or a local file name.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::CDM::Mdib >
  parseMdibContainer (const ::std::string& uri,
                      ::xercesc::DOMErrorHandler& eh,
                      ::xml_schema::Flags f = 0,
                      const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream.
   *
   * @param is A standrad input stream.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::CDM::Mdib >
  parseMdibContainer (::std::istream& is,
                      ::xml_schema::Flags f = 0,
                      const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with an error handler.
   *
   * @param is A standrad input stream.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::CDM::Mdib >
  parseMdibContainer (::std::istream& is,
                      ::xml_schema::ErrorHandler& eh,
                      ::xml_schema::Flags f = 0,
                      const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a Xerces-C++ DOM error
   * handler.
   *
   * @param is A standrad input stream.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::CDM::Mdib >
  parseMdibContainer (::std::istream& is,
                      ::xercesc::DOMErrorHandler& eh,
                      ::xml_schema::Flags f = 0,
                      const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::CDM::Mdib >
  parseMdibContainer (::std::istream& is,
                      const ::std::string& id,
                      ::xml_schema::Flags f = 0,
                      const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id and an
   * error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::CDM::Mdib >
  parseMdibContainer (::std::istream& is,
                      const ::std::string& id,
                      ::xml_schema::ErrorHandler& eh,
                      ::xml_schema::Flags f = 0,
                      const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id and a
   * Xerces-C++ DOM error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::CDM::Mdib >
  parseMdibContainer (::std::istream& is,
                      const ::std::string& id,
                      ::xercesc::DOMErrorHandler& eh,
                      ::xml_schema::Flags f = 0,
                      const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source.
   *
   * @param is A Xerces-C++ input source.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::CDM::Mdib >
  parseMdibContainer (::xercesc::InputSource& is,
                      ::xml_schema::Flags f = 0,
                      const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source with an error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::CDM::Mdib >
  parseMdibContainer (::xercesc::InputSource& is,
                      ::xml_schema::ErrorHandler& eh,
                      ::xml_schema::Flags f = 0,
                      const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
   * error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::CDM::Mdib >
  parseMdibContainer (::xercesc::InputSource& is,
                      ::xercesc::DOMErrorHandler& eh,
                      ::xml_schema::Flags f = 0,
                      const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   */
  ::std::unique_ptr< ::CDM::Mdib >
  parseMdibContainer (const ::xercesc::DOMDocument& d,
                      ::xml_schema::Flags f = 0,
                      const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A pointer to the Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function is normally used together with the keep_dom and
   * own_dom parsing flags to assign ownership of the DOM document
   * to the object model.
   */
  ::std::unique_ptr< ::CDM::Mdib >
  parseMdibContainer (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::Flags f = 0,
                      const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  //@}
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace CDM
{
  void
  operator<< (::xercesc::DOMElement&, const Mdib&);

  void
  operator<< (::xercesc::DOMElement&, const MdDescription&);

  void
  operator<< (::xercesc::DOMElement&, const MdState&);

  void
  operator<< (::xercesc::DOMElement&, const MeasurementValidity&);

  void
  operator<< (::xercesc::DOMAttr&, const MeasurementValidity&);

  void
  operator<< (::xml_schema::ListStream&,
              const MeasurementValidity&);

  void
  operator<< (::xercesc::DOMElement&, const Timestamp&);

  void
  operator<< (::xercesc::DOMAttr&, const Timestamp&);

  void
  operator<< (::xml_schema::ListStream&,
              const Timestamp&);

  void
  operator<< (::xercesc::DOMElement&, const VersionCounter&);

  void
  operator<< (::xercesc::DOMAttr&, const VersionCounter&);

  void
  operator<< (::xml_schema::ListStream&,
              const VersionCounter&);

  void
  operator<< (::xercesc::DOMElement&, const ReferencedVersion&);

  void
  operator<< (::xercesc::DOMAttr&, const ReferencedVersion&);

  void
  operator<< (::xml_schema::ListStream&,
              const ReferencedVersion&);

  void
  operator<< (::xercesc::DOMElement&, const CodeIdentifier&);

  void
  operator<< (::xercesc::DOMAttr&, const CodeIdentifier&);

  void
  operator<< (::xml_schema::ListStream&,
              const CodeIdentifier&);

  void
  operator<< (::xercesc::DOMElement&, const SymbolicCodeName&);

  void
  operator<< (::xercesc::DOMAttr&, const SymbolicCodeName&);

  void
  operator<< (::xml_schema::ListStream&,
              const SymbolicCodeName&);

  void
  operator<< (::xercesc::DOMElement&, const LocalizedTextRef&);

  void
  operator<< (::xercesc::DOMAttr&, const LocalizedTextRef&);

  void
  operator<< (::xml_schema::ListStream&,
              const LocalizedTextRef&);

  void
  operator<< (::xercesc::DOMElement&, const LocalizedTextContent&);

  void
  operator<< (::xercesc::DOMAttr&, const LocalizedTextContent&);

  void
  operator<< (::xml_schema::ListStream&,
              const LocalizedTextContent&);

  void
  operator<< (::xercesc::DOMElement&, const LocalizedTextWidth&);

  void
  operator<< (::xercesc::DOMAttr&, const LocalizedTextWidth&);

  void
  operator<< (::xml_schema::ListStream&,
              const LocalizedTextWidth&);

  void
  operator<< (::xercesc::DOMElement&, const LocalizedText&);

  void
  operator<< (::xercesc::DOMElement&, const CodedValue&);

  void
  operator<< (::xercesc::DOMElement&, const InstanceIdentifier&);

  void
  operator<< (::xercesc::DOMElement&, const Range&);

  void
  operator<< (::xercesc::DOMElement&, const Measurement&);

  void
  operator<< (::xercesc::DOMElement&, const SafetyClassification&);

  void
  operator<< (::xercesc::DOMAttr&, const SafetyClassification&);

  void
  operator<< (::xml_schema::ListStream&,
              const SafetyClassification&);

  void
  operator<< (::xercesc::DOMElement&, const ComponentActivation&);

  void
  operator<< (::xercesc::DOMAttr&, const ComponentActivation&);

  void
  operator<< (::xml_schema::ListStream&,
              const ComponentActivation&);

  void
  operator<< (::xercesc::DOMElement&, const ApprovedJurisdictions&);

  void
  operator<< (::xercesc::DOMElement&, const OperatingJurisdiction&);

  void
  operator<< (::xercesc::DOMElement&, const Handle&);

  void
  operator<< (::xercesc::DOMAttr&, const Handle&);

  void
  operator<< (::xml_schema::ListStream&,
              const Handle&);

  void
  operator<< (::xercesc::DOMElement&, const HandleRef&);

  void
  operator<< (::xercesc::DOMAttr&, const HandleRef&);

  void
  operator<< (::xml_schema::ListStream&,
              const HandleRef&);

  void
  operator<< (::xercesc::DOMElement&, const PhysicalConnectorInfo&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractState&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractMultiState&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractDeviceComponentDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractComplexDeviceComponentDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const CalibrationState&);

  void
  operator<< (::xercesc::DOMAttr&, const CalibrationState&);

  void
  operator<< (::xml_schema::ListStream&,
              const CalibrationState&);

  void
  operator<< (::xercesc::DOMElement&, const CalibrationType&);

  void
  operator<< (::xercesc::DOMAttr&, const CalibrationType&);

  void
  operator<< (::xml_schema::ListStream&,
              const CalibrationType&);

  void
  operator<< (::xercesc::DOMElement&, const CalibrationInfo&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractDeviceComponentState&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractComplexDeviceComponentState&);

  void
  operator<< (::xercesc::DOMElement&, const MdsDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const MdsOperatingMode&);

  void
  operator<< (::xercesc::DOMAttr&, const MdsOperatingMode&);

  void
  operator<< (::xml_schema::ListStream&,
              const MdsOperatingMode&);

  void
  operator<< (::xercesc::DOMElement&, const MdsState&);

  void
  operator<< (::xercesc::DOMElement&, const VmdDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const VmdState&);

  void
  operator<< (::xercesc::DOMElement&, const ChannelDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const ChannelState&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractAlertDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractAlertState&);

  void
  operator<< (::xercesc::DOMElement&, const AlertActivation&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertActivation&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertActivation&);

  void
  operator<< (::xercesc::DOMElement&, const SystemSignalActivation&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSystemDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSystemState&);

  void
  operator<< (::xercesc::DOMElement&, const CauseInfo&);

  void
  operator<< (::xercesc::DOMElement&, const RemedyInfo&);

  void
  operator<< (::xercesc::DOMElement&, const AlertConditionKind&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertConditionKind&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertConditionKind&);

  void
  operator<< (::xercesc::DOMElement&, const AlertConditionPriority&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertConditionPriority&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertConditionPriority&);

  void
  operator<< (::xercesc::DOMElement&, const AlertConditionDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AlertConditionReference&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertConditionReference&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertConditionReference&);

  void
  operator<< (::xercesc::DOMElement&, const AlertConditionState&);

  void
  operator<< (::xercesc::DOMElement&, const LimitAlertConditionDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AlertConditionMonitoredLimits&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertConditionMonitoredLimits&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertConditionMonitoredLimits&);

  void
  operator<< (::xercesc::DOMElement&, const LimitAlertConditionState&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSignalManifestation&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertSignalManifestation&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertSignalManifestation&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSignalDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSignalPresence&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertSignalPresence&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertSignalPresence&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSignalPrimaryLocation&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertSignalPrimaryLocation&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertSignalPrimaryLocation&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSignalState&);

  void
  operator<< (::xercesc::DOMElement&, const QualityIndicator&);

  void
  operator<< (::xercesc::DOMAttr&, const QualityIndicator&);

  void
  operator<< (::xml_schema::ListStream&,
              const QualityIndicator&);

  void
  operator<< (::xercesc::DOMElement&, const GenerationMode&);

  void
  operator<< (::xercesc::DOMAttr&, const GenerationMode&);

  void
  operator<< (::xml_schema::ListStream&,
              const GenerationMode&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractMetricValue&);

  void
  operator<< (::xercesc::DOMElement&, const NumericMetricValue&);

  void
  operator<< (::xercesc::DOMElement&, const StringMetricValue&);

  void
  operator<< (::xercesc::DOMElement&, const RealTimeValueType&);

  void
  operator<< (::xercesc::DOMAttr&, const RealTimeValueType&);

  void
  operator<< (::xml_schema::ListStream&,
              const RealTimeValueType&);

  void
  operator<< (::xercesc::DOMElement&, const SampleArrayValue&);

  void
  operator<< (::xercesc::DOMElement&, const MetricCategory&);

  void
  operator<< (::xercesc::DOMAttr&, const MetricCategory&);

  void
  operator<< (::xml_schema::ListStream&,
              const MetricCategory&);

  void
  operator<< (::xercesc::DOMElement&, const DerivationMethod&);

  void
  operator<< (::xercesc::DOMAttr&, const DerivationMethod&);

  void
  operator<< (::xml_schema::ListStream&,
              const DerivationMethod&);

  void
  operator<< (::xercesc::DOMElement&, const MetricAvailability&);

  void
  operator<< (::xercesc::DOMAttr&, const MetricAvailability&);

  void
  operator<< (::xml_schema::ListStream&,
              const MetricAvailability&);

  void
  operator<< (::xercesc::DOMElement&, const EntryRef&);

  void
  operator<< (::xercesc::DOMAttr&, const EntryRef&);

  void
  operator<< (::xml_schema::ListStream&,
              const EntryRef&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractMetricDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractMetricState&);

  void
  operator<< (::xercesc::DOMElement&, const NumericMetricDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const NumericMetricState&);

  void
  operator<< (::xercesc::DOMElement&, const StringMetricDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const StringMetricState&);

  void
  operator<< (::xercesc::DOMElement&, const EnumStringMetricDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const EnumStringMetricState&);

  void
  operator<< (::xercesc::DOMElement&, const RealTimeSampleArrayMetricDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const RealTimeSampleArrayMetricState&);

  void
  operator<< (::xercesc::DOMElement&, const DistributionSampleArrayMetricDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const DistributionSampleArrayMetricState&);

  void
  operator<< (::xercesc::DOMElement&, const OperationRef&);

  void
  operator<< (::xercesc::DOMAttr&, const OperationRef&);

  void
  operator<< (::xml_schema::ListStream&,
              const OperationRef&);

  void
  operator<< (::xercesc::DOMElement&, const ScoDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const ScoState&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractSetStateOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const OperatingMode&);

  void
  operator<< (::xercesc::DOMAttr&, const OperatingMode&);

  void
  operator<< (::xml_schema::ListStream&,
              const OperatingMode&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const SetValueOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SetValueOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const SetStringOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SetStringOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const ActivateOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const ActivateOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const SetContextStateOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SetContextStateOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const SetMetricStateOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SetMetricStateOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const SetComponentStateOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SetComponentStateOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const SetAlertStateOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SetAlertStateOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const TimeZone&);

  void
  operator<< (::xercesc::DOMAttr&, const TimeZone&);

  void
  operator<< (::xml_schema::ListStream&,
              const TimeZone&);

  void
  operator<< (::xercesc::DOMElement&, const ClockDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const ClockState&);

  void
  operator<< (::xercesc::DOMElement&, const BatteryDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const BatteryState&);

  void
  operator<< (::xercesc::DOMElement&, const SystemContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SystemContextState&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const ContextAssociation&);

  void
  operator<< (::xercesc::DOMAttr&, const ContextAssociation&);

  void
  operator<< (::xml_schema::ListStream&,
              const ContextAssociation&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractContextState&);

  void
  operator<< (::xercesc::DOMElement&, const BaseDemographics&);

  void
  operator<< (::xercesc::DOMElement&, const PersonReference&);

  void
  operator<< (::xercesc::DOMElement&, const LocationDetail&);

  void
  operator<< (::xercesc::DOMElement&, const PatientContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const Sex&);

  void
  operator<< (::xercesc::DOMAttr&, const Sex&);

  void
  operator<< (::xml_schema::ListStream&,
              const Sex&);

  void
  operator<< (::xercesc::DOMElement&, const PatientType&);

  void
  operator<< (::xercesc::DOMAttr&, const PatientType&);

  void
  operator<< (::xml_schema::ListStream&,
              const PatientType&);

  void
  operator<< (::xercesc::DOMElement&, const PatientDemographicsCoreData&);

  void
  operator<< (::xercesc::DOMElement&, const NeonatalPatientDemographicsCoreData&);

  void
  operator<< (::xercesc::DOMElement&, const PatientContextState&);

  void
  operator<< (::xercesc::DOMElement&, const LocationContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const LocationContextState&);

  void
  operator<< (::xercesc::DOMElement&, const WorkflowContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const ClinicalInfo&);

  void
  operator<< (::xercesc::DOMElement&, const ImagingProcedure&);

  void
  operator<< (::xercesc::DOMElement&, const LocationReference&);

  void
  operator<< (::xercesc::DOMElement&, const OrderDetail&);

  void
  operator<< (::xercesc::DOMElement&, const PersonParticipation&);

  void
  operator<< (::xercesc::DOMElement&, const WorkflowContextState&);

  void
  operator<< (::xercesc::DOMElement&, const OperatorContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const OperatorContextState&);

  void
  operator<< (::xercesc::DOMElement&, const MeansContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const MeansContextState&);

  void
  operator<< (::xercesc::DOMElement&, const EnsembleContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const EnsembleContextState&);

  void
  operator<< (::xercesc::DOMElement&, const ContainmentTree&);

  void
  operator<< (::xercesc::DOMElement&, const ContainmentTreeEntry&);

  /**
   * @name Serialization functions for the %MdibContainer document root.
   */
  //@{

  /**
   * @brief Serialize to a standard output stream.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  serializeMdibContainer (::std::ostream& os,
                          const ::CDM::Mdib& x, 
                          const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                          const ::std::string& e = "UTF-8",
                          ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a standard output stream with an error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeMdibContainer (::std::ostream& os,
                          const ::CDM::Mdib& x, 
                          ::xml_schema::ErrorHandler& eh,
                          const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                          const ::std::string& e = "UTF-8",
                          ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a standard output stream with a Xerces-C++ DOM
   * error handler.
   *
   * @param os A standrad output stream.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeMdibContainer (::std::ostream& os,
                          const ::CDM::Mdib& x, 
                          ::xercesc::DOMErrorHandler& eh,
                          const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                          const ::std::string& e = "UTF-8",
                          ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function uses exceptions to report serialization errors.
   */
  void
  serializeMdibContainer (::xercesc::XMLFormatTarget& ft,
                          const ::CDM::Mdib& x, 
                          const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                          const ::std::string& e = "UTF-8",
                          ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with an error
   * handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh An error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeMdibContainer (::xercesc::XMLFormatTarget& ft,
                          const ::CDM::Mdib& x, 
                          ::xml_schema::ErrorHandler& eh,
                          const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                          const ::std::string& e = "UTF-8",
                          ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a Xerces-C++ XML format target with a
   * Xerces-C++ DOM error handler.
   *
   * @param ft A Xerces-C++ XML format target.
   * @param x An object model to serialize.
   * @param eh A Xerces-C++ DOM error handler.
   * @param m A namespace information map.
   * @param e A character encoding to produce XML in.
   * @param f Serialization flags.
   *
   * This function reports serialization errors by calling the error
   * handler.
   */
  void
  serializeMdibContainer (::xercesc::XMLFormatTarget& ft,
                          const ::CDM::Mdib& x, 
                          ::xercesc::DOMErrorHandler& eh,
                          const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                          const ::std::string& e = "UTF-8",
                          ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to an existing Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param x An object model to serialize.
   * @param f Serialization flags.
   *
   * Note that it is your responsibility to create the DOM document
   * with the correct root element as well as set the necessary
   * namespace mapping attributes.
   */
  void
  serializeMdibContainer (::xercesc::DOMDocument& d,
                          const ::CDM::Mdib& x,
                          ::xml_schema::Flags f = 0);

  /**
   * @brief Serialize to a new Xerces-C++ DOM document.
   *
   * @param x An object model to serialize.
   * @param m A namespace information map.
   * @param f Serialization flags.
   * @return A pointer to the new Xerces-C++ DOM document.
   */
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeMdibContainer (const ::CDM::Mdib& x, 
                          const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                          ::xml_schema::Flags f = 0);

  //@}

  void
  operator<< (::xercesc::DOMElement&, const Translation&);

  void
  operator<< (::xercesc::DOMElement&, const Root&);

  void
  operator<< (::xercesc::DOMAttr&, const Root&);

  void
  operator<< (::xml_schema::ListStream&,
              const Root&);

  void
  operator<< (::xercesc::DOMElement&, const Extension&);

  void
  operator<< (::xercesc::DOMAttr&, const Extension&);

  void
  operator<< (::xml_schema::ListStream&,
              const Extension&);

  void
  operator<< (::xercesc::DOMElement&, const ProductionSpecification&);

  void
  operator<< (::xercesc::DOMElement&, const CalibrationDocumentation&);

  void
  operator<< (::xercesc::DOMElement&, const MetaData&);

  void
  operator<< (::xercesc::DOMElement&, const CanEscalate&);

  void
  operator<< (::xercesc::DOMAttr&, const CanEscalate&);

  void
  operator<< (::xml_schema::ListStream&,
              const CanEscalate&);

  void
  operator<< (::xercesc::DOMElement&, const CanDeescalate&);

  void
  operator<< (::xercesc::DOMAttr&, const CanDeescalate&);

  void
  operator<< (::xml_schema::ListStream&,
              const CanDeescalate&);

  void
  operator<< (::xercesc::DOMElement&, const MetricQuality&);

  void
  operator<< (::xercesc::DOMElement&, const Annotation&);

  void
  operator<< (::xercesc::DOMElement&, const ApplyAnnotation&);

  void
  operator<< (::xercesc::DOMElement&, const Relation&);

  void
  operator<< (::xercesc::DOMElement&, const AllowedValue&);

  void
  operator<< (::xercesc::DOMElement&, const OperationGroup&);

  void
  operator<< (::xercesc::DOMElement&, const AccessLevel&);

  void
  operator<< (::xercesc::DOMAttr&, const AccessLevel&);

  void
  operator<< (::xml_schema::ListStream&,
              const AccessLevel&);

  void
  operator<< (::xercesc::DOMElement&, const AllowedValues&);

  void
  operator<< (::xercesc::DOMElement&, const Argument&);

  void
  operator<< (::xercesc::DOMElement&, const ChargeStatus&);

  void
  operator<< (::xercesc::DOMAttr&, const ChargeStatus&);

  void
  operator<< (::xml_schema::ListStream&,
              const ChargeStatus&);

  void
  operator<< (::xercesc::DOMElement&, const DateOfBirth&);

  void
  operator<< (::xercesc::DOMAttr&, const DateOfBirth&);

  void
  operator<< (::xml_schema::ListStream&,
              const DateOfBirth&);

  void
  operator<< (::xercesc::DOMElement&, const Criticality&);

  void
  operator<< (::xercesc::DOMAttr&, const Criticality&);

  void
  operator<< (::xml_schema::ListStream&,
              const Criticality&);

  void
  operator<< (::xercesc::DOMElement&, const RelatedMeasurement&);

  void
  operator<< (::xercesc::DOMElement&, const WorkflowDetail&);

  void
  operator<< (::xercesc::DOMElement&, const CalibrationResult&);

  void
  operator<< (::xercesc::DOMElement&, const Udi&);

  void
  operator<< (::xercesc::DOMElement&, const Kind&);

  void
  operator<< (::xercesc::DOMAttr&, const Kind&);

  void
  operator<< (::xml_schema::ListStream&,
              const Kind&);

  void
  operator<< (::xercesc::DOMElement&, const ReferenceRange&);

  void
  operator<< (::xercesc::DOMElement&, const RequestedOrderDetail&);

  void
  operator<< (::xercesc::DOMElement&, const PerformedOrderDetail&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // BICEPS_PARTICIPANT_MODEL_HXX
