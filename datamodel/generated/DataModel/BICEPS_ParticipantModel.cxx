// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "DataModel/BICEPS_ParticipantModel.hxx"

namespace CDM
{
  // Mdib
  // 

  const Mdib::ExtensionOptional& Mdib::
  Extension () const
  {
    return this->Extension_;
  }

  Mdib::ExtensionOptional& Mdib::
  Extension ()
  {
    return this->Extension_;
  }

  void Mdib::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void Mdib::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void Mdib::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const Mdib::MdDescriptionOptional& Mdib::
  MdDescription () const
  {
    return this->MdDescription_;
  }

  Mdib::MdDescriptionOptional& Mdib::
  MdDescription ()
  {
    return this->MdDescription_;
  }

  void Mdib::
  MdDescription (const MdDescriptionType& x)
  {
    this->MdDescription_.set (x);
  }

  void Mdib::
  MdDescription (const MdDescriptionOptional& x)
  {
    this->MdDescription_ = x;
  }

  void Mdib::
  MdDescription (::std::unique_ptr< MdDescriptionType > x)
  {
    this->MdDescription_.set (std::move (x));
  }

  const Mdib::MdStateOptional& Mdib::
  MdState () const
  {
    return this->MdState_;
  }

  Mdib::MdStateOptional& Mdib::
  MdState ()
  {
    return this->MdState_;
  }

  void Mdib::
  MdState (const MdStateType& x)
  {
    this->MdState_.set (x);
  }

  void Mdib::
  MdState (const MdStateOptional& x)
  {
    this->MdState_ = x;
  }

  void Mdib::
  MdState (::std::unique_ptr< MdStateType > x)
  {
    this->MdState_.set (std::move (x));
  }

  const Mdib::MdibVersionOptional& Mdib::
  MdibVersion () const
  {
    return this->MdibVersion_;
  }

  Mdib::MdibVersionOptional& Mdib::
  MdibVersion ()
  {
    return this->MdibVersion_;
  }

  void Mdib::
  MdibVersion (const MdibVersionType& x)
  {
    this->MdibVersion_.set (x);
  }

  void Mdib::
  MdibVersion (const MdibVersionOptional& x)
  {
    this->MdibVersion_ = x;
  }

  void Mdib::
  MdibVersion (::std::unique_ptr< MdibVersionType > x)
  {
    this->MdibVersion_.set (std::move (x));
  }

  const Mdib::SequenceIdType& Mdib::
  SequenceId () const
  {
    return this->SequenceId_.get ();
  }

  Mdib::SequenceIdType& Mdib::
  SequenceId ()
  {
    return this->SequenceId_.get ();
  }

  void Mdib::
  SequenceId (const SequenceIdType& x)
  {
    this->SequenceId_.set (x);
  }

  void Mdib::
  SequenceId (::std::unique_ptr< SequenceIdType > x)
  {
    this->SequenceId_.set (std::move (x));
  }

  const Mdib::InstanceIdOptional& Mdib::
  InstanceId () const
  {
    return this->InstanceId_;
  }

  Mdib::InstanceIdOptional& Mdib::
  InstanceId ()
  {
    return this->InstanceId_;
  }

  void Mdib::
  InstanceId (const InstanceIdType& x)
  {
    this->InstanceId_.set (x);
  }

  void Mdib::
  InstanceId (const InstanceIdOptional& x)
  {
    this->InstanceId_ = x;
  }


  // MdDescription
  // 

  const MdDescription::ExtensionOptional& MdDescription::
  Extension () const
  {
    return this->Extension_;
  }

  MdDescription::ExtensionOptional& MdDescription::
  Extension ()
  {
    return this->Extension_;
  }

  void MdDescription::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void MdDescription::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void MdDescription::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const MdDescription::MdsSequence& MdDescription::
  Mds () const
  {
    return this->Mds_;
  }

  MdDescription::MdsSequence& MdDescription::
  Mds ()
  {
    return this->Mds_;
  }

  void MdDescription::
  Mds (const MdsSequence& s)
  {
    this->Mds_ = s;
  }

  const MdDescription::DescriptionVersionOptional& MdDescription::
  DescriptionVersion () const
  {
    return this->DescriptionVersion_;
  }

  MdDescription::DescriptionVersionOptional& MdDescription::
  DescriptionVersion ()
  {
    return this->DescriptionVersion_;
  }

  void MdDescription::
  DescriptionVersion (const DescriptionVersionType& x)
  {
    this->DescriptionVersion_.set (x);
  }

  void MdDescription::
  DescriptionVersion (const DescriptionVersionOptional& x)
  {
    this->DescriptionVersion_ = x;
  }

  void MdDescription::
  DescriptionVersion (::std::unique_ptr< DescriptionVersionType > x)
  {
    this->DescriptionVersion_.set (std::move (x));
  }


  // MdState
  // 

  const MdState::ExtensionOptional& MdState::
  Extension () const
  {
    return this->Extension_;
  }

  MdState::ExtensionOptional& MdState::
  Extension ()
  {
    return this->Extension_;
  }

  void MdState::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void MdState::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void MdState::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const MdState::StateSequence& MdState::
  State () const
  {
    return this->State_;
  }

  MdState::StateSequence& MdState::
  State ()
  {
    return this->State_;
  }

  void MdState::
  State (const StateSequence& s)
  {
    this->State_ = s;
  }

  const MdState::StateVersionOptional& MdState::
  StateVersion () const
  {
    return this->StateVersion_;
  }

  MdState::StateVersionOptional& MdState::
  StateVersion ()
  {
    return this->StateVersion_;
  }

  void MdState::
  StateVersion (const StateVersionType& x)
  {
    this->StateVersion_.set (x);
  }

  void MdState::
  StateVersion (const StateVersionOptional& x)
  {
    this->StateVersion_ = x;
  }

  void MdState::
  StateVersion (::std::unique_ptr< StateVersionType > x)
  {
    this->StateVersion_.set (std::move (x));
  }


  // MeasurementValidity
  // 

  MeasurementValidity::
  MeasurementValidity (Value v)
  : ::xml_schema::String (_xsd_MeasurementValidity_literals_[v])
  {
  }

  MeasurementValidity::
  MeasurementValidity (const char* v)
  : ::xml_schema::String (v)
  {
  }

  MeasurementValidity::
  MeasurementValidity (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  MeasurementValidity::
  MeasurementValidity (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  MeasurementValidity::
  MeasurementValidity (const MeasurementValidity& v,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  MeasurementValidity& MeasurementValidity::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_MeasurementValidity_literals_[v]);

    return *this;
  }


  // Timestamp
  // 


  // VersionCounter
  // 


  // ReferencedVersion
  // 


  // CodeIdentifier
  // 


  // SymbolicCodeName
  // 


  // LocalizedTextRef
  // 


  // LocalizedTextContent
  // 


  // LocalizedTextWidth
  // 

  LocalizedTextWidth::
  LocalizedTextWidth (Value v)
  : ::xml_schema::String (_xsd_LocalizedTextWidth_literals_[v])
  {
  }

  LocalizedTextWidth::
  LocalizedTextWidth (const char* v)
  : ::xml_schema::String (v)
  {
  }

  LocalizedTextWidth::
  LocalizedTextWidth (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  LocalizedTextWidth::
  LocalizedTextWidth (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  LocalizedTextWidth::
  LocalizedTextWidth (const LocalizedTextWidth& v,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  LocalizedTextWidth& LocalizedTextWidth::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_LocalizedTextWidth_literals_[v]);

    return *this;
  }


  // LocalizedText
  // 

  const LocalizedText::RefOptional& LocalizedText::
  Ref () const
  {
    return this->Ref_;
  }

  LocalizedText::RefOptional& LocalizedText::
  Ref ()
  {
    return this->Ref_;
  }

  void LocalizedText::
  Ref (const RefType& x)
  {
    this->Ref_.set (x);
  }

  void LocalizedText::
  Ref (const RefOptional& x)
  {
    this->Ref_ = x;
  }

  void LocalizedText::
  Ref (::std::unique_ptr< RefType > x)
  {
    this->Ref_.set (std::move (x));
  }

  const LocalizedText::LangOptional& LocalizedText::
  Lang () const
  {
    return this->Lang_;
  }

  LocalizedText::LangOptional& LocalizedText::
  Lang ()
  {
    return this->Lang_;
  }

  void LocalizedText::
  Lang (const LangType& x)
  {
    this->Lang_.set (x);
  }

  void LocalizedText::
  Lang (const LangOptional& x)
  {
    this->Lang_ = x;
  }

  void LocalizedText::
  Lang (::std::unique_ptr< LangType > x)
  {
    this->Lang_.set (std::move (x));
  }

  const LocalizedText::VersionOptional& LocalizedText::
  Version () const
  {
    return this->Version_;
  }

  LocalizedText::VersionOptional& LocalizedText::
  Version ()
  {
    return this->Version_;
  }

  void LocalizedText::
  Version (const VersionType& x)
  {
    this->Version_.set (x);
  }

  void LocalizedText::
  Version (const VersionOptional& x)
  {
    this->Version_ = x;
  }

  void LocalizedText::
  Version (::std::unique_ptr< VersionType > x)
  {
    this->Version_.set (std::move (x));
  }

  const LocalizedText::TextWidthOptional& LocalizedText::
  TextWidth () const
  {
    return this->TextWidth_;
  }

  LocalizedText::TextWidthOptional& LocalizedText::
  TextWidth ()
  {
    return this->TextWidth_;
  }

  void LocalizedText::
  TextWidth (const TextWidthType& x)
  {
    this->TextWidth_.set (x);
  }

  void LocalizedText::
  TextWidth (const TextWidthOptional& x)
  {
    this->TextWidth_ = x;
  }

  void LocalizedText::
  TextWidth (::std::unique_ptr< TextWidthType > x)
  {
    this->TextWidth_.set (std::move (x));
  }


  // CodedValue
  // 

  const CodedValue::ExtensionOptional& CodedValue::
  Extension () const
  {
    return this->Extension_;
  }

  CodedValue::ExtensionOptional& CodedValue::
  Extension ()
  {
    return this->Extension_;
  }

  void CodedValue::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void CodedValue::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void CodedValue::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const CodedValue::CodingSystemNameSequence& CodedValue::
  CodingSystemName () const
  {
    return this->CodingSystemName_;
  }

  CodedValue::CodingSystemNameSequence& CodedValue::
  CodingSystemName ()
  {
    return this->CodingSystemName_;
  }

  void CodedValue::
  CodingSystemName (const CodingSystemNameSequence& s)
  {
    this->CodingSystemName_ = s;
  }

  const CodedValue::ConceptDescriptionSequence& CodedValue::
  ConceptDescription () const
  {
    return this->ConceptDescription_;
  }

  CodedValue::ConceptDescriptionSequence& CodedValue::
  ConceptDescription ()
  {
    return this->ConceptDescription_;
  }

  void CodedValue::
  ConceptDescription (const ConceptDescriptionSequence& s)
  {
    this->ConceptDescription_ = s;
  }

  const CodedValue::TranslationSequence& CodedValue::
  Translation () const
  {
    return this->Translation_;
  }

  CodedValue::TranslationSequence& CodedValue::
  Translation ()
  {
    return this->Translation_;
  }

  void CodedValue::
  Translation (const TranslationSequence& s)
  {
    this->Translation_ = s;
  }

  const CodedValue::CodeType& CodedValue::
  Code () const
  {
    return this->Code_.get ();
  }

  CodedValue::CodeType& CodedValue::
  Code ()
  {
    return this->Code_.get ();
  }

  void CodedValue::
  Code (const CodeType& x)
  {
    this->Code_.set (x);
  }

  void CodedValue::
  Code (::std::unique_ptr< CodeType > x)
  {
    this->Code_.set (std::move (x));
  }

  const CodedValue::CodingSystemOptional& CodedValue::
  CodingSystem () const
  {
    return this->CodingSystem_;
  }

  CodedValue::CodingSystemOptional& CodedValue::
  CodingSystem ()
  {
    return this->CodingSystem_;
  }

  void CodedValue::
  CodingSystem (const CodingSystemType& x)
  {
    this->CodingSystem_.set (x);
  }

  void CodedValue::
  CodingSystem (const CodingSystemOptional& x)
  {
    this->CodingSystem_ = x;
  }

  void CodedValue::
  CodingSystem (::std::unique_ptr< CodingSystemType > x)
  {
    this->CodingSystem_.set (std::move (x));
  }

  const CodedValue::CodingSystemVersionOptional& CodedValue::
  CodingSystemVersion () const
  {
    return this->CodingSystemVersion_;
  }

  CodedValue::CodingSystemVersionOptional& CodedValue::
  CodingSystemVersion ()
  {
    return this->CodingSystemVersion_;
  }

  void CodedValue::
  CodingSystemVersion (const CodingSystemVersionType& x)
  {
    this->CodingSystemVersion_.set (x);
  }

  void CodedValue::
  CodingSystemVersion (const CodingSystemVersionOptional& x)
  {
    this->CodingSystemVersion_ = x;
  }

  void CodedValue::
  CodingSystemVersion (::std::unique_ptr< CodingSystemVersionType > x)
  {
    this->CodingSystemVersion_.set (std::move (x));
  }

  const CodedValue::SymbolicCodeNameOptional& CodedValue::
  SymbolicCodeName () const
  {
    return this->SymbolicCodeName_;
  }

  CodedValue::SymbolicCodeNameOptional& CodedValue::
  SymbolicCodeName ()
  {
    return this->SymbolicCodeName_;
  }

  void CodedValue::
  SymbolicCodeName (const SymbolicCodeNameType& x)
  {
    this->SymbolicCodeName_.set (x);
  }

  void CodedValue::
  SymbolicCodeName (const SymbolicCodeNameOptional& x)
  {
    this->SymbolicCodeName_ = x;
  }

  void CodedValue::
  SymbolicCodeName (::std::unique_ptr< SymbolicCodeNameType > x)
  {
    this->SymbolicCodeName_.set (std::move (x));
  }


  // InstanceIdentifier
  // 

  const InstanceIdentifier::ExtensionOptional& InstanceIdentifier::
  Extension () const
  {
    return this->Extension_;
  }

  InstanceIdentifier::ExtensionOptional& InstanceIdentifier::
  Extension ()
  {
    return this->Extension_;
  }

  void InstanceIdentifier::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void InstanceIdentifier::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void InstanceIdentifier::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const InstanceIdentifier::TypeOptional& InstanceIdentifier::
  Type () const
  {
    return this->Type_;
  }

  InstanceIdentifier::TypeOptional& InstanceIdentifier::
  Type ()
  {
    return this->Type_;
  }

  void InstanceIdentifier::
  Type (const TypeType& x)
  {
    this->Type_.set (x);
  }

  void InstanceIdentifier::
  Type (const TypeOptional& x)
  {
    this->Type_ = x;
  }

  void InstanceIdentifier::
  Type (::std::unique_ptr< TypeType > x)
  {
    this->Type_.set (std::move (x));
  }

  const InstanceIdentifier::IdentifierNameSequence& InstanceIdentifier::
  IdentifierName () const
  {
    return this->IdentifierName_;
  }

  InstanceIdentifier::IdentifierNameSequence& InstanceIdentifier::
  IdentifierName ()
  {
    return this->IdentifierName_;
  }

  void InstanceIdentifier::
  IdentifierName (const IdentifierNameSequence& s)
  {
    this->IdentifierName_ = s;
  }

  const InstanceIdentifier::RootOptional& InstanceIdentifier::
  Root () const
  {
    return this->Root_;
  }

  InstanceIdentifier::RootOptional& InstanceIdentifier::
  Root ()
  {
    return this->Root_;
  }

  void InstanceIdentifier::
  Root (const RootType& x)
  {
    this->Root_.set (x);
  }

  void InstanceIdentifier::
  Root (const RootOptional& x)
  {
    this->Root_ = x;
  }

  void InstanceIdentifier::
  Root (::std::unique_ptr< RootType > x)
  {
    this->Root_.set (std::move (x));
  }

  const InstanceIdentifier::Extension1Optional& InstanceIdentifier::
  Extension1 () const
  {
    return this->Extension1_;
  }

  InstanceIdentifier::Extension1Optional& InstanceIdentifier::
  Extension1 ()
  {
    return this->Extension1_;
  }

  void InstanceIdentifier::
  Extension1 (const Extension1Type& x)
  {
    this->Extension1_.set (x);
  }

  void InstanceIdentifier::
  Extension1 (const Extension1Optional& x)
  {
    this->Extension1_ = x;
  }

  void InstanceIdentifier::
  Extension1 (::std::unique_ptr< Extension1Type > x)
  {
    this->Extension1_.set (std::move (x));
  }


  // Range
  // 

  const Range::ExtensionOptional& Range::
  Extension () const
  {
    return this->Extension_;
  }

  Range::ExtensionOptional& Range::
  Extension ()
  {
    return this->Extension_;
  }

  void Range::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void Range::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void Range::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const Range::LowerOptional& Range::
  Lower () const
  {
    return this->Lower_;
  }

  Range::LowerOptional& Range::
  Lower ()
  {
    return this->Lower_;
  }

  void Range::
  Lower (const LowerType& x)
  {
    this->Lower_.set (x);
  }

  void Range::
  Lower (const LowerOptional& x)
  {
    this->Lower_ = x;
  }

  const Range::UpperOptional& Range::
  Upper () const
  {
    return this->Upper_;
  }

  Range::UpperOptional& Range::
  Upper ()
  {
    return this->Upper_;
  }

  void Range::
  Upper (const UpperType& x)
  {
    this->Upper_.set (x);
  }

  void Range::
  Upper (const UpperOptional& x)
  {
    this->Upper_ = x;
  }

  const Range::StepWidthOptional& Range::
  StepWidth () const
  {
    return this->StepWidth_;
  }

  Range::StepWidthOptional& Range::
  StepWidth ()
  {
    return this->StepWidth_;
  }

  void Range::
  StepWidth (const StepWidthType& x)
  {
    this->StepWidth_.set (x);
  }

  void Range::
  StepWidth (const StepWidthOptional& x)
  {
    this->StepWidth_ = x;
  }

  const Range::RelativeAccuracyOptional& Range::
  RelativeAccuracy () const
  {
    return this->RelativeAccuracy_;
  }

  Range::RelativeAccuracyOptional& Range::
  RelativeAccuracy ()
  {
    return this->RelativeAccuracy_;
  }

  void Range::
  RelativeAccuracy (const RelativeAccuracyType& x)
  {
    this->RelativeAccuracy_.set (x);
  }

  void Range::
  RelativeAccuracy (const RelativeAccuracyOptional& x)
  {
    this->RelativeAccuracy_ = x;
  }

  const Range::AbsoluteAccuracyOptional& Range::
  AbsoluteAccuracy () const
  {
    return this->AbsoluteAccuracy_;
  }

  Range::AbsoluteAccuracyOptional& Range::
  AbsoluteAccuracy ()
  {
    return this->AbsoluteAccuracy_;
  }

  void Range::
  AbsoluteAccuracy (const AbsoluteAccuracyType& x)
  {
    this->AbsoluteAccuracy_.set (x);
  }

  void Range::
  AbsoluteAccuracy (const AbsoluteAccuracyOptional& x)
  {
    this->AbsoluteAccuracy_ = x;
  }


  // Measurement
  // 

  const Measurement::ExtensionOptional& Measurement::
  Extension () const
  {
    return this->Extension_;
  }

  Measurement::ExtensionOptional& Measurement::
  Extension ()
  {
    return this->Extension_;
  }

  void Measurement::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void Measurement::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void Measurement::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const Measurement::MeasurementUnitType& Measurement::
  MeasurementUnit () const
  {
    return this->MeasurementUnit_.get ();
  }

  Measurement::MeasurementUnitType& Measurement::
  MeasurementUnit ()
  {
    return this->MeasurementUnit_.get ();
  }

  void Measurement::
  MeasurementUnit (const MeasurementUnitType& x)
  {
    this->MeasurementUnit_.set (x);
  }

  void Measurement::
  MeasurementUnit (::std::unique_ptr< MeasurementUnitType > x)
  {
    this->MeasurementUnit_.set (std::move (x));
  }

  const Measurement::MeasuredValueType& Measurement::
  MeasuredValue () const
  {
    return this->MeasuredValue_.get ();
  }

  Measurement::MeasuredValueType& Measurement::
  MeasuredValue ()
  {
    return this->MeasuredValue_.get ();
  }

  void Measurement::
  MeasuredValue (const MeasuredValueType& x)
  {
    this->MeasuredValue_.set (x);
  }


  // SafetyClassification
  // 

  SafetyClassification::
  SafetyClassification (Value v)
  : ::xml_schema::String (_xsd_SafetyClassification_literals_[v])
  {
  }

  SafetyClassification::
  SafetyClassification (const char* v)
  : ::xml_schema::String (v)
  {
  }

  SafetyClassification::
  SafetyClassification (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  SafetyClassification::
  SafetyClassification (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  SafetyClassification::
  SafetyClassification (const SafetyClassification& v,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  SafetyClassification& SafetyClassification::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_SafetyClassification_literals_[v]);

    return *this;
  }


  // ComponentActivation
  // 

  ComponentActivation::
  ComponentActivation (Value v)
  : ::xml_schema::String (_xsd_ComponentActivation_literals_[v])
  {
  }

  ComponentActivation::
  ComponentActivation (const char* v)
  : ::xml_schema::String (v)
  {
  }

  ComponentActivation::
  ComponentActivation (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  ComponentActivation::
  ComponentActivation (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  ComponentActivation::
  ComponentActivation (const ComponentActivation& v,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  ComponentActivation& ComponentActivation::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_ComponentActivation_literals_[v]);

    return *this;
  }


  // ApprovedJurisdictions
  // 

  const ApprovedJurisdictions::ApprovedJurisdictionSequence& ApprovedJurisdictions::
  ApprovedJurisdiction () const
  {
    return this->ApprovedJurisdiction_;
  }

  ApprovedJurisdictions::ApprovedJurisdictionSequence& ApprovedJurisdictions::
  ApprovedJurisdiction ()
  {
    return this->ApprovedJurisdiction_;
  }

  void ApprovedJurisdictions::
  ApprovedJurisdiction (const ApprovedJurisdictionSequence& s)
  {
    this->ApprovedJurisdiction_ = s;
  }


  // OperatingJurisdiction
  // 


  // Handle
  // 


  // HandleRef
  // 


  // PhysicalConnectorInfo
  // 

  const PhysicalConnectorInfo::ExtensionOptional& PhysicalConnectorInfo::
  Extension () const
  {
    return this->Extension_;
  }

  PhysicalConnectorInfo::ExtensionOptional& PhysicalConnectorInfo::
  Extension ()
  {
    return this->Extension_;
  }

  void PhysicalConnectorInfo::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void PhysicalConnectorInfo::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void PhysicalConnectorInfo::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const PhysicalConnectorInfo::LabelSequence& PhysicalConnectorInfo::
  Label () const
  {
    return this->Label_;
  }

  PhysicalConnectorInfo::LabelSequence& PhysicalConnectorInfo::
  Label ()
  {
    return this->Label_;
  }

  void PhysicalConnectorInfo::
  Label (const LabelSequence& s)
  {
    this->Label_ = s;
  }

  const PhysicalConnectorInfo::NumberOptional& PhysicalConnectorInfo::
  Number () const
  {
    return this->Number_;
  }

  PhysicalConnectorInfo::NumberOptional& PhysicalConnectorInfo::
  Number ()
  {
    return this->Number_;
  }

  void PhysicalConnectorInfo::
  Number (const NumberType& x)
  {
    this->Number_.set (x);
  }

  void PhysicalConnectorInfo::
  Number (const NumberOptional& x)
  {
    this->Number_ = x;
  }


  // AbstractDescriptor
  // 

  const AbstractDescriptor::ExtensionOptional& AbstractDescriptor::
  Extension () const
  {
    return this->Extension_;
  }

  AbstractDescriptor::ExtensionOptional& AbstractDescriptor::
  Extension ()
  {
    return this->Extension_;
  }

  void AbstractDescriptor::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractDescriptor::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractDescriptor::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const AbstractDescriptor::TypeOptional& AbstractDescriptor::
  Type () const
  {
    return this->Type_;
  }

  AbstractDescriptor::TypeOptional& AbstractDescriptor::
  Type ()
  {
    return this->Type_;
  }

  void AbstractDescriptor::
  Type (const TypeType& x)
  {
    this->Type_.set (x);
  }

  void AbstractDescriptor::
  Type (const TypeOptional& x)
  {
    this->Type_ = x;
  }

  void AbstractDescriptor::
  Type (::std::unique_ptr< TypeType > x)
  {
    this->Type_.set (std::move (x));
  }

  const AbstractDescriptor::HandleType& AbstractDescriptor::
  Handle () const
  {
    return this->Handle_.get ();
  }

  AbstractDescriptor::HandleType& AbstractDescriptor::
  Handle ()
  {
    return this->Handle_.get ();
  }

  void AbstractDescriptor::
  Handle (const HandleType& x)
  {
    this->Handle_.set (x);
  }

  void AbstractDescriptor::
  Handle (::std::unique_ptr< HandleType > x)
  {
    this->Handle_.set (std::move (x));
  }

  const AbstractDescriptor::DescriptorVersionOptional& AbstractDescriptor::
  DescriptorVersion () const
  {
    return this->DescriptorVersion_;
  }

  AbstractDescriptor::DescriptorVersionOptional& AbstractDescriptor::
  DescriptorVersion ()
  {
    return this->DescriptorVersion_;
  }

  void AbstractDescriptor::
  DescriptorVersion (const DescriptorVersionType& x)
  {
    this->DescriptorVersion_.set (x);
  }

  void AbstractDescriptor::
  DescriptorVersion (const DescriptorVersionOptional& x)
  {
    this->DescriptorVersion_ = x;
  }

  void AbstractDescriptor::
  DescriptorVersion (::std::unique_ptr< DescriptorVersionType > x)
  {
    this->DescriptorVersion_.set (std::move (x));
  }

  const AbstractDescriptor::SafetyClassificationOptional& AbstractDescriptor::
  SafetyClassification () const
  {
    return this->SafetyClassification_;
  }

  AbstractDescriptor::SafetyClassificationOptional& AbstractDescriptor::
  SafetyClassification ()
  {
    return this->SafetyClassification_;
  }

  void AbstractDescriptor::
  SafetyClassification (const SafetyClassificationType& x)
  {
    this->SafetyClassification_.set (x);
  }

  void AbstractDescriptor::
  SafetyClassification (const SafetyClassificationOptional& x)
  {
    this->SafetyClassification_ = x;
  }

  void AbstractDescriptor::
  SafetyClassification (::std::unique_ptr< SafetyClassificationType > x)
  {
    this->SafetyClassification_.set (std::move (x));
  }


  // AbstractState
  // 

  const AbstractState::ExtensionOptional& AbstractState::
  Extension () const
  {
    return this->Extension_;
  }

  AbstractState::ExtensionOptional& AbstractState::
  Extension ()
  {
    return this->Extension_;
  }

  void AbstractState::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractState::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractState::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const AbstractState::StateVersionOptional& AbstractState::
  StateVersion () const
  {
    return this->StateVersion_;
  }

  AbstractState::StateVersionOptional& AbstractState::
  StateVersion ()
  {
    return this->StateVersion_;
  }

  void AbstractState::
  StateVersion (const StateVersionType& x)
  {
    this->StateVersion_.set (x);
  }

  void AbstractState::
  StateVersion (const StateVersionOptional& x)
  {
    this->StateVersion_ = x;
  }

  void AbstractState::
  StateVersion (::std::unique_ptr< StateVersionType > x)
  {
    this->StateVersion_.set (std::move (x));
  }

  const AbstractState::DescriptorHandleType& AbstractState::
  DescriptorHandle () const
  {
    return this->DescriptorHandle_.get ();
  }

  AbstractState::DescriptorHandleType& AbstractState::
  DescriptorHandle ()
  {
    return this->DescriptorHandle_.get ();
  }

  void AbstractState::
  DescriptorHandle (const DescriptorHandleType& x)
  {
    this->DescriptorHandle_.set (x);
  }

  void AbstractState::
  DescriptorHandle (::std::unique_ptr< DescriptorHandleType > x)
  {
    this->DescriptorHandle_.set (std::move (x));
  }

  const AbstractState::DescriptorVersionOptional& AbstractState::
  DescriptorVersion () const
  {
    return this->DescriptorVersion_;
  }

  AbstractState::DescriptorVersionOptional& AbstractState::
  DescriptorVersion ()
  {
    return this->DescriptorVersion_;
  }

  void AbstractState::
  DescriptorVersion (const DescriptorVersionType& x)
  {
    this->DescriptorVersion_.set (x);
  }

  void AbstractState::
  DescriptorVersion (const DescriptorVersionOptional& x)
  {
    this->DescriptorVersion_ = x;
  }

  void AbstractState::
  DescriptorVersion (::std::unique_ptr< DescriptorVersionType > x)
  {
    this->DescriptorVersion_.set (std::move (x));
  }


  // AbstractMultiState
  // 

  const AbstractMultiState::CategoryOptional& AbstractMultiState::
  Category () const
  {
    return this->Category_;
  }

  AbstractMultiState::CategoryOptional& AbstractMultiState::
  Category ()
  {
    return this->Category_;
  }

  void AbstractMultiState::
  Category (const CategoryType& x)
  {
    this->Category_.set (x);
  }

  void AbstractMultiState::
  Category (const CategoryOptional& x)
  {
    this->Category_ = x;
  }

  void AbstractMultiState::
  Category (::std::unique_ptr< CategoryType > x)
  {
    this->Category_.set (std::move (x));
  }

  const AbstractMultiState::HandleType& AbstractMultiState::
  Handle () const
  {
    return this->Handle_.get ();
  }

  AbstractMultiState::HandleType& AbstractMultiState::
  Handle ()
  {
    return this->Handle_.get ();
  }

  void AbstractMultiState::
  Handle (const HandleType& x)
  {
    this->Handle_.set (x);
  }

  void AbstractMultiState::
  Handle (::std::unique_ptr< HandleType > x)
  {
    this->Handle_.set (std::move (x));
  }


  // AbstractDeviceComponentDescriptor
  // 

  const AbstractDeviceComponentDescriptor::ProductionSpecificationSequence& AbstractDeviceComponentDescriptor::
  ProductionSpecification () const
  {
    return this->ProductionSpecification_;
  }

  AbstractDeviceComponentDescriptor::ProductionSpecificationSequence& AbstractDeviceComponentDescriptor::
  ProductionSpecification ()
  {
    return this->ProductionSpecification_;
  }

  void AbstractDeviceComponentDescriptor::
  ProductionSpecification (const ProductionSpecificationSequence& s)
  {
    this->ProductionSpecification_ = s;
  }


  // AbstractComplexDeviceComponentDescriptor
  // 

  const AbstractComplexDeviceComponentDescriptor::AlertSystemOptional& AbstractComplexDeviceComponentDescriptor::
  AlertSystem () const
  {
    return this->AlertSystem_;
  }

  AbstractComplexDeviceComponentDescriptor::AlertSystemOptional& AbstractComplexDeviceComponentDescriptor::
  AlertSystem ()
  {
    return this->AlertSystem_;
  }

  void AbstractComplexDeviceComponentDescriptor::
  AlertSystem (const AlertSystemType& x)
  {
    this->AlertSystem_.set (x);
  }

  void AbstractComplexDeviceComponentDescriptor::
  AlertSystem (const AlertSystemOptional& x)
  {
    this->AlertSystem_ = x;
  }

  void AbstractComplexDeviceComponentDescriptor::
  AlertSystem (::std::unique_ptr< AlertSystemType > x)
  {
    this->AlertSystem_.set (std::move (x));
  }

  const AbstractComplexDeviceComponentDescriptor::ScoOptional& AbstractComplexDeviceComponentDescriptor::
  Sco () const
  {
    return this->Sco_;
  }

  AbstractComplexDeviceComponentDescriptor::ScoOptional& AbstractComplexDeviceComponentDescriptor::
  Sco ()
  {
    return this->Sco_;
  }

  void AbstractComplexDeviceComponentDescriptor::
  Sco (const ScoType& x)
  {
    this->Sco_.set (x);
  }

  void AbstractComplexDeviceComponentDescriptor::
  Sco (const ScoOptional& x)
  {
    this->Sco_ = x;
  }

  void AbstractComplexDeviceComponentDescriptor::
  Sco (::std::unique_ptr< ScoType > x)
  {
    this->Sco_.set (std::move (x));
  }


  // CalibrationState
  // 

  CalibrationState::
  CalibrationState (Value v)
  : ::xml_schema::String (_xsd_CalibrationState_literals_[v])
  {
  }

  CalibrationState::
  CalibrationState (const char* v)
  : ::xml_schema::String (v)
  {
  }

  CalibrationState::
  CalibrationState (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  CalibrationState::
  CalibrationState (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  CalibrationState::
  CalibrationState (const CalibrationState& v,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  CalibrationState& CalibrationState::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_CalibrationState_literals_[v]);

    return *this;
  }


  // CalibrationType
  // 

  CalibrationType::
  CalibrationType (Value v)
  : ::xml_schema::String (_xsd_CalibrationType_literals_[v])
  {
  }

  CalibrationType::
  CalibrationType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  CalibrationType::
  CalibrationType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  CalibrationType::
  CalibrationType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  CalibrationType::
  CalibrationType (const CalibrationType& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  CalibrationType& CalibrationType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_CalibrationType_literals_[v]);

    return *this;
  }


  // CalibrationInfo
  // 

  const CalibrationInfo::ExtensionOptional& CalibrationInfo::
  Extension () const
  {
    return this->Extension_;
  }

  CalibrationInfo::ExtensionOptional& CalibrationInfo::
  Extension ()
  {
    return this->Extension_;
  }

  void CalibrationInfo::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void CalibrationInfo::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void CalibrationInfo::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const CalibrationInfo::CalibrationDocumentationSequence& CalibrationInfo::
  CalibrationDocumentation () const
  {
    return this->CalibrationDocumentation_;
  }

  CalibrationInfo::CalibrationDocumentationSequence& CalibrationInfo::
  CalibrationDocumentation ()
  {
    return this->CalibrationDocumentation_;
  }

  void CalibrationInfo::
  CalibrationDocumentation (const CalibrationDocumentationSequence& s)
  {
    this->CalibrationDocumentation_ = s;
  }

  const CalibrationInfo::ComponentCalibrationStateOptional& CalibrationInfo::
  ComponentCalibrationState () const
  {
    return this->ComponentCalibrationState_;
  }

  CalibrationInfo::ComponentCalibrationStateOptional& CalibrationInfo::
  ComponentCalibrationState ()
  {
    return this->ComponentCalibrationState_;
  }

  void CalibrationInfo::
  ComponentCalibrationState (const ComponentCalibrationStateType& x)
  {
    this->ComponentCalibrationState_.set (x);
  }

  void CalibrationInfo::
  ComponentCalibrationState (const ComponentCalibrationStateOptional& x)
  {
    this->ComponentCalibrationState_ = x;
  }

  void CalibrationInfo::
  ComponentCalibrationState (::std::unique_ptr< ComponentCalibrationStateType > x)
  {
    this->ComponentCalibrationState_.set (std::move (x));
  }

  const CalibrationInfo::TypeOptional& CalibrationInfo::
  Type () const
  {
    return this->Type_;
  }

  CalibrationInfo::TypeOptional& CalibrationInfo::
  Type ()
  {
    return this->Type_;
  }

  void CalibrationInfo::
  Type (const TypeType& x)
  {
    this->Type_.set (x);
  }

  void CalibrationInfo::
  Type (const TypeOptional& x)
  {
    this->Type_ = x;
  }

  void CalibrationInfo::
  Type (::std::unique_ptr< TypeType > x)
  {
    this->Type_.set (std::move (x));
  }

  const CalibrationInfo::TimeOptional& CalibrationInfo::
  Time () const
  {
    return this->Time_;
  }

  CalibrationInfo::TimeOptional& CalibrationInfo::
  Time ()
  {
    return this->Time_;
  }

  void CalibrationInfo::
  Time (const TimeType& x)
  {
    this->Time_.set (x);
  }

  void CalibrationInfo::
  Time (const TimeOptional& x)
  {
    this->Time_ = x;
  }

  void CalibrationInfo::
  Time (::std::unique_ptr< TimeType > x)
  {
    this->Time_.set (std::move (x));
  }


  // AbstractDeviceComponentState
  // 

  const AbstractDeviceComponentState::CalibrationInfoOptional& AbstractDeviceComponentState::
  CalibrationInfo () const
  {
    return this->CalibrationInfo_;
  }

  AbstractDeviceComponentState::CalibrationInfoOptional& AbstractDeviceComponentState::
  CalibrationInfo ()
  {
    return this->CalibrationInfo_;
  }

  void AbstractDeviceComponentState::
  CalibrationInfo (const CalibrationInfoType& x)
  {
    this->CalibrationInfo_.set (x);
  }

  void AbstractDeviceComponentState::
  CalibrationInfo (const CalibrationInfoOptional& x)
  {
    this->CalibrationInfo_ = x;
  }

  void AbstractDeviceComponentState::
  CalibrationInfo (::std::unique_ptr< CalibrationInfoType > x)
  {
    this->CalibrationInfo_.set (std::move (x));
  }

  const AbstractDeviceComponentState::NextCalibrationOptional& AbstractDeviceComponentState::
  NextCalibration () const
  {
    return this->NextCalibration_;
  }

  AbstractDeviceComponentState::NextCalibrationOptional& AbstractDeviceComponentState::
  NextCalibration ()
  {
    return this->NextCalibration_;
  }

  void AbstractDeviceComponentState::
  NextCalibration (const NextCalibrationType& x)
  {
    this->NextCalibration_.set (x);
  }

  void AbstractDeviceComponentState::
  NextCalibration (const NextCalibrationOptional& x)
  {
    this->NextCalibration_ = x;
  }

  void AbstractDeviceComponentState::
  NextCalibration (::std::unique_ptr< NextCalibrationType > x)
  {
    this->NextCalibration_.set (std::move (x));
  }

  const AbstractDeviceComponentState::PhysicalConnectorOptional& AbstractDeviceComponentState::
  PhysicalConnector () const
  {
    return this->PhysicalConnector_;
  }

  AbstractDeviceComponentState::PhysicalConnectorOptional& AbstractDeviceComponentState::
  PhysicalConnector ()
  {
    return this->PhysicalConnector_;
  }

  void AbstractDeviceComponentState::
  PhysicalConnector (const PhysicalConnectorType& x)
  {
    this->PhysicalConnector_.set (x);
  }

  void AbstractDeviceComponentState::
  PhysicalConnector (const PhysicalConnectorOptional& x)
  {
    this->PhysicalConnector_ = x;
  }

  void AbstractDeviceComponentState::
  PhysicalConnector (::std::unique_ptr< PhysicalConnectorType > x)
  {
    this->PhysicalConnector_.set (std::move (x));
  }

  const AbstractDeviceComponentState::ActivationStateOptional& AbstractDeviceComponentState::
  ActivationState () const
  {
    return this->ActivationState_;
  }

  AbstractDeviceComponentState::ActivationStateOptional& AbstractDeviceComponentState::
  ActivationState ()
  {
    return this->ActivationState_;
  }

  void AbstractDeviceComponentState::
  ActivationState (const ActivationStateType& x)
  {
    this->ActivationState_.set (x);
  }

  void AbstractDeviceComponentState::
  ActivationState (const ActivationStateOptional& x)
  {
    this->ActivationState_ = x;
  }

  void AbstractDeviceComponentState::
  ActivationState (::std::unique_ptr< ActivationStateType > x)
  {
    this->ActivationState_.set (std::move (x));
  }

  const AbstractDeviceComponentState::OperatingHoursOptional& AbstractDeviceComponentState::
  OperatingHours () const
  {
    return this->OperatingHours_;
  }

  AbstractDeviceComponentState::OperatingHoursOptional& AbstractDeviceComponentState::
  OperatingHours ()
  {
    return this->OperatingHours_;
  }

  void AbstractDeviceComponentState::
  OperatingHours (const OperatingHoursType& x)
  {
    this->OperatingHours_.set (x);
  }

  void AbstractDeviceComponentState::
  OperatingHours (const OperatingHoursOptional& x)
  {
    this->OperatingHours_ = x;
  }

  const AbstractDeviceComponentState::OperatingCyclesOptional& AbstractDeviceComponentState::
  OperatingCycles () const
  {
    return this->OperatingCycles_;
  }

  AbstractDeviceComponentState::OperatingCyclesOptional& AbstractDeviceComponentState::
  OperatingCycles ()
  {
    return this->OperatingCycles_;
  }

  void AbstractDeviceComponentState::
  OperatingCycles (const OperatingCyclesType& x)
  {
    this->OperatingCycles_.set (x);
  }

  void AbstractDeviceComponentState::
  OperatingCycles (const OperatingCyclesOptional& x)
  {
    this->OperatingCycles_ = x;
  }


  // AbstractComplexDeviceComponentState
  // 


  // MdsDescriptor
  // 

  const MdsDescriptor::MetaDataOptional& MdsDescriptor::
  MetaData () const
  {
    return this->MetaData_;
  }

  MdsDescriptor::MetaDataOptional& MdsDescriptor::
  MetaData ()
  {
    return this->MetaData_;
  }

  void MdsDescriptor::
  MetaData (const MetaDataType& x)
  {
    this->MetaData_.set (x);
  }

  void MdsDescriptor::
  MetaData (const MetaDataOptional& x)
  {
    this->MetaData_ = x;
  }

  void MdsDescriptor::
  MetaData (::std::unique_ptr< MetaDataType > x)
  {
    this->MetaData_.set (std::move (x));
  }

  const MdsDescriptor::SystemContextOptional& MdsDescriptor::
  SystemContext () const
  {
    return this->SystemContext_;
  }

  MdsDescriptor::SystemContextOptional& MdsDescriptor::
  SystemContext ()
  {
    return this->SystemContext_;
  }

  void MdsDescriptor::
  SystemContext (const SystemContextType& x)
  {
    this->SystemContext_.set (x);
  }

  void MdsDescriptor::
  SystemContext (const SystemContextOptional& x)
  {
    this->SystemContext_ = x;
  }

  void MdsDescriptor::
  SystemContext (::std::unique_ptr< SystemContextType > x)
  {
    this->SystemContext_.set (std::move (x));
  }

  const MdsDescriptor::ClockOptional& MdsDescriptor::
  Clock () const
  {
    return this->Clock_;
  }

  MdsDescriptor::ClockOptional& MdsDescriptor::
  Clock ()
  {
    return this->Clock_;
  }

  void MdsDescriptor::
  Clock (const ClockType& x)
  {
    this->Clock_.set (x);
  }

  void MdsDescriptor::
  Clock (const ClockOptional& x)
  {
    this->Clock_ = x;
  }

  void MdsDescriptor::
  Clock (::std::unique_ptr< ClockType > x)
  {
    this->Clock_.set (std::move (x));
  }

  const MdsDescriptor::BatterySequence& MdsDescriptor::
  Battery () const
  {
    return this->Battery_;
  }

  MdsDescriptor::BatterySequence& MdsDescriptor::
  Battery ()
  {
    return this->Battery_;
  }

  void MdsDescriptor::
  Battery (const BatterySequence& s)
  {
    this->Battery_ = s;
  }

  const MdsDescriptor::ApprovedJurisdictionsOptional& MdsDescriptor::
  ApprovedJurisdictions () const
  {
    return this->ApprovedJurisdictions_;
  }

  MdsDescriptor::ApprovedJurisdictionsOptional& MdsDescriptor::
  ApprovedJurisdictions ()
  {
    return this->ApprovedJurisdictions_;
  }

  void MdsDescriptor::
  ApprovedJurisdictions (const ApprovedJurisdictionsType& x)
  {
    this->ApprovedJurisdictions_.set (x);
  }

  void MdsDescriptor::
  ApprovedJurisdictions (const ApprovedJurisdictionsOptional& x)
  {
    this->ApprovedJurisdictions_ = x;
  }

  void MdsDescriptor::
  ApprovedJurisdictions (::std::unique_ptr< ApprovedJurisdictionsType > x)
  {
    this->ApprovedJurisdictions_.set (std::move (x));
  }

  const MdsDescriptor::VmdSequence& MdsDescriptor::
  Vmd () const
  {
    return this->Vmd_;
  }

  MdsDescriptor::VmdSequence& MdsDescriptor::
  Vmd ()
  {
    return this->Vmd_;
  }

  void MdsDescriptor::
  Vmd (const VmdSequence& s)
  {
    this->Vmd_ = s;
  }


  // MdsOperatingMode
  // 

  MdsOperatingMode::
  MdsOperatingMode (Value v)
  : ::xml_schema::String (_xsd_MdsOperatingMode_literals_[v])
  {
  }

  MdsOperatingMode::
  MdsOperatingMode (const char* v)
  : ::xml_schema::String (v)
  {
  }

  MdsOperatingMode::
  MdsOperatingMode (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  MdsOperatingMode::
  MdsOperatingMode (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  MdsOperatingMode::
  MdsOperatingMode (const MdsOperatingMode& v,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  MdsOperatingMode& MdsOperatingMode::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_MdsOperatingMode_literals_[v]);

    return *this;
  }


  // MdsState
  // 

  const MdsState::OperatingJurisdictionOptional& MdsState::
  OperatingJurisdiction () const
  {
    return this->OperatingJurisdiction_;
  }

  MdsState::OperatingJurisdictionOptional& MdsState::
  OperatingJurisdiction ()
  {
    return this->OperatingJurisdiction_;
  }

  void MdsState::
  OperatingJurisdiction (const OperatingJurisdictionType& x)
  {
    this->OperatingJurisdiction_.set (x);
  }

  void MdsState::
  OperatingJurisdiction (const OperatingJurisdictionOptional& x)
  {
    this->OperatingJurisdiction_ = x;
  }

  void MdsState::
  OperatingJurisdiction (::std::unique_ptr< OperatingJurisdictionType > x)
  {
    this->OperatingJurisdiction_.set (std::move (x));
  }

  const MdsState::LangOptional& MdsState::
  Lang () const
  {
    return this->Lang_;
  }

  MdsState::LangOptional& MdsState::
  Lang ()
  {
    return this->Lang_;
  }

  void MdsState::
  Lang (const LangType& x)
  {
    this->Lang_.set (x);
  }

  void MdsState::
  Lang (const LangOptional& x)
  {
    this->Lang_ = x;
  }

  void MdsState::
  Lang (::std::unique_ptr< LangType > x)
  {
    this->Lang_.set (std::move (x));
  }

  const MdsState::OperatingModeOptional& MdsState::
  OperatingMode () const
  {
    return this->OperatingMode_;
  }

  MdsState::OperatingModeOptional& MdsState::
  OperatingMode ()
  {
    return this->OperatingMode_;
  }

  void MdsState::
  OperatingMode (const OperatingModeType& x)
  {
    this->OperatingMode_.set (x);
  }

  void MdsState::
  OperatingMode (const OperatingModeOptional& x)
  {
    this->OperatingMode_ = x;
  }

  void MdsState::
  OperatingMode (::std::unique_ptr< OperatingModeType > x)
  {
    this->OperatingMode_.set (std::move (x));
  }


  // VmdDescriptor
  // 

  const VmdDescriptor::ApprovedJurisdictionsOptional& VmdDescriptor::
  ApprovedJurisdictions () const
  {
    return this->ApprovedJurisdictions_;
  }

  VmdDescriptor::ApprovedJurisdictionsOptional& VmdDescriptor::
  ApprovedJurisdictions ()
  {
    return this->ApprovedJurisdictions_;
  }

  void VmdDescriptor::
  ApprovedJurisdictions (const ApprovedJurisdictionsType& x)
  {
    this->ApprovedJurisdictions_.set (x);
  }

  void VmdDescriptor::
  ApprovedJurisdictions (const ApprovedJurisdictionsOptional& x)
  {
    this->ApprovedJurisdictions_ = x;
  }

  void VmdDescriptor::
  ApprovedJurisdictions (::std::unique_ptr< ApprovedJurisdictionsType > x)
  {
    this->ApprovedJurisdictions_.set (std::move (x));
  }

  const VmdDescriptor::ChannelSequence& VmdDescriptor::
  Channel () const
  {
    return this->Channel_;
  }

  VmdDescriptor::ChannelSequence& VmdDescriptor::
  Channel ()
  {
    return this->Channel_;
  }

  void VmdDescriptor::
  Channel (const ChannelSequence& s)
  {
    this->Channel_ = s;
  }


  // VmdState
  // 

  const VmdState::OperatingJurisdictionOptional& VmdState::
  OperatingJurisdiction () const
  {
    return this->OperatingJurisdiction_;
  }

  VmdState::OperatingJurisdictionOptional& VmdState::
  OperatingJurisdiction ()
  {
    return this->OperatingJurisdiction_;
  }

  void VmdState::
  OperatingJurisdiction (const OperatingJurisdictionType& x)
  {
    this->OperatingJurisdiction_.set (x);
  }

  void VmdState::
  OperatingJurisdiction (const OperatingJurisdictionOptional& x)
  {
    this->OperatingJurisdiction_ = x;
  }

  void VmdState::
  OperatingJurisdiction (::std::unique_ptr< OperatingJurisdictionType > x)
  {
    this->OperatingJurisdiction_.set (std::move (x));
  }


  // ChannelDescriptor
  // 

  const ChannelDescriptor::MetricSequence& ChannelDescriptor::
  Metric () const
  {
    return this->Metric_;
  }

  ChannelDescriptor::MetricSequence& ChannelDescriptor::
  Metric ()
  {
    return this->Metric_;
  }

  void ChannelDescriptor::
  Metric (const MetricSequence& s)
  {
    this->Metric_ = s;
  }


  // ChannelState
  // 


  // AbstractAlertDescriptor
  // 


  // AbstractAlertState
  // 

  const AbstractAlertState::ActivationStateType& AbstractAlertState::
  ActivationState () const
  {
    return this->ActivationState_.get ();
  }

  AbstractAlertState::ActivationStateType& AbstractAlertState::
  ActivationState ()
  {
    return this->ActivationState_.get ();
  }

  void AbstractAlertState::
  ActivationState (const ActivationStateType& x)
  {
    this->ActivationState_.set (x);
  }

  void AbstractAlertState::
  ActivationState (::std::unique_ptr< ActivationStateType > x)
  {
    this->ActivationState_.set (std::move (x));
  }


  // AlertActivation
  // 

  AlertActivation::
  AlertActivation (Value v)
  : ::xml_schema::String (_xsd_AlertActivation_literals_[v])
  {
  }

  AlertActivation::
  AlertActivation (const char* v)
  : ::xml_schema::String (v)
  {
  }

  AlertActivation::
  AlertActivation (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  AlertActivation::
  AlertActivation (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  AlertActivation::
  AlertActivation (const AlertActivation& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  AlertActivation& AlertActivation::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_AlertActivation_literals_[v]);

    return *this;
  }


  // SystemSignalActivation
  // 

  const SystemSignalActivation::ManifestationType& SystemSignalActivation::
  Manifestation () const
  {
    return this->Manifestation_.get ();
  }

  SystemSignalActivation::ManifestationType& SystemSignalActivation::
  Manifestation ()
  {
    return this->Manifestation_.get ();
  }

  void SystemSignalActivation::
  Manifestation (const ManifestationType& x)
  {
    this->Manifestation_.set (x);
  }

  void SystemSignalActivation::
  Manifestation (::std::unique_ptr< ManifestationType > x)
  {
    this->Manifestation_.set (std::move (x));
  }

  const SystemSignalActivation::StateType& SystemSignalActivation::
  State () const
  {
    return this->State_.get ();
  }

  SystemSignalActivation::StateType& SystemSignalActivation::
  State ()
  {
    return this->State_.get ();
  }

  void SystemSignalActivation::
  State (const StateType& x)
  {
    this->State_.set (x);
  }

  void SystemSignalActivation::
  State (::std::unique_ptr< StateType > x)
  {
    this->State_.set (std::move (x));
  }


  // AlertSystemDescriptor
  // 

  const AlertSystemDescriptor::AlertConditionSequence& AlertSystemDescriptor::
  AlertCondition () const
  {
    return this->AlertCondition_;
  }

  AlertSystemDescriptor::AlertConditionSequence& AlertSystemDescriptor::
  AlertCondition ()
  {
    return this->AlertCondition_;
  }

  void AlertSystemDescriptor::
  AlertCondition (const AlertConditionSequence& s)
  {
    this->AlertCondition_ = s;
  }

  const AlertSystemDescriptor::AlertSignalSequence& AlertSystemDescriptor::
  AlertSignal () const
  {
    return this->AlertSignal_;
  }

  AlertSystemDescriptor::AlertSignalSequence& AlertSystemDescriptor::
  AlertSignal ()
  {
    return this->AlertSignal_;
  }

  void AlertSystemDescriptor::
  AlertSignal (const AlertSignalSequence& s)
  {
    this->AlertSignal_ = s;
  }

  const AlertSystemDescriptor::MaxPhysiologicalParallelAlarmsOptional& AlertSystemDescriptor::
  MaxPhysiologicalParallelAlarms () const
  {
    return this->MaxPhysiologicalParallelAlarms_;
  }

  AlertSystemDescriptor::MaxPhysiologicalParallelAlarmsOptional& AlertSystemDescriptor::
  MaxPhysiologicalParallelAlarms ()
  {
    return this->MaxPhysiologicalParallelAlarms_;
  }

  void AlertSystemDescriptor::
  MaxPhysiologicalParallelAlarms (const MaxPhysiologicalParallelAlarmsType& x)
  {
    this->MaxPhysiologicalParallelAlarms_.set (x);
  }

  void AlertSystemDescriptor::
  MaxPhysiologicalParallelAlarms (const MaxPhysiologicalParallelAlarmsOptional& x)
  {
    this->MaxPhysiologicalParallelAlarms_ = x;
  }

  const AlertSystemDescriptor::MaxTechnicalParallelAlarmsOptional& AlertSystemDescriptor::
  MaxTechnicalParallelAlarms () const
  {
    return this->MaxTechnicalParallelAlarms_;
  }

  AlertSystemDescriptor::MaxTechnicalParallelAlarmsOptional& AlertSystemDescriptor::
  MaxTechnicalParallelAlarms ()
  {
    return this->MaxTechnicalParallelAlarms_;
  }

  void AlertSystemDescriptor::
  MaxTechnicalParallelAlarms (const MaxTechnicalParallelAlarmsType& x)
  {
    this->MaxTechnicalParallelAlarms_.set (x);
  }

  void AlertSystemDescriptor::
  MaxTechnicalParallelAlarms (const MaxTechnicalParallelAlarmsOptional& x)
  {
    this->MaxTechnicalParallelAlarms_ = x;
  }

  const AlertSystemDescriptor::SelfCheckPeriodOptional& AlertSystemDescriptor::
  SelfCheckPeriod () const
  {
    return this->SelfCheckPeriod_;
  }

  AlertSystemDescriptor::SelfCheckPeriodOptional& AlertSystemDescriptor::
  SelfCheckPeriod ()
  {
    return this->SelfCheckPeriod_;
  }

  void AlertSystemDescriptor::
  SelfCheckPeriod (const SelfCheckPeriodType& x)
  {
    this->SelfCheckPeriod_.set (x);
  }

  void AlertSystemDescriptor::
  SelfCheckPeriod (const SelfCheckPeriodOptional& x)
  {
    this->SelfCheckPeriod_ = x;
  }

  void AlertSystemDescriptor::
  SelfCheckPeriod (::std::unique_ptr< SelfCheckPeriodType > x)
  {
    this->SelfCheckPeriod_.set (std::move (x));
  }


  // AlertSystemState
  // 

  const AlertSystemState::SystemSignalActivationSequence& AlertSystemState::
  SystemSignalActivation () const
  {
    return this->SystemSignalActivation_;
  }

  AlertSystemState::SystemSignalActivationSequence& AlertSystemState::
  SystemSignalActivation ()
  {
    return this->SystemSignalActivation_;
  }

  void AlertSystemState::
  SystemSignalActivation (const SystemSignalActivationSequence& s)
  {
    this->SystemSignalActivation_ = s;
  }

  const AlertSystemState::LastSelfCheckOptional& AlertSystemState::
  LastSelfCheck () const
  {
    return this->LastSelfCheck_;
  }

  AlertSystemState::LastSelfCheckOptional& AlertSystemState::
  LastSelfCheck ()
  {
    return this->LastSelfCheck_;
  }

  void AlertSystemState::
  LastSelfCheck (const LastSelfCheckType& x)
  {
    this->LastSelfCheck_.set (x);
  }

  void AlertSystemState::
  LastSelfCheck (const LastSelfCheckOptional& x)
  {
    this->LastSelfCheck_ = x;
  }

  void AlertSystemState::
  LastSelfCheck (::std::unique_ptr< LastSelfCheckType > x)
  {
    this->LastSelfCheck_.set (std::move (x));
  }

  const AlertSystemState::SelfCheckCountOptional& AlertSystemState::
  SelfCheckCount () const
  {
    return this->SelfCheckCount_;
  }

  AlertSystemState::SelfCheckCountOptional& AlertSystemState::
  SelfCheckCount ()
  {
    return this->SelfCheckCount_;
  }

  void AlertSystemState::
  SelfCheckCount (const SelfCheckCountType& x)
  {
    this->SelfCheckCount_.set (x);
  }

  void AlertSystemState::
  SelfCheckCount (const SelfCheckCountOptional& x)
  {
    this->SelfCheckCount_ = x;
  }

  const AlertSystemState::PresentPhysiologicalAlarmConditionsOptional& AlertSystemState::
  PresentPhysiologicalAlarmConditions () const
  {
    return this->PresentPhysiologicalAlarmConditions_;
  }

  AlertSystemState::PresentPhysiologicalAlarmConditionsOptional& AlertSystemState::
  PresentPhysiologicalAlarmConditions ()
  {
    return this->PresentPhysiologicalAlarmConditions_;
  }

  void AlertSystemState::
  PresentPhysiologicalAlarmConditions (const PresentPhysiologicalAlarmConditionsType& x)
  {
    this->PresentPhysiologicalAlarmConditions_.set (x);
  }

  void AlertSystemState::
  PresentPhysiologicalAlarmConditions (const PresentPhysiologicalAlarmConditionsOptional& x)
  {
    this->PresentPhysiologicalAlarmConditions_ = x;
  }

  void AlertSystemState::
  PresentPhysiologicalAlarmConditions (::std::unique_ptr< PresentPhysiologicalAlarmConditionsType > x)
  {
    this->PresentPhysiologicalAlarmConditions_.set (std::move (x));
  }

  const AlertSystemState::PresentTechnicalAlarmConditionsOptional& AlertSystemState::
  PresentTechnicalAlarmConditions () const
  {
    return this->PresentTechnicalAlarmConditions_;
  }

  AlertSystemState::PresentTechnicalAlarmConditionsOptional& AlertSystemState::
  PresentTechnicalAlarmConditions ()
  {
    return this->PresentTechnicalAlarmConditions_;
  }

  void AlertSystemState::
  PresentTechnicalAlarmConditions (const PresentTechnicalAlarmConditionsType& x)
  {
    this->PresentTechnicalAlarmConditions_.set (x);
  }

  void AlertSystemState::
  PresentTechnicalAlarmConditions (const PresentTechnicalAlarmConditionsOptional& x)
  {
    this->PresentTechnicalAlarmConditions_ = x;
  }

  void AlertSystemState::
  PresentTechnicalAlarmConditions (::std::unique_ptr< PresentTechnicalAlarmConditionsType > x)
  {
    this->PresentTechnicalAlarmConditions_.set (std::move (x));
  }


  // CauseInfo
  // 

  const CauseInfo::ExtensionOptional& CauseInfo::
  Extension () const
  {
    return this->Extension_;
  }

  CauseInfo::ExtensionOptional& CauseInfo::
  Extension ()
  {
    return this->Extension_;
  }

  void CauseInfo::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void CauseInfo::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void CauseInfo::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const CauseInfo::RemedyInfoOptional& CauseInfo::
  RemedyInfo () const
  {
    return this->RemedyInfo_;
  }

  CauseInfo::RemedyInfoOptional& CauseInfo::
  RemedyInfo ()
  {
    return this->RemedyInfo_;
  }

  void CauseInfo::
  RemedyInfo (const RemedyInfoType& x)
  {
    this->RemedyInfo_.set (x);
  }

  void CauseInfo::
  RemedyInfo (const RemedyInfoOptional& x)
  {
    this->RemedyInfo_ = x;
  }

  void CauseInfo::
  RemedyInfo (::std::unique_ptr< RemedyInfoType > x)
  {
    this->RemedyInfo_.set (std::move (x));
  }

  const CauseInfo::DescriptionSequence& CauseInfo::
  Description () const
  {
    return this->Description_;
  }

  CauseInfo::DescriptionSequence& CauseInfo::
  Description ()
  {
    return this->Description_;
  }

  void CauseInfo::
  Description (const DescriptionSequence& s)
  {
    this->Description_ = s;
  }


  // RemedyInfo
  // 

  const RemedyInfo::ExtensionOptional& RemedyInfo::
  Extension () const
  {
    return this->Extension_;
  }

  RemedyInfo::ExtensionOptional& RemedyInfo::
  Extension ()
  {
    return this->Extension_;
  }

  void RemedyInfo::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void RemedyInfo::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void RemedyInfo::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const RemedyInfo::DescriptionSequence& RemedyInfo::
  Description () const
  {
    return this->Description_;
  }

  RemedyInfo::DescriptionSequence& RemedyInfo::
  Description ()
  {
    return this->Description_;
  }

  void RemedyInfo::
  Description (const DescriptionSequence& s)
  {
    this->Description_ = s;
  }


  // AlertConditionKind
  // 

  AlertConditionKind::
  AlertConditionKind (Value v)
  : ::xml_schema::String (_xsd_AlertConditionKind_literals_[v])
  {
  }

  AlertConditionKind::
  AlertConditionKind (const char* v)
  : ::xml_schema::String (v)
  {
  }

  AlertConditionKind::
  AlertConditionKind (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  AlertConditionKind::
  AlertConditionKind (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  AlertConditionKind::
  AlertConditionKind (const AlertConditionKind& v,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  AlertConditionKind& AlertConditionKind::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_AlertConditionKind_literals_[v]);

    return *this;
  }


  // AlertConditionPriority
  // 

  AlertConditionPriority::
  AlertConditionPriority (Value v)
  : ::xml_schema::String (_xsd_AlertConditionPriority_literals_[v])
  {
  }

  AlertConditionPriority::
  AlertConditionPriority (const char* v)
  : ::xml_schema::String (v)
  {
  }

  AlertConditionPriority::
  AlertConditionPriority (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  AlertConditionPriority::
  AlertConditionPriority (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  AlertConditionPriority::
  AlertConditionPriority (const AlertConditionPriority& v,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  AlertConditionPriority& AlertConditionPriority::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_AlertConditionPriority_literals_[v]);

    return *this;
  }


  // AlertConditionDescriptor
  // 

  const AlertConditionDescriptor::SourceSequence& AlertConditionDescriptor::
  Source () const
  {
    return this->Source_;
  }

  AlertConditionDescriptor::SourceSequence& AlertConditionDescriptor::
  Source ()
  {
    return this->Source_;
  }

  void AlertConditionDescriptor::
  Source (const SourceSequence& s)
  {
    this->Source_ = s;
  }

  const AlertConditionDescriptor::CauseInfoSequence& AlertConditionDescriptor::
  CauseInfo () const
  {
    return this->CauseInfo_;
  }

  AlertConditionDescriptor::CauseInfoSequence& AlertConditionDescriptor::
  CauseInfo ()
  {
    return this->CauseInfo_;
  }

  void AlertConditionDescriptor::
  CauseInfo (const CauseInfoSequence& s)
  {
    this->CauseInfo_ = s;
  }

  const AlertConditionDescriptor::KindType& AlertConditionDescriptor::
  Kind () const
  {
    return this->Kind_.get ();
  }

  AlertConditionDescriptor::KindType& AlertConditionDescriptor::
  Kind ()
  {
    return this->Kind_.get ();
  }

  void AlertConditionDescriptor::
  Kind (const KindType& x)
  {
    this->Kind_.set (x);
  }

  void AlertConditionDescriptor::
  Kind (::std::unique_ptr< KindType > x)
  {
    this->Kind_.set (std::move (x));
  }

  const AlertConditionDescriptor::PriorityType& AlertConditionDescriptor::
  Priority () const
  {
    return this->Priority_.get ();
  }

  AlertConditionDescriptor::PriorityType& AlertConditionDescriptor::
  Priority ()
  {
    return this->Priority_.get ();
  }

  void AlertConditionDescriptor::
  Priority (const PriorityType& x)
  {
    this->Priority_.set (x);
  }

  void AlertConditionDescriptor::
  Priority (::std::unique_ptr< PriorityType > x)
  {
    this->Priority_.set (std::move (x));
  }

  const AlertConditionDescriptor::DefaultConditionGenerationDelayOptional& AlertConditionDescriptor::
  DefaultConditionGenerationDelay () const
  {
    return this->DefaultConditionGenerationDelay_;
  }

  AlertConditionDescriptor::DefaultConditionGenerationDelayOptional& AlertConditionDescriptor::
  DefaultConditionGenerationDelay ()
  {
    return this->DefaultConditionGenerationDelay_;
  }

  void AlertConditionDescriptor::
  DefaultConditionGenerationDelay (const DefaultConditionGenerationDelayType& x)
  {
    this->DefaultConditionGenerationDelay_.set (x);
  }

  void AlertConditionDescriptor::
  DefaultConditionGenerationDelay (const DefaultConditionGenerationDelayOptional& x)
  {
    this->DefaultConditionGenerationDelay_ = x;
  }

  void AlertConditionDescriptor::
  DefaultConditionGenerationDelay (::std::unique_ptr< DefaultConditionGenerationDelayType > x)
  {
    this->DefaultConditionGenerationDelay_.set (std::move (x));
  }

  const AlertConditionDescriptor::CanEscalateOptional& AlertConditionDescriptor::
  CanEscalate () const
  {
    return this->CanEscalate_;
  }

  AlertConditionDescriptor::CanEscalateOptional& AlertConditionDescriptor::
  CanEscalate ()
  {
    return this->CanEscalate_;
  }

  void AlertConditionDescriptor::
  CanEscalate (const CanEscalateType& x)
  {
    this->CanEscalate_.set (x);
  }

  void AlertConditionDescriptor::
  CanEscalate (const CanEscalateOptional& x)
  {
    this->CanEscalate_ = x;
  }

  void AlertConditionDescriptor::
  CanEscalate (::std::unique_ptr< CanEscalateType > x)
  {
    this->CanEscalate_.set (std::move (x));
  }

  const AlertConditionDescriptor::CanDeescalateOptional& AlertConditionDescriptor::
  CanDeescalate () const
  {
    return this->CanDeescalate_;
  }

  AlertConditionDescriptor::CanDeescalateOptional& AlertConditionDescriptor::
  CanDeescalate ()
  {
    return this->CanDeescalate_;
  }

  void AlertConditionDescriptor::
  CanDeescalate (const CanDeescalateType& x)
  {
    this->CanDeescalate_.set (x);
  }

  void AlertConditionDescriptor::
  CanDeescalate (const CanDeescalateOptional& x)
  {
    this->CanDeescalate_ = x;
  }

  void AlertConditionDescriptor::
  CanDeescalate (::std::unique_ptr< CanDeescalateType > x)
  {
    this->CanDeescalate_.set (std::move (x));
  }


  // AlertConditionReference
  //

  AlertConditionReference::
  AlertConditionReference ()
  : ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (this)
  {
  }

  AlertConditionReference::
  AlertConditionReference (size_type n, const ::CDM::HandleRef& x)
  : ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (n, x, this)
  {
  }

  AlertConditionReference::
  AlertConditionReference (const AlertConditionReference& o,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (o, f, c),
    ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (o, f, this)
  {
  }

  // AlertConditionState
  // 

  const AlertConditionState::ActualConditionGenerationDelayOptional& AlertConditionState::
  ActualConditionGenerationDelay () const
  {
    return this->ActualConditionGenerationDelay_;
  }

  AlertConditionState::ActualConditionGenerationDelayOptional& AlertConditionState::
  ActualConditionGenerationDelay ()
  {
    return this->ActualConditionGenerationDelay_;
  }

  void AlertConditionState::
  ActualConditionGenerationDelay (const ActualConditionGenerationDelayType& x)
  {
    this->ActualConditionGenerationDelay_.set (x);
  }

  void AlertConditionState::
  ActualConditionGenerationDelay (const ActualConditionGenerationDelayOptional& x)
  {
    this->ActualConditionGenerationDelay_ = x;
  }

  void AlertConditionState::
  ActualConditionGenerationDelay (::std::unique_ptr< ActualConditionGenerationDelayType > x)
  {
    this->ActualConditionGenerationDelay_.set (std::move (x));
  }

  const AlertConditionState::ActualPriorityOptional& AlertConditionState::
  ActualPriority () const
  {
    return this->ActualPriority_;
  }

  AlertConditionState::ActualPriorityOptional& AlertConditionState::
  ActualPriority ()
  {
    return this->ActualPriority_;
  }

  void AlertConditionState::
  ActualPriority (const ActualPriorityType& x)
  {
    this->ActualPriority_.set (x);
  }

  void AlertConditionState::
  ActualPriority (const ActualPriorityOptional& x)
  {
    this->ActualPriority_ = x;
  }

  void AlertConditionState::
  ActualPriority (::std::unique_ptr< ActualPriorityType > x)
  {
    this->ActualPriority_.set (std::move (x));
  }

  const AlertConditionState::RankOptional& AlertConditionState::
  Rank () const
  {
    return this->Rank_;
  }

  AlertConditionState::RankOptional& AlertConditionState::
  Rank ()
  {
    return this->Rank_;
  }

  void AlertConditionState::
  Rank (const RankType& x)
  {
    this->Rank_.set (x);
  }

  void AlertConditionState::
  Rank (const RankOptional& x)
  {
    this->Rank_ = x;
  }

  const AlertConditionState::PresenceOptional& AlertConditionState::
  Presence () const
  {
    return this->Presence_;
  }

  AlertConditionState::PresenceOptional& AlertConditionState::
  Presence ()
  {
    return this->Presence_;
  }

  void AlertConditionState::
  Presence (const PresenceType& x)
  {
    this->Presence_.set (x);
  }

  void AlertConditionState::
  Presence (const PresenceOptional& x)
  {
    this->Presence_ = x;
  }

  const AlertConditionState::DeterminationTimeOptional& AlertConditionState::
  DeterminationTime () const
  {
    return this->DeterminationTime_;
  }

  AlertConditionState::DeterminationTimeOptional& AlertConditionState::
  DeterminationTime ()
  {
    return this->DeterminationTime_;
  }

  void AlertConditionState::
  DeterminationTime (const DeterminationTimeType& x)
  {
    this->DeterminationTime_.set (x);
  }

  void AlertConditionState::
  DeterminationTime (const DeterminationTimeOptional& x)
  {
    this->DeterminationTime_ = x;
  }

  void AlertConditionState::
  DeterminationTime (::std::unique_ptr< DeterminationTimeType > x)
  {
    this->DeterminationTime_.set (std::move (x));
  }


  // LimitAlertConditionDescriptor
  // 

  const LimitAlertConditionDescriptor::MaxLimitsType& LimitAlertConditionDescriptor::
  MaxLimits () const
  {
    return this->MaxLimits_.get ();
  }

  LimitAlertConditionDescriptor::MaxLimitsType& LimitAlertConditionDescriptor::
  MaxLimits ()
  {
    return this->MaxLimits_.get ();
  }

  void LimitAlertConditionDescriptor::
  MaxLimits (const MaxLimitsType& x)
  {
    this->MaxLimits_.set (x);
  }

  void LimitAlertConditionDescriptor::
  MaxLimits (::std::unique_ptr< MaxLimitsType > x)
  {
    this->MaxLimits_.set (std::move (x));
  }

  const LimitAlertConditionDescriptor::AutoLimitSupportedOptional& LimitAlertConditionDescriptor::
  AutoLimitSupported () const
  {
    return this->AutoLimitSupported_;
  }

  LimitAlertConditionDescriptor::AutoLimitSupportedOptional& LimitAlertConditionDescriptor::
  AutoLimitSupported ()
  {
    return this->AutoLimitSupported_;
  }

  void LimitAlertConditionDescriptor::
  AutoLimitSupported (const AutoLimitSupportedType& x)
  {
    this->AutoLimitSupported_.set (x);
  }

  void LimitAlertConditionDescriptor::
  AutoLimitSupported (const AutoLimitSupportedOptional& x)
  {
    this->AutoLimitSupported_ = x;
  }


  // AlertConditionMonitoredLimits
  // 

  AlertConditionMonitoredLimits::
  AlertConditionMonitoredLimits (Value v)
  : ::xml_schema::String (_xsd_AlertConditionMonitoredLimits_literals_[v])
  {
  }

  AlertConditionMonitoredLimits::
  AlertConditionMonitoredLimits (const char* v)
  : ::xml_schema::String (v)
  {
  }

  AlertConditionMonitoredLimits::
  AlertConditionMonitoredLimits (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  AlertConditionMonitoredLimits::
  AlertConditionMonitoredLimits (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  AlertConditionMonitoredLimits::
  AlertConditionMonitoredLimits (const AlertConditionMonitoredLimits& v,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  AlertConditionMonitoredLimits& AlertConditionMonitoredLimits::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_AlertConditionMonitoredLimits_literals_[v]);

    return *this;
  }


  // LimitAlertConditionState
  // 

  const LimitAlertConditionState::LimitsType& LimitAlertConditionState::
  Limits () const
  {
    return this->Limits_.get ();
  }

  LimitAlertConditionState::LimitsType& LimitAlertConditionState::
  Limits ()
  {
    return this->Limits_.get ();
  }

  void LimitAlertConditionState::
  Limits (const LimitsType& x)
  {
    this->Limits_.set (x);
  }

  void LimitAlertConditionState::
  Limits (::std::unique_ptr< LimitsType > x)
  {
    this->Limits_.set (std::move (x));
  }

  const LimitAlertConditionState::MonitoredAlertLimitsType& LimitAlertConditionState::
  MonitoredAlertLimits () const
  {
    return this->MonitoredAlertLimits_.get ();
  }

  LimitAlertConditionState::MonitoredAlertLimitsType& LimitAlertConditionState::
  MonitoredAlertLimits ()
  {
    return this->MonitoredAlertLimits_.get ();
  }

  void LimitAlertConditionState::
  MonitoredAlertLimits (const MonitoredAlertLimitsType& x)
  {
    this->MonitoredAlertLimits_.set (x);
  }

  void LimitAlertConditionState::
  MonitoredAlertLimits (::std::unique_ptr< MonitoredAlertLimitsType > x)
  {
    this->MonitoredAlertLimits_.set (std::move (x));
  }

  const LimitAlertConditionState::AutoLimitActivationStateOptional& LimitAlertConditionState::
  AutoLimitActivationState () const
  {
    return this->AutoLimitActivationState_;
  }

  LimitAlertConditionState::AutoLimitActivationStateOptional& LimitAlertConditionState::
  AutoLimitActivationState ()
  {
    return this->AutoLimitActivationState_;
  }

  void LimitAlertConditionState::
  AutoLimitActivationState (const AutoLimitActivationStateType& x)
  {
    this->AutoLimitActivationState_.set (x);
  }

  void LimitAlertConditionState::
  AutoLimitActivationState (const AutoLimitActivationStateOptional& x)
  {
    this->AutoLimitActivationState_ = x;
  }

  void LimitAlertConditionState::
  AutoLimitActivationState (::std::unique_ptr< AutoLimitActivationStateType > x)
  {
    this->AutoLimitActivationState_.set (std::move (x));
  }


  // AlertSignalManifestation
  // 

  AlertSignalManifestation::
  AlertSignalManifestation (Value v)
  : ::xml_schema::String (_xsd_AlertSignalManifestation_literals_[v])
  {
  }

  AlertSignalManifestation::
  AlertSignalManifestation (const char* v)
  : ::xml_schema::String (v)
  {
  }

  AlertSignalManifestation::
  AlertSignalManifestation (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  AlertSignalManifestation::
  AlertSignalManifestation (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  AlertSignalManifestation::
  AlertSignalManifestation (const AlertSignalManifestation& v,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  AlertSignalManifestation& AlertSignalManifestation::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_AlertSignalManifestation_literals_[v]);

    return *this;
  }


  // AlertSignalDescriptor
  // 

  const AlertSignalDescriptor::ConditionSignaledOptional& AlertSignalDescriptor::
  ConditionSignaled () const
  {
    return this->ConditionSignaled_;
  }

  AlertSignalDescriptor::ConditionSignaledOptional& AlertSignalDescriptor::
  ConditionSignaled ()
  {
    return this->ConditionSignaled_;
  }

  void AlertSignalDescriptor::
  ConditionSignaled (const ConditionSignaledType& x)
  {
    this->ConditionSignaled_.set (x);
  }

  void AlertSignalDescriptor::
  ConditionSignaled (const ConditionSignaledOptional& x)
  {
    this->ConditionSignaled_ = x;
  }

  void AlertSignalDescriptor::
  ConditionSignaled (::std::unique_ptr< ConditionSignaledType > x)
  {
    this->ConditionSignaled_.set (std::move (x));
  }

  const AlertSignalDescriptor::ManifestationType& AlertSignalDescriptor::
  Manifestation () const
  {
    return this->Manifestation_.get ();
  }

  AlertSignalDescriptor::ManifestationType& AlertSignalDescriptor::
  Manifestation ()
  {
    return this->Manifestation_.get ();
  }

  void AlertSignalDescriptor::
  Manifestation (const ManifestationType& x)
  {
    this->Manifestation_.set (x);
  }

  void AlertSignalDescriptor::
  Manifestation (::std::unique_ptr< ManifestationType > x)
  {
    this->Manifestation_.set (std::move (x));
  }

  const AlertSignalDescriptor::LatchingType& AlertSignalDescriptor::
  Latching () const
  {
    return this->Latching_.get ();
  }

  AlertSignalDescriptor::LatchingType& AlertSignalDescriptor::
  Latching ()
  {
    return this->Latching_.get ();
  }

  void AlertSignalDescriptor::
  Latching (const LatchingType& x)
  {
    this->Latching_.set (x);
  }

  const AlertSignalDescriptor::DefaultSignalGenerationDelayOptional& AlertSignalDescriptor::
  DefaultSignalGenerationDelay () const
  {
    return this->DefaultSignalGenerationDelay_;
  }

  AlertSignalDescriptor::DefaultSignalGenerationDelayOptional& AlertSignalDescriptor::
  DefaultSignalGenerationDelay ()
  {
    return this->DefaultSignalGenerationDelay_;
  }

  void AlertSignalDescriptor::
  DefaultSignalGenerationDelay (const DefaultSignalGenerationDelayType& x)
  {
    this->DefaultSignalGenerationDelay_.set (x);
  }

  void AlertSignalDescriptor::
  DefaultSignalGenerationDelay (const DefaultSignalGenerationDelayOptional& x)
  {
    this->DefaultSignalGenerationDelay_ = x;
  }

  void AlertSignalDescriptor::
  DefaultSignalGenerationDelay (::std::unique_ptr< DefaultSignalGenerationDelayType > x)
  {
    this->DefaultSignalGenerationDelay_.set (std::move (x));
  }

  const AlertSignalDescriptor::MinSignalGenerationDelayOptional& AlertSignalDescriptor::
  MinSignalGenerationDelay () const
  {
    return this->MinSignalGenerationDelay_;
  }

  AlertSignalDescriptor::MinSignalGenerationDelayOptional& AlertSignalDescriptor::
  MinSignalGenerationDelay ()
  {
    return this->MinSignalGenerationDelay_;
  }

  void AlertSignalDescriptor::
  MinSignalGenerationDelay (const MinSignalGenerationDelayType& x)
  {
    this->MinSignalGenerationDelay_.set (x);
  }

  void AlertSignalDescriptor::
  MinSignalGenerationDelay (const MinSignalGenerationDelayOptional& x)
  {
    this->MinSignalGenerationDelay_ = x;
  }

  void AlertSignalDescriptor::
  MinSignalGenerationDelay (::std::unique_ptr< MinSignalGenerationDelayType > x)
  {
    this->MinSignalGenerationDelay_.set (std::move (x));
  }

  const AlertSignalDescriptor::MaxSignalGenerationDelayOptional& AlertSignalDescriptor::
  MaxSignalGenerationDelay () const
  {
    return this->MaxSignalGenerationDelay_;
  }

  AlertSignalDescriptor::MaxSignalGenerationDelayOptional& AlertSignalDescriptor::
  MaxSignalGenerationDelay ()
  {
    return this->MaxSignalGenerationDelay_;
  }

  void AlertSignalDescriptor::
  MaxSignalGenerationDelay (const MaxSignalGenerationDelayType& x)
  {
    this->MaxSignalGenerationDelay_.set (x);
  }

  void AlertSignalDescriptor::
  MaxSignalGenerationDelay (const MaxSignalGenerationDelayOptional& x)
  {
    this->MaxSignalGenerationDelay_ = x;
  }

  void AlertSignalDescriptor::
  MaxSignalGenerationDelay (::std::unique_ptr< MaxSignalGenerationDelayType > x)
  {
    this->MaxSignalGenerationDelay_.set (std::move (x));
  }

  const AlertSignalDescriptor::SignalDelegationSupportedOptional& AlertSignalDescriptor::
  SignalDelegationSupported () const
  {
    return this->SignalDelegationSupported_;
  }

  AlertSignalDescriptor::SignalDelegationSupportedOptional& AlertSignalDescriptor::
  SignalDelegationSupported ()
  {
    return this->SignalDelegationSupported_;
  }

  void AlertSignalDescriptor::
  SignalDelegationSupported (const SignalDelegationSupportedType& x)
  {
    this->SignalDelegationSupported_.set (x);
  }

  void AlertSignalDescriptor::
  SignalDelegationSupported (const SignalDelegationSupportedOptional& x)
  {
    this->SignalDelegationSupported_ = x;
  }

  const AlertSignalDescriptor::AcknowledgementSupportedOptional& AlertSignalDescriptor::
  AcknowledgementSupported () const
  {
    return this->AcknowledgementSupported_;
  }

  AlertSignalDescriptor::AcknowledgementSupportedOptional& AlertSignalDescriptor::
  AcknowledgementSupported ()
  {
    return this->AcknowledgementSupported_;
  }

  void AlertSignalDescriptor::
  AcknowledgementSupported (const AcknowledgementSupportedType& x)
  {
    this->AcknowledgementSupported_.set (x);
  }

  void AlertSignalDescriptor::
  AcknowledgementSupported (const AcknowledgementSupportedOptional& x)
  {
    this->AcknowledgementSupported_ = x;
  }

  const AlertSignalDescriptor::AcknowledgeTimeoutOptional& AlertSignalDescriptor::
  AcknowledgeTimeout () const
  {
    return this->AcknowledgeTimeout_;
  }

  AlertSignalDescriptor::AcknowledgeTimeoutOptional& AlertSignalDescriptor::
  AcknowledgeTimeout ()
  {
    return this->AcknowledgeTimeout_;
  }

  void AlertSignalDescriptor::
  AcknowledgeTimeout (const AcknowledgeTimeoutType& x)
  {
    this->AcknowledgeTimeout_.set (x);
  }

  void AlertSignalDescriptor::
  AcknowledgeTimeout (const AcknowledgeTimeoutOptional& x)
  {
    this->AcknowledgeTimeout_ = x;
  }

  void AlertSignalDescriptor::
  AcknowledgeTimeout (::std::unique_ptr< AcknowledgeTimeoutType > x)
  {
    this->AcknowledgeTimeout_.set (std::move (x));
  }


  // AlertSignalPresence
  // 

  AlertSignalPresence::
  AlertSignalPresence (Value v)
  : ::xml_schema::String (_xsd_AlertSignalPresence_literals_[v])
  {
  }

  AlertSignalPresence::
  AlertSignalPresence (const char* v)
  : ::xml_schema::String (v)
  {
  }

  AlertSignalPresence::
  AlertSignalPresence (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  AlertSignalPresence::
  AlertSignalPresence (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  AlertSignalPresence::
  AlertSignalPresence (const AlertSignalPresence& v,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  AlertSignalPresence& AlertSignalPresence::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_AlertSignalPresence_literals_[v]);

    return *this;
  }


  // AlertSignalPrimaryLocation
  // 

  AlertSignalPrimaryLocation::
  AlertSignalPrimaryLocation (Value v)
  : ::xml_schema::String (_xsd_AlertSignalPrimaryLocation_literals_[v])
  {
  }

  AlertSignalPrimaryLocation::
  AlertSignalPrimaryLocation (const char* v)
  : ::xml_schema::String (v)
  {
  }

  AlertSignalPrimaryLocation::
  AlertSignalPrimaryLocation (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  AlertSignalPrimaryLocation::
  AlertSignalPrimaryLocation (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  AlertSignalPrimaryLocation::
  AlertSignalPrimaryLocation (const AlertSignalPrimaryLocation& v,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  AlertSignalPrimaryLocation& AlertSignalPrimaryLocation::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_AlertSignalPrimaryLocation_literals_[v]);

    return *this;
  }


  // AlertSignalState
  // 

  const AlertSignalState::ActualSignalGenerationDelayOptional& AlertSignalState::
  ActualSignalGenerationDelay () const
  {
    return this->ActualSignalGenerationDelay_;
  }

  AlertSignalState::ActualSignalGenerationDelayOptional& AlertSignalState::
  ActualSignalGenerationDelay ()
  {
    return this->ActualSignalGenerationDelay_;
  }

  void AlertSignalState::
  ActualSignalGenerationDelay (const ActualSignalGenerationDelayType& x)
  {
    this->ActualSignalGenerationDelay_.set (x);
  }

  void AlertSignalState::
  ActualSignalGenerationDelay (const ActualSignalGenerationDelayOptional& x)
  {
    this->ActualSignalGenerationDelay_ = x;
  }

  void AlertSignalState::
  ActualSignalGenerationDelay (::std::unique_ptr< ActualSignalGenerationDelayType > x)
  {
    this->ActualSignalGenerationDelay_.set (std::move (x));
  }

  const AlertSignalState::PresenceOptional& AlertSignalState::
  Presence () const
  {
    return this->Presence_;
  }

  AlertSignalState::PresenceOptional& AlertSignalState::
  Presence ()
  {
    return this->Presence_;
  }

  void AlertSignalState::
  Presence (const PresenceType& x)
  {
    this->Presence_.set (x);
  }

  void AlertSignalState::
  Presence (const PresenceOptional& x)
  {
    this->Presence_ = x;
  }

  void AlertSignalState::
  Presence (::std::unique_ptr< PresenceType > x)
  {
    this->Presence_.set (std::move (x));
  }

  const AlertSignalState::LocationOptional& AlertSignalState::
  Location () const
  {
    return this->Location_;
  }

  AlertSignalState::LocationOptional& AlertSignalState::
  Location ()
  {
    return this->Location_;
  }

  void AlertSignalState::
  Location (const LocationType& x)
  {
    this->Location_.set (x);
  }

  void AlertSignalState::
  Location (const LocationOptional& x)
  {
    this->Location_ = x;
  }

  void AlertSignalState::
  Location (::std::unique_ptr< LocationType > x)
  {
    this->Location_.set (std::move (x));
  }

  const AlertSignalState::SlotOptional& AlertSignalState::
  Slot () const
  {
    return this->Slot_;
  }

  AlertSignalState::SlotOptional& AlertSignalState::
  Slot ()
  {
    return this->Slot_;
  }

  void AlertSignalState::
  Slot (const SlotType& x)
  {
    this->Slot_.set (x);
  }

  void AlertSignalState::
  Slot (const SlotOptional& x)
  {
    this->Slot_ = x;
  }


  // QualityIndicator
  // 


  // GenerationMode
  // 

  GenerationMode::
  GenerationMode (Value v)
  : ::xml_schema::String (_xsd_GenerationMode_literals_[v])
  {
  }

  GenerationMode::
  GenerationMode (const char* v)
  : ::xml_schema::String (v)
  {
  }

  GenerationMode::
  GenerationMode (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  GenerationMode::
  GenerationMode (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  GenerationMode::
  GenerationMode (const GenerationMode& v,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  GenerationMode& GenerationMode::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_GenerationMode_literals_[v]);

    return *this;
  }


  // AbstractMetricValue
  // 

  const AbstractMetricValue::ExtensionOptional& AbstractMetricValue::
  Extension () const
  {
    return this->Extension_;
  }

  AbstractMetricValue::ExtensionOptional& AbstractMetricValue::
  Extension ()
  {
    return this->Extension_;
  }

  void AbstractMetricValue::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractMetricValue::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractMetricValue::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const AbstractMetricValue::MetricQualityType& AbstractMetricValue::
  MetricQuality () const
  {
    return this->MetricQuality_.get ();
  }

  AbstractMetricValue::MetricQualityType& AbstractMetricValue::
  MetricQuality ()
  {
    return this->MetricQuality_.get ();
  }

  void AbstractMetricValue::
  MetricQuality (const MetricQualityType& x)
  {
    this->MetricQuality_.set (x);
  }

  void AbstractMetricValue::
  MetricQuality (::std::unique_ptr< MetricQualityType > x)
  {
    this->MetricQuality_.set (std::move (x));
  }

  const AbstractMetricValue::AnnotationSequence& AbstractMetricValue::
  Annotation () const
  {
    return this->Annotation_;
  }

  AbstractMetricValue::AnnotationSequence& AbstractMetricValue::
  Annotation ()
  {
    return this->Annotation_;
  }

  void AbstractMetricValue::
  Annotation (const AnnotationSequence& s)
  {
    this->Annotation_ = s;
  }

  const AbstractMetricValue::StartTimeOptional& AbstractMetricValue::
  StartTime () const
  {
    return this->StartTime_;
  }

  AbstractMetricValue::StartTimeOptional& AbstractMetricValue::
  StartTime ()
  {
    return this->StartTime_;
  }

  void AbstractMetricValue::
  StartTime (const StartTimeType& x)
  {
    this->StartTime_.set (x);
  }

  void AbstractMetricValue::
  StartTime (const StartTimeOptional& x)
  {
    this->StartTime_ = x;
  }

  void AbstractMetricValue::
  StartTime (::std::unique_ptr< StartTimeType > x)
  {
    this->StartTime_.set (std::move (x));
  }

  const AbstractMetricValue::StopTimeOptional& AbstractMetricValue::
  StopTime () const
  {
    return this->StopTime_;
  }

  AbstractMetricValue::StopTimeOptional& AbstractMetricValue::
  StopTime ()
  {
    return this->StopTime_;
  }

  void AbstractMetricValue::
  StopTime (const StopTimeType& x)
  {
    this->StopTime_.set (x);
  }

  void AbstractMetricValue::
  StopTime (const StopTimeOptional& x)
  {
    this->StopTime_ = x;
  }

  void AbstractMetricValue::
  StopTime (::std::unique_ptr< StopTimeType > x)
  {
    this->StopTime_.set (std::move (x));
  }

  const AbstractMetricValue::DeterminationTimeOptional& AbstractMetricValue::
  DeterminationTime () const
  {
    return this->DeterminationTime_;
  }

  AbstractMetricValue::DeterminationTimeOptional& AbstractMetricValue::
  DeterminationTime ()
  {
    return this->DeterminationTime_;
  }

  void AbstractMetricValue::
  DeterminationTime (const DeterminationTimeType& x)
  {
    this->DeterminationTime_.set (x);
  }

  void AbstractMetricValue::
  DeterminationTime (const DeterminationTimeOptional& x)
  {
    this->DeterminationTime_ = x;
  }

  void AbstractMetricValue::
  DeterminationTime (::std::unique_ptr< DeterminationTimeType > x)
  {
    this->DeterminationTime_.set (std::move (x));
  }


  // NumericMetricValue
  // 

  const NumericMetricValue::ValueOptional& NumericMetricValue::
  Value () const
  {
    return this->Value_;
  }

  NumericMetricValue::ValueOptional& NumericMetricValue::
  Value ()
  {
    return this->Value_;
  }

  void NumericMetricValue::
  Value (const ValueType& x)
  {
    this->Value_.set (x);
  }

  void NumericMetricValue::
  Value (const ValueOptional& x)
  {
    this->Value_ = x;
  }


  // StringMetricValue
  // 

  const StringMetricValue::ValueOptional& StringMetricValue::
  Value () const
  {
    return this->Value_;
  }

  StringMetricValue::ValueOptional& StringMetricValue::
  Value ()
  {
    return this->Value_;
  }

  void StringMetricValue::
  Value (const ValueType& x)
  {
    this->Value_.set (x);
  }

  void StringMetricValue::
  Value (const ValueOptional& x)
  {
    this->Value_ = x;
  }

  void StringMetricValue::
  Value (::std::unique_ptr< ValueType > x)
  {
    this->Value_.set (std::move (x));
  }


  // RealTimeValueType
  //

  RealTimeValueType::
  RealTimeValueType ()
  : ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal > (this)
  {
  }

  RealTimeValueType::
  RealTimeValueType (size_type n, const ::xml_schema::Decimal& x)
  : ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal > (n, x, this)
  {
  }

  RealTimeValueType::
  RealTimeValueType (const RealTimeValueType& o,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal > (o, f, this)
  {
  }

  // SampleArrayValue
  // 

  const SampleArrayValue::ApplyAnnotationSequence& SampleArrayValue::
  ApplyAnnotation () const
  {
    return this->ApplyAnnotation_;
  }

  SampleArrayValue::ApplyAnnotationSequence& SampleArrayValue::
  ApplyAnnotation ()
  {
    return this->ApplyAnnotation_;
  }

  void SampleArrayValue::
  ApplyAnnotation (const ApplyAnnotationSequence& s)
  {
    this->ApplyAnnotation_ = s;
  }

  const SampleArrayValue::SamplesOptional& SampleArrayValue::
  Samples () const
  {
    return this->Samples_;
  }

  SampleArrayValue::SamplesOptional& SampleArrayValue::
  Samples ()
  {
    return this->Samples_;
  }

  void SampleArrayValue::
  Samples (const SamplesType& x)
  {
    this->Samples_.set (x);
  }

  void SampleArrayValue::
  Samples (const SamplesOptional& x)
  {
    this->Samples_ = x;
  }

  void SampleArrayValue::
  Samples (::std::unique_ptr< SamplesType > x)
  {
    this->Samples_.set (std::move (x));
  }


  // MetricCategory
  // 

  MetricCategory::
  MetricCategory (Value v)
  : ::xml_schema::String (_xsd_MetricCategory_literals_[v])
  {
  }

  MetricCategory::
  MetricCategory (const char* v)
  : ::xml_schema::String (v)
  {
  }

  MetricCategory::
  MetricCategory (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  MetricCategory::
  MetricCategory (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  MetricCategory::
  MetricCategory (const MetricCategory& v,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  MetricCategory& MetricCategory::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_MetricCategory_literals_[v]);

    return *this;
  }


  // DerivationMethod
  // 

  DerivationMethod::
  DerivationMethod (Value v)
  : ::xml_schema::String (_xsd_DerivationMethod_literals_[v])
  {
  }

  DerivationMethod::
  DerivationMethod (const char* v)
  : ::xml_schema::String (v)
  {
  }

  DerivationMethod::
  DerivationMethod (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  DerivationMethod::
  DerivationMethod (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  DerivationMethod::
  DerivationMethod (const DerivationMethod& v,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  DerivationMethod& DerivationMethod::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_DerivationMethod_literals_[v]);

    return *this;
  }


  // MetricAvailability
  // 

  MetricAvailability::
  MetricAvailability (Value v)
  : ::xml_schema::String (_xsd_MetricAvailability_literals_[v])
  {
  }

  MetricAvailability::
  MetricAvailability (const char* v)
  : ::xml_schema::String (v)
  {
  }

  MetricAvailability::
  MetricAvailability (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  MetricAvailability::
  MetricAvailability (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  MetricAvailability::
  MetricAvailability (const MetricAvailability& v,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  MetricAvailability& MetricAvailability::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_MetricAvailability_literals_[v]);

    return *this;
  }


  // EntryRef
  //

  EntryRef::
  EntryRef ()
  : ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (this)
  {
  }

  EntryRef::
  EntryRef (size_type n, const ::CDM::HandleRef& x)
  : ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (n, x, this)
  {
  }

  EntryRef::
  EntryRef (const EntryRef& o,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (o, f, c),
    ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (o, f, this)
  {
  }

  // AbstractMetricDescriptor
  // 

  const AbstractMetricDescriptor::UnitType& AbstractMetricDescriptor::
  Unit () const
  {
    return this->Unit_.get ();
  }

  AbstractMetricDescriptor::UnitType& AbstractMetricDescriptor::
  Unit ()
  {
    return this->Unit_.get ();
  }

  void AbstractMetricDescriptor::
  Unit (const UnitType& x)
  {
    this->Unit_.set (x);
  }

  void AbstractMetricDescriptor::
  Unit (::std::unique_ptr< UnitType > x)
  {
    this->Unit_.set (std::move (x));
  }

  const AbstractMetricDescriptor::BodySiteSequence& AbstractMetricDescriptor::
  BodySite () const
  {
    return this->BodySite_;
  }

  AbstractMetricDescriptor::BodySiteSequence& AbstractMetricDescriptor::
  BodySite ()
  {
    return this->BodySite_;
  }

  void AbstractMetricDescriptor::
  BodySite (const BodySiteSequence& s)
  {
    this->BodySite_ = s;
  }

  const AbstractMetricDescriptor::RelationSequence& AbstractMetricDescriptor::
  Relation () const
  {
    return this->Relation_;
  }

  AbstractMetricDescriptor::RelationSequence& AbstractMetricDescriptor::
  Relation ()
  {
    return this->Relation_;
  }

  void AbstractMetricDescriptor::
  Relation (const RelationSequence& s)
  {
    this->Relation_ = s;
  }

  const AbstractMetricDescriptor::MetricCategoryType& AbstractMetricDescriptor::
  MetricCategory () const
  {
    return this->MetricCategory_.get ();
  }

  AbstractMetricDescriptor::MetricCategoryType& AbstractMetricDescriptor::
  MetricCategory ()
  {
    return this->MetricCategory_.get ();
  }

  void AbstractMetricDescriptor::
  MetricCategory (const MetricCategoryType& x)
  {
    this->MetricCategory_.set (x);
  }

  void AbstractMetricDescriptor::
  MetricCategory (::std::unique_ptr< MetricCategoryType > x)
  {
    this->MetricCategory_.set (std::move (x));
  }

  const AbstractMetricDescriptor::DerivationMethodOptional& AbstractMetricDescriptor::
  DerivationMethod () const
  {
    return this->DerivationMethod_;
  }

  AbstractMetricDescriptor::DerivationMethodOptional& AbstractMetricDescriptor::
  DerivationMethod ()
  {
    return this->DerivationMethod_;
  }

  void AbstractMetricDescriptor::
  DerivationMethod (const DerivationMethodType& x)
  {
    this->DerivationMethod_.set (x);
  }

  void AbstractMetricDescriptor::
  DerivationMethod (const DerivationMethodOptional& x)
  {
    this->DerivationMethod_ = x;
  }

  void AbstractMetricDescriptor::
  DerivationMethod (::std::unique_ptr< DerivationMethodType > x)
  {
    this->DerivationMethod_.set (std::move (x));
  }

  const AbstractMetricDescriptor::MetricAvailabilityType& AbstractMetricDescriptor::
  MetricAvailability () const
  {
    return this->MetricAvailability_.get ();
  }

  AbstractMetricDescriptor::MetricAvailabilityType& AbstractMetricDescriptor::
  MetricAvailability ()
  {
    return this->MetricAvailability_.get ();
  }

  void AbstractMetricDescriptor::
  MetricAvailability (const MetricAvailabilityType& x)
  {
    this->MetricAvailability_.set (x);
  }

  void AbstractMetricDescriptor::
  MetricAvailability (::std::unique_ptr< MetricAvailabilityType > x)
  {
    this->MetricAvailability_.set (std::move (x));
  }

  const AbstractMetricDescriptor::MaxMeasurementTimeOptional& AbstractMetricDescriptor::
  MaxMeasurementTime () const
  {
    return this->MaxMeasurementTime_;
  }

  AbstractMetricDescriptor::MaxMeasurementTimeOptional& AbstractMetricDescriptor::
  MaxMeasurementTime ()
  {
    return this->MaxMeasurementTime_;
  }

  void AbstractMetricDescriptor::
  MaxMeasurementTime (const MaxMeasurementTimeType& x)
  {
    this->MaxMeasurementTime_.set (x);
  }

  void AbstractMetricDescriptor::
  MaxMeasurementTime (const MaxMeasurementTimeOptional& x)
  {
    this->MaxMeasurementTime_ = x;
  }

  void AbstractMetricDescriptor::
  MaxMeasurementTime (::std::unique_ptr< MaxMeasurementTimeType > x)
  {
    this->MaxMeasurementTime_.set (std::move (x));
  }

  const AbstractMetricDescriptor::MaxDelayTimeOptional& AbstractMetricDescriptor::
  MaxDelayTime () const
  {
    return this->MaxDelayTime_;
  }

  AbstractMetricDescriptor::MaxDelayTimeOptional& AbstractMetricDescriptor::
  MaxDelayTime ()
  {
    return this->MaxDelayTime_;
  }

  void AbstractMetricDescriptor::
  MaxDelayTime (const MaxDelayTimeType& x)
  {
    this->MaxDelayTime_.set (x);
  }

  void AbstractMetricDescriptor::
  MaxDelayTime (const MaxDelayTimeOptional& x)
  {
    this->MaxDelayTime_ = x;
  }

  void AbstractMetricDescriptor::
  MaxDelayTime (::std::unique_ptr< MaxDelayTimeType > x)
  {
    this->MaxDelayTime_.set (std::move (x));
  }

  const AbstractMetricDescriptor::DeterminationPeriodOptional& AbstractMetricDescriptor::
  DeterminationPeriod () const
  {
    return this->DeterminationPeriod_;
  }

  AbstractMetricDescriptor::DeterminationPeriodOptional& AbstractMetricDescriptor::
  DeterminationPeriod ()
  {
    return this->DeterminationPeriod_;
  }

  void AbstractMetricDescriptor::
  DeterminationPeriod (const DeterminationPeriodType& x)
  {
    this->DeterminationPeriod_.set (x);
  }

  void AbstractMetricDescriptor::
  DeterminationPeriod (const DeterminationPeriodOptional& x)
  {
    this->DeterminationPeriod_ = x;
  }

  void AbstractMetricDescriptor::
  DeterminationPeriod (::std::unique_ptr< DeterminationPeriodType > x)
  {
    this->DeterminationPeriod_.set (std::move (x));
  }

  const AbstractMetricDescriptor::LifeTimePeriodOptional& AbstractMetricDescriptor::
  LifeTimePeriod () const
  {
    return this->LifeTimePeriod_;
  }

  AbstractMetricDescriptor::LifeTimePeriodOptional& AbstractMetricDescriptor::
  LifeTimePeriod ()
  {
    return this->LifeTimePeriod_;
  }

  void AbstractMetricDescriptor::
  LifeTimePeriod (const LifeTimePeriodType& x)
  {
    this->LifeTimePeriod_.set (x);
  }

  void AbstractMetricDescriptor::
  LifeTimePeriod (const LifeTimePeriodOptional& x)
  {
    this->LifeTimePeriod_ = x;
  }

  void AbstractMetricDescriptor::
  LifeTimePeriod (::std::unique_ptr< LifeTimePeriodType > x)
  {
    this->LifeTimePeriod_.set (std::move (x));
  }

  const AbstractMetricDescriptor::ActivationDurationOptional& AbstractMetricDescriptor::
  ActivationDuration () const
  {
    return this->ActivationDuration_;
  }

  AbstractMetricDescriptor::ActivationDurationOptional& AbstractMetricDescriptor::
  ActivationDuration ()
  {
    return this->ActivationDuration_;
  }

  void AbstractMetricDescriptor::
  ActivationDuration (const ActivationDurationType& x)
  {
    this->ActivationDuration_.set (x);
  }

  void AbstractMetricDescriptor::
  ActivationDuration (const ActivationDurationOptional& x)
  {
    this->ActivationDuration_ = x;
  }

  void AbstractMetricDescriptor::
  ActivationDuration (::std::unique_ptr< ActivationDurationType > x)
  {
    this->ActivationDuration_.set (std::move (x));
  }


  // AbstractMetricState
  // 

  const AbstractMetricState::BodySiteSequence& AbstractMetricState::
  BodySite () const
  {
    return this->BodySite_;
  }

  AbstractMetricState::BodySiteSequence& AbstractMetricState::
  BodySite ()
  {
    return this->BodySite_;
  }

  void AbstractMetricState::
  BodySite (const BodySiteSequence& s)
  {
    this->BodySite_ = s;
  }

  const AbstractMetricState::PhysicalConnectorOptional& AbstractMetricState::
  PhysicalConnector () const
  {
    return this->PhysicalConnector_;
  }

  AbstractMetricState::PhysicalConnectorOptional& AbstractMetricState::
  PhysicalConnector ()
  {
    return this->PhysicalConnector_;
  }

  void AbstractMetricState::
  PhysicalConnector (const PhysicalConnectorType& x)
  {
    this->PhysicalConnector_.set (x);
  }

  void AbstractMetricState::
  PhysicalConnector (const PhysicalConnectorOptional& x)
  {
    this->PhysicalConnector_ = x;
  }

  void AbstractMetricState::
  PhysicalConnector (::std::unique_ptr< PhysicalConnectorType > x)
  {
    this->PhysicalConnector_.set (std::move (x));
  }

  const AbstractMetricState::ActivationStateOptional& AbstractMetricState::
  ActivationState () const
  {
    return this->ActivationState_;
  }

  AbstractMetricState::ActivationStateOptional& AbstractMetricState::
  ActivationState ()
  {
    return this->ActivationState_;
  }

  void AbstractMetricState::
  ActivationState (const ActivationStateType& x)
  {
    this->ActivationState_.set (x);
  }

  void AbstractMetricState::
  ActivationState (const ActivationStateOptional& x)
  {
    this->ActivationState_ = x;
  }

  void AbstractMetricState::
  ActivationState (::std::unique_ptr< ActivationStateType > x)
  {
    this->ActivationState_.set (std::move (x));
  }

  const AbstractMetricState::ActiveDeterminationPeriodOptional& AbstractMetricState::
  ActiveDeterminationPeriod () const
  {
    return this->ActiveDeterminationPeriod_;
  }

  AbstractMetricState::ActiveDeterminationPeriodOptional& AbstractMetricState::
  ActiveDeterminationPeriod ()
  {
    return this->ActiveDeterminationPeriod_;
  }

  void AbstractMetricState::
  ActiveDeterminationPeriod (const ActiveDeterminationPeriodType& x)
  {
    this->ActiveDeterminationPeriod_.set (x);
  }

  void AbstractMetricState::
  ActiveDeterminationPeriod (const ActiveDeterminationPeriodOptional& x)
  {
    this->ActiveDeterminationPeriod_ = x;
  }

  void AbstractMetricState::
  ActiveDeterminationPeriod (::std::unique_ptr< ActiveDeterminationPeriodType > x)
  {
    this->ActiveDeterminationPeriod_.set (std::move (x));
  }

  const AbstractMetricState::LifeTimePeriodOptional& AbstractMetricState::
  LifeTimePeriod () const
  {
    return this->LifeTimePeriod_;
  }

  AbstractMetricState::LifeTimePeriodOptional& AbstractMetricState::
  LifeTimePeriod ()
  {
    return this->LifeTimePeriod_;
  }

  void AbstractMetricState::
  LifeTimePeriod (const LifeTimePeriodType& x)
  {
    this->LifeTimePeriod_.set (x);
  }

  void AbstractMetricState::
  LifeTimePeriod (const LifeTimePeriodOptional& x)
  {
    this->LifeTimePeriod_ = x;
  }

  void AbstractMetricState::
  LifeTimePeriod (::std::unique_ptr< LifeTimePeriodType > x)
  {
    this->LifeTimePeriod_.set (std::move (x));
  }


  // NumericMetricDescriptor
  // 

  const NumericMetricDescriptor::TechnicalRangeSequence& NumericMetricDescriptor::
  TechnicalRange () const
  {
    return this->TechnicalRange_;
  }

  NumericMetricDescriptor::TechnicalRangeSequence& NumericMetricDescriptor::
  TechnicalRange ()
  {
    return this->TechnicalRange_;
  }

  void NumericMetricDescriptor::
  TechnicalRange (const TechnicalRangeSequence& s)
  {
    this->TechnicalRange_ = s;
  }

  const NumericMetricDescriptor::ResolutionType& NumericMetricDescriptor::
  Resolution () const
  {
    return this->Resolution_.get ();
  }

  NumericMetricDescriptor::ResolutionType& NumericMetricDescriptor::
  Resolution ()
  {
    return this->Resolution_.get ();
  }

  void NumericMetricDescriptor::
  Resolution (const ResolutionType& x)
  {
    this->Resolution_.set (x);
  }

  const NumericMetricDescriptor::AveragingPeriodOptional& NumericMetricDescriptor::
  AveragingPeriod () const
  {
    return this->AveragingPeriod_;
  }

  NumericMetricDescriptor::AveragingPeriodOptional& NumericMetricDescriptor::
  AveragingPeriod ()
  {
    return this->AveragingPeriod_;
  }

  void NumericMetricDescriptor::
  AveragingPeriod (const AveragingPeriodType& x)
  {
    this->AveragingPeriod_.set (x);
  }

  void NumericMetricDescriptor::
  AveragingPeriod (const AveragingPeriodOptional& x)
  {
    this->AveragingPeriod_ = x;
  }

  void NumericMetricDescriptor::
  AveragingPeriod (::std::unique_ptr< AveragingPeriodType > x)
  {
    this->AveragingPeriod_.set (std::move (x));
  }


  // NumericMetricState
  // 

  const NumericMetricState::MetricValueOptional& NumericMetricState::
  MetricValue () const
  {
    return this->MetricValue_;
  }

  NumericMetricState::MetricValueOptional& NumericMetricState::
  MetricValue ()
  {
    return this->MetricValue_;
  }

  void NumericMetricState::
  MetricValue (const MetricValueType& x)
  {
    this->MetricValue_.set (x);
  }

  void NumericMetricState::
  MetricValue (const MetricValueOptional& x)
  {
    this->MetricValue_ = x;
  }

  void NumericMetricState::
  MetricValue (::std::unique_ptr< MetricValueType > x)
  {
    this->MetricValue_.set (std::move (x));
  }

  const NumericMetricState::PhysiologicalRangeSequence& NumericMetricState::
  PhysiologicalRange () const
  {
    return this->PhysiologicalRange_;
  }

  NumericMetricState::PhysiologicalRangeSequence& NumericMetricState::
  PhysiologicalRange ()
  {
    return this->PhysiologicalRange_;
  }

  void NumericMetricState::
  PhysiologicalRange (const PhysiologicalRangeSequence& s)
  {
    this->PhysiologicalRange_ = s;
  }

  const NumericMetricState::ActiveAveragingPeriodOptional& NumericMetricState::
  ActiveAveragingPeriod () const
  {
    return this->ActiveAveragingPeriod_;
  }

  NumericMetricState::ActiveAveragingPeriodOptional& NumericMetricState::
  ActiveAveragingPeriod ()
  {
    return this->ActiveAveragingPeriod_;
  }

  void NumericMetricState::
  ActiveAveragingPeriod (const ActiveAveragingPeriodType& x)
  {
    this->ActiveAveragingPeriod_.set (x);
  }

  void NumericMetricState::
  ActiveAveragingPeriod (const ActiveAveragingPeriodOptional& x)
  {
    this->ActiveAveragingPeriod_ = x;
  }

  void NumericMetricState::
  ActiveAveragingPeriod (::std::unique_ptr< ActiveAveragingPeriodType > x)
  {
    this->ActiveAveragingPeriod_.set (std::move (x));
  }


  // StringMetricDescriptor
  // 


  // StringMetricState
  // 

  const StringMetricState::MetricValueOptional& StringMetricState::
  MetricValue () const
  {
    return this->MetricValue_;
  }

  StringMetricState::MetricValueOptional& StringMetricState::
  MetricValue ()
  {
    return this->MetricValue_;
  }

  void StringMetricState::
  MetricValue (const MetricValueType& x)
  {
    this->MetricValue_.set (x);
  }

  void StringMetricState::
  MetricValue (const MetricValueOptional& x)
  {
    this->MetricValue_ = x;
  }

  void StringMetricState::
  MetricValue (::std::unique_ptr< MetricValueType > x)
  {
    this->MetricValue_.set (std::move (x));
  }


  // EnumStringMetricDescriptor
  // 

  const EnumStringMetricDescriptor::AllowedValueSequence& EnumStringMetricDescriptor::
  AllowedValue () const
  {
    return this->AllowedValue_;
  }

  EnumStringMetricDescriptor::AllowedValueSequence& EnumStringMetricDescriptor::
  AllowedValue ()
  {
    return this->AllowedValue_;
  }

  void EnumStringMetricDescriptor::
  AllowedValue (const AllowedValueSequence& s)
  {
    this->AllowedValue_ = s;
  }


  // EnumStringMetricState
  // 


  // RealTimeSampleArrayMetricDescriptor
  // 

  const RealTimeSampleArrayMetricDescriptor::TechnicalRangeSequence& RealTimeSampleArrayMetricDescriptor::
  TechnicalRange () const
  {
    return this->TechnicalRange_;
  }

  RealTimeSampleArrayMetricDescriptor::TechnicalRangeSequence& RealTimeSampleArrayMetricDescriptor::
  TechnicalRange ()
  {
    return this->TechnicalRange_;
  }

  void RealTimeSampleArrayMetricDescriptor::
  TechnicalRange (const TechnicalRangeSequence& s)
  {
    this->TechnicalRange_ = s;
  }

  const RealTimeSampleArrayMetricDescriptor::ResolutionType& RealTimeSampleArrayMetricDescriptor::
  Resolution () const
  {
    return this->Resolution_.get ();
  }

  RealTimeSampleArrayMetricDescriptor::ResolutionType& RealTimeSampleArrayMetricDescriptor::
  Resolution ()
  {
    return this->Resolution_.get ();
  }

  void RealTimeSampleArrayMetricDescriptor::
  Resolution (const ResolutionType& x)
  {
    this->Resolution_.set (x);
  }

  const RealTimeSampleArrayMetricDescriptor::SamplePeriodType& RealTimeSampleArrayMetricDescriptor::
  SamplePeriod () const
  {
    return this->SamplePeriod_.get ();
  }

  RealTimeSampleArrayMetricDescriptor::SamplePeriodType& RealTimeSampleArrayMetricDescriptor::
  SamplePeriod ()
  {
    return this->SamplePeriod_.get ();
  }

  void RealTimeSampleArrayMetricDescriptor::
  SamplePeriod (const SamplePeriodType& x)
  {
    this->SamplePeriod_.set (x);
  }

  void RealTimeSampleArrayMetricDescriptor::
  SamplePeriod (::std::unique_ptr< SamplePeriodType > x)
  {
    this->SamplePeriod_.set (std::move (x));
  }


  // RealTimeSampleArrayMetricState
  // 

  const RealTimeSampleArrayMetricState::MetricValueOptional& RealTimeSampleArrayMetricState::
  MetricValue () const
  {
    return this->MetricValue_;
  }

  RealTimeSampleArrayMetricState::MetricValueOptional& RealTimeSampleArrayMetricState::
  MetricValue ()
  {
    return this->MetricValue_;
  }

  void RealTimeSampleArrayMetricState::
  MetricValue (const MetricValueType& x)
  {
    this->MetricValue_.set (x);
  }

  void RealTimeSampleArrayMetricState::
  MetricValue (const MetricValueOptional& x)
  {
    this->MetricValue_ = x;
  }

  void RealTimeSampleArrayMetricState::
  MetricValue (::std::unique_ptr< MetricValueType > x)
  {
    this->MetricValue_.set (std::move (x));
  }

  const RealTimeSampleArrayMetricState::PhysiologicalRangeSequence& RealTimeSampleArrayMetricState::
  PhysiologicalRange () const
  {
    return this->PhysiologicalRange_;
  }

  RealTimeSampleArrayMetricState::PhysiologicalRangeSequence& RealTimeSampleArrayMetricState::
  PhysiologicalRange ()
  {
    return this->PhysiologicalRange_;
  }

  void RealTimeSampleArrayMetricState::
  PhysiologicalRange (const PhysiologicalRangeSequence& s)
  {
    this->PhysiologicalRange_ = s;
  }


  // DistributionSampleArrayMetricDescriptor
  // 

  const DistributionSampleArrayMetricDescriptor::TechnicalRangeSequence& DistributionSampleArrayMetricDescriptor::
  TechnicalRange () const
  {
    return this->TechnicalRange_;
  }

  DistributionSampleArrayMetricDescriptor::TechnicalRangeSequence& DistributionSampleArrayMetricDescriptor::
  TechnicalRange ()
  {
    return this->TechnicalRange_;
  }

  void DistributionSampleArrayMetricDescriptor::
  TechnicalRange (const TechnicalRangeSequence& s)
  {
    this->TechnicalRange_ = s;
  }

  const DistributionSampleArrayMetricDescriptor::DomainUnitType& DistributionSampleArrayMetricDescriptor::
  DomainUnit () const
  {
    return this->DomainUnit_.get ();
  }

  DistributionSampleArrayMetricDescriptor::DomainUnitType& DistributionSampleArrayMetricDescriptor::
  DomainUnit ()
  {
    return this->DomainUnit_.get ();
  }

  void DistributionSampleArrayMetricDescriptor::
  DomainUnit (const DomainUnitType& x)
  {
    this->DomainUnit_.set (x);
  }

  void DistributionSampleArrayMetricDescriptor::
  DomainUnit (::std::unique_ptr< DomainUnitType > x)
  {
    this->DomainUnit_.set (std::move (x));
  }

  const DistributionSampleArrayMetricDescriptor::DistributionRangeType& DistributionSampleArrayMetricDescriptor::
  DistributionRange () const
  {
    return this->DistributionRange_.get ();
  }

  DistributionSampleArrayMetricDescriptor::DistributionRangeType& DistributionSampleArrayMetricDescriptor::
  DistributionRange ()
  {
    return this->DistributionRange_.get ();
  }

  void DistributionSampleArrayMetricDescriptor::
  DistributionRange (const DistributionRangeType& x)
  {
    this->DistributionRange_.set (x);
  }

  void DistributionSampleArrayMetricDescriptor::
  DistributionRange (::std::unique_ptr< DistributionRangeType > x)
  {
    this->DistributionRange_.set (std::move (x));
  }

  const DistributionSampleArrayMetricDescriptor::ResolutionType& DistributionSampleArrayMetricDescriptor::
  Resolution () const
  {
    return this->Resolution_.get ();
  }

  DistributionSampleArrayMetricDescriptor::ResolutionType& DistributionSampleArrayMetricDescriptor::
  Resolution ()
  {
    return this->Resolution_.get ();
  }

  void DistributionSampleArrayMetricDescriptor::
  Resolution (const ResolutionType& x)
  {
    this->Resolution_.set (x);
  }


  // DistributionSampleArrayMetricState
  // 

  const DistributionSampleArrayMetricState::MetricValueOptional& DistributionSampleArrayMetricState::
  MetricValue () const
  {
    return this->MetricValue_;
  }

  DistributionSampleArrayMetricState::MetricValueOptional& DistributionSampleArrayMetricState::
  MetricValue ()
  {
    return this->MetricValue_;
  }

  void DistributionSampleArrayMetricState::
  MetricValue (const MetricValueType& x)
  {
    this->MetricValue_.set (x);
  }

  void DistributionSampleArrayMetricState::
  MetricValue (const MetricValueOptional& x)
  {
    this->MetricValue_ = x;
  }

  void DistributionSampleArrayMetricState::
  MetricValue (::std::unique_ptr< MetricValueType > x)
  {
    this->MetricValue_.set (std::move (x));
  }

  const DistributionSampleArrayMetricState::PhysiologicalRangeSequence& DistributionSampleArrayMetricState::
  PhysiologicalRange () const
  {
    return this->PhysiologicalRange_;
  }

  DistributionSampleArrayMetricState::PhysiologicalRangeSequence& DistributionSampleArrayMetricState::
  PhysiologicalRange ()
  {
    return this->PhysiologicalRange_;
  }

  void DistributionSampleArrayMetricState::
  PhysiologicalRange (const PhysiologicalRangeSequence& s)
  {
    this->PhysiologicalRange_ = s;
  }


  // OperationRef
  //

  OperationRef::
  OperationRef ()
  : ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (this)
  {
  }

  OperationRef::
  OperationRef (size_type n, const ::CDM::HandleRef& x)
  : ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (n, x, this)
  {
  }

  OperationRef::
  OperationRef (const OperationRef& o,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (o, f, c),
    ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (o, f, this)
  {
  }

  // ScoDescriptor
  // 

  const ScoDescriptor::OperationSequence& ScoDescriptor::
  Operation () const
  {
    return this->Operation_;
  }

  ScoDescriptor::OperationSequence& ScoDescriptor::
  Operation ()
  {
    return this->Operation_;
  }

  void ScoDescriptor::
  Operation (const OperationSequence& s)
  {
    this->Operation_ = s;
  }


  // ScoState
  // 

  const ScoState::OperationGroupSequence& ScoState::
  OperationGroup () const
  {
    return this->OperationGroup_;
  }

  ScoState::OperationGroupSequence& ScoState::
  OperationGroup ()
  {
    return this->OperationGroup_;
  }

  void ScoState::
  OperationGroup (const OperationGroupSequence& s)
  {
    this->OperationGroup_ = s;
  }

  const ScoState::InvocationRequestedOptional& ScoState::
  InvocationRequested () const
  {
    return this->InvocationRequested_;
  }

  ScoState::InvocationRequestedOptional& ScoState::
  InvocationRequested ()
  {
    return this->InvocationRequested_;
  }

  void ScoState::
  InvocationRequested (const InvocationRequestedType& x)
  {
    this->InvocationRequested_.set (x);
  }

  void ScoState::
  InvocationRequested (const InvocationRequestedOptional& x)
  {
    this->InvocationRequested_ = x;
  }

  void ScoState::
  InvocationRequested (::std::unique_ptr< InvocationRequestedType > x)
  {
    this->InvocationRequested_.set (std::move (x));
  }

  const ScoState::InvocationRequiredOptional& ScoState::
  InvocationRequired () const
  {
    return this->InvocationRequired_;
  }

  ScoState::InvocationRequiredOptional& ScoState::
  InvocationRequired ()
  {
    return this->InvocationRequired_;
  }

  void ScoState::
  InvocationRequired (const InvocationRequiredType& x)
  {
    this->InvocationRequired_.set (x);
  }

  void ScoState::
  InvocationRequired (const InvocationRequiredOptional& x)
  {
    this->InvocationRequired_ = x;
  }

  void ScoState::
  InvocationRequired (::std::unique_ptr< InvocationRequiredType > x)
  {
    this->InvocationRequired_.set (std::move (x));
  }


  // AbstractOperationDescriptor
  // 

  const AbstractOperationDescriptor::OperationTargetType& AbstractOperationDescriptor::
  OperationTarget () const
  {
    return this->OperationTarget_.get ();
  }

  AbstractOperationDescriptor::OperationTargetType& AbstractOperationDescriptor::
  OperationTarget ()
  {
    return this->OperationTarget_.get ();
  }

  void AbstractOperationDescriptor::
  OperationTarget (const OperationTargetType& x)
  {
    this->OperationTarget_.set (x);
  }

  void AbstractOperationDescriptor::
  OperationTarget (::std::unique_ptr< OperationTargetType > x)
  {
    this->OperationTarget_.set (std::move (x));
  }

  const AbstractOperationDescriptor::MaxTimeToFinishOptional& AbstractOperationDescriptor::
  MaxTimeToFinish () const
  {
    return this->MaxTimeToFinish_;
  }

  AbstractOperationDescriptor::MaxTimeToFinishOptional& AbstractOperationDescriptor::
  MaxTimeToFinish ()
  {
    return this->MaxTimeToFinish_;
  }

  void AbstractOperationDescriptor::
  MaxTimeToFinish (const MaxTimeToFinishType& x)
  {
    this->MaxTimeToFinish_.set (x);
  }

  void AbstractOperationDescriptor::
  MaxTimeToFinish (const MaxTimeToFinishOptional& x)
  {
    this->MaxTimeToFinish_ = x;
  }

  void AbstractOperationDescriptor::
  MaxTimeToFinish (::std::unique_ptr< MaxTimeToFinishType > x)
  {
    this->MaxTimeToFinish_.set (std::move (x));
  }

  const AbstractOperationDescriptor::InvocationEffectiveTimeoutOptional& AbstractOperationDescriptor::
  InvocationEffectiveTimeout () const
  {
    return this->InvocationEffectiveTimeout_;
  }

  AbstractOperationDescriptor::InvocationEffectiveTimeoutOptional& AbstractOperationDescriptor::
  InvocationEffectiveTimeout ()
  {
    return this->InvocationEffectiveTimeout_;
  }

  void AbstractOperationDescriptor::
  InvocationEffectiveTimeout (const InvocationEffectiveTimeoutType& x)
  {
    this->InvocationEffectiveTimeout_.set (x);
  }

  void AbstractOperationDescriptor::
  InvocationEffectiveTimeout (const InvocationEffectiveTimeoutOptional& x)
  {
    this->InvocationEffectiveTimeout_ = x;
  }

  void AbstractOperationDescriptor::
  InvocationEffectiveTimeout (::std::unique_ptr< InvocationEffectiveTimeoutType > x)
  {
    this->InvocationEffectiveTimeout_.set (std::move (x));
  }

  const AbstractOperationDescriptor::RetriggerableOptional& AbstractOperationDescriptor::
  Retriggerable () const
  {
    return this->Retriggerable_;
  }

  AbstractOperationDescriptor::RetriggerableOptional& AbstractOperationDescriptor::
  Retriggerable ()
  {
    return this->Retriggerable_;
  }

  void AbstractOperationDescriptor::
  Retriggerable (const RetriggerableType& x)
  {
    this->Retriggerable_.set (x);
  }

  void AbstractOperationDescriptor::
  Retriggerable (const RetriggerableOptional& x)
  {
    this->Retriggerable_ = x;
  }

  const AbstractOperationDescriptor::AccessLevelOptional& AbstractOperationDescriptor::
  AccessLevel () const
  {
    return this->AccessLevel_;
  }

  AbstractOperationDescriptor::AccessLevelOptional& AbstractOperationDescriptor::
  AccessLevel ()
  {
    return this->AccessLevel_;
  }

  void AbstractOperationDescriptor::
  AccessLevel (const AccessLevelType& x)
  {
    this->AccessLevel_.set (x);
  }

  void AbstractOperationDescriptor::
  AccessLevel (const AccessLevelOptional& x)
  {
    this->AccessLevel_ = x;
  }

  void AbstractOperationDescriptor::
  AccessLevel (::std::unique_ptr< AccessLevelType > x)
  {
    this->AccessLevel_.set (std::move (x));
  }


  // AbstractSetStateOperationDescriptor
  // 

  const AbstractSetStateOperationDescriptor::ModifiableDataSequence& AbstractSetStateOperationDescriptor::
  ModifiableData () const
  {
    return this->ModifiableData_;
  }

  AbstractSetStateOperationDescriptor::ModifiableDataSequence& AbstractSetStateOperationDescriptor::
  ModifiableData ()
  {
    return this->ModifiableData_;
  }

  void AbstractSetStateOperationDescriptor::
  ModifiableData (const ModifiableDataSequence& s)
  {
    this->ModifiableData_ = s;
  }


  // OperatingMode
  // 

  OperatingMode::
  OperatingMode (Value v)
  : ::xml_schema::String (_xsd_OperatingMode_literals_[v])
  {
  }

  OperatingMode::
  OperatingMode (const char* v)
  : ::xml_schema::String (v)
  {
  }

  OperatingMode::
  OperatingMode (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  OperatingMode::
  OperatingMode (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  OperatingMode::
  OperatingMode (const OperatingMode& v,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  OperatingMode& OperatingMode::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_OperatingMode_literals_[v]);

    return *this;
  }


  // AbstractOperationState
  // 

  const AbstractOperationState::OperatingModeType& AbstractOperationState::
  OperatingMode () const
  {
    return this->OperatingMode_.get ();
  }

  AbstractOperationState::OperatingModeType& AbstractOperationState::
  OperatingMode ()
  {
    return this->OperatingMode_.get ();
  }

  void AbstractOperationState::
  OperatingMode (const OperatingModeType& x)
  {
    this->OperatingMode_.set (x);
  }

  void AbstractOperationState::
  OperatingMode (::std::unique_ptr< OperatingModeType > x)
  {
    this->OperatingMode_.set (std::move (x));
  }


  // SetValueOperationDescriptor
  // 


  // SetValueOperationState
  // 

  const SetValueOperationState::AllowedRangeSequence& SetValueOperationState::
  AllowedRange () const
  {
    return this->AllowedRange_;
  }

  SetValueOperationState::AllowedRangeSequence& SetValueOperationState::
  AllowedRange ()
  {
    return this->AllowedRange_;
  }

  void SetValueOperationState::
  AllowedRange (const AllowedRangeSequence& s)
  {
    this->AllowedRange_ = s;
  }


  // SetStringOperationDescriptor
  // 

  const SetStringOperationDescriptor::MaxLengthOptional& SetStringOperationDescriptor::
  MaxLength () const
  {
    return this->MaxLength_;
  }

  SetStringOperationDescriptor::MaxLengthOptional& SetStringOperationDescriptor::
  MaxLength ()
  {
    return this->MaxLength_;
  }

  void SetStringOperationDescriptor::
  MaxLength (const MaxLengthType& x)
  {
    this->MaxLength_.set (x);
  }

  void SetStringOperationDescriptor::
  MaxLength (const MaxLengthOptional& x)
  {
    this->MaxLength_ = x;
  }


  // SetStringOperationState
  // 

  const SetStringOperationState::AllowedValuesOptional& SetStringOperationState::
  AllowedValues () const
  {
    return this->AllowedValues_;
  }

  SetStringOperationState::AllowedValuesOptional& SetStringOperationState::
  AllowedValues ()
  {
    return this->AllowedValues_;
  }

  void SetStringOperationState::
  AllowedValues (const AllowedValuesType& x)
  {
    this->AllowedValues_.set (x);
  }

  void SetStringOperationState::
  AllowedValues (const AllowedValuesOptional& x)
  {
    this->AllowedValues_ = x;
  }

  void SetStringOperationState::
  AllowedValues (::std::unique_ptr< AllowedValuesType > x)
  {
    this->AllowedValues_.set (std::move (x));
  }


  // ActivateOperationDescriptor
  // 

  const ActivateOperationDescriptor::ArgumentSequence& ActivateOperationDescriptor::
  Argument () const
  {
    return this->Argument_;
  }

  ActivateOperationDescriptor::ArgumentSequence& ActivateOperationDescriptor::
  Argument ()
  {
    return this->Argument_;
  }

  void ActivateOperationDescriptor::
  Argument (const ArgumentSequence& s)
  {
    this->Argument_ = s;
  }


  // ActivateOperationState
  // 


  // SetContextStateOperationDescriptor
  // 


  // SetContextStateOperationState
  // 


  // SetMetricStateOperationDescriptor
  // 


  // SetMetricStateOperationState
  // 


  // SetComponentStateOperationDescriptor
  // 


  // SetComponentStateOperationState
  // 


  // SetAlertStateOperationDescriptor
  // 


  // SetAlertStateOperationState
  // 


  // TimeZone
  // 


  // ClockDescriptor
  // 

  const ClockDescriptor::TimeProtocolSequence& ClockDescriptor::
  TimeProtocol () const
  {
    return this->TimeProtocol_;
  }

  ClockDescriptor::TimeProtocolSequence& ClockDescriptor::
  TimeProtocol ()
  {
    return this->TimeProtocol_;
  }

  void ClockDescriptor::
  TimeProtocol (const TimeProtocolSequence& s)
  {
    this->TimeProtocol_ = s;
  }

  const ClockDescriptor::ResolutionOptional& ClockDescriptor::
  Resolution () const
  {
    return this->Resolution_;
  }

  ClockDescriptor::ResolutionOptional& ClockDescriptor::
  Resolution ()
  {
    return this->Resolution_;
  }

  void ClockDescriptor::
  Resolution (const ResolutionType& x)
  {
    this->Resolution_.set (x);
  }

  void ClockDescriptor::
  Resolution (const ResolutionOptional& x)
  {
    this->Resolution_ = x;
  }

  void ClockDescriptor::
  Resolution (::std::unique_ptr< ResolutionType > x)
  {
    this->Resolution_.set (std::move (x));
  }


  // ClockState
  // 

  const ClockState::ActiveSyncProtocolOptional& ClockState::
  ActiveSyncProtocol () const
  {
    return this->ActiveSyncProtocol_;
  }

  ClockState::ActiveSyncProtocolOptional& ClockState::
  ActiveSyncProtocol ()
  {
    return this->ActiveSyncProtocol_;
  }

  void ClockState::
  ActiveSyncProtocol (const ActiveSyncProtocolType& x)
  {
    this->ActiveSyncProtocol_.set (x);
  }

  void ClockState::
  ActiveSyncProtocol (const ActiveSyncProtocolOptional& x)
  {
    this->ActiveSyncProtocol_ = x;
  }

  void ClockState::
  ActiveSyncProtocol (::std::unique_ptr< ActiveSyncProtocolType > x)
  {
    this->ActiveSyncProtocol_.set (std::move (x));
  }

  const ClockState::ReferenceSourceSequence& ClockState::
  ReferenceSource () const
  {
    return this->ReferenceSource_;
  }

  ClockState::ReferenceSourceSequence& ClockState::
  ReferenceSource ()
  {
    return this->ReferenceSource_;
  }

  void ClockState::
  ReferenceSource (const ReferenceSourceSequence& s)
  {
    this->ReferenceSource_ = s;
  }

  const ClockState::DateAndTimeOptional& ClockState::
  DateAndTime () const
  {
    return this->DateAndTime_;
  }

  ClockState::DateAndTimeOptional& ClockState::
  DateAndTime ()
  {
    return this->DateAndTime_;
  }

  void ClockState::
  DateAndTime (const DateAndTimeType& x)
  {
    this->DateAndTime_.set (x);
  }

  void ClockState::
  DateAndTime (const DateAndTimeOptional& x)
  {
    this->DateAndTime_ = x;
  }

  void ClockState::
  DateAndTime (::std::unique_ptr< DateAndTimeType > x)
  {
    this->DateAndTime_.set (std::move (x));
  }

  const ClockState::RemoteSyncType& ClockState::
  RemoteSync () const
  {
    return this->RemoteSync_.get ();
  }

  ClockState::RemoteSyncType& ClockState::
  RemoteSync ()
  {
    return this->RemoteSync_.get ();
  }

  void ClockState::
  RemoteSync (const RemoteSyncType& x)
  {
    this->RemoteSync_.set (x);
  }

  const ClockState::AccuracyOptional& ClockState::
  Accuracy () const
  {
    return this->Accuracy_;
  }

  ClockState::AccuracyOptional& ClockState::
  Accuracy ()
  {
    return this->Accuracy_;
  }

  void ClockState::
  Accuracy (const AccuracyType& x)
  {
    this->Accuracy_.set (x);
  }

  void ClockState::
  Accuracy (const AccuracyOptional& x)
  {
    this->Accuracy_ = x;
  }

  const ClockState::LastSetOptional& ClockState::
  LastSet () const
  {
    return this->LastSet_;
  }

  ClockState::LastSetOptional& ClockState::
  LastSet ()
  {
    return this->LastSet_;
  }

  void ClockState::
  LastSet (const LastSetType& x)
  {
    this->LastSet_.set (x);
  }

  void ClockState::
  LastSet (const LastSetOptional& x)
  {
    this->LastSet_ = x;
  }

  void ClockState::
  LastSet (::std::unique_ptr< LastSetType > x)
  {
    this->LastSet_.set (std::move (x));
  }

  const ClockState::TimeZoneOptional& ClockState::
  TimeZone () const
  {
    return this->TimeZone_;
  }

  ClockState::TimeZoneOptional& ClockState::
  TimeZone ()
  {
    return this->TimeZone_;
  }

  void ClockState::
  TimeZone (const TimeZoneType& x)
  {
    this->TimeZone_.set (x);
  }

  void ClockState::
  TimeZone (const TimeZoneOptional& x)
  {
    this->TimeZone_ = x;
  }

  void ClockState::
  TimeZone (::std::unique_ptr< TimeZoneType > x)
  {
    this->TimeZone_.set (std::move (x));
  }

  const ClockState::CriticalUseOptional& ClockState::
  CriticalUse () const
  {
    return this->CriticalUse_;
  }

  ClockState::CriticalUseOptional& ClockState::
  CriticalUse ()
  {
    return this->CriticalUse_;
  }

  void ClockState::
  CriticalUse (const CriticalUseType& x)
  {
    this->CriticalUse_.set (x);
  }

  void ClockState::
  CriticalUse (const CriticalUseOptional& x)
  {
    this->CriticalUse_ = x;
  }


  // BatteryDescriptor
  // 

  const BatteryDescriptor::CapacityFullChargeOptional& BatteryDescriptor::
  CapacityFullCharge () const
  {
    return this->CapacityFullCharge_;
  }

  BatteryDescriptor::CapacityFullChargeOptional& BatteryDescriptor::
  CapacityFullCharge ()
  {
    return this->CapacityFullCharge_;
  }

  void BatteryDescriptor::
  CapacityFullCharge (const CapacityFullChargeType& x)
  {
    this->CapacityFullCharge_.set (x);
  }

  void BatteryDescriptor::
  CapacityFullCharge (const CapacityFullChargeOptional& x)
  {
    this->CapacityFullCharge_ = x;
  }

  void BatteryDescriptor::
  CapacityFullCharge (::std::unique_ptr< CapacityFullChargeType > x)
  {
    this->CapacityFullCharge_.set (std::move (x));
  }

  const BatteryDescriptor::CapacitySpecifiedOptional& BatteryDescriptor::
  CapacitySpecified () const
  {
    return this->CapacitySpecified_;
  }

  BatteryDescriptor::CapacitySpecifiedOptional& BatteryDescriptor::
  CapacitySpecified ()
  {
    return this->CapacitySpecified_;
  }

  void BatteryDescriptor::
  CapacitySpecified (const CapacitySpecifiedType& x)
  {
    this->CapacitySpecified_.set (x);
  }

  void BatteryDescriptor::
  CapacitySpecified (const CapacitySpecifiedOptional& x)
  {
    this->CapacitySpecified_ = x;
  }

  void BatteryDescriptor::
  CapacitySpecified (::std::unique_ptr< CapacitySpecifiedType > x)
  {
    this->CapacitySpecified_.set (std::move (x));
  }

  const BatteryDescriptor::VoltageSpecifiedOptional& BatteryDescriptor::
  VoltageSpecified () const
  {
    return this->VoltageSpecified_;
  }

  BatteryDescriptor::VoltageSpecifiedOptional& BatteryDescriptor::
  VoltageSpecified ()
  {
    return this->VoltageSpecified_;
  }

  void BatteryDescriptor::
  VoltageSpecified (const VoltageSpecifiedType& x)
  {
    this->VoltageSpecified_.set (x);
  }

  void BatteryDescriptor::
  VoltageSpecified (const VoltageSpecifiedOptional& x)
  {
    this->VoltageSpecified_ = x;
  }

  void BatteryDescriptor::
  VoltageSpecified (::std::unique_ptr< VoltageSpecifiedType > x)
  {
    this->VoltageSpecified_.set (std::move (x));
  }


  // BatteryState
  // 

  const BatteryState::CapacityRemainingOptional& BatteryState::
  CapacityRemaining () const
  {
    return this->CapacityRemaining_;
  }

  BatteryState::CapacityRemainingOptional& BatteryState::
  CapacityRemaining ()
  {
    return this->CapacityRemaining_;
  }

  void BatteryState::
  CapacityRemaining (const CapacityRemainingType& x)
  {
    this->CapacityRemaining_.set (x);
  }

  void BatteryState::
  CapacityRemaining (const CapacityRemainingOptional& x)
  {
    this->CapacityRemaining_ = x;
  }

  void BatteryState::
  CapacityRemaining (::std::unique_ptr< CapacityRemainingType > x)
  {
    this->CapacityRemaining_.set (std::move (x));
  }

  const BatteryState::VoltageOptional& BatteryState::
  Voltage () const
  {
    return this->Voltage_;
  }

  BatteryState::VoltageOptional& BatteryState::
  Voltage ()
  {
    return this->Voltage_;
  }

  void BatteryState::
  Voltage (const VoltageType& x)
  {
    this->Voltage_.set (x);
  }

  void BatteryState::
  Voltage (const VoltageOptional& x)
  {
    this->Voltage_ = x;
  }

  void BatteryState::
  Voltage (::std::unique_ptr< VoltageType > x)
  {
    this->Voltage_.set (std::move (x));
  }

  const BatteryState::CurrentOptional& BatteryState::
  Current () const
  {
    return this->Current_;
  }

  BatteryState::CurrentOptional& BatteryState::
  Current ()
  {
    return this->Current_;
  }

  void BatteryState::
  Current (const CurrentType& x)
  {
    this->Current_.set (x);
  }

  void BatteryState::
  Current (const CurrentOptional& x)
  {
    this->Current_ = x;
  }

  void BatteryState::
  Current (::std::unique_ptr< CurrentType > x)
  {
    this->Current_.set (std::move (x));
  }

  const BatteryState::TemperatureOptional& BatteryState::
  Temperature () const
  {
    return this->Temperature_;
  }

  BatteryState::TemperatureOptional& BatteryState::
  Temperature ()
  {
    return this->Temperature_;
  }

  void BatteryState::
  Temperature (const TemperatureType& x)
  {
    this->Temperature_.set (x);
  }

  void BatteryState::
  Temperature (const TemperatureOptional& x)
  {
    this->Temperature_ = x;
  }

  void BatteryState::
  Temperature (::std::unique_ptr< TemperatureType > x)
  {
    this->Temperature_.set (std::move (x));
  }

  const BatteryState::RemainingBatteryTimeOptional& BatteryState::
  RemainingBatteryTime () const
  {
    return this->RemainingBatteryTime_;
  }

  BatteryState::RemainingBatteryTimeOptional& BatteryState::
  RemainingBatteryTime ()
  {
    return this->RemainingBatteryTime_;
  }

  void BatteryState::
  RemainingBatteryTime (const RemainingBatteryTimeType& x)
  {
    this->RemainingBatteryTime_.set (x);
  }

  void BatteryState::
  RemainingBatteryTime (const RemainingBatteryTimeOptional& x)
  {
    this->RemainingBatteryTime_ = x;
  }

  void BatteryState::
  RemainingBatteryTime (::std::unique_ptr< RemainingBatteryTimeType > x)
  {
    this->RemainingBatteryTime_.set (std::move (x));
  }

  const BatteryState::ChargeStatusOptional& BatteryState::
  ChargeStatus () const
  {
    return this->ChargeStatus_;
  }

  BatteryState::ChargeStatusOptional& BatteryState::
  ChargeStatus ()
  {
    return this->ChargeStatus_;
  }

  void BatteryState::
  ChargeStatus (const ChargeStatusType& x)
  {
    this->ChargeStatus_.set (x);
  }

  void BatteryState::
  ChargeStatus (const ChargeStatusOptional& x)
  {
    this->ChargeStatus_ = x;
  }

  void BatteryState::
  ChargeStatus (::std::unique_ptr< ChargeStatusType > x)
  {
    this->ChargeStatus_.set (std::move (x));
  }

  const BatteryState::ChargeCyclesOptional& BatteryState::
  ChargeCycles () const
  {
    return this->ChargeCycles_;
  }

  BatteryState::ChargeCyclesOptional& BatteryState::
  ChargeCycles ()
  {
    return this->ChargeCycles_;
  }

  void BatteryState::
  ChargeCycles (const ChargeCyclesType& x)
  {
    this->ChargeCycles_.set (x);
  }

  void BatteryState::
  ChargeCycles (const ChargeCyclesOptional& x)
  {
    this->ChargeCycles_ = x;
  }


  // SystemContextDescriptor
  // 

  const SystemContextDescriptor::PatientContextOptional& SystemContextDescriptor::
  PatientContext () const
  {
    return this->PatientContext_;
  }

  SystemContextDescriptor::PatientContextOptional& SystemContextDescriptor::
  PatientContext ()
  {
    return this->PatientContext_;
  }

  void SystemContextDescriptor::
  PatientContext (const PatientContextType& x)
  {
    this->PatientContext_.set (x);
  }

  void SystemContextDescriptor::
  PatientContext (const PatientContextOptional& x)
  {
    this->PatientContext_ = x;
  }

  void SystemContextDescriptor::
  PatientContext (::std::unique_ptr< PatientContextType > x)
  {
    this->PatientContext_.set (std::move (x));
  }

  const SystemContextDescriptor::LocationContextOptional& SystemContextDescriptor::
  LocationContext () const
  {
    return this->LocationContext_;
  }

  SystemContextDescriptor::LocationContextOptional& SystemContextDescriptor::
  LocationContext ()
  {
    return this->LocationContext_;
  }

  void SystemContextDescriptor::
  LocationContext (const LocationContextType& x)
  {
    this->LocationContext_.set (x);
  }

  void SystemContextDescriptor::
  LocationContext (const LocationContextOptional& x)
  {
    this->LocationContext_ = x;
  }

  void SystemContextDescriptor::
  LocationContext (::std::unique_ptr< LocationContextType > x)
  {
    this->LocationContext_.set (std::move (x));
  }

  const SystemContextDescriptor::EnsembleContextSequence& SystemContextDescriptor::
  EnsembleContext () const
  {
    return this->EnsembleContext_;
  }

  SystemContextDescriptor::EnsembleContextSequence& SystemContextDescriptor::
  EnsembleContext ()
  {
    return this->EnsembleContext_;
  }

  void SystemContextDescriptor::
  EnsembleContext (const EnsembleContextSequence& s)
  {
    this->EnsembleContext_ = s;
  }

  const SystemContextDescriptor::OperatorContextSequence& SystemContextDescriptor::
  OperatorContext () const
  {
    return this->OperatorContext_;
  }

  SystemContextDescriptor::OperatorContextSequence& SystemContextDescriptor::
  OperatorContext ()
  {
    return this->OperatorContext_;
  }

  void SystemContextDescriptor::
  OperatorContext (const OperatorContextSequence& s)
  {
    this->OperatorContext_ = s;
  }

  const SystemContextDescriptor::WorkflowContextSequence& SystemContextDescriptor::
  WorkflowContext () const
  {
    return this->WorkflowContext_;
  }

  SystemContextDescriptor::WorkflowContextSequence& SystemContextDescriptor::
  WorkflowContext ()
  {
    return this->WorkflowContext_;
  }

  void SystemContextDescriptor::
  WorkflowContext (const WorkflowContextSequence& s)
  {
    this->WorkflowContext_ = s;
  }

  const SystemContextDescriptor::MeansContextSequence& SystemContextDescriptor::
  MeansContext () const
  {
    return this->MeansContext_;
  }

  SystemContextDescriptor::MeansContextSequence& SystemContextDescriptor::
  MeansContext ()
  {
    return this->MeansContext_;
  }

  void SystemContextDescriptor::
  MeansContext (const MeansContextSequence& s)
  {
    this->MeansContext_ = s;
  }


  // SystemContextState
  // 


  // AbstractContextDescriptor
  // 


  // ContextAssociation
  // 

  ContextAssociation::
  ContextAssociation (Value v)
  : ::xml_schema::String (_xsd_ContextAssociation_literals_[v])
  {
  }

  ContextAssociation::
  ContextAssociation (const char* v)
  : ::xml_schema::String (v)
  {
  }

  ContextAssociation::
  ContextAssociation (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  ContextAssociation::
  ContextAssociation (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  ContextAssociation::
  ContextAssociation (const ContextAssociation& v,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  ContextAssociation& ContextAssociation::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_ContextAssociation_literals_[v]);

    return *this;
  }


  // AbstractContextState
  // 

  const AbstractContextState::ValidatorSequence& AbstractContextState::
  Validator () const
  {
    return this->Validator_;
  }

  AbstractContextState::ValidatorSequence& AbstractContextState::
  Validator ()
  {
    return this->Validator_;
  }

  void AbstractContextState::
  Validator (const ValidatorSequence& s)
  {
    this->Validator_ = s;
  }

  const AbstractContextState::IdentificationSequence& AbstractContextState::
  Identification () const
  {
    return this->Identification_;
  }

  AbstractContextState::IdentificationSequence& AbstractContextState::
  Identification ()
  {
    return this->Identification_;
  }

  void AbstractContextState::
  Identification (const IdentificationSequence& s)
  {
    this->Identification_ = s;
  }

  const AbstractContextState::ContextAssociationOptional& AbstractContextState::
  ContextAssociation () const
  {
    return this->ContextAssociation_;
  }

  AbstractContextState::ContextAssociationOptional& AbstractContextState::
  ContextAssociation ()
  {
    return this->ContextAssociation_;
  }

  void AbstractContextState::
  ContextAssociation (const ContextAssociationType& x)
  {
    this->ContextAssociation_.set (x);
  }

  void AbstractContextState::
  ContextAssociation (const ContextAssociationOptional& x)
  {
    this->ContextAssociation_ = x;
  }

  void AbstractContextState::
  ContextAssociation (::std::unique_ptr< ContextAssociationType > x)
  {
    this->ContextAssociation_.set (std::move (x));
  }

  const AbstractContextState::BindingMdibVersionOptional& AbstractContextState::
  BindingMdibVersion () const
  {
    return this->BindingMdibVersion_;
  }

  AbstractContextState::BindingMdibVersionOptional& AbstractContextState::
  BindingMdibVersion ()
  {
    return this->BindingMdibVersion_;
  }

  void AbstractContextState::
  BindingMdibVersion (const BindingMdibVersionType& x)
  {
    this->BindingMdibVersion_.set (x);
  }

  void AbstractContextState::
  BindingMdibVersion (const BindingMdibVersionOptional& x)
  {
    this->BindingMdibVersion_ = x;
  }

  void AbstractContextState::
  BindingMdibVersion (::std::unique_ptr< BindingMdibVersionType > x)
  {
    this->BindingMdibVersion_.set (std::move (x));
  }

  const AbstractContextState::UnbindingMdibVersionOptional& AbstractContextState::
  UnbindingMdibVersion () const
  {
    return this->UnbindingMdibVersion_;
  }

  AbstractContextState::UnbindingMdibVersionOptional& AbstractContextState::
  UnbindingMdibVersion ()
  {
    return this->UnbindingMdibVersion_;
  }

  void AbstractContextState::
  UnbindingMdibVersion (const UnbindingMdibVersionType& x)
  {
    this->UnbindingMdibVersion_.set (x);
  }

  void AbstractContextState::
  UnbindingMdibVersion (const UnbindingMdibVersionOptional& x)
  {
    this->UnbindingMdibVersion_ = x;
  }

  void AbstractContextState::
  UnbindingMdibVersion (::std::unique_ptr< UnbindingMdibVersionType > x)
  {
    this->UnbindingMdibVersion_.set (std::move (x));
  }

  const AbstractContextState::BindingStartTimeOptional& AbstractContextState::
  BindingStartTime () const
  {
    return this->BindingStartTime_;
  }

  AbstractContextState::BindingStartTimeOptional& AbstractContextState::
  BindingStartTime ()
  {
    return this->BindingStartTime_;
  }

  void AbstractContextState::
  BindingStartTime (const BindingStartTimeType& x)
  {
    this->BindingStartTime_.set (x);
  }

  void AbstractContextState::
  BindingStartTime (const BindingStartTimeOptional& x)
  {
    this->BindingStartTime_ = x;
  }

  void AbstractContextState::
  BindingStartTime (::std::unique_ptr< BindingStartTimeType > x)
  {
    this->BindingStartTime_.set (std::move (x));
  }

  const AbstractContextState::BindingEndTimeOptional& AbstractContextState::
  BindingEndTime () const
  {
    return this->BindingEndTime_;
  }

  AbstractContextState::BindingEndTimeOptional& AbstractContextState::
  BindingEndTime ()
  {
    return this->BindingEndTime_;
  }

  void AbstractContextState::
  BindingEndTime (const BindingEndTimeType& x)
  {
    this->BindingEndTime_.set (x);
  }

  void AbstractContextState::
  BindingEndTime (const BindingEndTimeOptional& x)
  {
    this->BindingEndTime_ = x;
  }

  void AbstractContextState::
  BindingEndTime (::std::unique_ptr< BindingEndTimeType > x)
  {
    this->BindingEndTime_.set (std::move (x));
  }


  // BaseDemographics
  // 

  const BaseDemographics::ExtensionOptional& BaseDemographics::
  Extension () const
  {
    return this->Extension_;
  }

  BaseDemographics::ExtensionOptional& BaseDemographics::
  Extension ()
  {
    return this->Extension_;
  }

  void BaseDemographics::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void BaseDemographics::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void BaseDemographics::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const BaseDemographics::GivennameOptional& BaseDemographics::
  Givenname () const
  {
    return this->Givenname_;
  }

  BaseDemographics::GivennameOptional& BaseDemographics::
  Givenname ()
  {
    return this->Givenname_;
  }

  void BaseDemographics::
  Givenname (const GivennameType& x)
  {
    this->Givenname_.set (x);
  }

  void BaseDemographics::
  Givenname (const GivennameOptional& x)
  {
    this->Givenname_ = x;
  }

  void BaseDemographics::
  Givenname (::std::unique_ptr< GivennameType > x)
  {
    this->Givenname_.set (std::move (x));
  }

  const BaseDemographics::MiddlenameSequence& BaseDemographics::
  Middlename () const
  {
    return this->Middlename_;
  }

  BaseDemographics::MiddlenameSequence& BaseDemographics::
  Middlename ()
  {
    return this->Middlename_;
  }

  void BaseDemographics::
  Middlename (const MiddlenameSequence& s)
  {
    this->Middlename_ = s;
  }

  const BaseDemographics::FamilynameOptional& BaseDemographics::
  Familyname () const
  {
    return this->Familyname_;
  }

  BaseDemographics::FamilynameOptional& BaseDemographics::
  Familyname ()
  {
    return this->Familyname_;
  }

  void BaseDemographics::
  Familyname (const FamilynameType& x)
  {
    this->Familyname_.set (x);
  }

  void BaseDemographics::
  Familyname (const FamilynameOptional& x)
  {
    this->Familyname_ = x;
  }

  void BaseDemographics::
  Familyname (::std::unique_ptr< FamilynameType > x)
  {
    this->Familyname_.set (std::move (x));
  }

  const BaseDemographics::BirthnameOptional& BaseDemographics::
  Birthname () const
  {
    return this->Birthname_;
  }

  BaseDemographics::BirthnameOptional& BaseDemographics::
  Birthname ()
  {
    return this->Birthname_;
  }

  void BaseDemographics::
  Birthname (const BirthnameType& x)
  {
    this->Birthname_.set (x);
  }

  void BaseDemographics::
  Birthname (const BirthnameOptional& x)
  {
    this->Birthname_ = x;
  }

  void BaseDemographics::
  Birthname (::std::unique_ptr< BirthnameType > x)
  {
    this->Birthname_.set (std::move (x));
  }

  const BaseDemographics::TitleOptional& BaseDemographics::
  Title () const
  {
    return this->Title_;
  }

  BaseDemographics::TitleOptional& BaseDemographics::
  Title ()
  {
    return this->Title_;
  }

  void BaseDemographics::
  Title (const TitleType& x)
  {
    this->Title_.set (x);
  }

  void BaseDemographics::
  Title (const TitleOptional& x)
  {
    this->Title_ = x;
  }

  void BaseDemographics::
  Title (::std::unique_ptr< TitleType > x)
  {
    this->Title_.set (std::move (x));
  }


  // PersonReference
  // 

  const PersonReference::ExtensionOptional& PersonReference::
  Extension () const
  {
    return this->Extension_;
  }

  PersonReference::ExtensionOptional& PersonReference::
  Extension ()
  {
    return this->Extension_;
  }

  void PersonReference::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void PersonReference::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void PersonReference::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const PersonReference::IdentificationSequence& PersonReference::
  Identification () const
  {
    return this->Identification_;
  }

  PersonReference::IdentificationSequence& PersonReference::
  Identification ()
  {
    return this->Identification_;
  }

  void PersonReference::
  Identification (const IdentificationSequence& s)
  {
    this->Identification_ = s;
  }

  const PersonReference::NameOptional& PersonReference::
  Name () const
  {
    return this->Name_;
  }

  PersonReference::NameOptional& PersonReference::
  Name ()
  {
    return this->Name_;
  }

  void PersonReference::
  Name (const NameType& x)
  {
    this->Name_.set (x);
  }

  void PersonReference::
  Name (const NameOptional& x)
  {
    this->Name_ = x;
  }

  void PersonReference::
  Name (::std::unique_ptr< NameType > x)
  {
    this->Name_.set (std::move (x));
  }


  // LocationDetail
  // 

  const LocationDetail::ExtensionOptional& LocationDetail::
  Extension () const
  {
    return this->Extension_;
  }

  LocationDetail::ExtensionOptional& LocationDetail::
  Extension ()
  {
    return this->Extension_;
  }

  void LocationDetail::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void LocationDetail::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void LocationDetail::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const LocationDetail::PoCOptional& LocationDetail::
  PoC () const
  {
    return this->PoC_;
  }

  LocationDetail::PoCOptional& LocationDetail::
  PoC ()
  {
    return this->PoC_;
  }

  void LocationDetail::
  PoC (const PoCType& x)
  {
    this->PoC_.set (x);
  }

  void LocationDetail::
  PoC (const PoCOptional& x)
  {
    this->PoC_ = x;
  }

  void LocationDetail::
  PoC (::std::unique_ptr< PoCType > x)
  {
    this->PoC_.set (std::move (x));
  }

  const LocationDetail::RoomOptional& LocationDetail::
  Room () const
  {
    return this->Room_;
  }

  LocationDetail::RoomOptional& LocationDetail::
  Room ()
  {
    return this->Room_;
  }

  void LocationDetail::
  Room (const RoomType& x)
  {
    this->Room_.set (x);
  }

  void LocationDetail::
  Room (const RoomOptional& x)
  {
    this->Room_ = x;
  }

  void LocationDetail::
  Room (::std::unique_ptr< RoomType > x)
  {
    this->Room_.set (std::move (x));
  }

  const LocationDetail::BedOptional& LocationDetail::
  Bed () const
  {
    return this->Bed_;
  }

  LocationDetail::BedOptional& LocationDetail::
  Bed ()
  {
    return this->Bed_;
  }

  void LocationDetail::
  Bed (const BedType& x)
  {
    this->Bed_.set (x);
  }

  void LocationDetail::
  Bed (const BedOptional& x)
  {
    this->Bed_ = x;
  }

  void LocationDetail::
  Bed (::std::unique_ptr< BedType > x)
  {
    this->Bed_.set (std::move (x));
  }

  const LocationDetail::FacilityOptional& LocationDetail::
  Facility () const
  {
    return this->Facility_;
  }

  LocationDetail::FacilityOptional& LocationDetail::
  Facility ()
  {
    return this->Facility_;
  }

  void LocationDetail::
  Facility (const FacilityType& x)
  {
    this->Facility_.set (x);
  }

  void LocationDetail::
  Facility (const FacilityOptional& x)
  {
    this->Facility_ = x;
  }

  void LocationDetail::
  Facility (::std::unique_ptr< FacilityType > x)
  {
    this->Facility_.set (std::move (x));
  }

  const LocationDetail::BuildingOptional& LocationDetail::
  Building () const
  {
    return this->Building_;
  }

  LocationDetail::BuildingOptional& LocationDetail::
  Building ()
  {
    return this->Building_;
  }

  void LocationDetail::
  Building (const BuildingType& x)
  {
    this->Building_.set (x);
  }

  void LocationDetail::
  Building (const BuildingOptional& x)
  {
    this->Building_ = x;
  }

  void LocationDetail::
  Building (::std::unique_ptr< BuildingType > x)
  {
    this->Building_.set (std::move (x));
  }

  const LocationDetail::FloorOptional& LocationDetail::
  Floor () const
  {
    return this->Floor_;
  }

  LocationDetail::FloorOptional& LocationDetail::
  Floor ()
  {
    return this->Floor_;
  }

  void LocationDetail::
  Floor (const FloorType& x)
  {
    this->Floor_.set (x);
  }

  void LocationDetail::
  Floor (const FloorOptional& x)
  {
    this->Floor_ = x;
  }

  void LocationDetail::
  Floor (::std::unique_ptr< FloorType > x)
  {
    this->Floor_.set (std::move (x));
  }


  // PatientContextDescriptor
  // 


  // Sex
  // 

  Sex::
  Sex (Value v)
  : ::xml_schema::String (_xsd_Sex_literals_[v])
  {
  }

  Sex::
  Sex (const char* v)
  : ::xml_schema::String (v)
  {
  }

  Sex::
  Sex (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  Sex::
  Sex (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Sex::
  Sex (const Sex& v,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Sex& Sex::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Sex_literals_[v]);

    return *this;
  }


  // PatientType
  // 

  PatientType::
  PatientType (Value v)
  : ::xml_schema::String (_xsd_PatientType_literals_[v])
  {
  }

  PatientType::
  PatientType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  PatientType::
  PatientType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  PatientType::
  PatientType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  PatientType::
  PatientType (const PatientType& v,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  PatientType& PatientType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_PatientType_literals_[v]);

    return *this;
  }


  // PatientDemographicsCoreData
  // 

  const PatientDemographicsCoreData::SexOptional& PatientDemographicsCoreData::
  Sex () const
  {
    return this->Sex_;
  }

  PatientDemographicsCoreData::SexOptional& PatientDemographicsCoreData::
  Sex ()
  {
    return this->Sex_;
  }

  void PatientDemographicsCoreData::
  Sex (const SexType& x)
  {
    this->Sex_.set (x);
  }

  void PatientDemographicsCoreData::
  Sex (const SexOptional& x)
  {
    this->Sex_ = x;
  }

  void PatientDemographicsCoreData::
  Sex (::std::unique_ptr< SexType > x)
  {
    this->Sex_.set (std::move (x));
  }

  const PatientDemographicsCoreData::PatientTypeOptional& PatientDemographicsCoreData::
  PatientType () const
  {
    return this->PatientType_;
  }

  PatientDemographicsCoreData::PatientTypeOptional& PatientDemographicsCoreData::
  PatientType ()
  {
    return this->PatientType_;
  }

  void PatientDemographicsCoreData::
  PatientType (const PatientTypeType& x)
  {
    this->PatientType_.set (x);
  }

  void PatientDemographicsCoreData::
  PatientType (const PatientTypeOptional& x)
  {
    this->PatientType_ = x;
  }

  void PatientDemographicsCoreData::
  PatientType (::std::unique_ptr< PatientTypeType > x)
  {
    this->PatientType_.set (std::move (x));
  }

  const PatientDemographicsCoreData::DateOfBirthOptional& PatientDemographicsCoreData::
  DateOfBirth () const
  {
    return this->DateOfBirth_;
  }

  PatientDemographicsCoreData::DateOfBirthOptional& PatientDemographicsCoreData::
  DateOfBirth ()
  {
    return this->DateOfBirth_;
  }

  void PatientDemographicsCoreData::
  DateOfBirth (const DateOfBirthType& x)
  {
    this->DateOfBirth_.set (x);
  }

  void PatientDemographicsCoreData::
  DateOfBirth (const DateOfBirthOptional& x)
  {
    this->DateOfBirth_ = x;
  }

  void PatientDemographicsCoreData::
  DateOfBirth (::std::unique_ptr< DateOfBirthType > x)
  {
    this->DateOfBirth_.set (std::move (x));
  }

  const PatientDemographicsCoreData::HeightOptional& PatientDemographicsCoreData::
  Height () const
  {
    return this->Height_;
  }

  PatientDemographicsCoreData::HeightOptional& PatientDemographicsCoreData::
  Height ()
  {
    return this->Height_;
  }

  void PatientDemographicsCoreData::
  Height (const HeightType& x)
  {
    this->Height_.set (x);
  }

  void PatientDemographicsCoreData::
  Height (const HeightOptional& x)
  {
    this->Height_ = x;
  }

  void PatientDemographicsCoreData::
  Height (::std::unique_ptr< HeightType > x)
  {
    this->Height_.set (std::move (x));
  }

  const PatientDemographicsCoreData::WeightOptional& PatientDemographicsCoreData::
  Weight () const
  {
    return this->Weight_;
  }

  PatientDemographicsCoreData::WeightOptional& PatientDemographicsCoreData::
  Weight ()
  {
    return this->Weight_;
  }

  void PatientDemographicsCoreData::
  Weight (const WeightType& x)
  {
    this->Weight_.set (x);
  }

  void PatientDemographicsCoreData::
  Weight (const WeightOptional& x)
  {
    this->Weight_ = x;
  }

  void PatientDemographicsCoreData::
  Weight (::std::unique_ptr< WeightType > x)
  {
    this->Weight_.set (std::move (x));
  }

  const PatientDemographicsCoreData::RaceOptional& PatientDemographicsCoreData::
  Race () const
  {
    return this->Race_;
  }

  PatientDemographicsCoreData::RaceOptional& PatientDemographicsCoreData::
  Race ()
  {
    return this->Race_;
  }

  void PatientDemographicsCoreData::
  Race (const RaceType& x)
  {
    this->Race_.set (x);
  }

  void PatientDemographicsCoreData::
  Race (const RaceOptional& x)
  {
    this->Race_ = x;
  }

  void PatientDemographicsCoreData::
  Race (::std::unique_ptr< RaceType > x)
  {
    this->Race_.set (std::move (x));
  }


  // NeonatalPatientDemographicsCoreData
  // 

  const NeonatalPatientDemographicsCoreData::GestationalAgeOptional& NeonatalPatientDemographicsCoreData::
  GestationalAge () const
  {
    return this->GestationalAge_;
  }

  NeonatalPatientDemographicsCoreData::GestationalAgeOptional& NeonatalPatientDemographicsCoreData::
  GestationalAge ()
  {
    return this->GestationalAge_;
  }

  void NeonatalPatientDemographicsCoreData::
  GestationalAge (const GestationalAgeType& x)
  {
    this->GestationalAge_.set (x);
  }

  void NeonatalPatientDemographicsCoreData::
  GestationalAge (const GestationalAgeOptional& x)
  {
    this->GestationalAge_ = x;
  }

  void NeonatalPatientDemographicsCoreData::
  GestationalAge (::std::unique_ptr< GestationalAgeType > x)
  {
    this->GestationalAge_.set (std::move (x));
  }

  const NeonatalPatientDemographicsCoreData::BirthLengthOptional& NeonatalPatientDemographicsCoreData::
  BirthLength () const
  {
    return this->BirthLength_;
  }

  NeonatalPatientDemographicsCoreData::BirthLengthOptional& NeonatalPatientDemographicsCoreData::
  BirthLength ()
  {
    return this->BirthLength_;
  }

  void NeonatalPatientDemographicsCoreData::
  BirthLength (const BirthLengthType& x)
  {
    this->BirthLength_.set (x);
  }

  void NeonatalPatientDemographicsCoreData::
  BirthLength (const BirthLengthOptional& x)
  {
    this->BirthLength_ = x;
  }

  void NeonatalPatientDemographicsCoreData::
  BirthLength (::std::unique_ptr< BirthLengthType > x)
  {
    this->BirthLength_.set (std::move (x));
  }

  const NeonatalPatientDemographicsCoreData::BirthWeightOptional& NeonatalPatientDemographicsCoreData::
  BirthWeight () const
  {
    return this->BirthWeight_;
  }

  NeonatalPatientDemographicsCoreData::BirthWeightOptional& NeonatalPatientDemographicsCoreData::
  BirthWeight ()
  {
    return this->BirthWeight_;
  }

  void NeonatalPatientDemographicsCoreData::
  BirthWeight (const BirthWeightType& x)
  {
    this->BirthWeight_.set (x);
  }

  void NeonatalPatientDemographicsCoreData::
  BirthWeight (const BirthWeightOptional& x)
  {
    this->BirthWeight_ = x;
  }

  void NeonatalPatientDemographicsCoreData::
  BirthWeight (::std::unique_ptr< BirthWeightType > x)
  {
    this->BirthWeight_.set (std::move (x));
  }

  const NeonatalPatientDemographicsCoreData::HeadCircumferenceOptional& NeonatalPatientDemographicsCoreData::
  HeadCircumference () const
  {
    return this->HeadCircumference_;
  }

  NeonatalPatientDemographicsCoreData::HeadCircumferenceOptional& NeonatalPatientDemographicsCoreData::
  HeadCircumference ()
  {
    return this->HeadCircumference_;
  }

  void NeonatalPatientDemographicsCoreData::
  HeadCircumference (const HeadCircumferenceType& x)
  {
    this->HeadCircumference_.set (x);
  }

  void NeonatalPatientDemographicsCoreData::
  HeadCircumference (const HeadCircumferenceOptional& x)
  {
    this->HeadCircumference_ = x;
  }

  void NeonatalPatientDemographicsCoreData::
  HeadCircumference (::std::unique_ptr< HeadCircumferenceType > x)
  {
    this->HeadCircumference_.set (std::move (x));
  }

  const NeonatalPatientDemographicsCoreData::MotherOptional& NeonatalPatientDemographicsCoreData::
  Mother () const
  {
    return this->Mother_;
  }

  NeonatalPatientDemographicsCoreData::MotherOptional& NeonatalPatientDemographicsCoreData::
  Mother ()
  {
    return this->Mother_;
  }

  void NeonatalPatientDemographicsCoreData::
  Mother (const MotherType& x)
  {
    this->Mother_.set (x);
  }

  void NeonatalPatientDemographicsCoreData::
  Mother (const MotherOptional& x)
  {
    this->Mother_ = x;
  }

  void NeonatalPatientDemographicsCoreData::
  Mother (::std::unique_ptr< MotherType > x)
  {
    this->Mother_.set (std::move (x));
  }


  // PatientContextState
  // 

  const PatientContextState::CoreDataOptional& PatientContextState::
  CoreData () const
  {
    return this->CoreData_;
  }

  PatientContextState::CoreDataOptional& PatientContextState::
  CoreData ()
  {
    return this->CoreData_;
  }

  void PatientContextState::
  CoreData (const CoreDataType& x)
  {
    this->CoreData_.set (x);
  }

  void PatientContextState::
  CoreData (const CoreDataOptional& x)
  {
    this->CoreData_ = x;
  }

  void PatientContextState::
  CoreData (::std::unique_ptr< CoreDataType > x)
  {
    this->CoreData_.set (std::move (x));
  }


  // LocationContextDescriptor
  // 


  // LocationContextState
  // 

  const LocationContextState::LocationDetailOptional& LocationContextState::
  LocationDetail () const
  {
    return this->LocationDetail_;
  }

  LocationContextState::LocationDetailOptional& LocationContextState::
  LocationDetail ()
  {
    return this->LocationDetail_;
  }

  void LocationContextState::
  LocationDetail (const LocationDetailType& x)
  {
    this->LocationDetail_.set (x);
  }

  void LocationContextState::
  LocationDetail (const LocationDetailOptional& x)
  {
    this->LocationDetail_ = x;
  }

  void LocationContextState::
  LocationDetail (::std::unique_ptr< LocationDetailType > x)
  {
    this->LocationDetail_.set (std::move (x));
  }


  // WorkflowContextDescriptor
  // 


  // ClinicalInfo
  // 

  const ClinicalInfo::ExtensionOptional& ClinicalInfo::
  Extension () const
  {
    return this->Extension_;
  }

  ClinicalInfo::ExtensionOptional& ClinicalInfo::
  Extension ()
  {
    return this->Extension_;
  }

  void ClinicalInfo::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void ClinicalInfo::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void ClinicalInfo::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const ClinicalInfo::TypeOptional& ClinicalInfo::
  Type () const
  {
    return this->Type_;
  }

  ClinicalInfo::TypeOptional& ClinicalInfo::
  Type ()
  {
    return this->Type_;
  }

  void ClinicalInfo::
  Type (const TypeType& x)
  {
    this->Type_.set (x);
  }

  void ClinicalInfo::
  Type (const TypeOptional& x)
  {
    this->Type_ = x;
  }

  void ClinicalInfo::
  Type (::std::unique_ptr< TypeType > x)
  {
    this->Type_.set (std::move (x));
  }

  const ClinicalInfo::CodeOptional& ClinicalInfo::
  Code () const
  {
    return this->Code_;
  }

  ClinicalInfo::CodeOptional& ClinicalInfo::
  Code ()
  {
    return this->Code_;
  }

  void ClinicalInfo::
  Code (const CodeType& x)
  {
    this->Code_.set (x);
  }

  void ClinicalInfo::
  Code (const CodeOptional& x)
  {
    this->Code_ = x;
  }

  void ClinicalInfo::
  Code (::std::unique_ptr< CodeType > x)
  {
    this->Code_.set (std::move (x));
  }

  const ClinicalInfo::CriticalityOptional& ClinicalInfo::
  Criticality () const
  {
    return this->Criticality_;
  }

  ClinicalInfo::CriticalityOptional& ClinicalInfo::
  Criticality ()
  {
    return this->Criticality_;
  }

  void ClinicalInfo::
  Criticality (const CriticalityType& x)
  {
    this->Criticality_.set (x);
  }

  void ClinicalInfo::
  Criticality (const CriticalityOptional& x)
  {
    this->Criticality_ = x;
  }

  void ClinicalInfo::
  Criticality (::std::unique_ptr< CriticalityType > x)
  {
    this->Criticality_.set (std::move (x));
  }

  const ClinicalInfo::DescriptionSequence& ClinicalInfo::
  Description () const
  {
    return this->Description_;
  }

  ClinicalInfo::DescriptionSequence& ClinicalInfo::
  Description ()
  {
    return this->Description_;
  }

  void ClinicalInfo::
  Description (const DescriptionSequence& s)
  {
    this->Description_ = s;
  }

  const ClinicalInfo::RelatedMeasurementSequence& ClinicalInfo::
  RelatedMeasurement () const
  {
    return this->RelatedMeasurement_;
  }

  ClinicalInfo::RelatedMeasurementSequence& ClinicalInfo::
  RelatedMeasurement ()
  {
    return this->RelatedMeasurement_;
  }

  void ClinicalInfo::
  RelatedMeasurement (const RelatedMeasurementSequence& s)
  {
    this->RelatedMeasurement_ = s;
  }


  // ImagingProcedure
  // 

  const ImagingProcedure::ExtensionOptional& ImagingProcedure::
  Extension () const
  {
    return this->Extension_;
  }

  ImagingProcedure::ExtensionOptional& ImagingProcedure::
  Extension ()
  {
    return this->Extension_;
  }

  void ImagingProcedure::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void ImagingProcedure::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void ImagingProcedure::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const ImagingProcedure::AccessionIdentifierType& ImagingProcedure::
  AccessionIdentifier () const
  {
    return this->AccessionIdentifier_.get ();
  }

  ImagingProcedure::AccessionIdentifierType& ImagingProcedure::
  AccessionIdentifier ()
  {
    return this->AccessionIdentifier_.get ();
  }

  void ImagingProcedure::
  AccessionIdentifier (const AccessionIdentifierType& x)
  {
    this->AccessionIdentifier_.set (x);
  }

  void ImagingProcedure::
  AccessionIdentifier (::std::unique_ptr< AccessionIdentifierType > x)
  {
    this->AccessionIdentifier_.set (std::move (x));
  }

  const ImagingProcedure::RequestedProcedureIdType& ImagingProcedure::
  RequestedProcedureId () const
  {
    return this->RequestedProcedureId_.get ();
  }

  ImagingProcedure::RequestedProcedureIdType& ImagingProcedure::
  RequestedProcedureId ()
  {
    return this->RequestedProcedureId_.get ();
  }

  void ImagingProcedure::
  RequestedProcedureId (const RequestedProcedureIdType& x)
  {
    this->RequestedProcedureId_.set (x);
  }

  void ImagingProcedure::
  RequestedProcedureId (::std::unique_ptr< RequestedProcedureIdType > x)
  {
    this->RequestedProcedureId_.set (std::move (x));
  }

  const ImagingProcedure::StudyInstanceUidType& ImagingProcedure::
  StudyInstanceUid () const
  {
    return this->StudyInstanceUid_.get ();
  }

  ImagingProcedure::StudyInstanceUidType& ImagingProcedure::
  StudyInstanceUid ()
  {
    return this->StudyInstanceUid_.get ();
  }

  void ImagingProcedure::
  StudyInstanceUid (const StudyInstanceUidType& x)
  {
    this->StudyInstanceUid_.set (x);
  }

  void ImagingProcedure::
  StudyInstanceUid (::std::unique_ptr< StudyInstanceUidType > x)
  {
    this->StudyInstanceUid_.set (std::move (x));
  }

  const ImagingProcedure::ScheduledProcedureStepIdType& ImagingProcedure::
  ScheduledProcedureStepId () const
  {
    return this->ScheduledProcedureStepId_.get ();
  }

  ImagingProcedure::ScheduledProcedureStepIdType& ImagingProcedure::
  ScheduledProcedureStepId ()
  {
    return this->ScheduledProcedureStepId_.get ();
  }

  void ImagingProcedure::
  ScheduledProcedureStepId (const ScheduledProcedureStepIdType& x)
  {
    this->ScheduledProcedureStepId_.set (x);
  }

  void ImagingProcedure::
  ScheduledProcedureStepId (::std::unique_ptr< ScheduledProcedureStepIdType > x)
  {
    this->ScheduledProcedureStepId_.set (std::move (x));
  }

  const ImagingProcedure::ModalityOptional& ImagingProcedure::
  Modality () const
  {
    return this->Modality_;
  }

  ImagingProcedure::ModalityOptional& ImagingProcedure::
  Modality ()
  {
    return this->Modality_;
  }

  void ImagingProcedure::
  Modality (const ModalityType& x)
  {
    this->Modality_.set (x);
  }

  void ImagingProcedure::
  Modality (const ModalityOptional& x)
  {
    this->Modality_ = x;
  }

  void ImagingProcedure::
  Modality (::std::unique_ptr< ModalityType > x)
  {
    this->Modality_.set (std::move (x));
  }

  const ImagingProcedure::ProtocolCodeOptional& ImagingProcedure::
  ProtocolCode () const
  {
    return this->ProtocolCode_;
  }

  ImagingProcedure::ProtocolCodeOptional& ImagingProcedure::
  ProtocolCode ()
  {
    return this->ProtocolCode_;
  }

  void ImagingProcedure::
  ProtocolCode (const ProtocolCodeType& x)
  {
    this->ProtocolCode_.set (x);
  }

  void ImagingProcedure::
  ProtocolCode (const ProtocolCodeOptional& x)
  {
    this->ProtocolCode_ = x;
  }

  void ImagingProcedure::
  ProtocolCode (::std::unique_ptr< ProtocolCodeType > x)
  {
    this->ProtocolCode_.set (std::move (x));
  }


  // LocationReference
  // 

  const LocationReference::ExtensionOptional& LocationReference::
  Extension () const
  {
    return this->Extension_;
  }

  LocationReference::ExtensionOptional& LocationReference::
  Extension ()
  {
    return this->Extension_;
  }

  void LocationReference::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void LocationReference::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void LocationReference::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const LocationReference::IdentificationSequence& LocationReference::
  Identification () const
  {
    return this->Identification_;
  }

  LocationReference::IdentificationSequence& LocationReference::
  Identification ()
  {
    return this->Identification_;
  }

  void LocationReference::
  Identification (const IdentificationSequence& s)
  {
    this->Identification_ = s;
  }

  const LocationReference::LocationDetailOptional& LocationReference::
  LocationDetail () const
  {
    return this->LocationDetail_;
  }

  LocationReference::LocationDetailOptional& LocationReference::
  LocationDetail ()
  {
    return this->LocationDetail_;
  }

  void LocationReference::
  LocationDetail (const LocationDetailType& x)
  {
    this->LocationDetail_.set (x);
  }

  void LocationReference::
  LocationDetail (const LocationDetailOptional& x)
  {
    this->LocationDetail_ = x;
  }

  void LocationReference::
  LocationDetail (::std::unique_ptr< LocationDetailType > x)
  {
    this->LocationDetail_.set (std::move (x));
  }


  // OrderDetail
  // 

  const OrderDetail::ExtensionOptional& OrderDetail::
  Extension () const
  {
    return this->Extension_;
  }

  OrderDetail::ExtensionOptional& OrderDetail::
  Extension ()
  {
    return this->Extension_;
  }

  void OrderDetail::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void OrderDetail::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void OrderDetail::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const OrderDetail::StartOptional& OrderDetail::
  Start () const
  {
    return this->Start_;
  }

  OrderDetail::StartOptional& OrderDetail::
  Start ()
  {
    return this->Start_;
  }

  void OrderDetail::
  Start (const StartType& x)
  {
    this->Start_.set (x);
  }

  void OrderDetail::
  Start (const StartOptional& x)
  {
    this->Start_ = x;
  }

  void OrderDetail::
  Start (::std::unique_ptr< StartType > x)
  {
    this->Start_.set (std::move (x));
  }

  const OrderDetail::EndOptional& OrderDetail::
  End () const
  {
    return this->End_;
  }

  OrderDetail::EndOptional& OrderDetail::
  End ()
  {
    return this->End_;
  }

  void OrderDetail::
  End (const EndType& x)
  {
    this->End_.set (x);
  }

  void OrderDetail::
  End (const EndOptional& x)
  {
    this->End_ = x;
  }

  void OrderDetail::
  End (::std::unique_ptr< EndType > x)
  {
    this->End_.set (std::move (x));
  }

  const OrderDetail::PerformerSequence& OrderDetail::
  Performer () const
  {
    return this->Performer_;
  }

  OrderDetail::PerformerSequence& OrderDetail::
  Performer ()
  {
    return this->Performer_;
  }

  void OrderDetail::
  Performer (const PerformerSequence& s)
  {
    this->Performer_ = s;
  }

  const OrderDetail::ServiceSequence& OrderDetail::
  Service () const
  {
    return this->Service_;
  }

  OrderDetail::ServiceSequence& OrderDetail::
  Service ()
  {
    return this->Service_;
  }

  void OrderDetail::
  Service (const ServiceSequence& s)
  {
    this->Service_ = s;
  }

  const OrderDetail::ImagingProcedureSequence& OrderDetail::
  ImagingProcedure () const
  {
    return this->ImagingProcedure_;
  }

  OrderDetail::ImagingProcedureSequence& OrderDetail::
  ImagingProcedure ()
  {
    return this->ImagingProcedure_;
  }

  void OrderDetail::
  ImagingProcedure (const ImagingProcedureSequence& s)
  {
    this->ImagingProcedure_ = s;
  }


  // PersonParticipation
  // 

  const PersonParticipation::RoleSequence& PersonParticipation::
  Role () const
  {
    return this->Role_;
  }

  PersonParticipation::RoleSequence& PersonParticipation::
  Role ()
  {
    return this->Role_;
  }

  void PersonParticipation::
  Role (const RoleSequence& s)
  {
    this->Role_ = s;
  }


  // WorkflowContextState
  // 

  const WorkflowContextState::WorkflowDetailOptional& WorkflowContextState::
  WorkflowDetail () const
  {
    return this->WorkflowDetail_;
  }

  WorkflowContextState::WorkflowDetailOptional& WorkflowContextState::
  WorkflowDetail ()
  {
    return this->WorkflowDetail_;
  }

  void WorkflowContextState::
  WorkflowDetail (const WorkflowDetailType& x)
  {
    this->WorkflowDetail_.set (x);
  }

  void WorkflowContextState::
  WorkflowDetail (const WorkflowDetailOptional& x)
  {
    this->WorkflowDetail_ = x;
  }

  void WorkflowContextState::
  WorkflowDetail (::std::unique_ptr< WorkflowDetailType > x)
  {
    this->WorkflowDetail_.set (std::move (x));
  }


  // OperatorContextDescriptor
  // 


  // OperatorContextState
  // 

  const OperatorContextState::OperatorDetailsOptional& OperatorContextState::
  OperatorDetails () const
  {
    return this->OperatorDetails_;
  }

  OperatorContextState::OperatorDetailsOptional& OperatorContextState::
  OperatorDetails ()
  {
    return this->OperatorDetails_;
  }

  void OperatorContextState::
  OperatorDetails (const OperatorDetailsType& x)
  {
    this->OperatorDetails_.set (x);
  }

  void OperatorContextState::
  OperatorDetails (const OperatorDetailsOptional& x)
  {
    this->OperatorDetails_ = x;
  }

  void OperatorContextState::
  OperatorDetails (::std::unique_ptr< OperatorDetailsType > x)
  {
    this->OperatorDetails_.set (std::move (x));
  }


  // MeansContextDescriptor
  // 


  // MeansContextState
  // 


  // EnsembleContextDescriptor
  // 


  // EnsembleContextState
  // 


  // ContainmentTree
  // 

  const ContainmentTree::ExtensionOptional& ContainmentTree::
  Extension () const
  {
    return this->Extension_;
  }

  ContainmentTree::ExtensionOptional& ContainmentTree::
  Extension ()
  {
    return this->Extension_;
  }

  void ContainmentTree::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void ContainmentTree::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void ContainmentTree::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const ContainmentTree::EntrySequence& ContainmentTree::
  Entry () const
  {
    return this->Entry_;
  }

  ContainmentTree::EntrySequence& ContainmentTree::
  Entry ()
  {
    return this->Entry_;
  }

  void ContainmentTree::
  Entry (const EntrySequence& s)
  {
    this->Entry_ = s;
  }

  const ContainmentTree::HandleRefOptional& ContainmentTree::
  HandleRef () const
  {
    return this->HandleRef_;
  }

  ContainmentTree::HandleRefOptional& ContainmentTree::
  HandleRef ()
  {
    return this->HandleRef_;
  }

  void ContainmentTree::
  HandleRef (const HandleRefType& x)
  {
    this->HandleRef_.set (x);
  }

  void ContainmentTree::
  HandleRef (const HandleRefOptional& x)
  {
    this->HandleRef_ = x;
  }

  void ContainmentTree::
  HandleRef (::std::unique_ptr< HandleRefType > x)
  {
    this->HandleRef_.set (std::move (x));
  }

  const ContainmentTree::ParentHandleRefOptional& ContainmentTree::
  ParentHandleRef () const
  {
    return this->ParentHandleRef_;
  }

  ContainmentTree::ParentHandleRefOptional& ContainmentTree::
  ParentHandleRef ()
  {
    return this->ParentHandleRef_;
  }

  void ContainmentTree::
  ParentHandleRef (const ParentHandleRefType& x)
  {
    this->ParentHandleRef_.set (x);
  }

  void ContainmentTree::
  ParentHandleRef (const ParentHandleRefOptional& x)
  {
    this->ParentHandleRef_ = x;
  }

  void ContainmentTree::
  ParentHandleRef (::std::unique_ptr< ParentHandleRefType > x)
  {
    this->ParentHandleRef_.set (std::move (x));
  }

  const ContainmentTree::EntryTypeOptional& ContainmentTree::
  EntryType1 () const
  {
    return this->EntryType_;
  }

  ContainmentTree::EntryTypeOptional& ContainmentTree::
  EntryType1 ()
  {
    return this->EntryType_;
  }

  void ContainmentTree::
  EntryType1 (const EntryTypeType& x)
  {
    this->EntryType_.set (x);
  }

  void ContainmentTree::
  EntryType1 (const EntryTypeOptional& x)
  {
    this->EntryType_ = x;
  }

  void ContainmentTree::
  EntryType1 (::std::unique_ptr< EntryTypeType > x)
  {
    this->EntryType_.set (std::move (x));
  }

  const ContainmentTree::ChildrenCountOptional& ContainmentTree::
  ChildrenCount () const
  {
    return this->ChildrenCount_;
  }

  ContainmentTree::ChildrenCountOptional& ContainmentTree::
  ChildrenCount ()
  {
    return this->ChildrenCount_;
  }

  void ContainmentTree::
  ChildrenCount (const ChildrenCountType& x)
  {
    this->ChildrenCount_.set (x);
  }

  void ContainmentTree::
  ChildrenCount (const ChildrenCountOptional& x)
  {
    this->ChildrenCount_ = x;
  }


  // ContainmentTreeEntry
  // 

  const ContainmentTreeEntry::ExtensionOptional& ContainmentTreeEntry::
  Extension () const
  {
    return this->Extension_;
  }

  ContainmentTreeEntry::ExtensionOptional& ContainmentTreeEntry::
  Extension ()
  {
    return this->Extension_;
  }

  void ContainmentTreeEntry::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void ContainmentTreeEntry::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void ContainmentTreeEntry::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const ContainmentTreeEntry::TypeOptional& ContainmentTreeEntry::
  Type () const
  {
    return this->Type_;
  }

  ContainmentTreeEntry::TypeOptional& ContainmentTreeEntry::
  Type ()
  {
    return this->Type_;
  }

  void ContainmentTreeEntry::
  Type (const TypeType& x)
  {
    this->Type_.set (x);
  }

  void ContainmentTreeEntry::
  Type (const TypeOptional& x)
  {
    this->Type_ = x;
  }

  void ContainmentTreeEntry::
  Type (::std::unique_ptr< TypeType > x)
  {
    this->Type_.set (std::move (x));
  }

  const ContainmentTreeEntry::HandleRefOptional& ContainmentTreeEntry::
  HandleRef () const
  {
    return this->HandleRef_;
  }

  ContainmentTreeEntry::HandleRefOptional& ContainmentTreeEntry::
  HandleRef ()
  {
    return this->HandleRef_;
  }

  void ContainmentTreeEntry::
  HandleRef (const HandleRefType& x)
  {
    this->HandleRef_.set (x);
  }

  void ContainmentTreeEntry::
  HandleRef (const HandleRefOptional& x)
  {
    this->HandleRef_ = x;
  }

  void ContainmentTreeEntry::
  HandleRef (::std::unique_ptr< HandleRefType > x)
  {
    this->HandleRef_.set (std::move (x));
  }

  const ContainmentTreeEntry::ParentHandleRefOptional& ContainmentTreeEntry::
  ParentHandleRef () const
  {
    return this->ParentHandleRef_;
  }

  ContainmentTreeEntry::ParentHandleRefOptional& ContainmentTreeEntry::
  ParentHandleRef ()
  {
    return this->ParentHandleRef_;
  }

  void ContainmentTreeEntry::
  ParentHandleRef (const ParentHandleRefType& x)
  {
    this->ParentHandleRef_.set (x);
  }

  void ContainmentTreeEntry::
  ParentHandleRef (const ParentHandleRefOptional& x)
  {
    this->ParentHandleRef_ = x;
  }

  void ContainmentTreeEntry::
  ParentHandleRef (::std::unique_ptr< ParentHandleRefType > x)
  {
    this->ParentHandleRef_.set (std::move (x));
  }

  const ContainmentTreeEntry::EntryTypeOptional& ContainmentTreeEntry::
  EntryType () const
  {
    return this->EntryType_;
  }

  ContainmentTreeEntry::EntryTypeOptional& ContainmentTreeEntry::
  EntryType ()
  {
    return this->EntryType_;
  }

  void ContainmentTreeEntry::
  EntryType (const EntryTypeType& x)
  {
    this->EntryType_.set (x);
  }

  void ContainmentTreeEntry::
  EntryType (const EntryTypeOptional& x)
  {
    this->EntryType_ = x;
  }

  void ContainmentTreeEntry::
  EntryType (::std::unique_ptr< EntryTypeType > x)
  {
    this->EntryType_.set (std::move (x));
  }

  const ContainmentTreeEntry::ChildrenCountOptional& ContainmentTreeEntry::
  ChildrenCount () const
  {
    return this->ChildrenCount_;
  }

  ContainmentTreeEntry::ChildrenCountOptional& ContainmentTreeEntry::
  ChildrenCount ()
  {
    return this->ChildrenCount_;
  }

  void ContainmentTreeEntry::
  ChildrenCount (const ChildrenCountType& x)
  {
    this->ChildrenCount_.set (x);
  }

  void ContainmentTreeEntry::
  ChildrenCount (const ChildrenCountOptional& x)
  {
    this->ChildrenCount_ = x;
  }


  // Translation
  // 

  const Translation::ExtensionOptional& Translation::
  Extension () const
  {
    return this->Extension_;
  }

  Translation::ExtensionOptional& Translation::
  Extension ()
  {
    return this->Extension_;
  }

  void Translation::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void Translation::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void Translation::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const Translation::CodeType& Translation::
  Code () const
  {
    return this->Code_.get ();
  }

  Translation::CodeType& Translation::
  Code ()
  {
    return this->Code_.get ();
  }

  void Translation::
  Code (const CodeType& x)
  {
    this->Code_.set (x);
  }

  void Translation::
  Code (::std::unique_ptr< CodeType > x)
  {
    this->Code_.set (std::move (x));
  }

  const Translation::CodingSystemOptional& Translation::
  CodingSystem () const
  {
    return this->CodingSystem_;
  }

  Translation::CodingSystemOptional& Translation::
  CodingSystem ()
  {
    return this->CodingSystem_;
  }

  void Translation::
  CodingSystem (const CodingSystemType& x)
  {
    this->CodingSystem_.set (x);
  }

  void Translation::
  CodingSystem (const CodingSystemOptional& x)
  {
    this->CodingSystem_ = x;
  }

  void Translation::
  CodingSystem (::std::unique_ptr< CodingSystemType > x)
  {
    this->CodingSystem_.set (std::move (x));
  }

  const Translation::CodingSystemVersionOptional& Translation::
  CodingSystemVersion () const
  {
    return this->CodingSystemVersion_;
  }

  Translation::CodingSystemVersionOptional& Translation::
  CodingSystemVersion ()
  {
    return this->CodingSystemVersion_;
  }

  void Translation::
  CodingSystemVersion (const CodingSystemVersionType& x)
  {
    this->CodingSystemVersion_.set (x);
  }

  void Translation::
  CodingSystemVersion (const CodingSystemVersionOptional& x)
  {
    this->CodingSystemVersion_ = x;
  }

  void Translation::
  CodingSystemVersion (::std::unique_ptr< CodingSystemVersionType > x)
  {
    this->CodingSystemVersion_.set (std::move (x));
  }


  // Root
  // 


  // Extension
  // 


  // ProductionSpecification
  // 

  const ProductionSpecification::SpecTypeType& ProductionSpecification::
  SpecType () const
  {
    return this->SpecType_.get ();
  }

  ProductionSpecification::SpecTypeType& ProductionSpecification::
  SpecType ()
  {
    return this->SpecType_.get ();
  }

  void ProductionSpecification::
  SpecType (const SpecTypeType& x)
  {
    this->SpecType_.set (x);
  }

  void ProductionSpecification::
  SpecType (::std::unique_ptr< SpecTypeType > x)
  {
    this->SpecType_.set (std::move (x));
  }

  const ProductionSpecification::ProductionSpecType& ProductionSpecification::
  ProductionSpec () const
  {
    return this->ProductionSpec_.get ();
  }

  ProductionSpecification::ProductionSpecType& ProductionSpecification::
  ProductionSpec ()
  {
    return this->ProductionSpec_.get ();
  }

  void ProductionSpecification::
  ProductionSpec (const ProductionSpecType& x)
  {
    this->ProductionSpec_.set (x);
  }

  void ProductionSpecification::
  ProductionSpec (::std::unique_ptr< ProductionSpecType > x)
  {
    this->ProductionSpec_.set (std::move (x));
  }

  const ProductionSpecification::ComponentIdOptional& ProductionSpecification::
  ComponentId () const
  {
    return this->ComponentId_;
  }

  ProductionSpecification::ComponentIdOptional& ProductionSpecification::
  ComponentId ()
  {
    return this->ComponentId_;
  }

  void ProductionSpecification::
  ComponentId (const ComponentIdType& x)
  {
    this->ComponentId_.set (x);
  }

  void ProductionSpecification::
  ComponentId (const ComponentIdOptional& x)
  {
    this->ComponentId_ = x;
  }

  void ProductionSpecification::
  ComponentId (::std::unique_ptr< ComponentIdType > x)
  {
    this->ComponentId_.set (std::move (x));
  }


  // CalibrationDocumentation
  // 

  const CalibrationDocumentation::DocumentationSequence& CalibrationDocumentation::
  Documentation () const
  {
    return this->Documentation_;
  }

  CalibrationDocumentation::DocumentationSequence& CalibrationDocumentation::
  Documentation ()
  {
    return this->Documentation_;
  }

  void CalibrationDocumentation::
  Documentation (const DocumentationSequence& s)
  {
    this->Documentation_ = s;
  }

  const CalibrationDocumentation::CalibrationResultSequence& CalibrationDocumentation::
  CalibrationResult () const
  {
    return this->CalibrationResult_;
  }

  CalibrationDocumentation::CalibrationResultSequence& CalibrationDocumentation::
  CalibrationResult ()
  {
    return this->CalibrationResult_;
  }

  void CalibrationDocumentation::
  CalibrationResult (const CalibrationResultSequence& s)
  {
    this->CalibrationResult_ = s;
  }


  // MetaData
  // 

  const MetaData::ExtensionOptional& MetaData::
  Extension () const
  {
    return this->Extension_;
  }

  MetaData::ExtensionOptional& MetaData::
  Extension ()
  {
    return this->Extension_;
  }

  void MetaData::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void MetaData::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void MetaData::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const MetaData::UdiSequence& MetaData::
  Udi () const
  {
    return this->Udi_;
  }

  MetaData::UdiSequence& MetaData::
  Udi ()
  {
    return this->Udi_;
  }

  void MetaData::
  Udi (const UdiSequence& s)
  {
    this->Udi_ = s;
  }

  const MetaData::LotNumberOptional& MetaData::
  LotNumber () const
  {
    return this->LotNumber_;
  }

  MetaData::LotNumberOptional& MetaData::
  LotNumber ()
  {
    return this->LotNumber_;
  }

  void MetaData::
  LotNumber (const LotNumberType& x)
  {
    this->LotNumber_.set (x);
  }

  void MetaData::
  LotNumber (const LotNumberOptional& x)
  {
    this->LotNumber_ = x;
  }

  void MetaData::
  LotNumber (::std::unique_ptr< LotNumberType > x)
  {
    this->LotNumber_.set (std::move (x));
  }

  const MetaData::ManufacturerSequence& MetaData::
  Manufacturer () const
  {
    return this->Manufacturer_;
  }

  MetaData::ManufacturerSequence& MetaData::
  Manufacturer ()
  {
    return this->Manufacturer_;
  }

  void MetaData::
  Manufacturer (const ManufacturerSequence& s)
  {
    this->Manufacturer_ = s;
  }

  const MetaData::ManufactureDateOptional& MetaData::
  ManufactureDate () const
  {
    return this->ManufactureDate_;
  }

  MetaData::ManufactureDateOptional& MetaData::
  ManufactureDate ()
  {
    return this->ManufactureDate_;
  }

  void MetaData::
  ManufactureDate (const ManufactureDateType& x)
  {
    this->ManufactureDate_.set (x);
  }

  void MetaData::
  ManufactureDate (const ManufactureDateOptional& x)
  {
    this->ManufactureDate_ = x;
  }

  void MetaData::
  ManufactureDate (::std::unique_ptr< ManufactureDateType > x)
  {
    this->ManufactureDate_.set (std::move (x));
  }

  const MetaData::ExpirationDateOptional& MetaData::
  ExpirationDate () const
  {
    return this->ExpirationDate_;
  }

  MetaData::ExpirationDateOptional& MetaData::
  ExpirationDate ()
  {
    return this->ExpirationDate_;
  }

  void MetaData::
  ExpirationDate (const ExpirationDateType& x)
  {
    this->ExpirationDate_.set (x);
  }

  void MetaData::
  ExpirationDate (const ExpirationDateOptional& x)
  {
    this->ExpirationDate_ = x;
  }

  void MetaData::
  ExpirationDate (::std::unique_ptr< ExpirationDateType > x)
  {
    this->ExpirationDate_.set (std::move (x));
  }

  const MetaData::ModelNameSequence& MetaData::
  ModelName () const
  {
    return this->ModelName_;
  }

  MetaData::ModelNameSequence& MetaData::
  ModelName ()
  {
    return this->ModelName_;
  }

  void MetaData::
  ModelName (const ModelNameSequence& s)
  {
    this->ModelName_ = s;
  }

  const MetaData::ModelNumberOptional& MetaData::
  ModelNumber () const
  {
    return this->ModelNumber_;
  }

  MetaData::ModelNumberOptional& MetaData::
  ModelNumber ()
  {
    return this->ModelNumber_;
  }

  void MetaData::
  ModelNumber (const ModelNumberType& x)
  {
    this->ModelNumber_.set (x);
  }

  void MetaData::
  ModelNumber (const ModelNumberOptional& x)
  {
    this->ModelNumber_ = x;
  }

  void MetaData::
  ModelNumber (::std::unique_ptr< ModelNumberType > x)
  {
    this->ModelNumber_.set (std::move (x));
  }

  const MetaData::SerialNumberSequence& MetaData::
  SerialNumber () const
  {
    return this->SerialNumber_;
  }

  MetaData::SerialNumberSequence& MetaData::
  SerialNumber ()
  {
    return this->SerialNumber_;
  }

  void MetaData::
  SerialNumber (const SerialNumberSequence& s)
  {
    this->SerialNumber_ = s;
  }


  // CanEscalate
  // 

  CanEscalate::
  CanEscalate (Value v)
  : ::CDM::AlertConditionPriority (v)
  {
  }

  CanEscalate::
  CanEscalate (const char* v)
  : ::CDM::AlertConditionPriority (v)
  {
  }

  CanEscalate::
  CanEscalate (const ::std::string& v)
  : ::CDM::AlertConditionPriority (v)
  {
  }

  CanEscalate::
  CanEscalate (const ::CDM::AlertConditionPriority& v)
  : ::CDM::AlertConditionPriority (v)
  {
  }

  CanEscalate::
  CanEscalate (const CanEscalate& v,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::CDM::AlertConditionPriority (v, f, c)
  {
  }

  CanEscalate& CanEscalate::
  operator= (Value v)
  {
    static_cast< ::CDM::AlertConditionPriority& > (*this) = v;

    return *this;
  }


  // CanDeescalate
  // 

  CanDeescalate::
  CanDeescalate (Value v)
  : ::CDM::AlertConditionPriority (v)
  {
  }

  CanDeescalate::
  CanDeescalate (const char* v)
  : ::CDM::AlertConditionPriority (v)
  {
  }

  CanDeescalate::
  CanDeescalate (const ::std::string& v)
  : ::CDM::AlertConditionPriority (v)
  {
  }

  CanDeescalate::
  CanDeescalate (const ::CDM::AlertConditionPriority& v)
  : ::CDM::AlertConditionPriority (v)
  {
  }

  CanDeescalate::
  CanDeescalate (const CanDeescalate& v,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AlertConditionPriority (v, f, c)
  {
  }

  CanDeescalate& CanDeescalate::
  operator= (Value v)
  {
    static_cast< ::CDM::AlertConditionPriority& > (*this) = v;

    return *this;
  }


  // MetricQuality
  // 

  const MetricQuality::ExtensionOptional& MetricQuality::
  Extension () const
  {
    return this->Extension_;
  }

  MetricQuality::ExtensionOptional& MetricQuality::
  Extension ()
  {
    return this->Extension_;
  }

  void MetricQuality::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void MetricQuality::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void MetricQuality::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const MetricQuality::ValidityType& MetricQuality::
  Validity () const
  {
    return this->Validity_.get ();
  }

  MetricQuality::ValidityType& MetricQuality::
  Validity ()
  {
    return this->Validity_.get ();
  }

  void MetricQuality::
  Validity (const ValidityType& x)
  {
    this->Validity_.set (x);
  }

  void MetricQuality::
  Validity (::std::unique_ptr< ValidityType > x)
  {
    this->Validity_.set (std::move (x));
  }

  const MetricQuality::ModeOptional& MetricQuality::
  Mode () const
  {
    return this->Mode_;
  }

  MetricQuality::ModeOptional& MetricQuality::
  Mode ()
  {
    return this->Mode_;
  }

  void MetricQuality::
  Mode (const ModeType& x)
  {
    this->Mode_.set (x);
  }

  void MetricQuality::
  Mode (const ModeOptional& x)
  {
    this->Mode_ = x;
  }

  void MetricQuality::
  Mode (::std::unique_ptr< ModeType > x)
  {
    this->Mode_.set (std::move (x));
  }

  const MetricQuality::QiOptional& MetricQuality::
  Qi () const
  {
    return this->Qi_;
  }

  MetricQuality::QiOptional& MetricQuality::
  Qi ()
  {
    return this->Qi_;
  }

  void MetricQuality::
  Qi (const QiType& x)
  {
    this->Qi_.set (x);
  }

  void MetricQuality::
  Qi (const QiOptional& x)
  {
    this->Qi_ = x;
  }

  void MetricQuality::
  Qi (::std::unique_ptr< QiType > x)
  {
    this->Qi_.set (std::move (x));
  }


  // Annotation
  // 

  const Annotation::ExtensionOptional& Annotation::
  Extension () const
  {
    return this->Extension_;
  }

  Annotation::ExtensionOptional& Annotation::
  Extension ()
  {
    return this->Extension_;
  }

  void Annotation::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void Annotation::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void Annotation::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const Annotation::TypeType& Annotation::
  Type () const
  {
    return this->Type_.get ();
  }

  Annotation::TypeType& Annotation::
  Type ()
  {
    return this->Type_.get ();
  }

  void Annotation::
  Type (const TypeType& x)
  {
    this->Type_.set (x);
  }

  void Annotation::
  Type (::std::unique_ptr< TypeType > x)
  {
    this->Type_.set (std::move (x));
  }


  // ApplyAnnotation
  // 

  const ApplyAnnotation::AnnotationIndexType& ApplyAnnotation::
  AnnotationIndex () const
  {
    return this->AnnotationIndex_.get ();
  }

  ApplyAnnotation::AnnotationIndexType& ApplyAnnotation::
  AnnotationIndex ()
  {
    return this->AnnotationIndex_.get ();
  }

  void ApplyAnnotation::
  AnnotationIndex (const AnnotationIndexType& x)
  {
    this->AnnotationIndex_.set (x);
  }

  const ApplyAnnotation::SampleIndexType& ApplyAnnotation::
  SampleIndex () const
  {
    return this->SampleIndex_.get ();
  }

  ApplyAnnotation::SampleIndexType& ApplyAnnotation::
  SampleIndex ()
  {
    return this->SampleIndex_.get ();
  }

  void ApplyAnnotation::
  SampleIndex (const SampleIndexType& x)
  {
    this->SampleIndex_.set (x);
  }


  // Relation
  // 

  const Relation::ExtensionOptional& Relation::
  Extension () const
  {
    return this->Extension_;
  }

  Relation::ExtensionOptional& Relation::
  Extension ()
  {
    return this->Extension_;
  }

  void Relation::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void Relation::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void Relation::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const Relation::CodeOptional& Relation::
  Code () const
  {
    return this->Code_;
  }

  Relation::CodeOptional& Relation::
  Code ()
  {
    return this->Code_;
  }

  void Relation::
  Code (const CodeType& x)
  {
    this->Code_.set (x);
  }

  void Relation::
  Code (const CodeOptional& x)
  {
    this->Code_ = x;
  }

  void Relation::
  Code (::std::unique_ptr< CodeType > x)
  {
    this->Code_.set (std::move (x));
  }

  const Relation::IdentificationOptional& Relation::
  Identification () const
  {
    return this->Identification_;
  }

  Relation::IdentificationOptional& Relation::
  Identification ()
  {
    return this->Identification_;
  }

  void Relation::
  Identification (const IdentificationType& x)
  {
    this->Identification_.set (x);
  }

  void Relation::
  Identification (const IdentificationOptional& x)
  {
    this->Identification_ = x;
  }

  void Relation::
  Identification (::std::unique_ptr< IdentificationType > x)
  {
    this->Identification_.set (std::move (x));
  }

  const Relation::KindType& Relation::
  Kind () const
  {
    return this->Kind_.get ();
  }

  Relation::KindType& Relation::
  Kind ()
  {
    return this->Kind_.get ();
  }

  void Relation::
  Kind (const KindType& x)
  {
    this->Kind_.set (x);
  }

  void Relation::
  Kind (::std::unique_ptr< KindType > x)
  {
    this->Kind_.set (std::move (x));
  }

  const Relation::EntriesType& Relation::
  Entries () const
  {
    return this->Entries_.get ();
  }

  Relation::EntriesType& Relation::
  Entries ()
  {
    return this->Entries_.get ();
  }

  void Relation::
  Entries (const EntriesType& x)
  {
    this->Entries_.set (x);
  }

  void Relation::
  Entries (::std::unique_ptr< EntriesType > x)
  {
    this->Entries_.set (std::move (x));
  }


  // AllowedValue
  // 

  const AllowedValue::ValueType& AllowedValue::
  Value () const
  {
    return this->Value_.get ();
  }

  AllowedValue::ValueType& AllowedValue::
  Value ()
  {
    return this->Value_.get ();
  }

  void AllowedValue::
  Value (const ValueType& x)
  {
    this->Value_.set (x);
  }

  void AllowedValue::
  Value (::std::unique_ptr< ValueType > x)
  {
    this->Value_.set (std::move (x));
  }

  const AllowedValue::TypeOptional& AllowedValue::
  Type () const
  {
    return this->Type_;
  }

  AllowedValue::TypeOptional& AllowedValue::
  Type ()
  {
    return this->Type_;
  }

  void AllowedValue::
  Type (const TypeType& x)
  {
    this->Type_.set (x);
  }

  void AllowedValue::
  Type (const TypeOptional& x)
  {
    this->Type_ = x;
  }

  void AllowedValue::
  Type (::std::unique_ptr< TypeType > x)
  {
    this->Type_.set (std::move (x));
  }

  const AllowedValue::IdentificationOptional& AllowedValue::
  Identification () const
  {
    return this->Identification_;
  }

  AllowedValue::IdentificationOptional& AllowedValue::
  Identification ()
  {
    return this->Identification_;
  }

  void AllowedValue::
  Identification (const IdentificationType& x)
  {
    this->Identification_.set (x);
  }

  void AllowedValue::
  Identification (const IdentificationOptional& x)
  {
    this->Identification_ = x;
  }

  void AllowedValue::
  Identification (::std::unique_ptr< IdentificationType > x)
  {
    this->Identification_.set (std::move (x));
  }

  const AllowedValue::CharacteristicOptional& AllowedValue::
  Characteristic () const
  {
    return this->Characteristic_;
  }

  AllowedValue::CharacteristicOptional& AllowedValue::
  Characteristic ()
  {
    return this->Characteristic_;
  }

  void AllowedValue::
  Characteristic (const CharacteristicType& x)
  {
    this->Characteristic_.set (x);
  }

  void AllowedValue::
  Characteristic (const CharacteristicOptional& x)
  {
    this->Characteristic_ = x;
  }

  void AllowedValue::
  Characteristic (::std::unique_ptr< CharacteristicType > x)
  {
    this->Characteristic_.set (std::move (x));
  }


  // OperationGroup
  // 

  const OperationGroup::ExtensionOptional& OperationGroup::
  Extension () const
  {
    return this->Extension_;
  }

  OperationGroup::ExtensionOptional& OperationGroup::
  Extension ()
  {
    return this->Extension_;
  }

  void OperationGroup::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void OperationGroup::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void OperationGroup::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const OperationGroup::TypeType& OperationGroup::
  Type () const
  {
    return this->Type_.get ();
  }

  OperationGroup::TypeType& OperationGroup::
  Type ()
  {
    return this->Type_.get ();
  }

  void OperationGroup::
  Type (const TypeType& x)
  {
    this->Type_.set (x);
  }

  void OperationGroup::
  Type (::std::unique_ptr< TypeType > x)
  {
    this->Type_.set (std::move (x));
  }

  const OperationGroup::OperatingModeOptional& OperationGroup::
  OperatingMode () const
  {
    return this->OperatingMode_;
  }

  OperationGroup::OperatingModeOptional& OperationGroup::
  OperatingMode ()
  {
    return this->OperatingMode_;
  }

  void OperationGroup::
  OperatingMode (const OperatingModeType& x)
  {
    this->OperatingMode_.set (x);
  }

  void OperationGroup::
  OperatingMode (const OperatingModeOptional& x)
  {
    this->OperatingMode_ = x;
  }

  void OperationGroup::
  OperatingMode (::std::unique_ptr< OperatingModeType > x)
  {
    this->OperatingMode_.set (std::move (x));
  }

  const OperationGroup::OperationsOptional& OperationGroup::
  Operations () const
  {
    return this->Operations_;
  }

  OperationGroup::OperationsOptional& OperationGroup::
  Operations ()
  {
    return this->Operations_;
  }

  void OperationGroup::
  Operations (const OperationsType& x)
  {
    this->Operations_.set (x);
  }

  void OperationGroup::
  Operations (const OperationsOptional& x)
  {
    this->Operations_ = x;
  }

  void OperationGroup::
  Operations (::std::unique_ptr< OperationsType > x)
  {
    this->Operations_.set (std::move (x));
  }


  // AccessLevel
  // 

  AccessLevel::
  AccessLevel (Value v)
  : ::xml_schema::String (_xsd_AccessLevel_literals_[v])
  {
  }

  AccessLevel::
  AccessLevel (const char* v)
  : ::xml_schema::String (v)
  {
  }

  AccessLevel::
  AccessLevel (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  AccessLevel::
  AccessLevel (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  AccessLevel::
  AccessLevel (const AccessLevel& v,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  AccessLevel& AccessLevel::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_AccessLevel_literals_[v]);

    return *this;
  }


  // AllowedValues
  // 

  const AllowedValues::ValueSequence& AllowedValues::
  Value () const
  {
    return this->Value_;
  }

  AllowedValues::ValueSequence& AllowedValues::
  Value ()
  {
    return this->Value_;
  }

  void AllowedValues::
  Value (const ValueSequence& s)
  {
    this->Value_ = s;
  }


  // Argument
  // 

  const Argument::ArgNameType& Argument::
  ArgName () const
  {
    return this->ArgName_.get ();
  }

  Argument::ArgNameType& Argument::
  ArgName ()
  {
    return this->ArgName_.get ();
  }

  void Argument::
  ArgName (const ArgNameType& x)
  {
    this->ArgName_.set (x);
  }

  void Argument::
  ArgName (::std::unique_ptr< ArgNameType > x)
  {
    this->ArgName_.set (std::move (x));
  }

  const Argument::ArgType& Argument::
  Arg () const
  {
    return this->Arg_.get ();
  }

  Argument::ArgType& Argument::
  Arg ()
  {
    return this->Arg_.get ();
  }

  void Argument::
  Arg (const ArgType& x)
  {
    this->Arg_.set (x);
  }

  void Argument::
  Arg (::std::unique_ptr< ArgType > x)
  {
    this->Arg_.set (std::move (x));
  }


  // ChargeStatus
  // 

  ChargeStatus::
  ChargeStatus (Value v)
  : ::xml_schema::String (_xsd_ChargeStatus_literals_[v])
  {
  }

  ChargeStatus::
  ChargeStatus (const char* v)
  : ::xml_schema::String (v)
  {
  }

  ChargeStatus::
  ChargeStatus (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  ChargeStatus::
  ChargeStatus (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  ChargeStatus::
  ChargeStatus (const ChargeStatus& v,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  ChargeStatus& ChargeStatus::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_ChargeStatus_literals_[v]);

    return *this;
  }


  // DateOfBirth
  //

  DateOfBirth::
  DateOfBirth (const char* s)
  : ::xml_schema::String (s)
  {
  }

  DateOfBirth::
  DateOfBirth (const ::std::string& s)
  : ::xml_schema::String (s)
  {
  }

  DateOfBirth::
  DateOfBirth (const DateOfBirth& o,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (o, f, c)
  {
  }

  // Criticality
  // 

  Criticality::
  Criticality (Value v)
  : ::xml_schema::String (_xsd_Criticality_literals_[v])
  {
  }

  Criticality::
  Criticality (const char* v)
  : ::xml_schema::String (v)
  {
  }

  Criticality::
  Criticality (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  Criticality::
  Criticality (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Criticality::
  Criticality (const Criticality& v,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Criticality& Criticality::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Criticality_literals_[v]);

    return *this;
  }


  // RelatedMeasurement
  // 

  const RelatedMeasurement::ValueType& RelatedMeasurement::
  Value () const
  {
    return this->Value_.get ();
  }

  RelatedMeasurement::ValueType& RelatedMeasurement::
  Value ()
  {
    return this->Value_.get ();
  }

  void RelatedMeasurement::
  Value (const ValueType& x)
  {
    this->Value_.set (x);
  }

  void RelatedMeasurement::
  Value (::std::unique_ptr< ValueType > x)
  {
    this->Value_.set (std::move (x));
  }

  const RelatedMeasurement::ReferenceRangeSequence& RelatedMeasurement::
  ReferenceRange () const
  {
    return this->ReferenceRange_;
  }

  RelatedMeasurement::ReferenceRangeSequence& RelatedMeasurement::
  ReferenceRange ()
  {
    return this->ReferenceRange_;
  }

  void RelatedMeasurement::
  ReferenceRange (const ReferenceRangeSequence& s)
  {
    this->ReferenceRange_ = s;
  }

  const RelatedMeasurement::ValidityOptional& RelatedMeasurement::
  Validity () const
  {
    return this->Validity_;
  }

  RelatedMeasurement::ValidityOptional& RelatedMeasurement::
  Validity ()
  {
    return this->Validity_;
  }

  void RelatedMeasurement::
  Validity (const ValidityType& x)
  {
    this->Validity_.set (x);
  }

  void RelatedMeasurement::
  Validity (const ValidityOptional& x)
  {
    this->Validity_ = x;
  }

  void RelatedMeasurement::
  Validity (::std::unique_ptr< ValidityType > x)
  {
    this->Validity_.set (std::move (x));
  }


  // WorkflowDetail
  // 

  const WorkflowDetail::ExtensionOptional& WorkflowDetail::
  Extension () const
  {
    return this->Extension_;
  }

  WorkflowDetail::ExtensionOptional& WorkflowDetail::
  Extension ()
  {
    return this->Extension_;
  }

  void WorkflowDetail::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void WorkflowDetail::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void WorkflowDetail::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const WorkflowDetail::PatientType& WorkflowDetail::
  Patient () const
  {
    return this->Patient_.get ();
  }

  WorkflowDetail::PatientType& WorkflowDetail::
  Patient ()
  {
    return this->Patient_.get ();
  }

  void WorkflowDetail::
  Patient (const PatientType& x)
  {
    this->Patient_.set (x);
  }

  void WorkflowDetail::
  Patient (::std::unique_ptr< PatientType > x)
  {
    this->Patient_.set (std::move (x));
  }

  const WorkflowDetail::AssignedLocationOptional& WorkflowDetail::
  AssignedLocation () const
  {
    return this->AssignedLocation_;
  }

  WorkflowDetail::AssignedLocationOptional& WorkflowDetail::
  AssignedLocation ()
  {
    return this->AssignedLocation_;
  }

  void WorkflowDetail::
  AssignedLocation (const AssignedLocationType& x)
  {
    this->AssignedLocation_.set (x);
  }

  void WorkflowDetail::
  AssignedLocation (const AssignedLocationOptional& x)
  {
    this->AssignedLocation_ = x;
  }

  void WorkflowDetail::
  AssignedLocation (::std::unique_ptr< AssignedLocationType > x)
  {
    this->AssignedLocation_.set (std::move (x));
  }

  const WorkflowDetail::VisitNumberOptional& WorkflowDetail::
  VisitNumber () const
  {
    return this->VisitNumber_;
  }

  WorkflowDetail::VisitNumberOptional& WorkflowDetail::
  VisitNumber ()
  {
    return this->VisitNumber_;
  }

  void WorkflowDetail::
  VisitNumber (const VisitNumberType& x)
  {
    this->VisitNumber_.set (x);
  }

  void WorkflowDetail::
  VisitNumber (const VisitNumberOptional& x)
  {
    this->VisitNumber_ = x;
  }

  void WorkflowDetail::
  VisitNumber (::std::unique_ptr< VisitNumberType > x)
  {
    this->VisitNumber_.set (std::move (x));
  }

  const WorkflowDetail::DangerCodeSequence& WorkflowDetail::
  DangerCode () const
  {
    return this->DangerCode_;
  }

  WorkflowDetail::DangerCodeSequence& WorkflowDetail::
  DangerCode ()
  {
    return this->DangerCode_;
  }

  void WorkflowDetail::
  DangerCode (const DangerCodeSequence& s)
  {
    this->DangerCode_ = s;
  }

  const WorkflowDetail::RelevantClinicalInfoSequence& WorkflowDetail::
  RelevantClinicalInfo () const
  {
    return this->RelevantClinicalInfo_;
  }

  WorkflowDetail::RelevantClinicalInfoSequence& WorkflowDetail::
  RelevantClinicalInfo ()
  {
    return this->RelevantClinicalInfo_;
  }

  void WorkflowDetail::
  RelevantClinicalInfo (const RelevantClinicalInfoSequence& s)
  {
    this->RelevantClinicalInfo_ = s;
  }

  const WorkflowDetail::RequestedOrderDetailOptional& WorkflowDetail::
  RequestedOrderDetail () const
  {
    return this->RequestedOrderDetail_;
  }

  WorkflowDetail::RequestedOrderDetailOptional& WorkflowDetail::
  RequestedOrderDetail ()
  {
    return this->RequestedOrderDetail_;
  }

  void WorkflowDetail::
  RequestedOrderDetail (const RequestedOrderDetailType& x)
  {
    this->RequestedOrderDetail_.set (x);
  }

  void WorkflowDetail::
  RequestedOrderDetail (const RequestedOrderDetailOptional& x)
  {
    this->RequestedOrderDetail_ = x;
  }

  void WorkflowDetail::
  RequestedOrderDetail (::std::unique_ptr< RequestedOrderDetailType > x)
  {
    this->RequestedOrderDetail_.set (std::move (x));
  }

  const WorkflowDetail::PerformedOrderDetailOptional& WorkflowDetail::
  PerformedOrderDetail () const
  {
    return this->PerformedOrderDetail_;
  }

  WorkflowDetail::PerformedOrderDetailOptional& WorkflowDetail::
  PerformedOrderDetail ()
  {
    return this->PerformedOrderDetail_;
  }

  void WorkflowDetail::
  PerformedOrderDetail (const PerformedOrderDetailType& x)
  {
    this->PerformedOrderDetail_.set (x);
  }

  void WorkflowDetail::
  PerformedOrderDetail (const PerformedOrderDetailOptional& x)
  {
    this->PerformedOrderDetail_ = x;
  }

  void WorkflowDetail::
  PerformedOrderDetail (::std::unique_ptr< PerformedOrderDetailType > x)
  {
    this->PerformedOrderDetail_.set (std::move (x));
  }


  // CalibrationResult
  // 

  const CalibrationResult::CodeType& CalibrationResult::
  Code () const
  {
    return this->Code_.get ();
  }

  CalibrationResult::CodeType& CalibrationResult::
  Code ()
  {
    return this->Code_.get ();
  }

  void CalibrationResult::
  Code (const CodeType& x)
  {
    this->Code_.set (x);
  }

  void CalibrationResult::
  Code (::std::unique_ptr< CodeType > x)
  {
    this->Code_.set (std::move (x));
  }

  const CalibrationResult::ValueType& CalibrationResult::
  Value () const
  {
    return this->Value_.get ();
  }

  CalibrationResult::ValueType& CalibrationResult::
  Value ()
  {
    return this->Value_.get ();
  }

  void CalibrationResult::
  Value (const ValueType& x)
  {
    this->Value_.set (x);
  }

  void CalibrationResult::
  Value (::std::unique_ptr< ValueType > x)
  {
    this->Value_.set (std::move (x));
  }


  // Udi
  // 

  const Udi::ExtensionOptional& Udi::
  Extension () const
  {
    return this->Extension_;
  }

  Udi::ExtensionOptional& Udi::
  Extension ()
  {
    return this->Extension_;
  }

  void Udi::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void Udi::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void Udi::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const Udi::DeviceIdentifierType& Udi::
  DeviceIdentifier () const
  {
    return this->DeviceIdentifier_.get ();
  }

  Udi::DeviceIdentifierType& Udi::
  DeviceIdentifier ()
  {
    return this->DeviceIdentifier_.get ();
  }

  void Udi::
  DeviceIdentifier (const DeviceIdentifierType& x)
  {
    this->DeviceIdentifier_.set (x);
  }

  void Udi::
  DeviceIdentifier (::std::unique_ptr< DeviceIdentifierType > x)
  {
    this->DeviceIdentifier_.set (std::move (x));
  }

  const Udi::HumanReadableFormType& Udi::
  HumanReadableForm () const
  {
    return this->HumanReadableForm_.get ();
  }

  Udi::HumanReadableFormType& Udi::
  HumanReadableForm ()
  {
    return this->HumanReadableForm_.get ();
  }

  void Udi::
  HumanReadableForm (const HumanReadableFormType& x)
  {
    this->HumanReadableForm_.set (x);
  }

  void Udi::
  HumanReadableForm (::std::unique_ptr< HumanReadableFormType > x)
  {
    this->HumanReadableForm_.set (std::move (x));
  }

  const Udi::IssuerType& Udi::
  Issuer () const
  {
    return this->Issuer_.get ();
  }

  Udi::IssuerType& Udi::
  Issuer ()
  {
    return this->Issuer_.get ();
  }

  void Udi::
  Issuer (const IssuerType& x)
  {
    this->Issuer_.set (x);
  }

  void Udi::
  Issuer (::std::unique_ptr< IssuerType > x)
  {
    this->Issuer_.set (std::move (x));
  }

  const Udi::JurisdictionOptional& Udi::
  Jurisdiction () const
  {
    return this->Jurisdiction_;
  }

  Udi::JurisdictionOptional& Udi::
  Jurisdiction ()
  {
    return this->Jurisdiction_;
  }

  void Udi::
  Jurisdiction (const JurisdictionType& x)
  {
    this->Jurisdiction_.set (x);
  }

  void Udi::
  Jurisdiction (const JurisdictionOptional& x)
  {
    this->Jurisdiction_ = x;
  }

  void Udi::
  Jurisdiction (::std::unique_ptr< JurisdictionType > x)
  {
    this->Jurisdiction_.set (std::move (x));
  }


  // Kind
  // 

  Kind::
  Kind (Value v)
  : ::xml_schema::String (_xsd_Kind_literals_[v])
  {
  }

  Kind::
  Kind (const char* v)
  : ::xml_schema::String (v)
  {
  }

  Kind::
  Kind (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  Kind::
  Kind (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Kind::
  Kind (const Kind& v,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Kind& Kind::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Kind_literals_[v]);

    return *this;
  }


  // ReferenceRange
  // 

  const ReferenceRange::RangeType& ReferenceRange::
  Range () const
  {
    return this->Range_.get ();
  }

  ReferenceRange::RangeType& ReferenceRange::
  Range ()
  {
    return this->Range_.get ();
  }

  void ReferenceRange::
  Range (const RangeType& x)
  {
    this->Range_.set (x);
  }

  void ReferenceRange::
  Range (::std::unique_ptr< RangeType > x)
  {
    this->Range_.set (std::move (x));
  }

  const ReferenceRange::MeaningOptional& ReferenceRange::
  Meaning () const
  {
    return this->Meaning_;
  }

  ReferenceRange::MeaningOptional& ReferenceRange::
  Meaning ()
  {
    return this->Meaning_;
  }

  void ReferenceRange::
  Meaning (const MeaningType& x)
  {
    this->Meaning_.set (x);
  }

  void ReferenceRange::
  Meaning (const MeaningOptional& x)
  {
    this->Meaning_ = x;
  }

  void ReferenceRange::
  Meaning (::std::unique_ptr< MeaningType > x)
  {
    this->Meaning_.set (std::move (x));
  }


  // RequestedOrderDetail
  // 

  const RequestedOrderDetail::ReferringPhysicianOptional& RequestedOrderDetail::
  ReferringPhysician () const
  {
    return this->ReferringPhysician_;
  }

  RequestedOrderDetail::ReferringPhysicianOptional& RequestedOrderDetail::
  ReferringPhysician ()
  {
    return this->ReferringPhysician_;
  }

  void RequestedOrderDetail::
  ReferringPhysician (const ReferringPhysicianType& x)
  {
    this->ReferringPhysician_.set (x);
  }

  void RequestedOrderDetail::
  ReferringPhysician (const ReferringPhysicianOptional& x)
  {
    this->ReferringPhysician_ = x;
  }

  void RequestedOrderDetail::
  ReferringPhysician (::std::unique_ptr< ReferringPhysicianType > x)
  {
    this->ReferringPhysician_.set (std::move (x));
  }

  const RequestedOrderDetail::RequestingPhysicianOptional& RequestedOrderDetail::
  RequestingPhysician () const
  {
    return this->RequestingPhysician_;
  }

  RequestedOrderDetail::RequestingPhysicianOptional& RequestedOrderDetail::
  RequestingPhysician ()
  {
    return this->RequestingPhysician_;
  }

  void RequestedOrderDetail::
  RequestingPhysician (const RequestingPhysicianType& x)
  {
    this->RequestingPhysician_.set (x);
  }

  void RequestedOrderDetail::
  RequestingPhysician (const RequestingPhysicianOptional& x)
  {
    this->RequestingPhysician_ = x;
  }

  void RequestedOrderDetail::
  RequestingPhysician (::std::unique_ptr< RequestingPhysicianType > x)
  {
    this->RequestingPhysician_.set (std::move (x));
  }

  const RequestedOrderDetail::PlacerOrderNumberType& RequestedOrderDetail::
  PlacerOrderNumber () const
  {
    return this->PlacerOrderNumber_.get ();
  }

  RequestedOrderDetail::PlacerOrderNumberType& RequestedOrderDetail::
  PlacerOrderNumber ()
  {
    return this->PlacerOrderNumber_.get ();
  }

  void RequestedOrderDetail::
  PlacerOrderNumber (const PlacerOrderNumberType& x)
  {
    this->PlacerOrderNumber_.set (x);
  }

  void RequestedOrderDetail::
  PlacerOrderNumber (::std::unique_ptr< PlacerOrderNumberType > x)
  {
    this->PlacerOrderNumber_.set (std::move (x));
  }


  // PerformedOrderDetail
  // 

  const PerformedOrderDetail::FillerOrderNumberOptional& PerformedOrderDetail::
  FillerOrderNumber () const
  {
    return this->FillerOrderNumber_;
  }

  PerformedOrderDetail::FillerOrderNumberOptional& PerformedOrderDetail::
  FillerOrderNumber ()
  {
    return this->FillerOrderNumber_;
  }

  void PerformedOrderDetail::
  FillerOrderNumber (const FillerOrderNumberType& x)
  {
    this->FillerOrderNumber_.set (x);
  }

  void PerformedOrderDetail::
  FillerOrderNumber (const FillerOrderNumberOptional& x)
  {
    this->FillerOrderNumber_ = x;
  }

  void PerformedOrderDetail::
  FillerOrderNumber (::std::unique_ptr< FillerOrderNumberType > x)
  {
    this->FillerOrderNumber_.set (std::move (x));
  }

  const PerformedOrderDetail::ResultingClinicalInfoSequence& PerformedOrderDetail::
  ResultingClinicalInfo () const
  {
    return this->ResultingClinicalInfo_;
  }

  PerformedOrderDetail::ResultingClinicalInfoSequence& PerformedOrderDetail::
  ResultingClinicalInfo ()
  {
    return this->ResultingClinicalInfo_;
  }

  void PerformedOrderDetail::
  ResultingClinicalInfo (const ResultingClinicalInfoSequence& s)
  {
    this->ResultingClinicalInfo_ = s;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace CDM
{
  // Mdib
  //

  Mdib::
  Mdib (const SequenceIdType& SequenceId)
  : ::xml_schema::Type (),
    Extension_ (this),
    MdDescription_ (this),
    MdState_ (this),
    MdibVersion_ (this),
    SequenceId_ (SequenceId, this),
    InstanceId_ (this)
  {
  }

  Mdib::
  Mdib (const Mdib& x,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    MdDescription_ (x.MdDescription_, f, this),
    MdState_ (x.MdState_, f, this),
    MdibVersion_ (x.MdibVersion_, f, this),
    SequenceId_ (x.SequenceId_, f, this),
    InstanceId_ (x.InstanceId_, f, this)
  {
  }

  Mdib::
  Mdib (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    MdDescription_ (this),
    MdState_ (this),
    MdibVersion_ (this),
    SequenceId_ (this),
    InstanceId_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Mdib::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // MdDescription
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MdDescription",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< MdDescriptionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->MdDescription_)
          {
            ::std::unique_ptr< MdDescriptionType > r (
              dynamic_cast< MdDescriptionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MdDescription_.set (::std::move (r));
            continue;
          }
        }
      }

      // MdState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MdState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< MdStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->MdState_)
          {
            ::std::unique_ptr< MdStateType > r (
              dynamic_cast< MdStateType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MdState_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MdibVersion" && n.namespace_ ().empty ())
      {
        this->MdibVersion_.set (MdibVersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "SequenceId" && n.namespace_ ().empty ())
      {
        this->SequenceId_.set (SequenceIdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "InstanceId" && n.namespace_ ().empty ())
      {
        this->InstanceId_.set (InstanceIdTraits::create (i, f, this));
        continue;
      }
    }

    if (!SequenceId_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "SequenceId",
        "");
    }
  }

  Mdib* Mdib::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Mdib (*this, f, c);
  }

  Mdib& Mdib::
  operator= (const Mdib& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->MdDescription_ = x.MdDescription_;
      this->MdState_ = x.MdState_;
      this->MdibVersion_ = x.MdibVersion_;
      this->SequenceId_ = x.SequenceId_;
      this->InstanceId_ = x.InstanceId_;
    }

    return *this;
  }

  Mdib::
  ~Mdib ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Mdib >
  _xsd_Mdib_type_factory_init (
    "Mdib",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // MdDescription
  //

  MdDescription::
  MdDescription ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Mds_ (this),
    DescriptionVersion_ (this)
  {
  }

  MdDescription::
  MdDescription (const MdDescription& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Mds_ (x.Mds_, f, this),
    DescriptionVersion_ (x.DescriptionVersion_, f, this)
  {
  }

  MdDescription::
  MdDescription (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Mds_ (this),
    DescriptionVersion_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MdDescription::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // Mds
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Mds",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< MdsType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< MdsType > r (
            dynamic_cast< MdsType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Mds_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "DescriptionVersion" && n.namespace_ ().empty ())
      {
        this->DescriptionVersion_.set (DescriptionVersionTraits::create (i, f, this));
        continue;
      }
    }
  }

  MdDescription* MdDescription::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MdDescription (*this, f, c);
  }

  MdDescription& MdDescription::
  operator= (const MdDescription& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Mds_ = x.Mds_;
      this->DescriptionVersion_ = x.DescriptionVersion_;
    }

    return *this;
  }

  MdDescription::
  ~MdDescription ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MdDescription >
  _xsd_MdDescription_type_factory_init (
    "MdDescription",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // MdState
  //

  MdState::
  MdState ()
  : ::xml_schema::Type (),
    Extension_ (this),
    State_ (this),
    StateVersion_ (this)
  {
  }

  MdState::
  MdState (const MdState& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    State_ (x.State_, f, this),
    StateVersion_ (x.StateVersion_, f, this)
  {
  }

  MdState::
  MdState (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    State_ (this),
    StateVersion_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MdState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // State
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "State",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< StateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< StateType > r (
            dynamic_cast< StateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->State_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "StateVersion" && n.namespace_ ().empty ())
      {
        this->StateVersion_.set (StateVersionTraits::create (i, f, this));
        continue;
      }
    }
  }

  MdState* MdState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MdState (*this, f, c);
  }

  MdState& MdState::
  operator= (const MdState& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->State_ = x.State_;
      this->StateVersion_ = x.StateVersion_;
    }

    return *this;
  }

  MdState::
  ~MdState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MdState >
  _xsd_MdState_type_factory_init (
    "MdState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // MeasurementValidity
  //

  MeasurementValidity::
  MeasurementValidity (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_MeasurementValidity_convert ();
  }

  MeasurementValidity::
  MeasurementValidity (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_MeasurementValidity_convert ();
  }

  MeasurementValidity::
  MeasurementValidity (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_MeasurementValidity_convert ();
  }

  MeasurementValidity* MeasurementValidity::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MeasurementValidity (*this, f, c);
  }

  MeasurementValidity::Value MeasurementValidity::
  _xsd_MeasurementValidity_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MeasurementValidity_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_MeasurementValidity_indexes_,
                      _xsd_MeasurementValidity_indexes_ + 9,
                      *this,
                      c));

    if (i == _xsd_MeasurementValidity_indexes_ + 9 || _xsd_MeasurementValidity_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const MeasurementValidity::
  _xsd_MeasurementValidity_literals_[9] =
  {
    "Vld",
    "Vldated",
    "Ong",
    "Qst",
    "Calib",
    "Inv",
    "Oflw",
    "Uflw",
    "NA"
  };

  const MeasurementValidity::Value MeasurementValidity::
  _xsd_MeasurementValidity_indexes_[9] =
  {
    ::CDM::MeasurementValidity::Calib,
    ::CDM::MeasurementValidity::Inv,
    ::CDM::MeasurementValidity::NA,
    ::CDM::MeasurementValidity::Oflw,
    ::CDM::MeasurementValidity::Ong,
    ::CDM::MeasurementValidity::Qst,
    ::CDM::MeasurementValidity::Uflw,
    ::CDM::MeasurementValidity::Vld,
    ::CDM::MeasurementValidity::Vldated
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MeasurementValidity >
  _xsd_MeasurementValidity_type_factory_init (
    "MeasurementValidity",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // Timestamp
  //

  Timestamp::
  Timestamp (const ::xml_schema::UnsignedLong& _xsd_UnsignedLong_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (_xsd_UnsignedLong_base)
  {
  }

  Timestamp::
  Timestamp (const Timestamp& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  Timestamp::
  Timestamp (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  Timestamp::
  Timestamp (const ::xercesc::DOMAttr& a,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  Timestamp::
  Timestamp (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  Timestamp* Timestamp::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Timestamp (*this, f, c);
  }

  Timestamp::
  ~Timestamp ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Timestamp >
  _xsd_Timestamp_type_factory_init (
    "Timestamp",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // VersionCounter
  //

  VersionCounter::
  VersionCounter (const ::xml_schema::UnsignedLong& _xsd_UnsignedLong_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (_xsd_UnsignedLong_base)
  {
  }

  VersionCounter::
  VersionCounter (const VersionCounter& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  VersionCounter::
  VersionCounter (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  VersionCounter::
  VersionCounter (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  VersionCounter::
  VersionCounter (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  VersionCounter* VersionCounter::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VersionCounter (*this, f, c);
  }

  VersionCounter::
  ~VersionCounter ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, VersionCounter >
  _xsd_VersionCounter_type_factory_init (
    "VersionCounter",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // ReferencedVersion
  //

  ReferencedVersion::
  ReferencedVersion (const ::xml_schema::UnsignedLong& _xsd_UnsignedLong_base)
  : ::CDM::VersionCounter (_xsd_UnsignedLong_base)
  {
  }

  ReferencedVersion::
  ReferencedVersion (const ReferencedVersion& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::VersionCounter (x, f, c)
  {
  }

  ReferencedVersion::
  ReferencedVersion (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::VersionCounter (e, f, c)
  {
  }

  ReferencedVersion::
  ReferencedVersion (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::VersionCounter (a, f, c)
  {
  }

  ReferencedVersion::
  ReferencedVersion (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::VersionCounter (s, e, f, c)
  {
  }

  ReferencedVersion* ReferencedVersion::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReferencedVersion (*this, f, c);
  }

  ReferencedVersion::
  ~ReferencedVersion ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ReferencedVersion >
  _xsd_ReferencedVersion_type_factory_init (
    "ReferencedVersion",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // CodeIdentifier
  //

  CodeIdentifier::
  CodeIdentifier ()
  : ::xml_schema::String ()
  {
  }

  CodeIdentifier::
  CodeIdentifier (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  CodeIdentifier::
  CodeIdentifier (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  CodeIdentifier::
  CodeIdentifier (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  CodeIdentifier::
  CodeIdentifier (const CodeIdentifier& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  CodeIdentifier::
  CodeIdentifier (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  CodeIdentifier::
  CodeIdentifier (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  CodeIdentifier::
  CodeIdentifier (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  CodeIdentifier* CodeIdentifier::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CodeIdentifier (*this, f, c);
  }

  CodeIdentifier::
  ~CodeIdentifier ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CodeIdentifier >
  _xsd_CodeIdentifier_type_factory_init (
    "CodeIdentifier",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SymbolicCodeName
  //

  SymbolicCodeName::
  SymbolicCodeName ()
  : ::xml_schema::String ()
  {
  }

  SymbolicCodeName::
  SymbolicCodeName (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  SymbolicCodeName::
  SymbolicCodeName (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  SymbolicCodeName::
  SymbolicCodeName (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  SymbolicCodeName::
  SymbolicCodeName (const SymbolicCodeName& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  SymbolicCodeName::
  SymbolicCodeName (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  SymbolicCodeName::
  SymbolicCodeName (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  SymbolicCodeName::
  SymbolicCodeName (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  SymbolicCodeName* SymbolicCodeName::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SymbolicCodeName (*this, f, c);
  }

  SymbolicCodeName::
  ~SymbolicCodeName ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SymbolicCodeName >
  _xsd_SymbolicCodeName_type_factory_init (
    "SymbolicCodeName",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // LocalizedTextRef
  //

  LocalizedTextRef::
  LocalizedTextRef ()
  : ::xml_schema::String ()
  {
  }

  LocalizedTextRef::
  LocalizedTextRef (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  LocalizedTextRef::
  LocalizedTextRef (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  LocalizedTextRef::
  LocalizedTextRef (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  LocalizedTextRef::
  LocalizedTextRef (const LocalizedTextRef& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  LocalizedTextRef::
  LocalizedTextRef (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  LocalizedTextRef::
  LocalizedTextRef (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  LocalizedTextRef::
  LocalizedTextRef (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  LocalizedTextRef* LocalizedTextRef::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LocalizedTextRef (*this, f, c);
  }

  LocalizedTextRef::
  ~LocalizedTextRef ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LocalizedTextRef >
  _xsd_LocalizedTextRef_type_factory_init (
    "LocalizedTextRef",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // LocalizedTextContent
  //

  LocalizedTextContent::
  LocalizedTextContent ()
  : ::xml_schema::String ()
  {
  }

  LocalizedTextContent::
  LocalizedTextContent (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  LocalizedTextContent::
  LocalizedTextContent (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  LocalizedTextContent::
  LocalizedTextContent (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  LocalizedTextContent::
  LocalizedTextContent (const LocalizedTextContent& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  LocalizedTextContent::
  LocalizedTextContent (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  LocalizedTextContent::
  LocalizedTextContent (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  LocalizedTextContent::
  LocalizedTextContent (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  LocalizedTextContent* LocalizedTextContent::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LocalizedTextContent (*this, f, c);
  }

  LocalizedTextContent::
  ~LocalizedTextContent ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LocalizedTextContent >
  _xsd_LocalizedTextContent_type_factory_init (
    "LocalizedTextContent",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // LocalizedTextWidth
  //

  LocalizedTextWidth::
  LocalizedTextWidth (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_LocalizedTextWidth_convert ();
  }

  LocalizedTextWidth::
  LocalizedTextWidth (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_LocalizedTextWidth_convert ();
  }

  LocalizedTextWidth::
  LocalizedTextWidth (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_LocalizedTextWidth_convert ();
  }

  LocalizedTextWidth* LocalizedTextWidth::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LocalizedTextWidth (*this, f, c);
  }

  LocalizedTextWidth::Value LocalizedTextWidth::
  _xsd_LocalizedTextWidth_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_LocalizedTextWidth_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_LocalizedTextWidth_indexes_,
                      _xsd_LocalizedTextWidth_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_LocalizedTextWidth_indexes_ + 6 || _xsd_LocalizedTextWidth_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const LocalizedTextWidth::
  _xsd_LocalizedTextWidth_literals_[6] =
  {
    "xs",
    "s",
    "m",
    "l",
    "xl",
    "xxl"
  };

  const LocalizedTextWidth::Value LocalizedTextWidth::
  _xsd_LocalizedTextWidth_indexes_[6] =
  {
    ::CDM::LocalizedTextWidth::l,
    ::CDM::LocalizedTextWidth::m,
    ::CDM::LocalizedTextWidth::s,
    ::CDM::LocalizedTextWidth::xl,
    ::CDM::LocalizedTextWidth::xs,
    ::CDM::LocalizedTextWidth::xxl
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LocalizedTextWidth >
  _xsd_LocalizedTextWidth_type_factory_init (
    "LocalizedTextWidth",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // LocalizedText
  //

  LocalizedText::
  LocalizedText ()
  : ::CDM::LocalizedTextContent (),
    Ref_ (this),
    Lang_ (this),
    Version_ (this),
    TextWidth_ (this)
  {
  }

  LocalizedText::
  LocalizedText (const char* _xsd_String_base)
  : ::CDM::LocalizedTextContent (_xsd_String_base),
    Ref_ (this),
    Lang_ (this),
    Version_ (this),
    TextWidth_ (this)
  {
  }

  LocalizedText::
  LocalizedText (const ::std::string& _xsd_String_base)
  : ::CDM::LocalizedTextContent (_xsd_String_base),
    Ref_ (this),
    Lang_ (this),
    Version_ (this),
    TextWidth_ (this)
  {
  }

  LocalizedText::
  LocalizedText (const ::xml_schema::String& _xsd_String_base)
  : ::CDM::LocalizedTextContent (_xsd_String_base),
    Ref_ (this),
    Lang_ (this),
    Version_ (this),
    TextWidth_ (this)
  {
  }

  LocalizedText::
  LocalizedText (const LocalizedText& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::LocalizedTextContent (x, f, c),
    Ref_ (x.Ref_, f, this),
    Lang_ (x.Lang_, f, this),
    Version_ (x.Version_, f, this),
    TextWidth_ (x.TextWidth_, f, this)
  {
  }

  LocalizedText::
  LocalizedText (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::LocalizedTextContent (e, f | ::xml_schema::Flags::base, c),
    Ref_ (this),
    Lang_ (this),
    Version_ (this),
    TextWidth_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void LocalizedText::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Ref" && n.namespace_ ().empty ())
      {
        this->Ref_.set (RefTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Lang" && n.namespace_ ().empty ())
      {
        this->Lang_.set (LangTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Version" && n.namespace_ ().empty ())
      {
        this->Version_.set (VersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "TextWidth" && n.namespace_ ().empty ())
      {
        this->TextWidth_.set (TextWidthTraits::create (i, f, this));
        continue;
      }
    }
  }

  LocalizedText* LocalizedText::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LocalizedText (*this, f, c);
  }

  LocalizedText& LocalizedText::
  operator= (const LocalizedText& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::LocalizedTextContent& > (*this) = x;
      this->Ref_ = x.Ref_;
      this->Lang_ = x.Lang_;
      this->Version_ = x.Version_;
      this->TextWidth_ = x.TextWidth_;
    }

    return *this;
  }

  LocalizedText::
  ~LocalizedText ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LocalizedText >
  _xsd_LocalizedText_type_factory_init (
    "LocalizedText",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // CodedValue
  //

  CodedValue::
  CodedValue (const CodeType& Code)
  : ::xml_schema::Type (),
    Extension_ (this),
    CodingSystemName_ (this),
    ConceptDescription_ (this),
    Translation_ (this),
    Code_ (Code, this),
    CodingSystem_ (this),
    CodingSystemVersion_ (this),
    SymbolicCodeName_ (this)
  {
  }

  CodedValue::
  CodedValue (const CodedValue& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    CodingSystemName_ (x.CodingSystemName_, f, this),
    ConceptDescription_ (x.ConceptDescription_, f, this),
    Translation_ (x.Translation_, f, this),
    Code_ (x.Code_, f, this),
    CodingSystem_ (x.CodingSystem_, f, this),
    CodingSystemVersion_ (x.CodingSystemVersion_, f, this),
    SymbolicCodeName_ (x.SymbolicCodeName_, f, this)
  {
  }

  CodedValue::
  CodedValue (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    CodingSystemName_ (this),
    ConceptDescription_ (this),
    Translation_ (this),
    Code_ (this),
    CodingSystem_ (this),
    CodingSystemVersion_ (this),
    SymbolicCodeName_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void CodedValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // CodingSystemName
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CodingSystemName",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< CodingSystemNameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< CodingSystemNameType > r (
            dynamic_cast< CodingSystemNameType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->CodingSystemName_.push_back (::std::move (r));
          continue;
        }
      }

      // ConceptDescription
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ConceptDescription",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ConceptDescriptionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ConceptDescriptionType > r (
            dynamic_cast< ConceptDescriptionType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ConceptDescription_.push_back (::std::move (r));
          continue;
        }
      }

      // Translation
      //
      if (n.name () == "Translation" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< TranslationType > r (
          TranslationTraits::create (i, f, this));

        this->Translation_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Code" && n.namespace_ ().empty ())
      {
        this->Code_.set (CodeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "CodingSystem" && n.namespace_ ().empty ())
      {
        this->CodingSystem_.set (CodingSystemTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "CodingSystemVersion" && n.namespace_ ().empty ())
      {
        this->CodingSystemVersion_.set (CodingSystemVersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "SymbolicCodeName" && n.namespace_ ().empty ())
      {
        this->SymbolicCodeName_.set (SymbolicCodeNameTraits::create (i, f, this));
        continue;
      }
    }

    if (!Code_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Code",
        "");
    }
  }

  CodedValue* CodedValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CodedValue (*this, f, c);
  }

  CodedValue& CodedValue::
  operator= (const CodedValue& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->CodingSystemName_ = x.CodingSystemName_;
      this->ConceptDescription_ = x.ConceptDescription_;
      this->Translation_ = x.Translation_;
      this->Code_ = x.Code_;
      this->CodingSystem_ = x.CodingSystem_;
      this->CodingSystemVersion_ = x.CodingSystemVersion_;
      this->SymbolicCodeName_ = x.SymbolicCodeName_;
    }

    return *this;
  }

  CodedValue::
  ~CodedValue ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CodedValue >
  _xsd_CodedValue_type_factory_init (
    "CodedValue",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // InstanceIdentifier
  //

  InstanceIdentifier::
  InstanceIdentifier ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Type_ (this),
    IdentifierName_ (this),
    Root_ (this),
    Extension1_ (this)
  {
  }

  InstanceIdentifier::
  InstanceIdentifier (const InstanceIdentifier& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Type_ (x.Type_, f, this),
    IdentifierName_ (x.IdentifierName_, f, this),
    Root_ (x.Root_, f, this),
    Extension1_ (x.Extension1_, f, this)
  {
  }

  InstanceIdentifier::
  InstanceIdentifier (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Type_ (this),
    IdentifierName_ (this),
    Root_ (this),
    Extension1_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void InstanceIdentifier::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // Type
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Type",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< TypeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Type_)
          {
            ::std::unique_ptr< TypeType > r (
              dynamic_cast< TypeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Type_.set (::std::move (r));
            continue;
          }
        }
      }

      // IdentifierName
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "IdentifierName",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< IdentifierNameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< IdentifierNameType > r (
            dynamic_cast< IdentifierNameType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->IdentifierName_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Root" && n.namespace_ ().empty ())
      {
        this->Root_.set (RootTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Extension" && n.namespace_ ().empty ())
      {
        this->Extension1_.set (Extension1Traits::create (i, f, this));
        continue;
      }
    }
  }

  InstanceIdentifier* InstanceIdentifier::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InstanceIdentifier (*this, f, c);
  }

  InstanceIdentifier& InstanceIdentifier::
  operator= (const InstanceIdentifier& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Type_ = x.Type_;
      this->IdentifierName_ = x.IdentifierName_;
      this->Root_ = x.Root_;
      this->Extension1_ = x.Extension1_;
    }

    return *this;
  }

  InstanceIdentifier::
  ~InstanceIdentifier ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, InstanceIdentifier >
  _xsd_InstanceIdentifier_type_factory_init (
    "InstanceIdentifier",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // Range
  //

  Range::
  Range ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Lower_ (this),
    Upper_ (this),
    StepWidth_ (this),
    RelativeAccuracy_ (this),
    AbsoluteAccuracy_ (this)
  {
  }

  Range::
  Range (const Range& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Lower_ (x.Lower_, f, this),
    Upper_ (x.Upper_, f, this),
    StepWidth_ (x.StepWidth_, f, this),
    RelativeAccuracy_ (x.RelativeAccuracy_, f, this),
    AbsoluteAccuracy_ (x.AbsoluteAccuracy_, f, this)
  {
  }

  Range::
  Range (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Lower_ (this),
    Upper_ (this),
    StepWidth_ (this),
    RelativeAccuracy_ (this),
    AbsoluteAccuracy_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Range::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Lower" && n.namespace_ ().empty ())
      {
        this->Lower_.set (LowerTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Upper" && n.namespace_ ().empty ())
      {
        this->Upper_.set (UpperTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "StepWidth" && n.namespace_ ().empty ())
      {
        this->StepWidth_.set (StepWidthTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "RelativeAccuracy" && n.namespace_ ().empty ())
      {
        this->RelativeAccuracy_.set (RelativeAccuracyTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "AbsoluteAccuracy" && n.namespace_ ().empty ())
      {
        this->AbsoluteAccuracy_.set (AbsoluteAccuracyTraits::create (i, f, this));
        continue;
      }
    }
  }

  Range* Range::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Range (*this, f, c);
  }

  Range& Range::
  operator= (const Range& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Lower_ = x.Lower_;
      this->Upper_ = x.Upper_;
      this->StepWidth_ = x.StepWidth_;
      this->RelativeAccuracy_ = x.RelativeAccuracy_;
      this->AbsoluteAccuracy_ = x.AbsoluteAccuracy_;
    }

    return *this;
  }

  Range::
  ~Range ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Range >
  _xsd_Range_type_factory_init (
    "Range",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // Measurement
  //

  Measurement::
  Measurement (const MeasurementUnitType& MeasurementUnit,
               const MeasuredValueType& MeasuredValue)
  : ::xml_schema::Type (),
    Extension_ (this),
    MeasurementUnit_ (MeasurementUnit, this),
    MeasuredValue_ (MeasuredValue, this)
  {
  }

  Measurement::
  Measurement (::std::unique_ptr< MeasurementUnitType > MeasurementUnit,
               const MeasuredValueType& MeasuredValue)
  : ::xml_schema::Type (),
    Extension_ (this),
    MeasurementUnit_ (std::move (MeasurementUnit), this),
    MeasuredValue_ (MeasuredValue, this)
  {
  }

  Measurement::
  Measurement (const Measurement& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    MeasurementUnit_ (x.MeasurementUnit_, f, this),
    MeasuredValue_ (x.MeasuredValue_, f, this)
  {
  }

  Measurement::
  Measurement (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    MeasurementUnit_ (this),
    MeasuredValue_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Measurement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // MeasurementUnit
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MeasurementUnit",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< MeasurementUnitType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MeasurementUnit_.present ())
          {
            ::std::unique_ptr< MeasurementUnitType > r (
              dynamic_cast< MeasurementUnitType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MeasurementUnit_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!MeasurementUnit_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MeasurementUnit",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MeasuredValue" && n.namespace_ ().empty ())
      {
        this->MeasuredValue_.set (MeasuredValueTraits::create (i, f, this));
        continue;
      }
    }

    if (!MeasuredValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "MeasuredValue",
        "");
    }
  }

  Measurement* Measurement::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Measurement (*this, f, c);
  }

  Measurement& Measurement::
  operator= (const Measurement& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->MeasurementUnit_ = x.MeasurementUnit_;
      this->MeasuredValue_ = x.MeasuredValue_;
    }

    return *this;
  }

  Measurement::
  ~Measurement ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Measurement >
  _xsd_Measurement_type_factory_init (
    "Measurement",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SafetyClassification
  //

  SafetyClassification::
  SafetyClassification (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_SafetyClassification_convert ();
  }

  SafetyClassification::
  SafetyClassification (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_SafetyClassification_convert ();
  }

  SafetyClassification::
  SafetyClassification (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_SafetyClassification_convert ();
  }

  SafetyClassification* SafetyClassification::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SafetyClassification (*this, f, c);
  }

  SafetyClassification::Value SafetyClassification::
  _xsd_SafetyClassification_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_SafetyClassification_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_SafetyClassification_indexes_,
                      _xsd_SafetyClassification_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_SafetyClassification_indexes_ + 4 || _xsd_SafetyClassification_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const SafetyClassification::
  _xsd_SafetyClassification_literals_[4] =
  {
    "Inf",
    "MedA",
    "MedB",
    "MedC"
  };

  const SafetyClassification::Value SafetyClassification::
  _xsd_SafetyClassification_indexes_[4] =
  {
    ::CDM::SafetyClassification::Inf,
    ::CDM::SafetyClassification::MedA,
    ::CDM::SafetyClassification::MedB,
    ::CDM::SafetyClassification::MedC
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SafetyClassification >
  _xsd_SafetyClassification_type_factory_init (
    "SafetyClassification",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // ComponentActivation
  //

  ComponentActivation::
  ComponentActivation (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_ComponentActivation_convert ();
  }

  ComponentActivation::
  ComponentActivation (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_ComponentActivation_convert ();
  }

  ComponentActivation::
  ComponentActivation (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_ComponentActivation_convert ();
  }

  ComponentActivation* ComponentActivation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ComponentActivation (*this, f, c);
  }

  ComponentActivation::Value ComponentActivation::
  _xsd_ComponentActivation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ComponentActivation_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_ComponentActivation_indexes_,
                      _xsd_ComponentActivation_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_ComponentActivation_indexes_ + 6 || _xsd_ComponentActivation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ComponentActivation::
  _xsd_ComponentActivation_literals_[6] =
  {
    "On",
    "NotRdy",
    "StndBy",
    "Off",
    "Shtdn",
    "Fail"
  };

  const ComponentActivation::Value ComponentActivation::
  _xsd_ComponentActivation_indexes_[6] =
  {
    ::CDM::ComponentActivation::Fail,
    ::CDM::ComponentActivation::NotRdy,
    ::CDM::ComponentActivation::Off,
    ::CDM::ComponentActivation::On,
    ::CDM::ComponentActivation::Shtdn,
    ::CDM::ComponentActivation::StndBy
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ComponentActivation >
  _xsd_ComponentActivation_type_factory_init (
    "ComponentActivation",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // ApprovedJurisdictions
  //

  ApprovedJurisdictions::
  ApprovedJurisdictions ()
  : ::xml_schema::Type (),
    ApprovedJurisdiction_ (this)
  {
  }

  ApprovedJurisdictions::
  ApprovedJurisdictions (const ApprovedJurisdictions& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ApprovedJurisdiction_ (x.ApprovedJurisdiction_, f, this)
  {
  }

  ApprovedJurisdictions::
  ApprovedJurisdictions (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ApprovedJurisdiction_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ApprovedJurisdictions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ApprovedJurisdiction
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ApprovedJurisdiction",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ApprovedJurisdictionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ApprovedJurisdictionType > r (
            dynamic_cast< ApprovedJurisdictionType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ApprovedJurisdiction_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ApprovedJurisdictions* ApprovedJurisdictions::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ApprovedJurisdictions (*this, f, c);
  }

  ApprovedJurisdictions& ApprovedJurisdictions::
  operator= (const ApprovedJurisdictions& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->ApprovedJurisdiction_ = x.ApprovedJurisdiction_;
    }

    return *this;
  }

  ApprovedJurisdictions::
  ~ApprovedJurisdictions ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ApprovedJurisdictions >
  _xsd_ApprovedJurisdictions_type_factory_init (
    "ApprovedJurisdictions",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // OperatingJurisdiction
  //

  OperatingJurisdiction::
  OperatingJurisdiction ()
  : ::CDM::InstanceIdentifier ()
  {
  }

  OperatingJurisdiction::
  OperatingJurisdiction (const OperatingJurisdiction& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::InstanceIdentifier (x, f, c)
  {
  }

  OperatingJurisdiction::
  OperatingJurisdiction (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::InstanceIdentifier (e, f, c)
  {
  }

  OperatingJurisdiction* OperatingJurisdiction::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OperatingJurisdiction (*this, f, c);
  }

  OperatingJurisdiction::
  ~OperatingJurisdiction ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OperatingJurisdiction >
  _xsd_OperatingJurisdiction_type_factory_init (
    "OperatingJurisdiction",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // Handle
  //

  Handle::
  Handle ()
  : ::xml_schema::String ()
  {
  }

  Handle::
  Handle (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  Handle::
  Handle (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  Handle::
  Handle (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  Handle::
  Handle (const Handle& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  Handle::
  Handle (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  Handle::
  Handle (const ::xercesc::DOMAttr& a,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  Handle::
  Handle (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  Handle* Handle::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Handle (*this, f, c);
  }

  Handle::
  ~Handle ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Handle >
  _xsd_Handle_type_factory_init (
    "Handle",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // HandleRef
  //

  HandleRef::
  HandleRef ()
  : ::xml_schema::String ()
  {
  }

  HandleRef::
  HandleRef (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  HandleRef::
  HandleRef (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  HandleRef::
  HandleRef (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  HandleRef::
  HandleRef (const HandleRef& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  HandleRef::
  HandleRef (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  HandleRef::
  HandleRef (const ::xercesc::DOMAttr& a,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  HandleRef::
  HandleRef (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  HandleRef* HandleRef::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HandleRef (*this, f, c);
  }

  HandleRef::
  ~HandleRef ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, HandleRef >
  _xsd_HandleRef_type_factory_init (
    "HandleRef",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // PhysicalConnectorInfo
  //

  PhysicalConnectorInfo::
  PhysicalConnectorInfo ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Label_ (this),
    Number_ (this)
  {
  }

  PhysicalConnectorInfo::
  PhysicalConnectorInfo (const PhysicalConnectorInfo& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Label_ (x.Label_, f, this),
    Number_ (x.Number_, f, this)
  {
  }

  PhysicalConnectorInfo::
  PhysicalConnectorInfo (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Label_ (this),
    Number_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void PhysicalConnectorInfo::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // Label
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Label",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< LabelType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< LabelType > r (
            dynamic_cast< LabelType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Label_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Number" && n.namespace_ ().empty ())
      {
        this->Number_.set (NumberTraits::create (i, f, this));
        continue;
      }
    }
  }

  PhysicalConnectorInfo* PhysicalConnectorInfo::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PhysicalConnectorInfo (*this, f, c);
  }

  PhysicalConnectorInfo& PhysicalConnectorInfo::
  operator= (const PhysicalConnectorInfo& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Label_ = x.Label_;
      this->Number_ = x.Number_;
    }

    return *this;
  }

  PhysicalConnectorInfo::
  ~PhysicalConnectorInfo ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, PhysicalConnectorInfo >
  _xsd_PhysicalConnectorInfo_type_factory_init (
    "PhysicalConnectorInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AbstractDescriptor
  //

  AbstractDescriptor::
  AbstractDescriptor (const HandleType& Handle)
  : ::xml_schema::Type (),
    Extension_ (this),
    Type_ (this),
    Handle_ (Handle, this),
    DescriptorVersion_ (this),
    SafetyClassification_ (this)
  {
  }

  AbstractDescriptor::
  AbstractDescriptor (const AbstractDescriptor& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Type_ (x.Type_, f, this),
    Handle_ (x.Handle_, f, this),
    DescriptorVersion_ (x.DescriptorVersion_, f, this),
    SafetyClassification_ (x.SafetyClassification_, f, this)
  {
  }

  AbstractDescriptor::
  AbstractDescriptor (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Type_ (this),
    Handle_ (this),
    DescriptorVersion_ (this),
    SafetyClassification_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // Type
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Type",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< TypeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Type_)
          {
            ::std::unique_ptr< TypeType > r (
              dynamic_cast< TypeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Type_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Handle" && n.namespace_ ().empty ())
      {
        this->Handle_.set (HandleTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "DescriptorVersion" && n.namespace_ ().empty ())
      {
        this->DescriptorVersion_.set (DescriptorVersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "SafetyClassification" && n.namespace_ ().empty ())
      {
        this->SafetyClassification_.set (SafetyClassificationTraits::create (i, f, this));
        continue;
      }
    }

    if (!Handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Handle",
        "");
    }
  }

  AbstractDescriptor* AbstractDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractDescriptor (*this, f, c);
  }

  AbstractDescriptor& AbstractDescriptor::
  operator= (const AbstractDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Type_ = x.Type_;
      this->Handle_ = x.Handle_;
      this->DescriptorVersion_ = x.DescriptorVersion_;
      this->SafetyClassification_ = x.SafetyClassification_;
    }

    return *this;
  }

  AbstractDescriptor::
  ~AbstractDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractDescriptor >
  _xsd_AbstractDescriptor_type_factory_init (
    "AbstractDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AbstractState
  //

  AbstractState::
  AbstractState (const DescriptorHandleType& DescriptorHandle)
  : ::xml_schema::Type (),
    Extension_ (this),
    StateVersion_ (this),
    DescriptorHandle_ (DescriptorHandle, this),
    DescriptorVersion_ (this)
  {
  }

  AbstractState::
  AbstractState (const AbstractState& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    StateVersion_ (x.StateVersion_, f, this),
    DescriptorHandle_ (x.DescriptorHandle_, f, this),
    DescriptorVersion_ (x.DescriptorVersion_, f, this)
  {
  }

  AbstractState::
  AbstractState (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    StateVersion_ (this),
    DescriptorHandle_ (this),
    DescriptorVersion_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "StateVersion" && n.namespace_ ().empty ())
      {
        this->StateVersion_.set (StateVersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "DescriptorHandle" && n.namespace_ ().empty ())
      {
        this->DescriptorHandle_.set (DescriptorHandleTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "DescriptorVersion" && n.namespace_ ().empty ())
      {
        this->DescriptorVersion_.set (DescriptorVersionTraits::create (i, f, this));
        continue;
      }
    }

    if (!DescriptorHandle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "DescriptorHandle",
        "");
    }
  }

  AbstractState* AbstractState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractState (*this, f, c);
  }

  AbstractState& AbstractState::
  operator= (const AbstractState& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->StateVersion_ = x.StateVersion_;
      this->DescriptorHandle_ = x.DescriptorHandle_;
      this->DescriptorVersion_ = x.DescriptorVersion_;
    }

    return *this;
  }

  AbstractState::
  ~AbstractState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractState >
  _xsd_AbstractState_type_factory_init (
    "AbstractState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AbstractMultiState
  //

  AbstractMultiState::
  AbstractMultiState (const DescriptorHandleType& DescriptorHandle,
                      const HandleType& Handle)
  : ::CDM::AbstractState (DescriptorHandle),
    Category_ (this),
    Handle_ (Handle, this)
  {
  }

  AbstractMultiState::
  AbstractMultiState (const AbstractMultiState& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractState (x, f, c),
    Category_ (x.Category_, f, this),
    Handle_ (x.Handle_, f, this)
  {
  }

  AbstractMultiState::
  AbstractMultiState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractState (e, f | ::xml_schema::Flags::base, c),
    Category_ (this),
    Handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractMultiState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Category
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Category",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< CategoryType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Category_)
          {
            ::std::unique_ptr< CategoryType > r (
              dynamic_cast< CategoryType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Category_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Handle" && n.namespace_ ().empty ())
      {
        this->Handle_.set (HandleTraits::create (i, f, this));
        continue;
      }
    }

    if (!Handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Handle",
        "");
    }
  }

  AbstractMultiState* AbstractMultiState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractMultiState (*this, f, c);
  }

  AbstractMultiState& AbstractMultiState::
  operator= (const AbstractMultiState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractState& > (*this) = x;
      this->Category_ = x.Category_;
      this->Handle_ = x.Handle_;
    }

    return *this;
  }

  AbstractMultiState::
  ~AbstractMultiState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractMultiState >
  _xsd_AbstractMultiState_type_factory_init (
    "AbstractMultiState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AbstractDeviceComponentDescriptor
  //

  AbstractDeviceComponentDescriptor::
  AbstractDeviceComponentDescriptor (const HandleType& Handle)
  : ::CDM::AbstractDescriptor (Handle),
    ProductionSpecification_ (this)
  {
  }

  AbstractDeviceComponentDescriptor::
  AbstractDeviceComponentDescriptor (const AbstractDeviceComponentDescriptor& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (x, f, c),
    ProductionSpecification_ (x.ProductionSpecification_, f, this)
  {
  }

  AbstractDeviceComponentDescriptor::
  AbstractDeviceComponentDescriptor (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (e, f | ::xml_schema::Flags::base, c),
    ProductionSpecification_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractDeviceComponentDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ProductionSpecification
      //
      if (n.name () == "ProductionSpecification" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< ProductionSpecificationType > r (
          ProductionSpecificationTraits::create (i, f, this));

        this->ProductionSpecification_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AbstractDeviceComponentDescriptor* AbstractDeviceComponentDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractDeviceComponentDescriptor (*this, f, c);
  }

  AbstractDeviceComponentDescriptor& AbstractDeviceComponentDescriptor::
  operator= (const AbstractDeviceComponentDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDescriptor& > (*this) = x;
      this->ProductionSpecification_ = x.ProductionSpecification_;
    }

    return *this;
  }

  AbstractDeviceComponentDescriptor::
  ~AbstractDeviceComponentDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractDeviceComponentDescriptor >
  _xsd_AbstractDeviceComponentDescriptor_type_factory_init (
    "AbstractDeviceComponentDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AbstractComplexDeviceComponentDescriptor
  //

  AbstractComplexDeviceComponentDescriptor::
  AbstractComplexDeviceComponentDescriptor (const HandleType& Handle)
  : ::CDM::AbstractDeviceComponentDescriptor (Handle),
    AlertSystem_ (this),
    Sco_ (this)
  {
  }

  AbstractComplexDeviceComponentDescriptor::
  AbstractComplexDeviceComponentDescriptor (const AbstractComplexDeviceComponentDescriptor& x,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentDescriptor (x, f, c),
    AlertSystem_ (x.AlertSystem_, f, this),
    Sco_ (x.Sco_, f, this)
  {
  }

  AbstractComplexDeviceComponentDescriptor::
  AbstractComplexDeviceComponentDescriptor (const ::xercesc::DOMElement& e,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentDescriptor (e, f | ::xml_schema::Flags::base, c),
    AlertSystem_ (this),
    Sco_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractComplexDeviceComponentDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDeviceComponentDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AlertSystem
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AlertSystem",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< AlertSystemType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AlertSystem_)
          {
            ::std::unique_ptr< AlertSystemType > r (
              dynamic_cast< AlertSystemType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AlertSystem_.set (::std::move (r));
            continue;
          }
        }
      }

      // Sco
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Sco",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ScoType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Sco_)
          {
            ::std::unique_ptr< ScoType > r (
              dynamic_cast< ScoType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Sco_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  AbstractComplexDeviceComponentDescriptor* AbstractComplexDeviceComponentDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractComplexDeviceComponentDescriptor (*this, f, c);
  }

  AbstractComplexDeviceComponentDescriptor& AbstractComplexDeviceComponentDescriptor::
  operator= (const AbstractComplexDeviceComponentDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDeviceComponentDescriptor& > (*this) = x;
      this->AlertSystem_ = x.AlertSystem_;
      this->Sco_ = x.Sco_;
    }

    return *this;
  }

  AbstractComplexDeviceComponentDescriptor::
  ~AbstractComplexDeviceComponentDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractComplexDeviceComponentDescriptor >
  _xsd_AbstractComplexDeviceComponentDescriptor_type_factory_init (
    "AbstractComplexDeviceComponentDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // CalibrationState
  //

  CalibrationState::
  CalibrationState (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_CalibrationState_convert ();
  }

  CalibrationState::
  CalibrationState (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_CalibrationState_convert ();
  }

  CalibrationState::
  CalibrationState (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_CalibrationState_convert ();
  }

  CalibrationState* CalibrationState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CalibrationState (*this, f, c);
  }

  CalibrationState::Value CalibrationState::
  _xsd_CalibrationState_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CalibrationState_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_CalibrationState_indexes_,
                      _xsd_CalibrationState_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_CalibrationState_indexes_ + 5 || _xsd_CalibrationState_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const CalibrationState::
  _xsd_CalibrationState_literals_[5] =
  {
    "No",
    "Req",
    "Run",
    "Cal",
    "Oth"
  };

  const CalibrationState::Value CalibrationState::
  _xsd_CalibrationState_indexes_[5] =
  {
    ::CDM::CalibrationState::Cal,
    ::CDM::CalibrationState::No,
    ::CDM::CalibrationState::Oth,
    ::CDM::CalibrationState::Req,
    ::CDM::CalibrationState::Run
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CalibrationState >
  _xsd_CalibrationState_type_factory_init (
    "CalibrationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // CalibrationType
  //

  CalibrationType::
  CalibrationType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_CalibrationType_convert ();
  }

  CalibrationType::
  CalibrationType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_CalibrationType_convert ();
  }

  CalibrationType::
  CalibrationType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_CalibrationType_convert ();
  }

  CalibrationType* CalibrationType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CalibrationType (*this, f, c);
  }

  CalibrationType::Value CalibrationType::
  _xsd_CalibrationType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CalibrationType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_CalibrationType_indexes_,
                      _xsd_CalibrationType_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_CalibrationType_indexes_ + 4 || _xsd_CalibrationType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const CalibrationType::
  _xsd_CalibrationType_literals_[4] =
  {
    "Offset",
    "Gain",
    "TP",
    "Unspec"
  };

  const CalibrationType::Value CalibrationType::
  _xsd_CalibrationType_indexes_[4] =
  {
    ::CDM::CalibrationType::Gain,
    ::CDM::CalibrationType::Offset,
    ::CDM::CalibrationType::TP,
    ::CDM::CalibrationType::Unspec
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CalibrationType >
  _xsd_CalibrationType_type_factory_init (
    "CalibrationType",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // CalibrationInfo
  //

  CalibrationInfo::
  CalibrationInfo ()
  : ::xml_schema::Type (),
    Extension_ (this),
    CalibrationDocumentation_ (this),
    ComponentCalibrationState_ (this),
    Type_ (this),
    Time_ (this)
  {
  }

  CalibrationInfo::
  CalibrationInfo (const CalibrationInfo& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    CalibrationDocumentation_ (x.CalibrationDocumentation_, f, this),
    ComponentCalibrationState_ (x.ComponentCalibrationState_, f, this),
    Type_ (x.Type_, f, this),
    Time_ (x.Time_, f, this)
  {
  }

  CalibrationInfo::
  CalibrationInfo (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    CalibrationDocumentation_ (this),
    ComponentCalibrationState_ (this),
    Type_ (this),
    Time_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void CalibrationInfo::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // CalibrationDocumentation
      //
      if (n.name () == "CalibrationDocumentation" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< CalibrationDocumentationType > r (
          CalibrationDocumentationTraits::create (i, f, this));

        this->CalibrationDocumentation_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ComponentCalibrationState" && n.namespace_ ().empty ())
      {
        this->ComponentCalibrationState_.set (ComponentCalibrationStateTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Type" && n.namespace_ ().empty ())
      {
        this->Type_.set (TypeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Time" && n.namespace_ ().empty ())
      {
        this->Time_.set (TimeTraits::create (i, f, this));
        continue;
      }
    }
  }

  CalibrationInfo* CalibrationInfo::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CalibrationInfo (*this, f, c);
  }

  CalibrationInfo& CalibrationInfo::
  operator= (const CalibrationInfo& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->CalibrationDocumentation_ = x.CalibrationDocumentation_;
      this->ComponentCalibrationState_ = x.ComponentCalibrationState_;
      this->Type_ = x.Type_;
      this->Time_ = x.Time_;
    }

    return *this;
  }

  CalibrationInfo::
  ~CalibrationInfo ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CalibrationInfo >
  _xsd_CalibrationInfo_type_factory_init (
    "CalibrationInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AbstractDeviceComponentState
  //

  AbstractDeviceComponentState::
  AbstractDeviceComponentState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractState (DescriptorHandle),
    CalibrationInfo_ (this),
    NextCalibration_ (this),
    PhysicalConnector_ (this),
    ActivationState_ (this),
    OperatingHours_ (this),
    OperatingCycles_ (this)
  {
  }

  AbstractDeviceComponentState::
  AbstractDeviceComponentState (const AbstractDeviceComponentState& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::CDM::AbstractState (x, f, c),
    CalibrationInfo_ (x.CalibrationInfo_, f, this),
    NextCalibration_ (x.NextCalibration_, f, this),
    PhysicalConnector_ (x.PhysicalConnector_, f, this),
    ActivationState_ (x.ActivationState_, f, this),
    OperatingHours_ (x.OperatingHours_, f, this),
    OperatingCycles_ (x.OperatingCycles_, f, this)
  {
  }

  AbstractDeviceComponentState::
  AbstractDeviceComponentState (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::CDM::AbstractState (e, f | ::xml_schema::Flags::base, c),
    CalibrationInfo_ (this),
    NextCalibration_ (this),
    PhysicalConnector_ (this),
    ActivationState_ (this),
    OperatingHours_ (this),
    OperatingCycles_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractDeviceComponentState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CalibrationInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CalibrationInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< CalibrationInfoType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CalibrationInfo_)
          {
            ::std::unique_ptr< CalibrationInfoType > r (
              dynamic_cast< CalibrationInfoType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CalibrationInfo_.set (::std::move (r));
            continue;
          }
        }
      }

      // NextCalibration
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "NextCalibration",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< NextCalibrationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->NextCalibration_)
          {
            ::std::unique_ptr< NextCalibrationType > r (
              dynamic_cast< NextCalibrationType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->NextCalibration_.set (::std::move (r));
            continue;
          }
        }
      }

      // PhysicalConnector
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "PhysicalConnector",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< PhysicalConnectorType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->PhysicalConnector_)
          {
            ::std::unique_ptr< PhysicalConnectorType > r (
              dynamic_cast< PhysicalConnectorType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->PhysicalConnector_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ActivationState" && n.namespace_ ().empty ())
      {
        this->ActivationState_.set (ActivationStateTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "OperatingHours" && n.namespace_ ().empty ())
      {
        this->OperatingHours_.set (OperatingHoursTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "OperatingCycles" && n.namespace_ ().empty ())
      {
        this->OperatingCycles_.set (OperatingCyclesTraits::create (i, f, this));
        continue;
      }
    }
  }

  AbstractDeviceComponentState* AbstractDeviceComponentState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractDeviceComponentState (*this, f, c);
  }

  AbstractDeviceComponentState& AbstractDeviceComponentState::
  operator= (const AbstractDeviceComponentState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractState& > (*this) = x;
      this->CalibrationInfo_ = x.CalibrationInfo_;
      this->NextCalibration_ = x.NextCalibration_;
      this->PhysicalConnector_ = x.PhysicalConnector_;
      this->ActivationState_ = x.ActivationState_;
      this->OperatingHours_ = x.OperatingHours_;
      this->OperatingCycles_ = x.OperatingCycles_;
    }

    return *this;
  }

  AbstractDeviceComponentState::
  ~AbstractDeviceComponentState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractDeviceComponentState >
  _xsd_AbstractDeviceComponentState_type_factory_init (
    "AbstractDeviceComponentState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AbstractComplexDeviceComponentState
  //

  AbstractComplexDeviceComponentState::
  AbstractComplexDeviceComponentState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractDeviceComponentState (DescriptorHandle)
  {
  }

  AbstractComplexDeviceComponentState::
  AbstractComplexDeviceComponentState (const AbstractComplexDeviceComponentState& x,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentState (x, f, c)
  {
  }

  AbstractComplexDeviceComponentState::
  AbstractComplexDeviceComponentState (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentState (e, f, c)
  {
  }

  AbstractComplexDeviceComponentState* AbstractComplexDeviceComponentState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractComplexDeviceComponentState (*this, f, c);
  }

  AbstractComplexDeviceComponentState::
  ~AbstractComplexDeviceComponentState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractComplexDeviceComponentState >
  _xsd_AbstractComplexDeviceComponentState_type_factory_init (
    "AbstractComplexDeviceComponentState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // MdsDescriptor
  //

  MdsDescriptor::
  MdsDescriptor (const HandleType& Handle)
  : ::CDM::AbstractComplexDeviceComponentDescriptor (Handle),
    MetaData_ (this),
    SystemContext_ (this),
    Clock_ (this),
    Battery_ (this),
    ApprovedJurisdictions_ (this),
    Vmd_ (this)
  {
  }

  MdsDescriptor::
  MdsDescriptor (const MdsDescriptor& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AbstractComplexDeviceComponentDescriptor (x, f, c),
    MetaData_ (x.MetaData_, f, this),
    SystemContext_ (x.SystemContext_, f, this),
    Clock_ (x.Clock_, f, this),
    Battery_ (x.Battery_, f, this),
    ApprovedJurisdictions_ (x.ApprovedJurisdictions_, f, this),
    Vmd_ (x.Vmd_, f, this)
  {
  }

  MdsDescriptor::
  MdsDescriptor (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AbstractComplexDeviceComponentDescriptor (e, f | ::xml_schema::Flags::base, c),
    MetaData_ (this),
    SystemContext_ (this),
    Clock_ (this),
    Battery_ (this),
    ApprovedJurisdictions_ (this),
    Vmd_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MdsDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractComplexDeviceComponentDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MetaData
      //
      if (n.name () == "MetaData" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< MetaDataType > r (
          MetaDataTraits::create (i, f, this));

        if (!this->MetaData_)
        {
          this->MetaData_.set (::std::move (r));
          continue;
        }
      }

      // SystemContext
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SystemContext",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< SystemContextType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->SystemContext_)
          {
            ::std::unique_ptr< SystemContextType > r (
              dynamic_cast< SystemContextType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SystemContext_.set (::std::move (r));
            continue;
          }
        }
      }

      // Clock
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Clock",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ClockType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Clock_)
          {
            ::std::unique_ptr< ClockType > r (
              dynamic_cast< ClockType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Clock_.set (::std::move (r));
            continue;
          }
        }
      }

      // Battery
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Battery",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< BatteryType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< BatteryType > r (
            dynamic_cast< BatteryType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Battery_.push_back (::std::move (r));
          continue;
        }
      }

      // ApprovedJurisdictions
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ApprovedJurisdictions",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ApprovedJurisdictionsType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ApprovedJurisdictions_)
          {
            ::std::unique_ptr< ApprovedJurisdictionsType > r (
              dynamic_cast< ApprovedJurisdictionsType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ApprovedJurisdictions_.set (::std::move (r));
            continue;
          }
        }
      }

      // Vmd
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Vmd",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< VmdType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< VmdType > r (
            dynamic_cast< VmdType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Vmd_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  MdsDescriptor* MdsDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MdsDescriptor (*this, f, c);
  }

  MdsDescriptor& MdsDescriptor::
  operator= (const MdsDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractComplexDeviceComponentDescriptor& > (*this) = x;
      this->MetaData_ = x.MetaData_;
      this->SystemContext_ = x.SystemContext_;
      this->Clock_ = x.Clock_;
      this->Battery_ = x.Battery_;
      this->ApprovedJurisdictions_ = x.ApprovedJurisdictions_;
      this->Vmd_ = x.Vmd_;
    }

    return *this;
  }

  MdsDescriptor::
  ~MdsDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MdsDescriptor >
  _xsd_MdsDescriptor_type_factory_init (
    "MdsDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // MdsOperatingMode
  //

  MdsOperatingMode::
  MdsOperatingMode (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_MdsOperatingMode_convert ();
  }

  MdsOperatingMode::
  MdsOperatingMode (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_MdsOperatingMode_convert ();
  }

  MdsOperatingMode::
  MdsOperatingMode (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_MdsOperatingMode_convert ();
  }

  MdsOperatingMode* MdsOperatingMode::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MdsOperatingMode (*this, f, c);
  }

  MdsOperatingMode::Value MdsOperatingMode::
  _xsd_MdsOperatingMode_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MdsOperatingMode_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_MdsOperatingMode_indexes_,
                      _xsd_MdsOperatingMode_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_MdsOperatingMode_indexes_ + 4 || _xsd_MdsOperatingMode_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const MdsOperatingMode::
  _xsd_MdsOperatingMode_literals_[4] =
  {
    "Nml",
    "Dmo",
    "Srv",
    "Mtn"
  };

  const MdsOperatingMode::Value MdsOperatingMode::
  _xsd_MdsOperatingMode_indexes_[4] =
  {
    ::CDM::MdsOperatingMode::Dmo,
    ::CDM::MdsOperatingMode::Mtn,
    ::CDM::MdsOperatingMode::Nml,
    ::CDM::MdsOperatingMode::Srv
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MdsOperatingMode >
  _xsd_MdsOperatingMode_type_factory_init (
    "MdsOperatingMode",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // MdsState
  //

  MdsState::
  MdsState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractComplexDeviceComponentState (DescriptorHandle),
    OperatingJurisdiction_ (this),
    Lang_ (this),
    OperatingMode_ (this)
  {
  }

  MdsState::
  MdsState (const MdsState& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::CDM::AbstractComplexDeviceComponentState (x, f, c),
    OperatingJurisdiction_ (x.OperatingJurisdiction_, f, this),
    Lang_ (x.Lang_, f, this),
    OperatingMode_ (x.OperatingMode_, f, this)
  {
  }

  MdsState::
  MdsState (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::CDM::AbstractComplexDeviceComponentState (e, f | ::xml_schema::Flags::base, c),
    OperatingJurisdiction_ (this),
    Lang_ (this),
    OperatingMode_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MdsState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractComplexDeviceComponentState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OperatingJurisdiction
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OperatingJurisdiction",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< OperatingJurisdictionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->OperatingJurisdiction_)
          {
            ::std::unique_ptr< OperatingJurisdictionType > r (
              dynamic_cast< OperatingJurisdictionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OperatingJurisdiction_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Lang" && n.namespace_ ().empty ())
      {
        this->Lang_.set (LangTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "OperatingMode" && n.namespace_ ().empty ())
      {
        this->OperatingMode_.set (OperatingModeTraits::create (i, f, this));
        continue;
      }
    }
  }

  MdsState* MdsState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MdsState (*this, f, c);
  }

  MdsState& MdsState::
  operator= (const MdsState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractComplexDeviceComponentState& > (*this) = x;
      this->OperatingJurisdiction_ = x.OperatingJurisdiction_;
      this->Lang_ = x.Lang_;
      this->OperatingMode_ = x.OperatingMode_;
    }

    return *this;
  }

  MdsState::
  ~MdsState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MdsState >
  _xsd_MdsState_type_factory_init (
    "MdsState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // VmdDescriptor
  //

  VmdDescriptor::
  VmdDescriptor (const HandleType& Handle)
  : ::CDM::AbstractComplexDeviceComponentDescriptor (Handle),
    ApprovedJurisdictions_ (this),
    Channel_ (this)
  {
  }

  VmdDescriptor::
  VmdDescriptor (const VmdDescriptor& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AbstractComplexDeviceComponentDescriptor (x, f, c),
    ApprovedJurisdictions_ (x.ApprovedJurisdictions_, f, this),
    Channel_ (x.Channel_, f, this)
  {
  }

  VmdDescriptor::
  VmdDescriptor (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AbstractComplexDeviceComponentDescriptor (e, f | ::xml_schema::Flags::base, c),
    ApprovedJurisdictions_ (this),
    Channel_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void VmdDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractComplexDeviceComponentDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ApprovedJurisdictions
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ApprovedJurisdictions",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ApprovedJurisdictionsType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ApprovedJurisdictions_)
          {
            ::std::unique_ptr< ApprovedJurisdictionsType > r (
              dynamic_cast< ApprovedJurisdictionsType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ApprovedJurisdictions_.set (::std::move (r));
            continue;
          }
        }
      }

      // Channel
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Channel",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ChannelType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ChannelType > r (
            dynamic_cast< ChannelType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Channel_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  VmdDescriptor* VmdDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VmdDescriptor (*this, f, c);
  }

  VmdDescriptor& VmdDescriptor::
  operator= (const VmdDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractComplexDeviceComponentDescriptor& > (*this) = x;
      this->ApprovedJurisdictions_ = x.ApprovedJurisdictions_;
      this->Channel_ = x.Channel_;
    }

    return *this;
  }

  VmdDescriptor::
  ~VmdDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, VmdDescriptor >
  _xsd_VmdDescriptor_type_factory_init (
    "VmdDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // VmdState
  //

  VmdState::
  VmdState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractComplexDeviceComponentState (DescriptorHandle),
    OperatingJurisdiction_ (this)
  {
  }

  VmdState::
  VmdState (const VmdState& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::CDM::AbstractComplexDeviceComponentState (x, f, c),
    OperatingJurisdiction_ (x.OperatingJurisdiction_, f, this)
  {
  }

  VmdState::
  VmdState (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::CDM::AbstractComplexDeviceComponentState (e, f | ::xml_schema::Flags::base, c),
    OperatingJurisdiction_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void VmdState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractComplexDeviceComponentState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OperatingJurisdiction
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OperatingJurisdiction",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< OperatingJurisdictionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->OperatingJurisdiction_)
          {
            ::std::unique_ptr< OperatingJurisdictionType > r (
              dynamic_cast< OperatingJurisdictionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OperatingJurisdiction_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  VmdState* VmdState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VmdState (*this, f, c);
  }

  VmdState& VmdState::
  operator= (const VmdState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractComplexDeviceComponentState& > (*this) = x;
      this->OperatingJurisdiction_ = x.OperatingJurisdiction_;
    }

    return *this;
  }

  VmdState::
  ~VmdState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, VmdState >
  _xsd_VmdState_type_factory_init (
    "VmdState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // ChannelDescriptor
  //

  ChannelDescriptor::
  ChannelDescriptor (const HandleType& Handle)
  : ::CDM::AbstractDeviceComponentDescriptor (Handle),
    Metric_ (this)
  {
  }

  ChannelDescriptor::
  ChannelDescriptor (const ChannelDescriptor& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentDescriptor (x, f, c),
    Metric_ (x.Metric_, f, this)
  {
  }

  ChannelDescriptor::
  ChannelDescriptor (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentDescriptor (e, f | ::xml_schema::Flags::base, c),
    Metric_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ChannelDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDeviceComponentDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Metric
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Metric",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< MetricType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< MetricType > r (
            dynamic_cast< MetricType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Metric_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ChannelDescriptor* ChannelDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ChannelDescriptor (*this, f, c);
  }

  ChannelDescriptor& ChannelDescriptor::
  operator= (const ChannelDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDeviceComponentDescriptor& > (*this) = x;
      this->Metric_ = x.Metric_;
    }

    return *this;
  }

  ChannelDescriptor::
  ~ChannelDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ChannelDescriptor >
  _xsd_ChannelDescriptor_type_factory_init (
    "ChannelDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // ChannelState
  //

  ChannelState::
  ChannelState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractDeviceComponentState (DescriptorHandle)
  {
  }

  ChannelState::
  ChannelState (const ChannelState& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentState (x, f, c)
  {
  }

  ChannelState::
  ChannelState (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentState (e, f, c)
  {
  }

  ChannelState* ChannelState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ChannelState (*this, f, c);
  }

  ChannelState::
  ~ChannelState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ChannelState >
  _xsd_ChannelState_type_factory_init (
    "ChannelState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AbstractAlertDescriptor
  //

  AbstractAlertDescriptor::
  AbstractAlertDescriptor (const HandleType& Handle)
  : ::CDM::AbstractDescriptor (Handle)
  {
  }

  AbstractAlertDescriptor::
  AbstractAlertDescriptor (const AbstractAlertDescriptor& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (x, f, c)
  {
  }

  AbstractAlertDescriptor::
  AbstractAlertDescriptor (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (e, f, c)
  {
  }

  AbstractAlertDescriptor* AbstractAlertDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractAlertDescriptor (*this, f, c);
  }

  AbstractAlertDescriptor::
  ~AbstractAlertDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractAlertDescriptor >
  _xsd_AbstractAlertDescriptor_type_factory_init (
    "AbstractAlertDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AbstractAlertState
  //

  AbstractAlertState::
  AbstractAlertState (const DescriptorHandleType& DescriptorHandle,
                      const ActivationStateType& ActivationState)
  : ::CDM::AbstractState (DescriptorHandle),
    ActivationState_ (ActivationState, this)
  {
  }

  AbstractAlertState::
  AbstractAlertState (const AbstractAlertState& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractState (x, f, c),
    ActivationState_ (x.ActivationState_, f, this)
  {
  }

  AbstractAlertState::
  AbstractAlertState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractState (e, f | ::xml_schema::Flags::base, c),
    ActivationState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractAlertState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractState::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ActivationState" && n.namespace_ ().empty ())
      {
        this->ActivationState_.set (ActivationStateTraits::create (i, f, this));
        continue;
      }
    }

    if (!ActivationState_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ActivationState",
        "");
    }
  }

  AbstractAlertState* AbstractAlertState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractAlertState (*this, f, c);
  }

  AbstractAlertState& AbstractAlertState::
  operator= (const AbstractAlertState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractState& > (*this) = x;
      this->ActivationState_ = x.ActivationState_;
    }

    return *this;
  }

  AbstractAlertState::
  ~AbstractAlertState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractAlertState >
  _xsd_AbstractAlertState_type_factory_init (
    "AbstractAlertState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AlertActivation
  //

  AlertActivation::
  AlertActivation (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_AlertActivation_convert ();
  }

  AlertActivation::
  AlertActivation (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_AlertActivation_convert ();
  }

  AlertActivation::
  AlertActivation (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_AlertActivation_convert ();
  }

  AlertActivation* AlertActivation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertActivation (*this, f, c);
  }

  AlertActivation::Value AlertActivation::
  _xsd_AlertActivation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AlertActivation_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_AlertActivation_indexes_,
                      _xsd_AlertActivation_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_AlertActivation_indexes_ + 3 || _xsd_AlertActivation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const AlertActivation::
  _xsd_AlertActivation_literals_[3] =
  {
    "On",
    "Off",
    "Psd"
  };

  const AlertActivation::Value AlertActivation::
  _xsd_AlertActivation_indexes_[3] =
  {
    ::CDM::AlertActivation::Off,
    ::CDM::AlertActivation::On,
    ::CDM::AlertActivation::Psd
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertActivation >
  _xsd_AlertActivation_type_factory_init (
    "AlertActivation",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SystemSignalActivation
  //

  SystemSignalActivation::
  SystemSignalActivation (const ManifestationType& Manifestation,
                          const StateType& State)
  : ::xml_schema::Type (),
    Manifestation_ (Manifestation, this),
    State_ (State, this)
  {
  }

  SystemSignalActivation::
  SystemSignalActivation (const SystemSignalActivation& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Manifestation_ (x.Manifestation_, f, this),
    State_ (x.State_, f, this)
  {
  }

  SystemSignalActivation::
  SystemSignalActivation (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Manifestation_ (this),
    State_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SystemSignalActivation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Manifestation" && n.namespace_ ().empty ())
      {
        this->Manifestation_.set (ManifestationTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "State" && n.namespace_ ().empty ())
      {
        this->State_.set (StateTraits::create (i, f, this));
        continue;
      }
    }

    if (!Manifestation_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Manifestation",
        "");
    }

    if (!State_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "State",
        "");
    }
  }

  SystemSignalActivation* SystemSignalActivation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SystemSignalActivation (*this, f, c);
  }

  SystemSignalActivation& SystemSignalActivation::
  operator= (const SystemSignalActivation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Manifestation_ = x.Manifestation_;
      this->State_ = x.State_;
    }

    return *this;
  }

  SystemSignalActivation::
  ~SystemSignalActivation ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SystemSignalActivation >
  _xsd_SystemSignalActivation_type_factory_init (
    "SystemSignalActivation",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AlertSystemDescriptor
  //

  AlertSystemDescriptor::
  AlertSystemDescriptor (const HandleType& Handle)
  : ::CDM::AbstractAlertDescriptor (Handle),
    AlertCondition_ (this),
    AlertSignal_ (this),
    MaxPhysiologicalParallelAlarms_ (this),
    MaxTechnicalParallelAlarms_ (this),
    SelfCheckPeriod_ (this)
  {
  }

  AlertSystemDescriptor::
  AlertSystemDescriptor (const AlertSystemDescriptor& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::AbstractAlertDescriptor (x, f, c),
    AlertCondition_ (x.AlertCondition_, f, this),
    AlertSignal_ (x.AlertSignal_, f, this),
    MaxPhysiologicalParallelAlarms_ (x.MaxPhysiologicalParallelAlarms_, f, this),
    MaxTechnicalParallelAlarms_ (x.MaxTechnicalParallelAlarms_, f, this),
    SelfCheckPeriod_ (x.SelfCheckPeriod_, f, this)
  {
  }

  AlertSystemDescriptor::
  AlertSystemDescriptor (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::AbstractAlertDescriptor (e, f | ::xml_schema::Flags::base, c),
    AlertCondition_ (this),
    AlertSignal_ (this),
    MaxPhysiologicalParallelAlarms_ (this),
    MaxTechnicalParallelAlarms_ (this),
    SelfCheckPeriod_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AlertSystemDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractAlertDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AlertCondition
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AlertCondition",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< AlertConditionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< AlertConditionType > r (
            dynamic_cast< AlertConditionType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->AlertCondition_.push_back (::std::move (r));
          continue;
        }
      }

      // AlertSignal
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AlertSignal",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< AlertSignalType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< AlertSignalType > r (
            dynamic_cast< AlertSignalType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->AlertSignal_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MaxPhysiologicalParallelAlarms" && n.namespace_ ().empty ())
      {
        this->MaxPhysiologicalParallelAlarms_.set (MaxPhysiologicalParallelAlarmsTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "MaxTechnicalParallelAlarms" && n.namespace_ ().empty ())
      {
        this->MaxTechnicalParallelAlarms_.set (MaxTechnicalParallelAlarmsTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "SelfCheckPeriod" && n.namespace_ ().empty ())
      {
        this->SelfCheckPeriod_.set (SelfCheckPeriodTraits::create (i, f, this));
        continue;
      }
    }
  }

  AlertSystemDescriptor* AlertSystemDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertSystemDescriptor (*this, f, c);
  }

  AlertSystemDescriptor& AlertSystemDescriptor::
  operator= (const AlertSystemDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractAlertDescriptor& > (*this) = x;
      this->AlertCondition_ = x.AlertCondition_;
      this->AlertSignal_ = x.AlertSignal_;
      this->MaxPhysiologicalParallelAlarms_ = x.MaxPhysiologicalParallelAlarms_;
      this->MaxTechnicalParallelAlarms_ = x.MaxTechnicalParallelAlarms_;
      this->SelfCheckPeriod_ = x.SelfCheckPeriod_;
    }

    return *this;
  }

  AlertSystemDescriptor::
  ~AlertSystemDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertSystemDescriptor >
  _xsd_AlertSystemDescriptor_type_factory_init (
    "AlertSystemDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AlertSystemState
  //

  AlertSystemState::
  AlertSystemState (const DescriptorHandleType& DescriptorHandle,
                    const ActivationStateType& ActivationState)
  : ::CDM::AbstractAlertState (DescriptorHandle,
                               ActivationState),
    SystemSignalActivation_ (this),
    LastSelfCheck_ (this),
    SelfCheckCount_ (this),
    PresentPhysiologicalAlarmConditions_ (this),
    PresentTechnicalAlarmConditions_ (this)
  {
  }

  AlertSystemState::
  AlertSystemState (const AlertSystemState& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::CDM::AbstractAlertState (x, f, c),
    SystemSignalActivation_ (x.SystemSignalActivation_, f, this),
    LastSelfCheck_ (x.LastSelfCheck_, f, this),
    SelfCheckCount_ (x.SelfCheckCount_, f, this),
    PresentPhysiologicalAlarmConditions_ (x.PresentPhysiologicalAlarmConditions_, f, this),
    PresentTechnicalAlarmConditions_ (x.PresentTechnicalAlarmConditions_, f, this)
  {
  }

  AlertSystemState::
  AlertSystemState (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::CDM::AbstractAlertState (e, f | ::xml_schema::Flags::base, c),
    SystemSignalActivation_ (this),
    LastSelfCheck_ (this),
    SelfCheckCount_ (this),
    PresentPhysiologicalAlarmConditions_ (this),
    PresentTechnicalAlarmConditions_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AlertSystemState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractAlertState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SystemSignalActivation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SystemSignalActivation",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< SystemSignalActivationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< SystemSignalActivationType > r (
            dynamic_cast< SystemSignalActivationType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->SystemSignalActivation_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "LastSelfCheck" && n.namespace_ ().empty ())
      {
        this->LastSelfCheck_.set (LastSelfCheckTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "SelfCheckCount" && n.namespace_ ().empty ())
      {
        this->SelfCheckCount_.set (SelfCheckCountTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "PresentPhysiologicalAlarmConditions" && n.namespace_ ().empty ())
      {
        this->PresentPhysiologicalAlarmConditions_.set (PresentPhysiologicalAlarmConditionsTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "PresentTechnicalAlarmConditions" && n.namespace_ ().empty ())
      {
        this->PresentTechnicalAlarmConditions_.set (PresentTechnicalAlarmConditionsTraits::create (i, f, this));
        continue;
      }
    }
  }

  AlertSystemState* AlertSystemState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertSystemState (*this, f, c);
  }

  AlertSystemState& AlertSystemState::
  operator= (const AlertSystemState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractAlertState& > (*this) = x;
      this->SystemSignalActivation_ = x.SystemSignalActivation_;
      this->LastSelfCheck_ = x.LastSelfCheck_;
      this->SelfCheckCount_ = x.SelfCheckCount_;
      this->PresentPhysiologicalAlarmConditions_ = x.PresentPhysiologicalAlarmConditions_;
      this->PresentTechnicalAlarmConditions_ = x.PresentTechnicalAlarmConditions_;
    }

    return *this;
  }

  AlertSystemState::
  ~AlertSystemState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertSystemState >
  _xsd_AlertSystemState_type_factory_init (
    "AlertSystemState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // CauseInfo
  //

  CauseInfo::
  CauseInfo ()
  : ::xml_schema::Type (),
    Extension_ (this),
    RemedyInfo_ (this),
    Description_ (this)
  {
  }

  CauseInfo::
  CauseInfo (const CauseInfo& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    RemedyInfo_ (x.RemedyInfo_, f, this),
    Description_ (x.Description_, f, this)
  {
  }

  CauseInfo::
  CauseInfo (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    RemedyInfo_ (this),
    Description_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CauseInfo::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // RemedyInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "RemedyInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< RemedyInfoType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->RemedyInfo_)
          {
            ::std::unique_ptr< RemedyInfoType > r (
              dynamic_cast< RemedyInfoType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->RemedyInfo_.set (::std::move (r));
            continue;
          }
        }
      }

      // Description
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Description",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< DescriptionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< DescriptionType > r (
            dynamic_cast< DescriptionType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Description_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  CauseInfo* CauseInfo::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CauseInfo (*this, f, c);
  }

  CauseInfo& CauseInfo::
  operator= (const CauseInfo& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->RemedyInfo_ = x.RemedyInfo_;
      this->Description_ = x.Description_;
    }

    return *this;
  }

  CauseInfo::
  ~CauseInfo ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CauseInfo >
  _xsd_CauseInfo_type_factory_init (
    "CauseInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // RemedyInfo
  //

  RemedyInfo::
  RemedyInfo ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Description_ (this)
  {
  }

  RemedyInfo::
  RemedyInfo (const RemedyInfo& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Description_ (x.Description_, f, this)
  {
  }

  RemedyInfo::
  RemedyInfo (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Description_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void RemedyInfo::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // Description
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Description",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< DescriptionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< DescriptionType > r (
            dynamic_cast< DescriptionType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Description_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  RemedyInfo* RemedyInfo::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RemedyInfo (*this, f, c);
  }

  RemedyInfo& RemedyInfo::
  operator= (const RemedyInfo& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Description_ = x.Description_;
    }

    return *this;
  }

  RemedyInfo::
  ~RemedyInfo ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RemedyInfo >
  _xsd_RemedyInfo_type_factory_init (
    "RemedyInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AlertConditionKind
  //

  AlertConditionKind::
  AlertConditionKind (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_AlertConditionKind_convert ();
  }

  AlertConditionKind::
  AlertConditionKind (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_AlertConditionKind_convert ();
  }

  AlertConditionKind::
  AlertConditionKind (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_AlertConditionKind_convert ();
  }

  AlertConditionKind* AlertConditionKind::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertConditionKind (*this, f, c);
  }

  AlertConditionKind::Value AlertConditionKind::
  _xsd_AlertConditionKind_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AlertConditionKind_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_AlertConditionKind_indexes_,
                      _xsd_AlertConditionKind_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_AlertConditionKind_indexes_ + 3 || _xsd_AlertConditionKind_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const AlertConditionKind::
  _xsd_AlertConditionKind_literals_[3] =
  {
    "Phy",
    "Tec",
    "Oth"
  };

  const AlertConditionKind::Value AlertConditionKind::
  _xsd_AlertConditionKind_indexes_[3] =
  {
    ::CDM::AlertConditionKind::Oth,
    ::CDM::AlertConditionKind::Phy,
    ::CDM::AlertConditionKind::Tec
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertConditionKind >
  _xsd_AlertConditionKind_type_factory_init (
    "AlertConditionKind",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AlertConditionPriority
  //

  AlertConditionPriority::
  AlertConditionPriority (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_AlertConditionPriority_convert ();
  }

  AlertConditionPriority::
  AlertConditionPriority (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_AlertConditionPriority_convert ();
  }

  AlertConditionPriority::
  AlertConditionPriority (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_AlertConditionPriority_convert ();
  }

  AlertConditionPriority* AlertConditionPriority::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertConditionPriority (*this, f, c);
  }

  AlertConditionPriority::Value AlertConditionPriority::
  _xsd_AlertConditionPriority_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AlertConditionPriority_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_AlertConditionPriority_indexes_,
                      _xsd_AlertConditionPriority_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_AlertConditionPriority_indexes_ + 4 || _xsd_AlertConditionPriority_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const AlertConditionPriority::
  _xsd_AlertConditionPriority_literals_[4] =
  {
    "Lo",
    "Me",
    "Hi",
    "None"
  };

  const AlertConditionPriority::Value AlertConditionPriority::
  _xsd_AlertConditionPriority_indexes_[4] =
  {
    ::CDM::AlertConditionPriority::Hi,
    ::CDM::AlertConditionPriority::Lo,
    ::CDM::AlertConditionPriority::Me,
    ::CDM::AlertConditionPriority::None
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertConditionPriority >
  _xsd_AlertConditionPriority_type_factory_init (
    "AlertConditionPriority",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AlertConditionDescriptor
  //

  AlertConditionDescriptor::
  AlertConditionDescriptor (const HandleType& Handle,
                            const KindType& Kind,
                            const PriorityType& Priority)
  : ::CDM::AbstractAlertDescriptor (Handle),
    Source_ (this),
    CauseInfo_ (this),
    Kind_ (Kind, this),
    Priority_ (Priority, this),
    DefaultConditionGenerationDelay_ (this),
    CanEscalate_ (this),
    CanDeescalate_ (this)
  {
  }

  AlertConditionDescriptor::
  AlertConditionDescriptor (const AlertConditionDescriptor& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AbstractAlertDescriptor (x, f, c),
    Source_ (x.Source_, f, this),
    CauseInfo_ (x.CauseInfo_, f, this),
    Kind_ (x.Kind_, f, this),
    Priority_ (x.Priority_, f, this),
    DefaultConditionGenerationDelay_ (x.DefaultConditionGenerationDelay_, f, this),
    CanEscalate_ (x.CanEscalate_, f, this),
    CanDeescalate_ (x.CanDeescalate_, f, this)
  {
  }

  AlertConditionDescriptor::
  AlertConditionDescriptor (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AbstractAlertDescriptor (e, f | ::xml_schema::Flags::base, c),
    Source_ (this),
    CauseInfo_ (this),
    Kind_ (this),
    Priority_ (this),
    DefaultConditionGenerationDelay_ (this),
    CanEscalate_ (this),
    CanDeescalate_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AlertConditionDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractAlertDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Source
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Source",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< SourceType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< SourceType > r (
            dynamic_cast< SourceType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Source_.push_back (::std::move (r));
          continue;
        }
      }

      // CauseInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CauseInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< CauseInfoType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< CauseInfoType > r (
            dynamic_cast< CauseInfoType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->CauseInfo_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Kind" && n.namespace_ ().empty ())
      {
        this->Kind_.set (KindTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Priority" && n.namespace_ ().empty ())
      {
        this->Priority_.set (PriorityTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "DefaultConditionGenerationDelay" && n.namespace_ ().empty ())
      {
        this->DefaultConditionGenerationDelay_.set (DefaultConditionGenerationDelayTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "CanEscalate" && n.namespace_ ().empty ())
      {
        this->CanEscalate_.set (CanEscalateTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "CanDeescalate" && n.namespace_ ().empty ())
      {
        this->CanDeescalate_.set (CanDeescalateTraits::create (i, f, this));
        continue;
      }
    }

    if (!Kind_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Kind",
        "");
    }

    if (!Priority_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Priority",
        "");
    }
  }

  AlertConditionDescriptor* AlertConditionDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertConditionDescriptor (*this, f, c);
  }

  AlertConditionDescriptor& AlertConditionDescriptor::
  operator= (const AlertConditionDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractAlertDescriptor& > (*this) = x;
      this->Source_ = x.Source_;
      this->CauseInfo_ = x.CauseInfo_;
      this->Kind_ = x.Kind_;
      this->Priority_ = x.Priority_;
      this->DefaultConditionGenerationDelay_ = x.DefaultConditionGenerationDelay_;
      this->CanEscalate_ = x.CanEscalate_;
      this->CanDeescalate_ = x.CanDeescalate_;
    }

    return *this;
  }

  AlertConditionDescriptor::
  ~AlertConditionDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertConditionDescriptor >
  _xsd_AlertConditionDescriptor_type_factory_init (
    "AlertConditionDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AlertConditionReference
  //

  AlertConditionReference::
  AlertConditionReference (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (e, f, c),
    ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (e, f, this)
  {
  }

  AlertConditionReference::
  AlertConditionReference (const ::xercesc::DOMAttr& a,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (a, f, c),
    ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (a, f, this)
  {
  }

  AlertConditionReference::
  AlertConditionReference (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (s, e, f, c),
    ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (s, e, f, this)
  {
  }

  AlertConditionReference* AlertConditionReference::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertConditionReference (*this, f, c);
  }

  AlertConditionReference::
  ~AlertConditionReference ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertConditionReference >
  _xsd_AlertConditionReference_type_factory_init (
    "AlertConditionReference",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AlertConditionState
  //

  AlertConditionState::
  AlertConditionState (const DescriptorHandleType& DescriptorHandle,
                       const ActivationStateType& ActivationState)
  : ::CDM::AbstractAlertState (DescriptorHandle,
                               ActivationState),
    ActualConditionGenerationDelay_ (this),
    ActualPriority_ (this),
    Rank_ (this),
    Presence_ (this),
    DeterminationTime_ (this)
  {
  }

  AlertConditionState::
  AlertConditionState (const AlertConditionState& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::AbstractAlertState (x, f, c),
    ActualConditionGenerationDelay_ (x.ActualConditionGenerationDelay_, f, this),
    ActualPriority_ (x.ActualPriority_, f, this),
    Rank_ (x.Rank_, f, this),
    Presence_ (x.Presence_, f, this),
    DeterminationTime_ (x.DeterminationTime_, f, this)
  {
  }

  AlertConditionState::
  AlertConditionState (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::AbstractAlertState (e, f | ::xml_schema::Flags::base, c),
    ActualConditionGenerationDelay_ (this),
    ActualPriority_ (this),
    Rank_ (this),
    Presence_ (this),
    DeterminationTime_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AlertConditionState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractAlertState::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ActualConditionGenerationDelay" && n.namespace_ ().empty ())
      {
        this->ActualConditionGenerationDelay_.set (ActualConditionGenerationDelayTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ActualPriority" && n.namespace_ ().empty ())
      {
        this->ActualPriority_.set (ActualPriorityTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Rank" && n.namespace_ ().empty ())
      {
        this->Rank_.set (RankTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Presence" && n.namespace_ ().empty ())
      {
        this->Presence_.set (PresenceTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "DeterminationTime" && n.namespace_ ().empty ())
      {
        this->DeterminationTime_.set (DeterminationTimeTraits::create (i, f, this));
        continue;
      }
    }
  }

  AlertConditionState* AlertConditionState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertConditionState (*this, f, c);
  }

  AlertConditionState& AlertConditionState::
  operator= (const AlertConditionState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractAlertState& > (*this) = x;
      this->ActualConditionGenerationDelay_ = x.ActualConditionGenerationDelay_;
      this->ActualPriority_ = x.ActualPriority_;
      this->Rank_ = x.Rank_;
      this->Presence_ = x.Presence_;
      this->DeterminationTime_ = x.DeterminationTime_;
    }

    return *this;
  }

  AlertConditionState::
  ~AlertConditionState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertConditionState >
  _xsd_AlertConditionState_type_factory_init (
    "AlertConditionState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // LimitAlertConditionDescriptor
  //

  LimitAlertConditionDescriptor::
  LimitAlertConditionDescriptor (const HandleType& Handle,
                                 const KindType& Kind,
                                 const PriorityType& Priority,
                                 const MaxLimitsType& MaxLimits)
  : ::CDM::AlertConditionDescriptor (Handle,
                                     Kind,
                                     Priority),
    MaxLimits_ (MaxLimits, this),
    AutoLimitSupported_ (this)
  {
  }

  LimitAlertConditionDescriptor::
  LimitAlertConditionDescriptor (const HandleType& Handle,
                                 const KindType& Kind,
                                 const PriorityType& Priority,
                                 ::std::unique_ptr< MaxLimitsType > MaxLimits)
  : ::CDM::AlertConditionDescriptor (Handle,
                                     Kind,
                                     Priority),
    MaxLimits_ (std::move (MaxLimits), this),
    AutoLimitSupported_ (this)
  {
  }

  LimitAlertConditionDescriptor::
  LimitAlertConditionDescriptor (const LimitAlertConditionDescriptor& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::CDM::AlertConditionDescriptor (x, f, c),
    MaxLimits_ (x.MaxLimits_, f, this),
    AutoLimitSupported_ (x.AutoLimitSupported_, f, this)
  {
  }

  LimitAlertConditionDescriptor::
  LimitAlertConditionDescriptor (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::CDM::AlertConditionDescriptor (e, f | ::xml_schema::Flags::base, c),
    MaxLimits_ (this),
    AutoLimitSupported_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void LimitAlertConditionDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AlertConditionDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MaxLimits
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MaxLimits",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< MaxLimitsType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MaxLimits_.present ())
          {
            ::std::unique_ptr< MaxLimitsType > r (
              dynamic_cast< MaxLimitsType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MaxLimits_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!MaxLimits_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MaxLimits",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "AutoLimitSupported" && n.namespace_ ().empty ())
      {
        this->AutoLimitSupported_.set (AutoLimitSupportedTraits::create (i, f, this));
        continue;
      }
    }
  }

  LimitAlertConditionDescriptor* LimitAlertConditionDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LimitAlertConditionDescriptor (*this, f, c);
  }

  LimitAlertConditionDescriptor& LimitAlertConditionDescriptor::
  operator= (const LimitAlertConditionDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AlertConditionDescriptor& > (*this) = x;
      this->MaxLimits_ = x.MaxLimits_;
      this->AutoLimitSupported_ = x.AutoLimitSupported_;
    }

    return *this;
  }

  LimitAlertConditionDescriptor::
  ~LimitAlertConditionDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LimitAlertConditionDescriptor >
  _xsd_LimitAlertConditionDescriptor_type_factory_init (
    "LimitAlertConditionDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AlertConditionMonitoredLimits
  //

  AlertConditionMonitoredLimits::
  AlertConditionMonitoredLimits (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_AlertConditionMonitoredLimits_convert ();
  }

  AlertConditionMonitoredLimits::
  AlertConditionMonitoredLimits (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_AlertConditionMonitoredLimits_convert ();
  }

  AlertConditionMonitoredLimits::
  AlertConditionMonitoredLimits (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_AlertConditionMonitoredLimits_convert ();
  }

  AlertConditionMonitoredLimits* AlertConditionMonitoredLimits::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertConditionMonitoredLimits (*this, f, c);
  }

  AlertConditionMonitoredLimits::Value AlertConditionMonitoredLimits::
  _xsd_AlertConditionMonitoredLimits_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AlertConditionMonitoredLimits_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_AlertConditionMonitoredLimits_indexes_,
                      _xsd_AlertConditionMonitoredLimits_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_AlertConditionMonitoredLimits_indexes_ + 4 || _xsd_AlertConditionMonitoredLimits_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const AlertConditionMonitoredLimits::
  _xsd_AlertConditionMonitoredLimits_literals_[4] =
  {
    "All",
    "LoOff",
    "HiOff",
    "None"
  };

  const AlertConditionMonitoredLimits::Value AlertConditionMonitoredLimits::
  _xsd_AlertConditionMonitoredLimits_indexes_[4] =
  {
    ::CDM::AlertConditionMonitoredLimits::All,
    ::CDM::AlertConditionMonitoredLimits::HiOff,
    ::CDM::AlertConditionMonitoredLimits::LoOff,
    ::CDM::AlertConditionMonitoredLimits::None
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertConditionMonitoredLimits >
  _xsd_AlertConditionMonitoredLimits_type_factory_init (
    "AlertConditionMonitoredLimits",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // LimitAlertConditionState
  //

  LimitAlertConditionState::
  LimitAlertConditionState (const DescriptorHandleType& DescriptorHandle,
                            const ActivationStateType& ActivationState,
                            const LimitsType& Limits,
                            const MonitoredAlertLimitsType& MonitoredAlertLimits)
  : ::CDM::AlertConditionState (DescriptorHandle,
                                ActivationState),
    Limits_ (Limits, this),
    MonitoredAlertLimits_ (MonitoredAlertLimits, this),
    AutoLimitActivationState_ (this)
  {
  }

  LimitAlertConditionState::
  LimitAlertConditionState (const DescriptorHandleType& DescriptorHandle,
                            const ActivationStateType& ActivationState,
                            ::std::unique_ptr< LimitsType > Limits,
                            const MonitoredAlertLimitsType& MonitoredAlertLimits)
  : ::CDM::AlertConditionState (DescriptorHandle,
                                ActivationState),
    Limits_ (std::move (Limits), this),
    MonitoredAlertLimits_ (MonitoredAlertLimits, this),
    AutoLimitActivationState_ (this)
  {
  }

  LimitAlertConditionState::
  LimitAlertConditionState (const LimitAlertConditionState& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AlertConditionState (x, f, c),
    Limits_ (x.Limits_, f, this),
    MonitoredAlertLimits_ (x.MonitoredAlertLimits_, f, this),
    AutoLimitActivationState_ (x.AutoLimitActivationState_, f, this)
  {
  }

  LimitAlertConditionState::
  LimitAlertConditionState (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AlertConditionState (e, f | ::xml_schema::Flags::base, c),
    Limits_ (this),
    MonitoredAlertLimits_ (this),
    AutoLimitActivationState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void LimitAlertConditionState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AlertConditionState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Limits
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Limits",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< LimitsType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Limits_.present ())
          {
            ::std::unique_ptr< LimitsType > r (
              dynamic_cast< LimitsType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Limits_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Limits_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Limits",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MonitoredAlertLimits" && n.namespace_ ().empty ())
      {
        this->MonitoredAlertLimits_.set (MonitoredAlertLimitsTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "AutoLimitActivationState" && n.namespace_ ().empty ())
      {
        this->AutoLimitActivationState_.set (AutoLimitActivationStateTraits::create (i, f, this));
        continue;
      }
    }

    if (!MonitoredAlertLimits_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "MonitoredAlertLimits",
        "");
    }
  }

  LimitAlertConditionState* LimitAlertConditionState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LimitAlertConditionState (*this, f, c);
  }

  LimitAlertConditionState& LimitAlertConditionState::
  operator= (const LimitAlertConditionState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AlertConditionState& > (*this) = x;
      this->Limits_ = x.Limits_;
      this->MonitoredAlertLimits_ = x.MonitoredAlertLimits_;
      this->AutoLimitActivationState_ = x.AutoLimitActivationState_;
    }

    return *this;
  }

  LimitAlertConditionState::
  ~LimitAlertConditionState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LimitAlertConditionState >
  _xsd_LimitAlertConditionState_type_factory_init (
    "LimitAlertConditionState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AlertSignalManifestation
  //

  AlertSignalManifestation::
  AlertSignalManifestation (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_AlertSignalManifestation_convert ();
  }

  AlertSignalManifestation::
  AlertSignalManifestation (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_AlertSignalManifestation_convert ();
  }

  AlertSignalManifestation::
  AlertSignalManifestation (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_AlertSignalManifestation_convert ();
  }

  AlertSignalManifestation* AlertSignalManifestation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertSignalManifestation (*this, f, c);
  }

  AlertSignalManifestation::Value AlertSignalManifestation::
  _xsd_AlertSignalManifestation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AlertSignalManifestation_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_AlertSignalManifestation_indexes_,
                      _xsd_AlertSignalManifestation_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_AlertSignalManifestation_indexes_ + 4 || _xsd_AlertSignalManifestation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const AlertSignalManifestation::
  _xsd_AlertSignalManifestation_literals_[4] =
  {
    "Aud",
    "Vis",
    "Tan",
    "Oth"
  };

  const AlertSignalManifestation::Value AlertSignalManifestation::
  _xsd_AlertSignalManifestation_indexes_[4] =
  {
    ::CDM::AlertSignalManifestation::Aud,
    ::CDM::AlertSignalManifestation::Oth,
    ::CDM::AlertSignalManifestation::Tan,
    ::CDM::AlertSignalManifestation::Vis
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertSignalManifestation >
  _xsd_AlertSignalManifestation_type_factory_init (
    "AlertSignalManifestation",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AlertSignalDescriptor
  //

  AlertSignalDescriptor::
  AlertSignalDescriptor (const HandleType& Handle,
                         const ManifestationType& Manifestation,
                         const LatchingType& Latching)
  : ::CDM::AbstractAlertDescriptor (Handle),
    ConditionSignaled_ (this),
    Manifestation_ (Manifestation, this),
    Latching_ (Latching, this),
    DefaultSignalGenerationDelay_ (this),
    MinSignalGenerationDelay_ (this),
    MaxSignalGenerationDelay_ (this),
    SignalDelegationSupported_ (this),
    AcknowledgementSupported_ (this),
    AcknowledgeTimeout_ (this)
  {
  }

  AlertSignalDescriptor::
  AlertSignalDescriptor (const AlertSignalDescriptor& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::AbstractAlertDescriptor (x, f, c),
    ConditionSignaled_ (x.ConditionSignaled_, f, this),
    Manifestation_ (x.Manifestation_, f, this),
    Latching_ (x.Latching_, f, this),
    DefaultSignalGenerationDelay_ (x.DefaultSignalGenerationDelay_, f, this),
    MinSignalGenerationDelay_ (x.MinSignalGenerationDelay_, f, this),
    MaxSignalGenerationDelay_ (x.MaxSignalGenerationDelay_, f, this),
    SignalDelegationSupported_ (x.SignalDelegationSupported_, f, this),
    AcknowledgementSupported_ (x.AcknowledgementSupported_, f, this),
    AcknowledgeTimeout_ (x.AcknowledgeTimeout_, f, this)
  {
  }

  AlertSignalDescriptor::
  AlertSignalDescriptor (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::AbstractAlertDescriptor (e, f | ::xml_schema::Flags::base, c),
    ConditionSignaled_ (this),
    Manifestation_ (this),
    Latching_ (this),
    DefaultSignalGenerationDelay_ (this),
    MinSignalGenerationDelay_ (this),
    MaxSignalGenerationDelay_ (this),
    SignalDelegationSupported_ (this),
    AcknowledgementSupported_ (this),
    AcknowledgeTimeout_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AlertSignalDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractAlertDescriptor::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ConditionSignaled" && n.namespace_ ().empty ())
      {
        this->ConditionSignaled_.set (ConditionSignaledTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Manifestation" && n.namespace_ ().empty ())
      {
        this->Manifestation_.set (ManifestationTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Latching" && n.namespace_ ().empty ())
      {
        this->Latching_.set (LatchingTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "DefaultSignalGenerationDelay" && n.namespace_ ().empty ())
      {
        this->DefaultSignalGenerationDelay_.set (DefaultSignalGenerationDelayTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "MinSignalGenerationDelay" && n.namespace_ ().empty ())
      {
        this->MinSignalGenerationDelay_.set (MinSignalGenerationDelayTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "MaxSignalGenerationDelay" && n.namespace_ ().empty ())
      {
        this->MaxSignalGenerationDelay_.set (MaxSignalGenerationDelayTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "SignalDelegationSupported" && n.namespace_ ().empty ())
      {
        this->SignalDelegationSupported_.set (SignalDelegationSupportedTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "AcknowledgementSupported" && n.namespace_ ().empty ())
      {
        this->AcknowledgementSupported_.set (AcknowledgementSupportedTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "AcknowledgeTimeout" && n.namespace_ ().empty ())
      {
        this->AcknowledgeTimeout_.set (AcknowledgeTimeoutTraits::create (i, f, this));
        continue;
      }
    }

    if (!Manifestation_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Manifestation",
        "");
    }

    if (!Latching_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Latching",
        "");
    }
  }

  AlertSignalDescriptor* AlertSignalDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertSignalDescriptor (*this, f, c);
  }

  AlertSignalDescriptor& AlertSignalDescriptor::
  operator= (const AlertSignalDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractAlertDescriptor& > (*this) = x;
      this->ConditionSignaled_ = x.ConditionSignaled_;
      this->Manifestation_ = x.Manifestation_;
      this->Latching_ = x.Latching_;
      this->DefaultSignalGenerationDelay_ = x.DefaultSignalGenerationDelay_;
      this->MinSignalGenerationDelay_ = x.MinSignalGenerationDelay_;
      this->MaxSignalGenerationDelay_ = x.MaxSignalGenerationDelay_;
      this->SignalDelegationSupported_ = x.SignalDelegationSupported_;
      this->AcknowledgementSupported_ = x.AcknowledgementSupported_;
      this->AcknowledgeTimeout_ = x.AcknowledgeTimeout_;
    }

    return *this;
  }

  AlertSignalDescriptor::
  ~AlertSignalDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertSignalDescriptor >
  _xsd_AlertSignalDescriptor_type_factory_init (
    "AlertSignalDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AlertSignalPresence
  //

  AlertSignalPresence::
  AlertSignalPresence (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_AlertSignalPresence_convert ();
  }

  AlertSignalPresence::
  AlertSignalPresence (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_AlertSignalPresence_convert ();
  }

  AlertSignalPresence::
  AlertSignalPresence (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_AlertSignalPresence_convert ();
  }

  AlertSignalPresence* AlertSignalPresence::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertSignalPresence (*this, f, c);
  }

  AlertSignalPresence::Value AlertSignalPresence::
  _xsd_AlertSignalPresence_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AlertSignalPresence_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_AlertSignalPresence_indexes_,
                      _xsd_AlertSignalPresence_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_AlertSignalPresence_indexes_ + 4 || _xsd_AlertSignalPresence_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const AlertSignalPresence::
  _xsd_AlertSignalPresence_literals_[4] =
  {
    "On",
    "Off",
    "Latch",
    "Ack"
  };

  const AlertSignalPresence::Value AlertSignalPresence::
  _xsd_AlertSignalPresence_indexes_[4] =
  {
    ::CDM::AlertSignalPresence::Ack,
    ::CDM::AlertSignalPresence::Latch,
    ::CDM::AlertSignalPresence::Off,
    ::CDM::AlertSignalPresence::On
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertSignalPresence >
  _xsd_AlertSignalPresence_type_factory_init (
    "AlertSignalPresence",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AlertSignalPrimaryLocation
  //

  AlertSignalPrimaryLocation::
  AlertSignalPrimaryLocation (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_AlertSignalPrimaryLocation_convert ();
  }

  AlertSignalPrimaryLocation::
  AlertSignalPrimaryLocation (const ::xercesc::DOMAttr& a,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_AlertSignalPrimaryLocation_convert ();
  }

  AlertSignalPrimaryLocation::
  AlertSignalPrimaryLocation (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_AlertSignalPrimaryLocation_convert ();
  }

  AlertSignalPrimaryLocation* AlertSignalPrimaryLocation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertSignalPrimaryLocation (*this, f, c);
  }

  AlertSignalPrimaryLocation::Value AlertSignalPrimaryLocation::
  _xsd_AlertSignalPrimaryLocation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AlertSignalPrimaryLocation_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_AlertSignalPrimaryLocation_indexes_,
                      _xsd_AlertSignalPrimaryLocation_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_AlertSignalPrimaryLocation_indexes_ + 2 || _xsd_AlertSignalPrimaryLocation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const AlertSignalPrimaryLocation::
  _xsd_AlertSignalPrimaryLocation_literals_[2] =
  {
    "Loc",
    "Rem"
  };

  const AlertSignalPrimaryLocation::Value AlertSignalPrimaryLocation::
  _xsd_AlertSignalPrimaryLocation_indexes_[2] =
  {
    ::CDM::AlertSignalPrimaryLocation::Loc,
    ::CDM::AlertSignalPrimaryLocation::Rem
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertSignalPrimaryLocation >
  _xsd_AlertSignalPrimaryLocation_type_factory_init (
    "AlertSignalPrimaryLocation",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AlertSignalState
  //

  AlertSignalState::
  AlertSignalState (const DescriptorHandleType& DescriptorHandle,
                    const ActivationStateType& ActivationState)
  : ::CDM::AbstractAlertState (DescriptorHandle,
                               ActivationState),
    ActualSignalGenerationDelay_ (this),
    Presence_ (this),
    Location_ (this),
    Slot_ (this)
  {
  }

  AlertSignalState::
  AlertSignalState (const AlertSignalState& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::CDM::AbstractAlertState (x, f, c),
    ActualSignalGenerationDelay_ (x.ActualSignalGenerationDelay_, f, this),
    Presence_ (x.Presence_, f, this),
    Location_ (x.Location_, f, this),
    Slot_ (x.Slot_, f, this)
  {
  }

  AlertSignalState::
  AlertSignalState (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::CDM::AbstractAlertState (e, f | ::xml_schema::Flags::base, c),
    ActualSignalGenerationDelay_ (this),
    Presence_ (this),
    Location_ (this),
    Slot_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AlertSignalState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractAlertState::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ActualSignalGenerationDelay" && n.namespace_ ().empty ())
      {
        this->ActualSignalGenerationDelay_.set (ActualSignalGenerationDelayTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Presence" && n.namespace_ ().empty ())
      {
        this->Presence_.set (PresenceTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Location" && n.namespace_ ().empty ())
      {
        this->Location_.set (LocationTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Slot" && n.namespace_ ().empty ())
      {
        this->Slot_.set (SlotTraits::create (i, f, this));
        continue;
      }
    }
  }

  AlertSignalState* AlertSignalState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertSignalState (*this, f, c);
  }

  AlertSignalState& AlertSignalState::
  operator= (const AlertSignalState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractAlertState& > (*this) = x;
      this->ActualSignalGenerationDelay_ = x.ActualSignalGenerationDelay_;
      this->Presence_ = x.Presence_;
      this->Location_ = x.Location_;
      this->Slot_ = x.Slot_;
    }

    return *this;
  }

  AlertSignalState::
  ~AlertSignalState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertSignalState >
  _xsd_AlertSignalState_type_factory_init (
    "AlertSignalState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // QualityIndicator
  //

  QualityIndicator::
  QualityIndicator (const ::xml_schema::Decimal& _xsd_Decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (_xsd_Decimal_base)
  {
  }

  QualityIndicator::
  QualityIndicator (const QualityIndicator& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
  }

  QualityIndicator::
  QualityIndicator (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
  }

  QualityIndicator::
  QualityIndicator (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
  }

  QualityIndicator::
  QualityIndicator (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
  }

  QualityIndicator* QualityIndicator::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class QualityIndicator (*this, f, c);
  }

  QualityIndicator::
  ~QualityIndicator ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, QualityIndicator >
  _xsd_QualityIndicator_type_factory_init (
    "QualityIndicator",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // GenerationMode
  //

  GenerationMode::
  GenerationMode (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_GenerationMode_convert ();
  }

  GenerationMode::
  GenerationMode (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_GenerationMode_convert ();
  }

  GenerationMode::
  GenerationMode (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_GenerationMode_convert ();
  }

  GenerationMode* GenerationMode::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GenerationMode (*this, f, c);
  }

  GenerationMode::Value GenerationMode::
  _xsd_GenerationMode_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_GenerationMode_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_GenerationMode_indexes_,
                      _xsd_GenerationMode_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_GenerationMode_indexes_ + 3 || _xsd_GenerationMode_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const GenerationMode::
  _xsd_GenerationMode_literals_[3] =
  {
    "Real",
    "Test",
    "Demo"
  };

  const GenerationMode::Value GenerationMode::
  _xsd_GenerationMode_indexes_[3] =
  {
    ::CDM::GenerationMode::Demo,
    ::CDM::GenerationMode::Real,
    ::CDM::GenerationMode::Test
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, GenerationMode >
  _xsd_GenerationMode_type_factory_init (
    "GenerationMode",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AbstractMetricValue
  //

  AbstractMetricValue::
  AbstractMetricValue (const MetricQualityType& MetricQuality)
  : ::xml_schema::Type (),
    Extension_ (this),
    MetricQuality_ (MetricQuality, this),
    Annotation_ (this),
    StartTime_ (this),
    StopTime_ (this),
    DeterminationTime_ (this)
  {
  }

  AbstractMetricValue::
  AbstractMetricValue (::std::unique_ptr< MetricQualityType > MetricQuality)
  : ::xml_schema::Type (),
    Extension_ (this),
    MetricQuality_ (std::move (MetricQuality), this),
    Annotation_ (this),
    StartTime_ (this),
    StopTime_ (this),
    DeterminationTime_ (this)
  {
  }

  AbstractMetricValue::
  AbstractMetricValue (const AbstractMetricValue& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    MetricQuality_ (x.MetricQuality_, f, this),
    Annotation_ (x.Annotation_, f, this),
    StartTime_ (x.StartTime_, f, this),
    StopTime_ (x.StopTime_, f, this),
    DeterminationTime_ (x.DeterminationTime_, f, this)
  {
  }

  AbstractMetricValue::
  AbstractMetricValue (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    MetricQuality_ (this),
    Annotation_ (this),
    StartTime_ (this),
    StopTime_ (this),
    DeterminationTime_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractMetricValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // MetricQuality
      //
      if (n.name () == "MetricQuality" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< MetricQualityType > r (
          MetricQualityTraits::create (i, f, this));

        if (!MetricQuality_.present ())
        {
          this->MetricQuality_.set (::std::move (r));
          continue;
        }
      }

      // Annotation
      //
      if (n.name () == "Annotation" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< AnnotationType > r (
          AnnotationTraits::create (i, f, this));

        this->Annotation_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!MetricQuality_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MetricQuality",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "StartTime" && n.namespace_ ().empty ())
      {
        this->StartTime_.set (StartTimeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "StopTime" && n.namespace_ ().empty ())
      {
        this->StopTime_.set (StopTimeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "DeterminationTime" && n.namespace_ ().empty ())
      {
        this->DeterminationTime_.set (DeterminationTimeTraits::create (i, f, this));
        continue;
      }
    }
  }

  AbstractMetricValue* AbstractMetricValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractMetricValue (*this, f, c);
  }

  AbstractMetricValue& AbstractMetricValue::
  operator= (const AbstractMetricValue& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->MetricQuality_ = x.MetricQuality_;
      this->Annotation_ = x.Annotation_;
      this->StartTime_ = x.StartTime_;
      this->StopTime_ = x.StopTime_;
      this->DeterminationTime_ = x.DeterminationTime_;
    }

    return *this;
  }

  AbstractMetricValue::
  ~AbstractMetricValue ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractMetricValue >
  _xsd_AbstractMetricValue_type_factory_init (
    "AbstractMetricValue",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // NumericMetricValue
  //

  NumericMetricValue::
  NumericMetricValue (const MetricQualityType& MetricQuality)
  : ::CDM::AbstractMetricValue (MetricQuality),
    Value_ (this)
  {
  }

  NumericMetricValue::
  NumericMetricValue (::std::unique_ptr< MetricQualityType > MetricQuality)
  : ::CDM::AbstractMetricValue (std::move (MetricQuality)),
    Value_ (this)
  {
  }

  NumericMetricValue::
  NumericMetricValue (const NumericMetricValue& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractMetricValue (x, f, c),
    Value_ (x.Value_, f, this)
  {
  }

  NumericMetricValue::
  NumericMetricValue (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractMetricValue (e, f | ::xml_schema::Flags::base, c),
    Value_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void NumericMetricValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricValue::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Value" && n.namespace_ ().empty ())
      {
        this->Value_.set (ValueTraits::create (i, f, this));
        continue;
      }
    }
  }

  NumericMetricValue* NumericMetricValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NumericMetricValue (*this, f, c);
  }

  NumericMetricValue& NumericMetricValue::
  operator= (const NumericMetricValue& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricValue& > (*this) = x;
      this->Value_ = x.Value_;
    }

    return *this;
  }

  NumericMetricValue::
  ~NumericMetricValue ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, NumericMetricValue >
  _xsd_NumericMetricValue_type_factory_init (
    "NumericMetricValue",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // StringMetricValue
  //

  StringMetricValue::
  StringMetricValue (const MetricQualityType& MetricQuality)
  : ::CDM::AbstractMetricValue (MetricQuality),
    Value_ (this)
  {
  }

  StringMetricValue::
  StringMetricValue (::std::unique_ptr< MetricQualityType > MetricQuality)
  : ::CDM::AbstractMetricValue (std::move (MetricQuality)),
    Value_ (this)
  {
  }

  StringMetricValue::
  StringMetricValue (const StringMetricValue& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::AbstractMetricValue (x, f, c),
    Value_ (x.Value_, f, this)
  {
  }

  StringMetricValue::
  StringMetricValue (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::AbstractMetricValue (e, f | ::xml_schema::Flags::base, c),
    Value_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void StringMetricValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricValue::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Value" && n.namespace_ ().empty ())
      {
        this->Value_.set (ValueTraits::create (i, f, this));
        continue;
      }
    }
  }

  StringMetricValue* StringMetricValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class StringMetricValue (*this, f, c);
  }

  StringMetricValue& StringMetricValue::
  operator= (const StringMetricValue& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricValue& > (*this) = x;
      this->Value_ = x.Value_;
    }

    return *this;
  }

  StringMetricValue::
  ~StringMetricValue ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, StringMetricValue >
  _xsd_StringMetricValue_type_factory_init (
    "StringMetricValue",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // RealTimeValueType
  //

  RealTimeValueType::
  RealTimeValueType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal > (e, f, this)
  {
  }

  RealTimeValueType::
  RealTimeValueType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal > (a, f, this)
  {
  }

  RealTimeValueType::
  RealTimeValueType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, this)
  {
  }

  RealTimeValueType* RealTimeValueType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RealTimeValueType (*this, f, c);
  }

  RealTimeValueType::
  ~RealTimeValueType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RealTimeValueType >
  _xsd_RealTimeValueType_type_factory_init (
    "RealTimeValueType",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SampleArrayValue
  //

  SampleArrayValue::
  SampleArrayValue (const MetricQualityType& MetricQuality)
  : ::CDM::AbstractMetricValue (MetricQuality),
    ApplyAnnotation_ (this),
    Samples_ (this)
  {
  }

  SampleArrayValue::
  SampleArrayValue (::std::unique_ptr< MetricQualityType > MetricQuality)
  : ::CDM::AbstractMetricValue (std::move (MetricQuality)),
    ApplyAnnotation_ (this),
    Samples_ (this)
  {
  }

  SampleArrayValue::
  SampleArrayValue (const SampleArrayValue& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::CDM::AbstractMetricValue (x, f, c),
    ApplyAnnotation_ (x.ApplyAnnotation_, f, this),
    Samples_ (x.Samples_, f, this)
  {
  }

  SampleArrayValue::
  SampleArrayValue (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::CDM::AbstractMetricValue (e, f | ::xml_schema::Flags::base, c),
    ApplyAnnotation_ (this),
    Samples_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SampleArrayValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricValue::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ApplyAnnotation
      //
      if (n.name () == "ApplyAnnotation" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< ApplyAnnotationType > r (
          ApplyAnnotationTraits::create (i, f, this));

        this->ApplyAnnotation_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Samples" && n.namespace_ ().empty ())
      {
        this->Samples_.set (SamplesTraits::create (i, f, this));
        continue;
      }
    }
  }

  SampleArrayValue* SampleArrayValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SampleArrayValue (*this, f, c);
  }

  SampleArrayValue& SampleArrayValue::
  operator= (const SampleArrayValue& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricValue& > (*this) = x;
      this->ApplyAnnotation_ = x.ApplyAnnotation_;
      this->Samples_ = x.Samples_;
    }

    return *this;
  }

  SampleArrayValue::
  ~SampleArrayValue ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SampleArrayValue >
  _xsd_SampleArrayValue_type_factory_init (
    "SampleArrayValue",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // MetricCategory
  //

  MetricCategory::
  MetricCategory (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_MetricCategory_convert ();
  }

  MetricCategory::
  MetricCategory (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_MetricCategory_convert ();
  }

  MetricCategory::
  MetricCategory (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_MetricCategory_convert ();
  }

  MetricCategory* MetricCategory::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MetricCategory (*this, f, c);
  }

  MetricCategory::Value MetricCategory::
  _xsd_MetricCategory_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MetricCategory_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_MetricCategory_indexes_,
                      _xsd_MetricCategory_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_MetricCategory_indexes_ + 6 || _xsd_MetricCategory_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const MetricCategory::
  _xsd_MetricCategory_literals_[6] =
  {
    "Unspec",
    "Msrmt",
    "Clc",
    "Set",
    "Preset",
    "Rcmm"
  };

  const MetricCategory::Value MetricCategory::
  _xsd_MetricCategory_indexes_[6] =
  {
    ::CDM::MetricCategory::Clc,
    ::CDM::MetricCategory::Msrmt,
    ::CDM::MetricCategory::Preset,
    ::CDM::MetricCategory::Rcmm,
    ::CDM::MetricCategory::Set,
    ::CDM::MetricCategory::Unspec
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MetricCategory >
  _xsd_MetricCategory_type_factory_init (
    "MetricCategory",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // DerivationMethod
  //

  DerivationMethod::
  DerivationMethod (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_DerivationMethod_convert ();
  }

  DerivationMethod::
  DerivationMethod (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_DerivationMethod_convert ();
  }

  DerivationMethod::
  DerivationMethod (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_DerivationMethod_convert ();
  }

  DerivationMethod* DerivationMethod::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DerivationMethod (*this, f, c);
  }

  DerivationMethod::Value DerivationMethod::
  _xsd_DerivationMethod_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_DerivationMethod_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_DerivationMethod_indexes_,
                      _xsd_DerivationMethod_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_DerivationMethod_indexes_ + 2 || _xsd_DerivationMethod_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const DerivationMethod::
  _xsd_DerivationMethod_literals_[2] =
  {
    "Auto",
    "Man"
  };

  const DerivationMethod::Value DerivationMethod::
  _xsd_DerivationMethod_indexes_[2] =
  {
    ::CDM::DerivationMethod::Auto,
    ::CDM::DerivationMethod::Man
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, DerivationMethod >
  _xsd_DerivationMethod_type_factory_init (
    "DerivationMethod",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // MetricAvailability
  //

  MetricAvailability::
  MetricAvailability (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_MetricAvailability_convert ();
  }

  MetricAvailability::
  MetricAvailability (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_MetricAvailability_convert ();
  }

  MetricAvailability::
  MetricAvailability (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_MetricAvailability_convert ();
  }

  MetricAvailability* MetricAvailability::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MetricAvailability (*this, f, c);
  }

  MetricAvailability::Value MetricAvailability::
  _xsd_MetricAvailability_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MetricAvailability_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_MetricAvailability_indexes_,
                      _xsd_MetricAvailability_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_MetricAvailability_indexes_ + 2 || _xsd_MetricAvailability_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const MetricAvailability::
  _xsd_MetricAvailability_literals_[2] =
  {
    "Intr",
    "Cont"
  };

  const MetricAvailability::Value MetricAvailability::
  _xsd_MetricAvailability_indexes_[2] =
  {
    ::CDM::MetricAvailability::Cont,
    ::CDM::MetricAvailability::Intr
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MetricAvailability >
  _xsd_MetricAvailability_type_factory_init (
    "MetricAvailability",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // EntryRef
  //

  EntryRef::
  EntryRef (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (e, f, c),
    ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (e, f, this)
  {
  }

  EntryRef::
  EntryRef (const ::xercesc::DOMAttr& a,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (a, f, c),
    ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (a, f, this)
  {
  }

  EntryRef::
  EntryRef (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (s, e, f, c),
    ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (s, e, f, this)
  {
  }

  EntryRef* EntryRef::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EntryRef (*this, f, c);
  }

  EntryRef::
  ~EntryRef ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EntryRef >
  _xsd_EntryRef_type_factory_init (
    "EntryRef",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AbstractMetricDescriptor
  //

  AbstractMetricDescriptor::
  AbstractMetricDescriptor (const HandleType& Handle,
                            const UnitType& Unit,
                            const MetricCategoryType& MetricCategory,
                            const MetricAvailabilityType& MetricAvailability)
  : ::CDM::AbstractDescriptor (Handle),
    Unit_ (Unit, this),
    BodySite_ (this),
    Relation_ (this),
    MetricCategory_ (MetricCategory, this),
    DerivationMethod_ (this),
    MetricAvailability_ (MetricAvailability, this),
    MaxMeasurementTime_ (this),
    MaxDelayTime_ (this),
    DeterminationPeriod_ (this),
    LifeTimePeriod_ (this),
    ActivationDuration_ (this)
  {
  }

  AbstractMetricDescriptor::
  AbstractMetricDescriptor (const HandleType& Handle,
                            ::std::unique_ptr< UnitType > Unit,
                            const MetricCategoryType& MetricCategory,
                            const MetricAvailabilityType& MetricAvailability)
  : ::CDM::AbstractDescriptor (Handle),
    Unit_ (std::move (Unit), this),
    BodySite_ (this),
    Relation_ (this),
    MetricCategory_ (MetricCategory, this),
    DerivationMethod_ (this),
    MetricAvailability_ (MetricAvailability, this),
    MaxMeasurementTime_ (this),
    MaxDelayTime_ (this),
    DeterminationPeriod_ (this),
    LifeTimePeriod_ (this),
    ActivationDuration_ (this)
  {
  }

  AbstractMetricDescriptor::
  AbstractMetricDescriptor (const AbstractMetricDescriptor& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (x, f, c),
    Unit_ (x.Unit_, f, this),
    BodySite_ (x.BodySite_, f, this),
    Relation_ (x.Relation_, f, this),
    MetricCategory_ (x.MetricCategory_, f, this),
    DerivationMethod_ (x.DerivationMethod_, f, this),
    MetricAvailability_ (x.MetricAvailability_, f, this),
    MaxMeasurementTime_ (x.MaxMeasurementTime_, f, this),
    MaxDelayTime_ (x.MaxDelayTime_, f, this),
    DeterminationPeriod_ (x.DeterminationPeriod_, f, this),
    LifeTimePeriod_ (x.LifeTimePeriod_, f, this),
    ActivationDuration_ (x.ActivationDuration_, f, this)
  {
  }

  AbstractMetricDescriptor::
  AbstractMetricDescriptor (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (e, f | ::xml_schema::Flags::base, c),
    Unit_ (this),
    BodySite_ (this),
    Relation_ (this),
    MetricCategory_ (this),
    DerivationMethod_ (this),
    MetricAvailability_ (this),
    MaxMeasurementTime_ (this),
    MaxDelayTime_ (this),
    DeterminationPeriod_ (this),
    LifeTimePeriod_ (this),
    ActivationDuration_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractMetricDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Unit
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Unit",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< UnitType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Unit_.present ())
          {
            ::std::unique_ptr< UnitType > r (
              dynamic_cast< UnitType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Unit_.set (::std::move (r));
            continue;
          }
        }
      }

      // BodySite
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "BodySite",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< BodySiteType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< BodySiteType > r (
            dynamic_cast< BodySiteType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->BodySite_.push_back (::std::move (r));
          continue;
        }
      }

      // Relation
      //
      if (n.name () == "Relation" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< RelationType > r (
          RelationTraits::create (i, f, this));

        this->Relation_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!Unit_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Unit",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MetricCategory" && n.namespace_ ().empty ())
      {
        this->MetricCategory_.set (MetricCategoryTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "DerivationMethod" && n.namespace_ ().empty ())
      {
        this->DerivationMethod_.set (DerivationMethodTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "MetricAvailability" && n.namespace_ ().empty ())
      {
        this->MetricAvailability_.set (MetricAvailabilityTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "MaxMeasurementTime" && n.namespace_ ().empty ())
      {
        this->MaxMeasurementTime_.set (MaxMeasurementTimeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "MaxDelayTime" && n.namespace_ ().empty ())
      {
        this->MaxDelayTime_.set (MaxDelayTimeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "DeterminationPeriod" && n.namespace_ ().empty ())
      {
        this->DeterminationPeriod_.set (DeterminationPeriodTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "LifeTimePeriod" && n.namespace_ ().empty ())
      {
        this->LifeTimePeriod_.set (LifeTimePeriodTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ActivationDuration" && n.namespace_ ().empty ())
      {
        this->ActivationDuration_.set (ActivationDurationTraits::create (i, f, this));
        continue;
      }
    }

    if (!MetricCategory_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "MetricCategory",
        "");
    }

    if (!MetricAvailability_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "MetricAvailability",
        "");
    }
  }

  AbstractMetricDescriptor* AbstractMetricDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractMetricDescriptor (*this, f, c);
  }

  AbstractMetricDescriptor& AbstractMetricDescriptor::
  operator= (const AbstractMetricDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDescriptor& > (*this) = x;
      this->Unit_ = x.Unit_;
      this->BodySite_ = x.BodySite_;
      this->Relation_ = x.Relation_;
      this->MetricCategory_ = x.MetricCategory_;
      this->DerivationMethod_ = x.DerivationMethod_;
      this->MetricAvailability_ = x.MetricAvailability_;
      this->MaxMeasurementTime_ = x.MaxMeasurementTime_;
      this->MaxDelayTime_ = x.MaxDelayTime_;
      this->DeterminationPeriod_ = x.DeterminationPeriod_;
      this->LifeTimePeriod_ = x.LifeTimePeriod_;
      this->ActivationDuration_ = x.ActivationDuration_;
    }

    return *this;
  }

  AbstractMetricDescriptor::
  ~AbstractMetricDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractMetricDescriptor >
  _xsd_AbstractMetricDescriptor_type_factory_init (
    "AbstractMetricDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AbstractMetricState
  //

  AbstractMetricState::
  AbstractMetricState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractState (DescriptorHandle),
    BodySite_ (this),
    PhysicalConnector_ (this),
    ActivationState_ (this),
    ActiveDeterminationPeriod_ (this),
    LifeTimePeriod_ (this)
  {
  }

  AbstractMetricState::
  AbstractMetricState (const AbstractMetricState& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::AbstractState (x, f, c),
    BodySite_ (x.BodySite_, f, this),
    PhysicalConnector_ (x.PhysicalConnector_, f, this),
    ActivationState_ (x.ActivationState_, f, this),
    ActiveDeterminationPeriod_ (x.ActiveDeterminationPeriod_, f, this),
    LifeTimePeriod_ (x.LifeTimePeriod_, f, this)
  {
  }

  AbstractMetricState::
  AbstractMetricState (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::AbstractState (e, f | ::xml_schema::Flags::base, c),
    BodySite_ (this),
    PhysicalConnector_ (this),
    ActivationState_ (this),
    ActiveDeterminationPeriod_ (this),
    LifeTimePeriod_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractMetricState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // BodySite
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "BodySite",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< BodySiteType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< BodySiteType > r (
            dynamic_cast< BodySiteType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->BodySite_.push_back (::std::move (r));
          continue;
        }
      }

      // PhysicalConnector
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "PhysicalConnector",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< PhysicalConnectorType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->PhysicalConnector_)
          {
            ::std::unique_ptr< PhysicalConnectorType > r (
              dynamic_cast< PhysicalConnectorType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->PhysicalConnector_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ActivationState" && n.namespace_ ().empty ())
      {
        this->ActivationState_.set (ActivationStateTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ActiveDeterminationPeriod" && n.namespace_ ().empty ())
      {
        this->ActiveDeterminationPeriod_.set (ActiveDeterminationPeriodTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "LifeTimePeriod" && n.namespace_ ().empty ())
      {
        this->LifeTimePeriod_.set (LifeTimePeriodTraits::create (i, f, this));
        continue;
      }
    }
  }

  AbstractMetricState* AbstractMetricState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractMetricState (*this, f, c);
  }

  AbstractMetricState& AbstractMetricState::
  operator= (const AbstractMetricState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractState& > (*this) = x;
      this->BodySite_ = x.BodySite_;
      this->PhysicalConnector_ = x.PhysicalConnector_;
      this->ActivationState_ = x.ActivationState_;
      this->ActiveDeterminationPeriod_ = x.ActiveDeterminationPeriod_;
      this->LifeTimePeriod_ = x.LifeTimePeriod_;
    }

    return *this;
  }

  AbstractMetricState::
  ~AbstractMetricState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractMetricState >
  _xsd_AbstractMetricState_type_factory_init (
    "AbstractMetricState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // NumericMetricDescriptor
  //

  NumericMetricDescriptor::
  NumericMetricDescriptor (const HandleType& Handle,
                           const UnitType& Unit,
                           const MetricCategoryType& MetricCategory,
                           const MetricAvailabilityType& MetricAvailability,
                           const ResolutionType& Resolution)
  : ::CDM::AbstractMetricDescriptor (Handle,
                                     Unit,
                                     MetricCategory,
                                     MetricAvailability),
    TechnicalRange_ (this),
    Resolution_ (Resolution, this),
    AveragingPeriod_ (this)
  {
  }

  NumericMetricDescriptor::
  NumericMetricDescriptor (const HandleType& Handle,
                           ::std::unique_ptr< UnitType > Unit,
                           const MetricCategoryType& MetricCategory,
                           const MetricAvailabilityType& MetricAvailability,
                           const ResolutionType& Resolution)
  : ::CDM::AbstractMetricDescriptor (Handle,
                                     std::move (Unit),
                                     MetricCategory,
                                     MetricAvailability),
    TechnicalRange_ (this),
    Resolution_ (Resolution, this),
    AveragingPeriod_ (this)
  {
  }

  NumericMetricDescriptor::
  NumericMetricDescriptor (const NumericMetricDescriptor& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::CDM::AbstractMetricDescriptor (x, f, c),
    TechnicalRange_ (x.TechnicalRange_, f, this),
    Resolution_ (x.Resolution_, f, this),
    AveragingPeriod_ (x.AveragingPeriod_, f, this)
  {
  }

  NumericMetricDescriptor::
  NumericMetricDescriptor (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::CDM::AbstractMetricDescriptor (e, f | ::xml_schema::Flags::base, c),
    TechnicalRange_ (this),
    Resolution_ (this),
    AveragingPeriod_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void NumericMetricDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TechnicalRange
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TechnicalRange",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< TechnicalRangeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< TechnicalRangeType > r (
            dynamic_cast< TechnicalRangeType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TechnicalRange_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Resolution" && n.namespace_ ().empty ())
      {
        this->Resolution_.set (ResolutionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "AveragingPeriod" && n.namespace_ ().empty ())
      {
        this->AveragingPeriod_.set (AveragingPeriodTraits::create (i, f, this));
        continue;
      }
    }

    if (!Resolution_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Resolution",
        "");
    }
  }

  NumericMetricDescriptor* NumericMetricDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NumericMetricDescriptor (*this, f, c);
  }

  NumericMetricDescriptor& NumericMetricDescriptor::
  operator= (const NumericMetricDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricDescriptor& > (*this) = x;
      this->TechnicalRange_ = x.TechnicalRange_;
      this->Resolution_ = x.Resolution_;
      this->AveragingPeriod_ = x.AveragingPeriod_;
    }

    return *this;
  }

  NumericMetricDescriptor::
  ~NumericMetricDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, NumericMetricDescriptor >
  _xsd_NumericMetricDescriptor_type_factory_init (
    "NumericMetricDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // NumericMetricState
  //

  NumericMetricState::
  NumericMetricState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractMetricState (DescriptorHandle),
    MetricValue_ (this),
    PhysiologicalRange_ (this),
    ActiveAveragingPeriod_ (this)
  {
  }

  NumericMetricState::
  NumericMetricState (const NumericMetricState& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractMetricState (x, f, c),
    MetricValue_ (x.MetricValue_, f, this),
    PhysiologicalRange_ (x.PhysiologicalRange_, f, this),
    ActiveAveragingPeriod_ (x.ActiveAveragingPeriod_, f, this)
  {
  }

  NumericMetricState::
  NumericMetricState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractMetricState (e, f | ::xml_schema::Flags::base, c),
    MetricValue_ (this),
    PhysiologicalRange_ (this),
    ActiveAveragingPeriod_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void NumericMetricState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MetricValue
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MetricValue",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< MetricValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->MetricValue_)
          {
            ::std::unique_ptr< MetricValueType > r (
              dynamic_cast< MetricValueType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MetricValue_.set (::std::move (r));
            continue;
          }
        }
      }

      // PhysiologicalRange
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "PhysiologicalRange",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< PhysiologicalRangeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< PhysiologicalRangeType > r (
            dynamic_cast< PhysiologicalRangeType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->PhysiologicalRange_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ActiveAveragingPeriod" && n.namespace_ ().empty ())
      {
        this->ActiveAveragingPeriod_.set (ActiveAveragingPeriodTraits::create (i, f, this));
        continue;
      }
    }
  }

  NumericMetricState* NumericMetricState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NumericMetricState (*this, f, c);
  }

  NumericMetricState& NumericMetricState::
  operator= (const NumericMetricState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricState& > (*this) = x;
      this->MetricValue_ = x.MetricValue_;
      this->PhysiologicalRange_ = x.PhysiologicalRange_;
      this->ActiveAveragingPeriod_ = x.ActiveAveragingPeriod_;
    }

    return *this;
  }

  NumericMetricState::
  ~NumericMetricState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, NumericMetricState >
  _xsd_NumericMetricState_type_factory_init (
    "NumericMetricState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // StringMetricDescriptor
  //

  StringMetricDescriptor::
  StringMetricDescriptor (const HandleType& Handle,
                          const UnitType& Unit,
                          const MetricCategoryType& MetricCategory,
                          const MetricAvailabilityType& MetricAvailability)
  : ::CDM::AbstractMetricDescriptor (Handle,
                                     Unit,
                                     MetricCategory,
                                     MetricAvailability)
  {
  }

  StringMetricDescriptor::
  StringMetricDescriptor (const HandleType& Handle,
                          ::std::unique_ptr< UnitType > Unit,
                          const MetricCategoryType& MetricCategory,
                          const MetricAvailabilityType& MetricAvailability)
  : ::CDM::AbstractMetricDescriptor (Handle,
                                     std::move (Unit),
                                     MetricCategory,
                                     MetricAvailability)
  {
  }

  StringMetricDescriptor::
  StringMetricDescriptor (const StringMetricDescriptor& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::AbstractMetricDescriptor (x, f, c)
  {
  }

  StringMetricDescriptor::
  StringMetricDescriptor (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::AbstractMetricDescriptor (e, f, c)
  {
  }

  StringMetricDescriptor* StringMetricDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class StringMetricDescriptor (*this, f, c);
  }

  StringMetricDescriptor::
  ~StringMetricDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, StringMetricDescriptor >
  _xsd_StringMetricDescriptor_type_factory_init (
    "StringMetricDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // StringMetricState
  //

  StringMetricState::
  StringMetricState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractMetricState (DescriptorHandle),
    MetricValue_ (this)
  {
  }

  StringMetricState::
  StringMetricState (const StringMetricState& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::AbstractMetricState (x, f, c),
    MetricValue_ (x.MetricValue_, f, this)
  {
  }

  StringMetricState::
  StringMetricState (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::AbstractMetricState (e, f | ::xml_schema::Flags::base, c),
    MetricValue_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void StringMetricState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MetricValue
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MetricValue",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< MetricValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->MetricValue_)
          {
            ::std::unique_ptr< MetricValueType > r (
              dynamic_cast< MetricValueType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MetricValue_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  StringMetricState* StringMetricState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class StringMetricState (*this, f, c);
  }

  StringMetricState& StringMetricState::
  operator= (const StringMetricState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricState& > (*this) = x;
      this->MetricValue_ = x.MetricValue_;
    }

    return *this;
  }

  StringMetricState::
  ~StringMetricState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, StringMetricState >
  _xsd_StringMetricState_type_factory_init (
    "StringMetricState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // EnumStringMetricDescriptor
  //

  EnumStringMetricDescriptor::
  EnumStringMetricDescriptor (const HandleType& Handle,
                              const UnitType& Unit,
                              const MetricCategoryType& MetricCategory,
                              const MetricAvailabilityType& MetricAvailability)
  : ::CDM::StringMetricDescriptor (Handle,
                                   Unit,
                                   MetricCategory,
                                   MetricAvailability),
    AllowedValue_ (this)
  {
  }

  EnumStringMetricDescriptor::
  EnumStringMetricDescriptor (const HandleType& Handle,
                              ::std::unique_ptr< UnitType > Unit,
                              const MetricCategoryType& MetricCategory,
                              const MetricAvailabilityType& MetricAvailability)
  : ::CDM::StringMetricDescriptor (Handle,
                                   std::move (Unit),
                                   MetricCategory,
                                   MetricAvailability),
    AllowedValue_ (this)
  {
  }

  EnumStringMetricDescriptor::
  EnumStringMetricDescriptor (const EnumStringMetricDescriptor& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::CDM::StringMetricDescriptor (x, f, c),
    AllowedValue_ (x.AllowedValue_, f, this)
  {
  }

  EnumStringMetricDescriptor::
  EnumStringMetricDescriptor (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::CDM::StringMetricDescriptor (e, f | ::xml_schema::Flags::base, c),
    AllowedValue_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void EnumStringMetricDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::StringMetricDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AllowedValue
      //
      if (n.name () == "AllowedValue" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< AllowedValueType > r (
          AllowedValueTraits::create (i, f, this));

        this->AllowedValue_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  EnumStringMetricDescriptor* EnumStringMetricDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EnumStringMetricDescriptor (*this, f, c);
  }

  EnumStringMetricDescriptor& EnumStringMetricDescriptor::
  operator= (const EnumStringMetricDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::StringMetricDescriptor& > (*this) = x;
      this->AllowedValue_ = x.AllowedValue_;
    }

    return *this;
  }

  EnumStringMetricDescriptor::
  ~EnumStringMetricDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumStringMetricDescriptor >
  _xsd_EnumStringMetricDescriptor_type_factory_init (
    "EnumStringMetricDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // EnumStringMetricState
  //

  EnumStringMetricState::
  EnumStringMetricState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::StringMetricState (DescriptorHandle)
  {
  }

  EnumStringMetricState::
  EnumStringMetricState (const EnumStringMetricState& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::StringMetricState (x, f, c)
  {
  }

  EnumStringMetricState::
  EnumStringMetricState (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::StringMetricState (e, f, c)
  {
  }

  EnumStringMetricState* EnumStringMetricState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EnumStringMetricState (*this, f, c);
  }

  EnumStringMetricState::
  ~EnumStringMetricState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumStringMetricState >
  _xsd_EnumStringMetricState_type_factory_init (
    "EnumStringMetricState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // RealTimeSampleArrayMetricDescriptor
  //

  RealTimeSampleArrayMetricDescriptor::
  RealTimeSampleArrayMetricDescriptor (const HandleType& Handle,
                                       const UnitType& Unit,
                                       const MetricCategoryType& MetricCategory,
                                       const MetricAvailabilityType& MetricAvailability,
                                       const ResolutionType& Resolution,
                                       const SamplePeriodType& SamplePeriod)
  : ::CDM::AbstractMetricDescriptor (Handle,
                                     Unit,
                                     MetricCategory,
                                     MetricAvailability),
    TechnicalRange_ (this),
    Resolution_ (Resolution, this),
    SamplePeriod_ (SamplePeriod, this)
  {
  }

  RealTimeSampleArrayMetricDescriptor::
  RealTimeSampleArrayMetricDescriptor (const HandleType& Handle,
                                       ::std::unique_ptr< UnitType > Unit,
                                       const MetricCategoryType& MetricCategory,
                                       const MetricAvailabilityType& MetricAvailability,
                                       const ResolutionType& Resolution,
                                       const SamplePeriodType& SamplePeriod)
  : ::CDM::AbstractMetricDescriptor (Handle,
                                     std::move (Unit),
                                     MetricCategory,
                                     MetricAvailability),
    TechnicalRange_ (this),
    Resolution_ (Resolution, this),
    SamplePeriod_ (SamplePeriod, this)
  {
  }

  RealTimeSampleArrayMetricDescriptor::
  RealTimeSampleArrayMetricDescriptor (const RealTimeSampleArrayMetricDescriptor& x,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::CDM::AbstractMetricDescriptor (x, f, c),
    TechnicalRange_ (x.TechnicalRange_, f, this),
    Resolution_ (x.Resolution_, f, this),
    SamplePeriod_ (x.SamplePeriod_, f, this)
  {
  }

  RealTimeSampleArrayMetricDescriptor::
  RealTimeSampleArrayMetricDescriptor (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::CDM::AbstractMetricDescriptor (e, f | ::xml_schema::Flags::base, c),
    TechnicalRange_ (this),
    Resolution_ (this),
    SamplePeriod_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void RealTimeSampleArrayMetricDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TechnicalRange
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TechnicalRange",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< TechnicalRangeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< TechnicalRangeType > r (
            dynamic_cast< TechnicalRangeType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TechnicalRange_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Resolution" && n.namespace_ ().empty ())
      {
        this->Resolution_.set (ResolutionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "SamplePeriod" && n.namespace_ ().empty ())
      {
        this->SamplePeriod_.set (SamplePeriodTraits::create (i, f, this));
        continue;
      }
    }

    if (!Resolution_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Resolution",
        "");
    }

    if (!SamplePeriod_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "SamplePeriod",
        "");
    }
  }

  RealTimeSampleArrayMetricDescriptor* RealTimeSampleArrayMetricDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RealTimeSampleArrayMetricDescriptor (*this, f, c);
  }

  RealTimeSampleArrayMetricDescriptor& RealTimeSampleArrayMetricDescriptor::
  operator= (const RealTimeSampleArrayMetricDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricDescriptor& > (*this) = x;
      this->TechnicalRange_ = x.TechnicalRange_;
      this->Resolution_ = x.Resolution_;
      this->SamplePeriod_ = x.SamplePeriod_;
    }

    return *this;
  }

  RealTimeSampleArrayMetricDescriptor::
  ~RealTimeSampleArrayMetricDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RealTimeSampleArrayMetricDescriptor >
  _xsd_RealTimeSampleArrayMetricDescriptor_type_factory_init (
    "RealTimeSampleArrayMetricDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // RealTimeSampleArrayMetricState
  //

  RealTimeSampleArrayMetricState::
  RealTimeSampleArrayMetricState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractMetricState (DescriptorHandle),
    MetricValue_ (this),
    PhysiologicalRange_ (this)
  {
  }

  RealTimeSampleArrayMetricState::
  RealTimeSampleArrayMetricState (const RealTimeSampleArrayMetricState& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::CDM::AbstractMetricState (x, f, c),
    MetricValue_ (x.MetricValue_, f, this),
    PhysiologicalRange_ (x.PhysiologicalRange_, f, this)
  {
  }

  RealTimeSampleArrayMetricState::
  RealTimeSampleArrayMetricState (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::CDM::AbstractMetricState (e, f | ::xml_schema::Flags::base, c),
    MetricValue_ (this),
    PhysiologicalRange_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void RealTimeSampleArrayMetricState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MetricValue
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MetricValue",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< MetricValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->MetricValue_)
          {
            ::std::unique_ptr< MetricValueType > r (
              dynamic_cast< MetricValueType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MetricValue_.set (::std::move (r));
            continue;
          }
        }
      }

      // PhysiologicalRange
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "PhysiologicalRange",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< PhysiologicalRangeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< PhysiologicalRangeType > r (
            dynamic_cast< PhysiologicalRangeType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->PhysiologicalRange_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  RealTimeSampleArrayMetricState* RealTimeSampleArrayMetricState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RealTimeSampleArrayMetricState (*this, f, c);
  }

  RealTimeSampleArrayMetricState& RealTimeSampleArrayMetricState::
  operator= (const RealTimeSampleArrayMetricState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricState& > (*this) = x;
      this->MetricValue_ = x.MetricValue_;
      this->PhysiologicalRange_ = x.PhysiologicalRange_;
    }

    return *this;
  }

  RealTimeSampleArrayMetricState::
  ~RealTimeSampleArrayMetricState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RealTimeSampleArrayMetricState >
  _xsd_RealTimeSampleArrayMetricState_type_factory_init (
    "RealTimeSampleArrayMetricState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // DistributionSampleArrayMetricDescriptor
  //

  DistributionSampleArrayMetricDescriptor::
  DistributionSampleArrayMetricDescriptor (const HandleType& Handle,
                                           const UnitType& Unit,
                                           const MetricCategoryType& MetricCategory,
                                           const MetricAvailabilityType& MetricAvailability,
                                           const DomainUnitType& DomainUnit,
                                           const DistributionRangeType& DistributionRange,
                                           const ResolutionType& Resolution)
  : ::CDM::AbstractMetricDescriptor (Handle,
                                     Unit,
                                     MetricCategory,
                                     MetricAvailability),
    TechnicalRange_ (this),
    DomainUnit_ (DomainUnit, this),
    DistributionRange_ (DistributionRange, this),
    Resolution_ (Resolution, this)
  {
  }

  DistributionSampleArrayMetricDescriptor::
  DistributionSampleArrayMetricDescriptor (const HandleType& Handle,
                                           ::std::unique_ptr< UnitType > Unit,
                                           const MetricCategoryType& MetricCategory,
                                           const MetricAvailabilityType& MetricAvailability,
                                           ::std::unique_ptr< DomainUnitType > DomainUnit,
                                           ::std::unique_ptr< DistributionRangeType > DistributionRange,
                                           const ResolutionType& Resolution)
  : ::CDM::AbstractMetricDescriptor (Handle,
                                     std::move (Unit),
                                     MetricCategory,
                                     MetricAvailability),
    TechnicalRange_ (this),
    DomainUnit_ (std::move (DomainUnit), this),
    DistributionRange_ (std::move (DistributionRange), this),
    Resolution_ (Resolution, this)
  {
  }

  DistributionSampleArrayMetricDescriptor::
  DistributionSampleArrayMetricDescriptor (const DistributionSampleArrayMetricDescriptor& x,
                                           ::xml_schema::Flags f,
                                           ::xml_schema::Container* c)
  : ::CDM::AbstractMetricDescriptor (x, f, c),
    TechnicalRange_ (x.TechnicalRange_, f, this),
    DomainUnit_ (x.DomainUnit_, f, this),
    DistributionRange_ (x.DistributionRange_, f, this),
    Resolution_ (x.Resolution_, f, this)
  {
  }

  DistributionSampleArrayMetricDescriptor::
  DistributionSampleArrayMetricDescriptor (const ::xercesc::DOMElement& e,
                                           ::xml_schema::Flags f,
                                           ::xml_schema::Container* c)
  : ::CDM::AbstractMetricDescriptor (e, f | ::xml_schema::Flags::base, c),
    TechnicalRange_ (this),
    DomainUnit_ (this),
    DistributionRange_ (this),
    Resolution_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DistributionSampleArrayMetricDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TechnicalRange
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TechnicalRange",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< TechnicalRangeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< TechnicalRangeType > r (
            dynamic_cast< TechnicalRangeType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TechnicalRange_.push_back (::std::move (r));
          continue;
        }
      }

      // DomainUnit
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DomainUnit",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< DomainUnitType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!DomainUnit_.present ())
          {
            ::std::unique_ptr< DomainUnitType > r (
              dynamic_cast< DomainUnitType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DomainUnit_.set (::std::move (r));
            continue;
          }
        }
      }

      // DistributionRange
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DistributionRange",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< DistributionRangeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!DistributionRange_.present ())
          {
            ::std::unique_ptr< DistributionRangeType > r (
              dynamic_cast< DistributionRangeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DistributionRange_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!DomainUnit_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DomainUnit",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }

    if (!DistributionRange_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DistributionRange",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Resolution" && n.namespace_ ().empty ())
      {
        this->Resolution_.set (ResolutionTraits::create (i, f, this));
        continue;
      }
    }

    if (!Resolution_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Resolution",
        "");
    }
  }

  DistributionSampleArrayMetricDescriptor* DistributionSampleArrayMetricDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DistributionSampleArrayMetricDescriptor (*this, f, c);
  }

  DistributionSampleArrayMetricDescriptor& DistributionSampleArrayMetricDescriptor::
  operator= (const DistributionSampleArrayMetricDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricDescriptor& > (*this) = x;
      this->TechnicalRange_ = x.TechnicalRange_;
      this->DomainUnit_ = x.DomainUnit_;
      this->DistributionRange_ = x.DistributionRange_;
      this->Resolution_ = x.Resolution_;
    }

    return *this;
  }

  DistributionSampleArrayMetricDescriptor::
  ~DistributionSampleArrayMetricDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, DistributionSampleArrayMetricDescriptor >
  _xsd_DistributionSampleArrayMetricDescriptor_type_factory_init (
    "DistributionSampleArrayMetricDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // DistributionSampleArrayMetricState
  //

  DistributionSampleArrayMetricState::
  DistributionSampleArrayMetricState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractMetricState (DescriptorHandle),
    MetricValue_ (this),
    PhysiologicalRange_ (this)
  {
  }

  DistributionSampleArrayMetricState::
  DistributionSampleArrayMetricState (const DistributionSampleArrayMetricState& x,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::CDM::AbstractMetricState (x, f, c),
    MetricValue_ (x.MetricValue_, f, this),
    PhysiologicalRange_ (x.PhysiologicalRange_, f, this)
  {
  }

  DistributionSampleArrayMetricState::
  DistributionSampleArrayMetricState (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::CDM::AbstractMetricState (e, f | ::xml_schema::Flags::base, c),
    MetricValue_ (this),
    PhysiologicalRange_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DistributionSampleArrayMetricState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MetricValue
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MetricValue",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< MetricValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->MetricValue_)
          {
            ::std::unique_ptr< MetricValueType > r (
              dynamic_cast< MetricValueType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MetricValue_.set (::std::move (r));
            continue;
          }
        }
      }

      // PhysiologicalRange
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "PhysiologicalRange",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< PhysiologicalRangeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< PhysiologicalRangeType > r (
            dynamic_cast< PhysiologicalRangeType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->PhysiologicalRange_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  DistributionSampleArrayMetricState* DistributionSampleArrayMetricState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DistributionSampleArrayMetricState (*this, f, c);
  }

  DistributionSampleArrayMetricState& DistributionSampleArrayMetricState::
  operator= (const DistributionSampleArrayMetricState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricState& > (*this) = x;
      this->MetricValue_ = x.MetricValue_;
      this->PhysiologicalRange_ = x.PhysiologicalRange_;
    }

    return *this;
  }

  DistributionSampleArrayMetricState::
  ~DistributionSampleArrayMetricState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, DistributionSampleArrayMetricState >
  _xsd_DistributionSampleArrayMetricState_type_factory_init (
    "DistributionSampleArrayMetricState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // OperationRef
  //

  OperationRef::
  OperationRef (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (e, f, c),
    ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (e, f, this)
  {
  }

  OperationRef::
  OperationRef (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (a, f, c),
    ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (a, f, this)
  {
  }

  OperationRef::
  OperationRef (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (s, e, f, c),
    ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (s, e, f, this)
  {
  }

  OperationRef* OperationRef::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OperationRef (*this, f, c);
  }

  OperationRef::
  ~OperationRef ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OperationRef >
  _xsd_OperationRef_type_factory_init (
    "OperationRef",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // ScoDescriptor
  //

  ScoDescriptor::
  ScoDescriptor (const HandleType& Handle)
  : ::CDM::AbstractDeviceComponentDescriptor (Handle),
    Operation_ (this)
  {
  }

  ScoDescriptor::
  ScoDescriptor (const ScoDescriptor& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentDescriptor (x, f, c),
    Operation_ (x.Operation_, f, this)
  {
  }

  ScoDescriptor::
  ScoDescriptor (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentDescriptor (e, f | ::xml_schema::Flags::base, c),
    Operation_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ScoDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDeviceComponentDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Operation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Operation",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< OperationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< OperationType > r (
            dynamic_cast< OperationType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Operation_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ScoDescriptor* ScoDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ScoDescriptor (*this, f, c);
  }

  ScoDescriptor& ScoDescriptor::
  operator= (const ScoDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDeviceComponentDescriptor& > (*this) = x;
      this->Operation_ = x.Operation_;
    }

    return *this;
  }

  ScoDescriptor::
  ~ScoDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ScoDescriptor >
  _xsd_ScoDescriptor_type_factory_init (
    "ScoDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // ScoState
  //

  ScoState::
  ScoState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractDeviceComponentState (DescriptorHandle),
    OperationGroup_ (this),
    InvocationRequested_ (this),
    InvocationRequired_ (this)
  {
  }

  ScoState::
  ScoState (const ScoState& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentState (x, f, c),
    OperationGroup_ (x.OperationGroup_, f, this),
    InvocationRequested_ (x.InvocationRequested_, f, this),
    InvocationRequired_ (x.InvocationRequired_, f, this)
  {
  }

  ScoState::
  ScoState (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentState (e, f | ::xml_schema::Flags::base, c),
    OperationGroup_ (this),
    InvocationRequested_ (this),
    InvocationRequired_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ScoState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDeviceComponentState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OperationGroup
      //
      if (n.name () == "OperationGroup" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< OperationGroupType > r (
          OperationGroupTraits::create (i, f, this));

        this->OperationGroup_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "InvocationRequested" && n.namespace_ ().empty ())
      {
        this->InvocationRequested_.set (InvocationRequestedTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "InvocationRequired" && n.namespace_ ().empty ())
      {
        this->InvocationRequired_.set (InvocationRequiredTraits::create (i, f, this));
        continue;
      }
    }
  }

  ScoState* ScoState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ScoState (*this, f, c);
  }

  ScoState& ScoState::
  operator= (const ScoState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDeviceComponentState& > (*this) = x;
      this->OperationGroup_ = x.OperationGroup_;
      this->InvocationRequested_ = x.InvocationRequested_;
      this->InvocationRequired_ = x.InvocationRequired_;
    }

    return *this;
  }

  ScoState::
  ~ScoState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ScoState >
  _xsd_ScoState_type_factory_init (
    "ScoState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AbstractOperationDescriptor
  //

  AbstractOperationDescriptor::
  AbstractOperationDescriptor (const HandleType& Handle,
                               const OperationTargetType& OperationTarget)
  : ::CDM::AbstractDescriptor (Handle),
    OperationTarget_ (OperationTarget, this),
    MaxTimeToFinish_ (this),
    InvocationEffectiveTimeout_ (this),
    Retriggerable_ (this),
    AccessLevel_ (this)
  {
  }

  AbstractOperationDescriptor::
  AbstractOperationDescriptor (const AbstractOperationDescriptor& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (x, f, c),
    OperationTarget_ (x.OperationTarget_, f, this),
    MaxTimeToFinish_ (x.MaxTimeToFinish_, f, this),
    InvocationEffectiveTimeout_ (x.InvocationEffectiveTimeout_, f, this),
    Retriggerable_ (x.Retriggerable_, f, this),
    AccessLevel_ (x.AccessLevel_, f, this)
  {
  }

  AbstractOperationDescriptor::
  AbstractOperationDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (e, f | ::xml_schema::Flags::base, c),
    OperationTarget_ (this),
    MaxTimeToFinish_ (this),
    InvocationEffectiveTimeout_ (this),
    Retriggerable_ (this),
    AccessLevel_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractOperationDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDescriptor::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "OperationTarget" && n.namespace_ ().empty ())
      {
        this->OperationTarget_.set (OperationTargetTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "MaxTimeToFinish" && n.namespace_ ().empty ())
      {
        this->MaxTimeToFinish_.set (MaxTimeToFinishTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "InvocationEffectiveTimeout" && n.namespace_ ().empty ())
      {
        this->InvocationEffectiveTimeout_.set (InvocationEffectiveTimeoutTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Retriggerable" && n.namespace_ ().empty ())
      {
        this->Retriggerable_.set (RetriggerableTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "AccessLevel" && n.namespace_ ().empty ())
      {
        this->AccessLevel_.set (AccessLevelTraits::create (i, f, this));
        continue;
      }
    }

    if (!OperationTarget_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "OperationTarget",
        "");
    }
  }

  AbstractOperationDescriptor* AbstractOperationDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractOperationDescriptor (*this, f, c);
  }

  AbstractOperationDescriptor& AbstractOperationDescriptor::
  operator= (const AbstractOperationDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDescriptor& > (*this) = x;
      this->OperationTarget_ = x.OperationTarget_;
      this->MaxTimeToFinish_ = x.MaxTimeToFinish_;
      this->InvocationEffectiveTimeout_ = x.InvocationEffectiveTimeout_;
      this->Retriggerable_ = x.Retriggerable_;
      this->AccessLevel_ = x.AccessLevel_;
    }

    return *this;
  }

  AbstractOperationDescriptor::
  ~AbstractOperationDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractOperationDescriptor >
  _xsd_AbstractOperationDescriptor_type_factory_init (
    "AbstractOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AbstractSetStateOperationDescriptor
  //

  AbstractSetStateOperationDescriptor::
  AbstractSetStateOperationDescriptor (const HandleType& Handle,
                                       const OperationTargetType& OperationTarget)
  : ::CDM::AbstractOperationDescriptor (Handle,
                                        OperationTarget),
    ModifiableData_ (this)
  {
  }

  AbstractSetStateOperationDescriptor::
  AbstractSetStateOperationDescriptor (const AbstractSetStateOperationDescriptor& x,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (x, f, c),
    ModifiableData_ (x.ModifiableData_, f, this)
  {
  }

  AbstractSetStateOperationDescriptor::
  AbstractSetStateOperationDescriptor (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (e, f | ::xml_schema::Flags::base, c),
    ModifiableData_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractSetStateOperationDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractOperationDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ModifiableData
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ModifiableData",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ModifiableDataType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ModifiableDataType > r (
            dynamic_cast< ModifiableDataType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ModifiableData_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  AbstractSetStateOperationDescriptor* AbstractSetStateOperationDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractSetStateOperationDescriptor (*this, f, c);
  }

  AbstractSetStateOperationDescriptor& AbstractSetStateOperationDescriptor::
  operator= (const AbstractSetStateOperationDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractOperationDescriptor& > (*this) = x;
      this->ModifiableData_ = x.ModifiableData_;
    }

    return *this;
  }

  AbstractSetStateOperationDescriptor::
  ~AbstractSetStateOperationDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractSetStateOperationDescriptor >
  _xsd_AbstractSetStateOperationDescriptor_type_factory_init (
    "AbstractSetStateOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // OperatingMode
  //

  OperatingMode::
  OperatingMode (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_OperatingMode_convert ();
  }

  OperatingMode::
  OperatingMode (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_OperatingMode_convert ();
  }

  OperatingMode::
  OperatingMode (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_OperatingMode_convert ();
  }

  OperatingMode* OperatingMode::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OperatingMode (*this, f, c);
  }

  OperatingMode::Value OperatingMode::
  _xsd_OperatingMode_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_OperatingMode_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_OperatingMode_indexes_,
                      _xsd_OperatingMode_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_OperatingMode_indexes_ + 3 || _xsd_OperatingMode_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const OperatingMode::
  _xsd_OperatingMode_literals_[3] =
  {
    "Dis",
    "En",
    "NA"
  };

  const OperatingMode::Value OperatingMode::
  _xsd_OperatingMode_indexes_[3] =
  {
    ::CDM::OperatingMode::Dis,
    ::CDM::OperatingMode::En,
    ::CDM::OperatingMode::NA
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OperatingMode >
  _xsd_OperatingMode_type_factory_init (
    "OperatingMode",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AbstractOperationState
  //

  AbstractOperationState::
  AbstractOperationState (const DescriptorHandleType& DescriptorHandle,
                          const OperatingModeType& OperatingMode)
  : ::CDM::AbstractState (DescriptorHandle),
    OperatingMode_ (OperatingMode, this)
  {
  }

  AbstractOperationState::
  AbstractOperationState (const AbstractOperationState& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::AbstractState (x, f, c),
    OperatingMode_ (x.OperatingMode_, f, this)
  {
  }

  AbstractOperationState::
  AbstractOperationState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::AbstractState (e, f | ::xml_schema::Flags::base, c),
    OperatingMode_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractOperationState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractState::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "OperatingMode" && n.namespace_ ().empty ())
      {
        this->OperatingMode_.set (OperatingModeTraits::create (i, f, this));
        continue;
      }
    }

    if (!OperatingMode_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "OperatingMode",
        "");
    }
  }

  AbstractOperationState* AbstractOperationState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractOperationState (*this, f, c);
  }

  AbstractOperationState& AbstractOperationState::
  operator= (const AbstractOperationState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractState& > (*this) = x;
      this->OperatingMode_ = x.OperatingMode_;
    }

    return *this;
  }

  AbstractOperationState::
  ~AbstractOperationState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractOperationState >
  _xsd_AbstractOperationState_type_factory_init (
    "AbstractOperationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SetValueOperationDescriptor
  //

  SetValueOperationDescriptor::
  SetValueOperationDescriptor (const HandleType& Handle,
                               const OperationTargetType& OperationTarget)
  : ::CDM::AbstractOperationDescriptor (Handle,
                                        OperationTarget)
  {
  }

  SetValueOperationDescriptor::
  SetValueOperationDescriptor (const SetValueOperationDescriptor& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (x, f, c)
  {
  }

  SetValueOperationDescriptor::
  SetValueOperationDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (e, f, c)
  {
  }

  SetValueOperationDescriptor* SetValueOperationDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetValueOperationDescriptor (*this, f, c);
  }

  SetValueOperationDescriptor::
  ~SetValueOperationDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetValueOperationDescriptor >
  _xsd_SetValueOperationDescriptor_type_factory_init (
    "SetValueOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SetValueOperationState
  //

  SetValueOperationState::
  SetValueOperationState (const DescriptorHandleType& DescriptorHandle,
                          const OperatingModeType& OperatingMode)
  : ::CDM::AbstractOperationState (DescriptorHandle,
                                   OperatingMode),
    AllowedRange_ (this)
  {
  }

  SetValueOperationState::
  SetValueOperationState (const SetValueOperationState& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::AbstractOperationState (x, f, c),
    AllowedRange_ (x.AllowedRange_, f, this)
  {
  }

  SetValueOperationState::
  SetValueOperationState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::AbstractOperationState (e, f | ::xml_schema::Flags::base, c),
    AllowedRange_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SetValueOperationState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractOperationState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AllowedRange
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AllowedRange",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< AllowedRangeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< AllowedRangeType > r (
            dynamic_cast< AllowedRangeType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->AllowedRange_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SetValueOperationState* SetValueOperationState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetValueOperationState (*this, f, c);
  }

  SetValueOperationState& SetValueOperationState::
  operator= (const SetValueOperationState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractOperationState& > (*this) = x;
      this->AllowedRange_ = x.AllowedRange_;
    }

    return *this;
  }

  SetValueOperationState::
  ~SetValueOperationState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetValueOperationState >
  _xsd_SetValueOperationState_type_factory_init (
    "SetValueOperationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SetStringOperationDescriptor
  //

  SetStringOperationDescriptor::
  SetStringOperationDescriptor (const HandleType& Handle,
                                const OperationTargetType& OperationTarget)
  : ::CDM::AbstractOperationDescriptor (Handle,
                                        OperationTarget),
    MaxLength_ (this)
  {
  }

  SetStringOperationDescriptor::
  SetStringOperationDescriptor (const SetStringOperationDescriptor& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (x, f, c),
    MaxLength_ (x.MaxLength_, f, this)
  {
  }

  SetStringOperationDescriptor::
  SetStringOperationDescriptor (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (e, f | ::xml_schema::Flags::base, c),
    MaxLength_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SetStringOperationDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractOperationDescriptor::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MaxLength" && n.namespace_ ().empty ())
      {
        this->MaxLength_.set (MaxLengthTraits::create (i, f, this));
        continue;
      }
    }
  }

  SetStringOperationDescriptor* SetStringOperationDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetStringOperationDescriptor (*this, f, c);
  }

  SetStringOperationDescriptor& SetStringOperationDescriptor::
  operator= (const SetStringOperationDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractOperationDescriptor& > (*this) = x;
      this->MaxLength_ = x.MaxLength_;
    }

    return *this;
  }

  SetStringOperationDescriptor::
  ~SetStringOperationDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetStringOperationDescriptor >
  _xsd_SetStringOperationDescriptor_type_factory_init (
    "SetStringOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SetStringOperationState
  //

  SetStringOperationState::
  SetStringOperationState (const DescriptorHandleType& DescriptorHandle,
                           const OperatingModeType& OperatingMode)
  : ::CDM::AbstractOperationState (DescriptorHandle,
                                   OperatingMode),
    AllowedValues_ (this)
  {
  }

  SetStringOperationState::
  SetStringOperationState (const SetStringOperationState& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::CDM::AbstractOperationState (x, f, c),
    AllowedValues_ (x.AllowedValues_, f, this)
  {
  }

  SetStringOperationState::
  SetStringOperationState (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::CDM::AbstractOperationState (e, f | ::xml_schema::Flags::base, c),
    AllowedValues_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SetStringOperationState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractOperationState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AllowedValues
      //
      if (n.name () == "AllowedValues" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< AllowedValuesType > r (
          AllowedValuesTraits::create (i, f, this));

        if (!this->AllowedValues_)
        {
          this->AllowedValues_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SetStringOperationState* SetStringOperationState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetStringOperationState (*this, f, c);
  }

  SetStringOperationState& SetStringOperationState::
  operator= (const SetStringOperationState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractOperationState& > (*this) = x;
      this->AllowedValues_ = x.AllowedValues_;
    }

    return *this;
  }

  SetStringOperationState::
  ~SetStringOperationState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetStringOperationState >
  _xsd_SetStringOperationState_type_factory_init (
    "SetStringOperationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // ActivateOperationDescriptor
  //

  ActivateOperationDescriptor::
  ActivateOperationDescriptor (const HandleType& Handle,
                               const OperationTargetType& OperationTarget)
  : ::CDM::AbstractSetStateOperationDescriptor (Handle,
                                                OperationTarget),
    Argument_ (this)
  {
  }

  ActivateOperationDescriptor::
  ActivateOperationDescriptor (const ActivateOperationDescriptor& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::AbstractSetStateOperationDescriptor (x, f, c),
    Argument_ (x.Argument_, f, this)
  {
  }

  ActivateOperationDescriptor::
  ActivateOperationDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::AbstractSetStateOperationDescriptor (e, f | ::xml_schema::Flags::base, c),
    Argument_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ActivateOperationDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractSetStateOperationDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Argument
      //
      if (n.name () == "Argument" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< ArgumentType > r (
          ArgumentTraits::create (i, f, this));

        this->Argument_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ActivateOperationDescriptor* ActivateOperationDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ActivateOperationDescriptor (*this, f, c);
  }

  ActivateOperationDescriptor& ActivateOperationDescriptor::
  operator= (const ActivateOperationDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractSetStateOperationDescriptor& > (*this) = x;
      this->Argument_ = x.Argument_;
    }

    return *this;
  }

  ActivateOperationDescriptor::
  ~ActivateOperationDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ActivateOperationDescriptor >
  _xsd_ActivateOperationDescriptor_type_factory_init (
    "ActivateOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // ActivateOperationState
  //

  ActivateOperationState::
  ActivateOperationState (const DescriptorHandleType& DescriptorHandle,
                          const OperatingModeType& OperatingMode)
  : ::CDM::AbstractOperationState (DescriptorHandle,
                                   OperatingMode)
  {
  }

  ActivateOperationState::
  ActivateOperationState (const ActivateOperationState& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::AbstractOperationState (x, f, c)
  {
  }

  ActivateOperationState::
  ActivateOperationState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::AbstractOperationState (e, f, c)
  {
  }

  ActivateOperationState* ActivateOperationState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ActivateOperationState (*this, f, c);
  }

  ActivateOperationState::
  ~ActivateOperationState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ActivateOperationState >
  _xsd_ActivateOperationState_type_factory_init (
    "ActivateOperationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SetContextStateOperationDescriptor
  //

  SetContextStateOperationDescriptor::
  SetContextStateOperationDescriptor (const HandleType& Handle,
                                      const OperationTargetType& OperationTarget)
  : ::CDM::AbstractSetStateOperationDescriptor (Handle,
                                                OperationTarget)
  {
  }

  SetContextStateOperationDescriptor::
  SetContextStateOperationDescriptor (const SetContextStateOperationDescriptor& x,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::CDM::AbstractSetStateOperationDescriptor (x, f, c)
  {
  }

  SetContextStateOperationDescriptor::
  SetContextStateOperationDescriptor (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::CDM::AbstractSetStateOperationDescriptor (e, f, c)
  {
  }

  SetContextStateOperationDescriptor* SetContextStateOperationDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetContextStateOperationDescriptor (*this, f, c);
  }

  SetContextStateOperationDescriptor::
  ~SetContextStateOperationDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetContextStateOperationDescriptor >
  _xsd_SetContextStateOperationDescriptor_type_factory_init (
    "SetContextStateOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SetContextStateOperationState
  //

  SetContextStateOperationState::
  SetContextStateOperationState (const DescriptorHandleType& DescriptorHandle,
                                 const OperatingModeType& OperatingMode)
  : ::CDM::AbstractOperationState (DescriptorHandle,
                                   OperatingMode)
  {
  }

  SetContextStateOperationState::
  SetContextStateOperationState (const SetContextStateOperationState& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::CDM::AbstractOperationState (x, f, c)
  {
  }

  SetContextStateOperationState::
  SetContextStateOperationState (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::CDM::AbstractOperationState (e, f, c)
  {
  }

  SetContextStateOperationState* SetContextStateOperationState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetContextStateOperationState (*this, f, c);
  }

  SetContextStateOperationState::
  ~SetContextStateOperationState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetContextStateOperationState >
  _xsd_SetContextStateOperationState_type_factory_init (
    "SetContextStateOperationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SetMetricStateOperationDescriptor
  //

  SetMetricStateOperationDescriptor::
  SetMetricStateOperationDescriptor (const HandleType& Handle,
                                     const OperationTargetType& OperationTarget)
  : ::CDM::AbstractSetStateOperationDescriptor (Handle,
                                                OperationTarget)
  {
  }

  SetMetricStateOperationDescriptor::
  SetMetricStateOperationDescriptor (const SetMetricStateOperationDescriptor& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::CDM::AbstractSetStateOperationDescriptor (x, f, c)
  {
  }

  SetMetricStateOperationDescriptor::
  SetMetricStateOperationDescriptor (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::CDM::AbstractSetStateOperationDescriptor (e, f, c)
  {
  }

  SetMetricStateOperationDescriptor* SetMetricStateOperationDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetMetricStateOperationDescriptor (*this, f, c);
  }

  SetMetricStateOperationDescriptor::
  ~SetMetricStateOperationDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetMetricStateOperationDescriptor >
  _xsd_SetMetricStateOperationDescriptor_type_factory_init (
    "SetMetricStateOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SetMetricStateOperationState
  //

  SetMetricStateOperationState::
  SetMetricStateOperationState (const DescriptorHandleType& DescriptorHandle,
                                const OperatingModeType& OperatingMode)
  : ::CDM::AbstractOperationState (DescriptorHandle,
                                   OperatingMode)
  {
  }

  SetMetricStateOperationState::
  SetMetricStateOperationState (const SetMetricStateOperationState& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::CDM::AbstractOperationState (x, f, c)
  {
  }

  SetMetricStateOperationState::
  SetMetricStateOperationState (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::CDM::AbstractOperationState (e, f, c)
  {
  }

  SetMetricStateOperationState* SetMetricStateOperationState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetMetricStateOperationState (*this, f, c);
  }

  SetMetricStateOperationState::
  ~SetMetricStateOperationState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetMetricStateOperationState >
  _xsd_SetMetricStateOperationState_type_factory_init (
    "SetMetricStateOperationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SetComponentStateOperationDescriptor
  //

  SetComponentStateOperationDescriptor::
  SetComponentStateOperationDescriptor (const HandleType& Handle,
                                        const OperationTargetType& OperationTarget)
  : ::CDM::AbstractSetStateOperationDescriptor (Handle,
                                                OperationTarget)
  {
  }

  SetComponentStateOperationDescriptor::
  SetComponentStateOperationDescriptor (const SetComponentStateOperationDescriptor& x,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::CDM::AbstractSetStateOperationDescriptor (x, f, c)
  {
  }

  SetComponentStateOperationDescriptor::
  SetComponentStateOperationDescriptor (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::CDM::AbstractSetStateOperationDescriptor (e, f, c)
  {
  }

  SetComponentStateOperationDescriptor* SetComponentStateOperationDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetComponentStateOperationDescriptor (*this, f, c);
  }

  SetComponentStateOperationDescriptor::
  ~SetComponentStateOperationDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetComponentStateOperationDescriptor >
  _xsd_SetComponentStateOperationDescriptor_type_factory_init (
    "SetComponentStateOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SetComponentStateOperationState
  //

  SetComponentStateOperationState::
  SetComponentStateOperationState (const DescriptorHandleType& DescriptorHandle,
                                   const OperatingModeType& OperatingMode)
  : ::CDM::AbstractOperationState (DescriptorHandle,
                                   OperatingMode)
  {
  }

  SetComponentStateOperationState::
  SetComponentStateOperationState (const SetComponentStateOperationState& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::CDM::AbstractOperationState (x, f, c)
  {
  }

  SetComponentStateOperationState::
  SetComponentStateOperationState (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::CDM::AbstractOperationState (e, f, c)
  {
  }

  SetComponentStateOperationState* SetComponentStateOperationState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetComponentStateOperationState (*this, f, c);
  }

  SetComponentStateOperationState::
  ~SetComponentStateOperationState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetComponentStateOperationState >
  _xsd_SetComponentStateOperationState_type_factory_init (
    "SetComponentStateOperationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SetAlertStateOperationDescriptor
  //

  SetAlertStateOperationDescriptor::
  SetAlertStateOperationDescriptor (const HandleType& Handle,
                                    const OperationTargetType& OperationTarget)
  : ::CDM::AbstractSetStateOperationDescriptor (Handle,
                                                OperationTarget)
  {
  }

  SetAlertStateOperationDescriptor::
  SetAlertStateOperationDescriptor (const SetAlertStateOperationDescriptor& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::CDM::AbstractSetStateOperationDescriptor (x, f, c)
  {
  }

  SetAlertStateOperationDescriptor::
  SetAlertStateOperationDescriptor (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::CDM::AbstractSetStateOperationDescriptor (e, f, c)
  {
  }

  SetAlertStateOperationDescriptor* SetAlertStateOperationDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetAlertStateOperationDescriptor (*this, f, c);
  }

  SetAlertStateOperationDescriptor::
  ~SetAlertStateOperationDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetAlertStateOperationDescriptor >
  _xsd_SetAlertStateOperationDescriptor_type_factory_init (
    "SetAlertStateOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SetAlertStateOperationState
  //

  SetAlertStateOperationState::
  SetAlertStateOperationState (const DescriptorHandleType& DescriptorHandle,
                               const OperatingModeType& OperatingMode)
  : ::CDM::AbstractOperationState (DescriptorHandle,
                                   OperatingMode)
  {
  }

  SetAlertStateOperationState::
  SetAlertStateOperationState (const SetAlertStateOperationState& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::AbstractOperationState (x, f, c)
  {
  }

  SetAlertStateOperationState::
  SetAlertStateOperationState (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::AbstractOperationState (e, f, c)
  {
  }

  SetAlertStateOperationState* SetAlertStateOperationState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetAlertStateOperationState (*this, f, c);
  }

  SetAlertStateOperationState::
  ~SetAlertStateOperationState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetAlertStateOperationState >
  _xsd_SetAlertStateOperationState_type_factory_init (
    "SetAlertStateOperationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // TimeZone
  //

  TimeZone::
  TimeZone ()
  : ::xml_schema::String ()
  {
  }

  TimeZone::
  TimeZone (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  TimeZone::
  TimeZone (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  TimeZone::
  TimeZone (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  TimeZone::
  TimeZone (const TimeZone& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  TimeZone::
  TimeZone (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  TimeZone::
  TimeZone (const ::xercesc::DOMAttr& a,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  TimeZone::
  TimeZone (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  TimeZone* TimeZone::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimeZone (*this, f, c);
  }

  TimeZone::
  ~TimeZone ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, TimeZone >
  _xsd_TimeZone_type_factory_init (
    "TimeZone",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // ClockDescriptor
  //

  ClockDescriptor::
  ClockDescriptor (const HandleType& Handle)
  : ::CDM::AbstractDeviceComponentDescriptor (Handle),
    TimeProtocol_ (this),
    Resolution_ (this)
  {
  }

  ClockDescriptor::
  ClockDescriptor (const ClockDescriptor& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentDescriptor (x, f, c),
    TimeProtocol_ (x.TimeProtocol_, f, this),
    Resolution_ (x.Resolution_, f, this)
  {
  }

  ClockDescriptor::
  ClockDescriptor (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentDescriptor (e, f | ::xml_schema::Flags::base, c),
    TimeProtocol_ (this),
    Resolution_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ClockDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDeviceComponentDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TimeProtocol
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TimeProtocol",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< TimeProtocolType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< TimeProtocolType > r (
            dynamic_cast< TimeProtocolType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TimeProtocol_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Resolution" && n.namespace_ ().empty ())
      {
        this->Resolution_.set (ResolutionTraits::create (i, f, this));
        continue;
      }
    }
  }

  ClockDescriptor* ClockDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ClockDescriptor (*this, f, c);
  }

  ClockDescriptor& ClockDescriptor::
  operator= (const ClockDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDeviceComponentDescriptor& > (*this) = x;
      this->TimeProtocol_ = x.TimeProtocol_;
      this->Resolution_ = x.Resolution_;
    }

    return *this;
  }

  ClockDescriptor::
  ~ClockDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ClockDescriptor >
  _xsd_ClockDescriptor_type_factory_init (
    "ClockDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // ClockState
  //

  ClockState::
  ClockState (const DescriptorHandleType& DescriptorHandle,
              const RemoteSyncType& RemoteSync)
  : ::CDM::AbstractDeviceComponentState (DescriptorHandle),
    ActiveSyncProtocol_ (this),
    ReferenceSource_ (this),
    DateAndTime_ (this),
    RemoteSync_ (RemoteSync, this),
    Accuracy_ (this),
    LastSet_ (this),
    TimeZone_ (this),
    CriticalUse_ (this)
  {
  }

  ClockState::
  ClockState (const ClockState& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentState (x, f, c),
    ActiveSyncProtocol_ (x.ActiveSyncProtocol_, f, this),
    ReferenceSource_ (x.ReferenceSource_, f, this),
    DateAndTime_ (x.DateAndTime_, f, this),
    RemoteSync_ (x.RemoteSync_, f, this),
    Accuracy_ (x.Accuracy_, f, this),
    LastSet_ (x.LastSet_, f, this),
    TimeZone_ (x.TimeZone_, f, this),
    CriticalUse_ (x.CriticalUse_, f, this)
  {
  }

  ClockState::
  ClockState (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentState (e, f | ::xml_schema::Flags::base, c),
    ActiveSyncProtocol_ (this),
    ReferenceSource_ (this),
    DateAndTime_ (this),
    RemoteSync_ (this),
    Accuracy_ (this),
    LastSet_ (this),
    TimeZone_ (this),
    CriticalUse_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ClockState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDeviceComponentState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ActiveSyncProtocol
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ActiveSyncProtocol",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ActiveSyncProtocolType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ActiveSyncProtocol_)
          {
            ::std::unique_ptr< ActiveSyncProtocolType > r (
              dynamic_cast< ActiveSyncProtocolType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ActiveSyncProtocol_.set (::std::move (r));
            continue;
          }
        }
      }

      // ReferenceSource
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ReferenceSource",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ReferenceSourceType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ReferenceSourceType > r (
            dynamic_cast< ReferenceSourceType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ReferenceSource_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "DateAndTime" && n.namespace_ ().empty ())
      {
        this->DateAndTime_.set (DateAndTimeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "RemoteSync" && n.namespace_ ().empty ())
      {
        this->RemoteSync_.set (RemoteSyncTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Accuracy" && n.namespace_ ().empty ())
      {
        this->Accuracy_.set (AccuracyTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "LastSet" && n.namespace_ ().empty ())
      {
        this->LastSet_.set (LastSetTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "TimeZone" && n.namespace_ ().empty ())
      {
        this->TimeZone_.set (TimeZoneTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "CriticalUse" && n.namespace_ ().empty ())
      {
        this->CriticalUse_.set (CriticalUseTraits::create (i, f, this));
        continue;
      }
    }

    if (!RemoteSync_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "RemoteSync",
        "");
    }
  }

  ClockState* ClockState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ClockState (*this, f, c);
  }

  ClockState& ClockState::
  operator= (const ClockState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDeviceComponentState& > (*this) = x;
      this->ActiveSyncProtocol_ = x.ActiveSyncProtocol_;
      this->ReferenceSource_ = x.ReferenceSource_;
      this->DateAndTime_ = x.DateAndTime_;
      this->RemoteSync_ = x.RemoteSync_;
      this->Accuracy_ = x.Accuracy_;
      this->LastSet_ = x.LastSet_;
      this->TimeZone_ = x.TimeZone_;
      this->CriticalUse_ = x.CriticalUse_;
    }

    return *this;
  }

  ClockState::
  ~ClockState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ClockState >
  _xsd_ClockState_type_factory_init (
    "ClockState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // BatteryDescriptor
  //

  BatteryDescriptor::
  BatteryDescriptor (const HandleType& Handle)
  : ::CDM::AbstractDeviceComponentDescriptor (Handle),
    CapacityFullCharge_ (this),
    CapacitySpecified_ (this),
    VoltageSpecified_ (this)
  {
  }

  BatteryDescriptor::
  BatteryDescriptor (const BatteryDescriptor& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentDescriptor (x, f, c),
    CapacityFullCharge_ (x.CapacityFullCharge_, f, this),
    CapacitySpecified_ (x.CapacitySpecified_, f, this),
    VoltageSpecified_ (x.VoltageSpecified_, f, this)
  {
  }

  BatteryDescriptor::
  BatteryDescriptor (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentDescriptor (e, f | ::xml_schema::Flags::base, c),
    CapacityFullCharge_ (this),
    CapacitySpecified_ (this),
    VoltageSpecified_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void BatteryDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDeviceComponentDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CapacityFullCharge
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CapacityFullCharge",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< CapacityFullChargeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CapacityFullCharge_)
          {
            ::std::unique_ptr< CapacityFullChargeType > r (
              dynamic_cast< CapacityFullChargeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CapacityFullCharge_.set (::std::move (r));
            continue;
          }
        }
      }

      // CapacitySpecified
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CapacitySpecified",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< CapacitySpecifiedType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CapacitySpecified_)
          {
            ::std::unique_ptr< CapacitySpecifiedType > r (
              dynamic_cast< CapacitySpecifiedType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CapacitySpecified_.set (::std::move (r));
            continue;
          }
        }
      }

      // VoltageSpecified
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "VoltageSpecified",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< VoltageSpecifiedType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->VoltageSpecified_)
          {
            ::std::unique_ptr< VoltageSpecifiedType > r (
              dynamic_cast< VoltageSpecifiedType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->VoltageSpecified_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  BatteryDescriptor* BatteryDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BatteryDescriptor (*this, f, c);
  }

  BatteryDescriptor& BatteryDescriptor::
  operator= (const BatteryDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDeviceComponentDescriptor& > (*this) = x;
      this->CapacityFullCharge_ = x.CapacityFullCharge_;
      this->CapacitySpecified_ = x.CapacitySpecified_;
      this->VoltageSpecified_ = x.VoltageSpecified_;
    }

    return *this;
  }

  BatteryDescriptor::
  ~BatteryDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, BatteryDescriptor >
  _xsd_BatteryDescriptor_type_factory_init (
    "BatteryDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // BatteryState
  //

  BatteryState::
  BatteryState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractDeviceComponentState (DescriptorHandle),
    CapacityRemaining_ (this),
    Voltage_ (this),
    Current_ (this),
    Temperature_ (this),
    RemainingBatteryTime_ (this),
    ChargeStatus_ (this),
    ChargeCycles_ (this)
  {
  }

  BatteryState::
  BatteryState (const BatteryState& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentState (x, f, c),
    CapacityRemaining_ (x.CapacityRemaining_, f, this),
    Voltage_ (x.Voltage_, f, this),
    Current_ (x.Current_, f, this),
    Temperature_ (x.Temperature_, f, this),
    RemainingBatteryTime_ (x.RemainingBatteryTime_, f, this),
    ChargeStatus_ (x.ChargeStatus_, f, this),
    ChargeCycles_ (x.ChargeCycles_, f, this)
  {
  }

  BatteryState::
  BatteryState (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentState (e, f | ::xml_schema::Flags::base, c),
    CapacityRemaining_ (this),
    Voltage_ (this),
    Current_ (this),
    Temperature_ (this),
    RemainingBatteryTime_ (this),
    ChargeStatus_ (this),
    ChargeCycles_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void BatteryState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDeviceComponentState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CapacityRemaining
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CapacityRemaining",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< CapacityRemainingType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CapacityRemaining_)
          {
            ::std::unique_ptr< CapacityRemainingType > r (
              dynamic_cast< CapacityRemainingType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CapacityRemaining_.set (::std::move (r));
            continue;
          }
        }
      }

      // Voltage
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Voltage",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< VoltageType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Voltage_)
          {
            ::std::unique_ptr< VoltageType > r (
              dynamic_cast< VoltageType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Voltage_.set (::std::move (r));
            continue;
          }
        }
      }

      // Current
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Current",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< CurrentType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Current_)
          {
            ::std::unique_ptr< CurrentType > r (
              dynamic_cast< CurrentType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Current_.set (::std::move (r));
            continue;
          }
        }
      }

      // Temperature
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Temperature",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< TemperatureType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Temperature_)
          {
            ::std::unique_ptr< TemperatureType > r (
              dynamic_cast< TemperatureType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Temperature_.set (::std::move (r));
            continue;
          }
        }
      }

      // RemainingBatteryTime
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "RemainingBatteryTime",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< RemainingBatteryTimeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->RemainingBatteryTime_)
          {
            ::std::unique_ptr< RemainingBatteryTimeType > r (
              dynamic_cast< RemainingBatteryTimeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->RemainingBatteryTime_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ChargeStatus" && n.namespace_ ().empty ())
      {
        this->ChargeStatus_.set (ChargeStatusTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ChargeCycles" && n.namespace_ ().empty ())
      {
        this->ChargeCycles_.set (ChargeCyclesTraits::create (i, f, this));
        continue;
      }
    }
  }

  BatteryState* BatteryState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BatteryState (*this, f, c);
  }

  BatteryState& BatteryState::
  operator= (const BatteryState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDeviceComponentState& > (*this) = x;
      this->CapacityRemaining_ = x.CapacityRemaining_;
      this->Voltage_ = x.Voltage_;
      this->Current_ = x.Current_;
      this->Temperature_ = x.Temperature_;
      this->RemainingBatteryTime_ = x.RemainingBatteryTime_;
      this->ChargeStatus_ = x.ChargeStatus_;
      this->ChargeCycles_ = x.ChargeCycles_;
    }

    return *this;
  }

  BatteryState::
  ~BatteryState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, BatteryState >
  _xsd_BatteryState_type_factory_init (
    "BatteryState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SystemContextDescriptor
  //

  SystemContextDescriptor::
  SystemContextDescriptor (const HandleType& Handle)
  : ::CDM::AbstractDeviceComponentDescriptor (Handle),
    PatientContext_ (this),
    LocationContext_ (this),
    EnsembleContext_ (this),
    OperatorContext_ (this),
    WorkflowContext_ (this),
    MeansContext_ (this)
  {
  }

  SystemContextDescriptor::
  SystemContextDescriptor (const SystemContextDescriptor& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentDescriptor (x, f, c),
    PatientContext_ (x.PatientContext_, f, this),
    LocationContext_ (x.LocationContext_, f, this),
    EnsembleContext_ (x.EnsembleContext_, f, this),
    OperatorContext_ (x.OperatorContext_, f, this),
    WorkflowContext_ (x.WorkflowContext_, f, this),
    MeansContext_ (x.MeansContext_, f, this)
  {
  }

  SystemContextDescriptor::
  SystemContextDescriptor (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentDescriptor (e, f | ::xml_schema::Flags::base, c),
    PatientContext_ (this),
    LocationContext_ (this),
    EnsembleContext_ (this),
    OperatorContext_ (this),
    WorkflowContext_ (this),
    MeansContext_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SystemContextDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDeviceComponentDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PatientContext
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "PatientContext",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< PatientContextType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->PatientContext_)
          {
            ::std::unique_ptr< PatientContextType > r (
              dynamic_cast< PatientContextType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->PatientContext_.set (::std::move (r));
            continue;
          }
        }
      }

      // LocationContext
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "LocationContext",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< LocationContextType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->LocationContext_)
          {
            ::std::unique_ptr< LocationContextType > r (
              dynamic_cast< LocationContextType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->LocationContext_.set (::std::move (r));
            continue;
          }
        }
      }

      // EnsembleContext
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "EnsembleContext",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< EnsembleContextType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< EnsembleContextType > r (
            dynamic_cast< EnsembleContextType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->EnsembleContext_.push_back (::std::move (r));
          continue;
        }
      }

      // OperatorContext
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OperatorContext",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< OperatorContextType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< OperatorContextType > r (
            dynamic_cast< OperatorContextType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->OperatorContext_.push_back (::std::move (r));
          continue;
        }
      }

      // WorkflowContext
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "WorkflowContext",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< WorkflowContextType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< WorkflowContextType > r (
            dynamic_cast< WorkflowContextType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->WorkflowContext_.push_back (::std::move (r));
          continue;
        }
      }

      // MeansContext
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MeansContext",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< MeansContextType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< MeansContextType > r (
            dynamic_cast< MeansContextType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->MeansContext_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SystemContextDescriptor* SystemContextDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SystemContextDescriptor (*this, f, c);
  }

  SystemContextDescriptor& SystemContextDescriptor::
  operator= (const SystemContextDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDeviceComponentDescriptor& > (*this) = x;
      this->PatientContext_ = x.PatientContext_;
      this->LocationContext_ = x.LocationContext_;
      this->EnsembleContext_ = x.EnsembleContext_;
      this->OperatorContext_ = x.OperatorContext_;
      this->WorkflowContext_ = x.WorkflowContext_;
      this->MeansContext_ = x.MeansContext_;
    }

    return *this;
  }

  SystemContextDescriptor::
  ~SystemContextDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SystemContextDescriptor >
  _xsd_SystemContextDescriptor_type_factory_init (
    "SystemContextDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // SystemContextState
  //

  SystemContextState::
  SystemContextState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractDeviceComponentState (DescriptorHandle)
  {
  }

  SystemContextState::
  SystemContextState (const SystemContextState& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentState (x, f, c)
  {
  }

  SystemContextState::
  SystemContextState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponentState (e, f, c)
  {
  }

  SystemContextState* SystemContextState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SystemContextState (*this, f, c);
  }

  SystemContextState::
  ~SystemContextState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SystemContextState >
  _xsd_SystemContextState_type_factory_init (
    "SystemContextState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AbstractContextDescriptor
  //

  AbstractContextDescriptor::
  AbstractContextDescriptor (const HandleType& Handle)
  : ::CDM::AbstractDescriptor (Handle)
  {
  }

  AbstractContextDescriptor::
  AbstractContextDescriptor (const AbstractContextDescriptor& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (x, f, c)
  {
  }

  AbstractContextDescriptor::
  AbstractContextDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (e, f, c)
  {
  }

  AbstractContextDescriptor* AbstractContextDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractContextDescriptor (*this, f, c);
  }

  AbstractContextDescriptor::
  ~AbstractContextDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractContextDescriptor >
  _xsd_AbstractContextDescriptor_type_factory_init (
    "AbstractContextDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // ContextAssociation
  //

  ContextAssociation::
  ContextAssociation (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_ContextAssociation_convert ();
  }

  ContextAssociation::
  ContextAssociation (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_ContextAssociation_convert ();
  }

  ContextAssociation::
  ContextAssociation (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_ContextAssociation_convert ();
  }

  ContextAssociation* ContextAssociation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ContextAssociation (*this, f, c);
  }

  ContextAssociation::Value ContextAssociation::
  _xsd_ContextAssociation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ContextAssociation_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_ContextAssociation_indexes_,
                      _xsd_ContextAssociation_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_ContextAssociation_indexes_ + 4 || _xsd_ContextAssociation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ContextAssociation::
  _xsd_ContextAssociation_literals_[4] =
  {
    "No",
    "Pre",
    "Assoc",
    "Dis"
  };

  const ContextAssociation::Value ContextAssociation::
  _xsd_ContextAssociation_indexes_[4] =
  {
    ::CDM::ContextAssociation::Assoc,
    ::CDM::ContextAssociation::Dis,
    ::CDM::ContextAssociation::No,
    ::CDM::ContextAssociation::Pre
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ContextAssociation >
  _xsd_ContextAssociation_type_factory_init (
    "ContextAssociation",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // AbstractContextState
  //

  AbstractContextState::
  AbstractContextState (const DescriptorHandleType& DescriptorHandle,
                        const HandleType& Handle)
  : ::CDM::AbstractMultiState (DescriptorHandle,
                               Handle),
    Validator_ (this),
    Identification_ (this),
    ContextAssociation_ (this),
    BindingMdibVersion_ (this),
    UnbindingMdibVersion_ (this),
    BindingStartTime_ (this),
    BindingEndTime_ (this)
  {
  }

  AbstractContextState::
  AbstractContextState (const AbstractContextState& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractMultiState (x, f, c),
    Validator_ (x.Validator_, f, this),
    Identification_ (x.Identification_, f, this),
    ContextAssociation_ (x.ContextAssociation_, f, this),
    BindingMdibVersion_ (x.BindingMdibVersion_, f, this),
    UnbindingMdibVersion_ (x.UnbindingMdibVersion_, f, this),
    BindingStartTime_ (x.BindingStartTime_, f, this),
    BindingEndTime_ (x.BindingEndTime_, f, this)
  {
  }

  AbstractContextState::
  AbstractContextState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractMultiState (e, f | ::xml_schema::Flags::base, c),
    Validator_ (this),
    Identification_ (this),
    ContextAssociation_ (this),
    BindingMdibVersion_ (this),
    UnbindingMdibVersion_ (this),
    BindingStartTime_ (this),
    BindingEndTime_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractContextState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMultiState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Validator
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Validator",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ValidatorType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ValidatorType > r (
            dynamic_cast< ValidatorType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Validator_.push_back (::std::move (r));
          continue;
        }
      }

      // Identification
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Identification",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< IdentificationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< IdentificationType > r (
            dynamic_cast< IdentificationType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Identification_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ContextAssociation" && n.namespace_ ().empty ())
      {
        this->ContextAssociation_.set (ContextAssociationTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "BindingMdibVersion" && n.namespace_ ().empty ())
      {
        this->BindingMdibVersion_.set (BindingMdibVersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "UnbindingMdibVersion" && n.namespace_ ().empty ())
      {
        this->UnbindingMdibVersion_.set (UnbindingMdibVersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "BindingStartTime" && n.namespace_ ().empty ())
      {
        this->BindingStartTime_.set (BindingStartTimeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "BindingEndTime" && n.namespace_ ().empty ())
      {
        this->BindingEndTime_.set (BindingEndTimeTraits::create (i, f, this));
        continue;
      }
    }
  }

  AbstractContextState* AbstractContextState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractContextState (*this, f, c);
  }

  AbstractContextState& AbstractContextState::
  operator= (const AbstractContextState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMultiState& > (*this) = x;
      this->Validator_ = x.Validator_;
      this->Identification_ = x.Identification_;
      this->ContextAssociation_ = x.ContextAssociation_;
      this->BindingMdibVersion_ = x.BindingMdibVersion_;
      this->UnbindingMdibVersion_ = x.UnbindingMdibVersion_;
      this->BindingStartTime_ = x.BindingStartTime_;
      this->BindingEndTime_ = x.BindingEndTime_;
    }

    return *this;
  }

  AbstractContextState::
  ~AbstractContextState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractContextState >
  _xsd_AbstractContextState_type_factory_init (
    "AbstractContextState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // BaseDemographics
  //

  BaseDemographics::
  BaseDemographics ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Givenname_ (this),
    Middlename_ (this),
    Familyname_ (this),
    Birthname_ (this),
    Title_ (this)
  {
  }

  BaseDemographics::
  BaseDemographics (const BaseDemographics& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Givenname_ (x.Givenname_, f, this),
    Middlename_ (x.Middlename_, f, this),
    Familyname_ (x.Familyname_, f, this),
    Birthname_ (x.Birthname_, f, this),
    Title_ (x.Title_, f, this)
  {
  }

  BaseDemographics::
  BaseDemographics (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Givenname_ (this),
    Middlename_ (this),
    Familyname_ (this),
    Birthname_ (this),
    Title_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void BaseDemographics::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // Givenname
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Givenname",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< GivennameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Givenname_)
          {
            ::std::unique_ptr< GivennameType > r (
              dynamic_cast< GivennameType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Givenname_.set (::std::move (r));
            continue;
          }
        }
      }

      // Middlename
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Middlename",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< MiddlenameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< MiddlenameType > r (
            dynamic_cast< MiddlenameType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Middlename_.push_back (::std::move (r));
          continue;
        }
      }

      // Familyname
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Familyname",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< FamilynameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Familyname_)
          {
            ::std::unique_ptr< FamilynameType > r (
              dynamic_cast< FamilynameType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Familyname_.set (::std::move (r));
            continue;
          }
        }
      }

      // Birthname
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Birthname",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< BirthnameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Birthname_)
          {
            ::std::unique_ptr< BirthnameType > r (
              dynamic_cast< BirthnameType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Birthname_.set (::std::move (r));
            continue;
          }
        }
      }

      // Title
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Title",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< TitleType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Title_)
          {
            ::std::unique_ptr< TitleType > r (
              dynamic_cast< TitleType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Title_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  BaseDemographics* BaseDemographics::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BaseDemographics (*this, f, c);
  }

  BaseDemographics& BaseDemographics::
  operator= (const BaseDemographics& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Givenname_ = x.Givenname_;
      this->Middlename_ = x.Middlename_;
      this->Familyname_ = x.Familyname_;
      this->Birthname_ = x.Birthname_;
      this->Title_ = x.Title_;
    }

    return *this;
  }

  BaseDemographics::
  ~BaseDemographics ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, BaseDemographics >
  _xsd_BaseDemographics_type_factory_init (
    "BaseDemographics",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // PersonReference
  //

  PersonReference::
  PersonReference ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Identification_ (this),
    Name_ (this)
  {
  }

  PersonReference::
  PersonReference (const PersonReference& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Identification_ (x.Identification_, f, this),
    Name_ (x.Name_, f, this)
  {
  }

  PersonReference::
  PersonReference (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Identification_ (this),
    Name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PersonReference::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // Identification
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Identification",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< IdentificationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< IdentificationType > r (
            dynamic_cast< IdentificationType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Identification_.push_back (::std::move (r));
          continue;
        }
      }

      // Name
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Name",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< NameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Name_)
          {
            ::std::unique_ptr< NameType > r (
              dynamic_cast< NameType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Name_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  PersonReference* PersonReference::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PersonReference (*this, f, c);
  }

  PersonReference& PersonReference::
  operator= (const PersonReference& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Identification_ = x.Identification_;
      this->Name_ = x.Name_;
    }

    return *this;
  }

  PersonReference::
  ~PersonReference ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, PersonReference >
  _xsd_PersonReference_type_factory_init (
    "PersonReference",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // LocationDetail
  //

  LocationDetail::
  LocationDetail ()
  : ::xml_schema::Type (),
    Extension_ (this),
    PoC_ (this),
    Room_ (this),
    Bed_ (this),
    Facility_ (this),
    Building_ (this),
    Floor_ (this)
  {
  }

  LocationDetail::
  LocationDetail (const LocationDetail& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    PoC_ (x.PoC_, f, this),
    Room_ (x.Room_, f, this),
    Bed_ (x.Bed_, f, this),
    Facility_ (x.Facility_, f, this),
    Building_ (x.Building_, f, this),
    Floor_ (x.Floor_, f, this)
  {
  }

  LocationDetail::
  LocationDetail (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    PoC_ (this),
    Room_ (this),
    Bed_ (this),
    Facility_ (this),
    Building_ (this),
    Floor_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void LocationDetail::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "PoC" && n.namespace_ ().empty ())
      {
        this->PoC_.set (PoCTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Room" && n.namespace_ ().empty ())
      {
        this->Room_.set (RoomTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Bed" && n.namespace_ ().empty ())
      {
        this->Bed_.set (BedTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Facility" && n.namespace_ ().empty ())
      {
        this->Facility_.set (FacilityTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Building" && n.namespace_ ().empty ())
      {
        this->Building_.set (BuildingTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Floor" && n.namespace_ ().empty ())
      {
        this->Floor_.set (FloorTraits::create (i, f, this));
        continue;
      }
    }
  }

  LocationDetail* LocationDetail::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LocationDetail (*this, f, c);
  }

  LocationDetail& LocationDetail::
  operator= (const LocationDetail& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->PoC_ = x.PoC_;
      this->Room_ = x.Room_;
      this->Bed_ = x.Bed_;
      this->Facility_ = x.Facility_;
      this->Building_ = x.Building_;
      this->Floor_ = x.Floor_;
    }

    return *this;
  }

  LocationDetail::
  ~LocationDetail ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LocationDetail >
  _xsd_LocationDetail_type_factory_init (
    "LocationDetail",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // PatientContextDescriptor
  //

  PatientContextDescriptor::
  PatientContextDescriptor (const HandleType& Handle)
  : ::CDM::AbstractContextDescriptor (Handle)
  {
  }

  PatientContextDescriptor::
  PatientContextDescriptor (const PatientContextDescriptor& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (x, f, c)
  {
  }

  PatientContextDescriptor::
  PatientContextDescriptor (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (e, f, c)
  {
  }

  PatientContextDescriptor* PatientContextDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PatientContextDescriptor (*this, f, c);
  }

  PatientContextDescriptor::
  ~PatientContextDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, PatientContextDescriptor >
  _xsd_PatientContextDescriptor_type_factory_init (
    "PatientContextDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // Sex
  //

  Sex::
  Sex (const ::xercesc::DOMElement& e,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Sex_convert ();
  }

  Sex::
  Sex (const ::xercesc::DOMAttr& a,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Sex_convert ();
  }

  Sex::
  Sex (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Sex_convert ();
  }

  Sex* Sex::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Sex (*this, f, c);
  }

  Sex::Value Sex::
  _xsd_Sex_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Sex_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Sex_indexes_,
                      _xsd_Sex_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_Sex_indexes_ + 4 || _xsd_Sex_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Sex::
  _xsd_Sex_literals_[4] =
  {
    "Unspec",
    "M",
    "F",
    "Unkn"
  };

  const Sex::Value Sex::
  _xsd_Sex_indexes_[4] =
  {
    ::CDM::Sex::F,
    ::CDM::Sex::M,
    ::CDM::Sex::Unkn,
    ::CDM::Sex::Unspec
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Sex >
  _xsd_Sex_type_factory_init (
    "Sex",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // PatientType
  //

  PatientType::
  PatientType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_PatientType_convert ();
  }

  PatientType::
  PatientType (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_PatientType_convert ();
  }

  PatientType::
  PatientType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_PatientType_convert ();
  }

  PatientType* PatientType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PatientType (*this, f, c);
  }

  PatientType::Value PatientType::
  _xsd_PatientType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_PatientType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_PatientType_indexes_,
                      _xsd_PatientType_indexes_ + 7,
                      *this,
                      c));

    if (i == _xsd_PatientType_indexes_ + 7 || _xsd_PatientType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const PatientType::
  _xsd_PatientType_literals_[7] =
  {
    "Unspec",
    "Ad",
    "Ado",
    "Ped",
    "Inf",
    "Neo",
    "Oth"
  };

  const PatientType::Value PatientType::
  _xsd_PatientType_indexes_[7] =
  {
    ::CDM::PatientType::Ad,
    ::CDM::PatientType::Ado,
    ::CDM::PatientType::Inf,
    ::CDM::PatientType::Neo,
    ::CDM::PatientType::Oth,
    ::CDM::PatientType::Ped,
    ::CDM::PatientType::Unspec
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, PatientType >
  _xsd_PatientType_type_factory_init (
    "PatientType",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // PatientDemographicsCoreData
  //

  PatientDemographicsCoreData::
  PatientDemographicsCoreData ()
  : ::CDM::BaseDemographics (),
    Sex_ (this),
    PatientType_ (this),
    DateOfBirth_ (this),
    Height_ (this),
    Weight_ (this),
    Race_ (this)
  {
  }

  PatientDemographicsCoreData::
  PatientDemographicsCoreData (const PatientDemographicsCoreData& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::BaseDemographics (x, f, c),
    Sex_ (x.Sex_, f, this),
    PatientType_ (x.PatientType_, f, this),
    DateOfBirth_ (x.DateOfBirth_, f, this),
    Height_ (x.Height_, f, this),
    Weight_ (x.Weight_, f, this),
    Race_ (x.Race_, f, this)
  {
  }

  PatientDemographicsCoreData::
  PatientDemographicsCoreData (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::BaseDemographics (e, f | ::xml_schema::Flags::base, c),
    Sex_ (this),
    PatientType_ (this),
    DateOfBirth_ (this),
    Height_ (this),
    Weight_ (this),
    Race_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PatientDemographicsCoreData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::BaseDemographics::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Sex
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Sex",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< SexType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Sex_)
          {
            ::std::unique_ptr< SexType > r (
              dynamic_cast< SexType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Sex_.set (::std::move (r));
            continue;
          }
        }
      }

      // PatientType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "PatientType",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< PatientTypeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->PatientType_)
          {
            ::std::unique_ptr< PatientTypeType > r (
              dynamic_cast< PatientTypeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->PatientType_.set (::std::move (r));
            continue;
          }
        }
      }

      // DateOfBirth
      //
      if (n.name () == "DateOfBirth" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< DateOfBirthType > r (
          DateOfBirthTraits::create (i, f, this));

        if (!this->DateOfBirth_)
        {
          this->DateOfBirth_.set (::std::move (r));
          continue;
        }
      }

      // Height
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Height",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< HeightType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Height_)
          {
            ::std::unique_ptr< HeightType > r (
              dynamic_cast< HeightType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Height_.set (::std::move (r));
            continue;
          }
        }
      }

      // Weight
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Weight",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< WeightType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Weight_)
          {
            ::std::unique_ptr< WeightType > r (
              dynamic_cast< WeightType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Weight_.set (::std::move (r));
            continue;
          }
        }
      }

      // Race
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Race",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< RaceType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Race_)
          {
            ::std::unique_ptr< RaceType > r (
              dynamic_cast< RaceType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Race_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  PatientDemographicsCoreData* PatientDemographicsCoreData::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PatientDemographicsCoreData (*this, f, c);
  }

  PatientDemographicsCoreData& PatientDemographicsCoreData::
  operator= (const PatientDemographicsCoreData& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::BaseDemographics& > (*this) = x;
      this->Sex_ = x.Sex_;
      this->PatientType_ = x.PatientType_;
      this->DateOfBirth_ = x.DateOfBirth_;
      this->Height_ = x.Height_;
      this->Weight_ = x.Weight_;
      this->Race_ = x.Race_;
    }

    return *this;
  }

  PatientDemographicsCoreData::
  ~PatientDemographicsCoreData ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, PatientDemographicsCoreData >
  _xsd_PatientDemographicsCoreData_type_factory_init (
    "PatientDemographicsCoreData",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // NeonatalPatientDemographicsCoreData
  //

  NeonatalPatientDemographicsCoreData::
  NeonatalPatientDemographicsCoreData ()
  : ::CDM::PatientDemographicsCoreData (),
    GestationalAge_ (this),
    BirthLength_ (this),
    BirthWeight_ (this),
    HeadCircumference_ (this),
    Mother_ (this)
  {
  }

  NeonatalPatientDemographicsCoreData::
  NeonatalPatientDemographicsCoreData (const NeonatalPatientDemographicsCoreData& x,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::CDM::PatientDemographicsCoreData (x, f, c),
    GestationalAge_ (x.GestationalAge_, f, this),
    BirthLength_ (x.BirthLength_, f, this),
    BirthWeight_ (x.BirthWeight_, f, this),
    HeadCircumference_ (x.HeadCircumference_, f, this),
    Mother_ (x.Mother_, f, this)
  {
  }

  NeonatalPatientDemographicsCoreData::
  NeonatalPatientDemographicsCoreData (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::CDM::PatientDemographicsCoreData (e, f | ::xml_schema::Flags::base, c),
    GestationalAge_ (this),
    BirthLength_ (this),
    BirthWeight_ (this),
    HeadCircumference_ (this),
    Mother_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void NeonatalPatientDemographicsCoreData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::PatientDemographicsCoreData::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // GestationalAge
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "GestationalAge",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< GestationalAgeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->GestationalAge_)
          {
            ::std::unique_ptr< GestationalAgeType > r (
              dynamic_cast< GestationalAgeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->GestationalAge_.set (::std::move (r));
            continue;
          }
        }
      }

      // BirthLength
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "BirthLength",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< BirthLengthType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->BirthLength_)
          {
            ::std::unique_ptr< BirthLengthType > r (
              dynamic_cast< BirthLengthType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->BirthLength_.set (::std::move (r));
            continue;
          }
        }
      }

      // BirthWeight
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "BirthWeight",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< BirthWeightType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->BirthWeight_)
          {
            ::std::unique_ptr< BirthWeightType > r (
              dynamic_cast< BirthWeightType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->BirthWeight_.set (::std::move (r));
            continue;
          }
        }
      }

      // HeadCircumference
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "HeadCircumference",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< HeadCircumferenceType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->HeadCircumference_)
          {
            ::std::unique_ptr< HeadCircumferenceType > r (
              dynamic_cast< HeadCircumferenceType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->HeadCircumference_.set (::std::move (r));
            continue;
          }
        }
      }

      // Mother
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Mother",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< MotherType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Mother_)
          {
            ::std::unique_ptr< MotherType > r (
              dynamic_cast< MotherType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Mother_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  NeonatalPatientDemographicsCoreData* NeonatalPatientDemographicsCoreData::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NeonatalPatientDemographicsCoreData (*this, f, c);
  }

  NeonatalPatientDemographicsCoreData& NeonatalPatientDemographicsCoreData::
  operator= (const NeonatalPatientDemographicsCoreData& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::PatientDemographicsCoreData& > (*this) = x;
      this->GestationalAge_ = x.GestationalAge_;
      this->BirthLength_ = x.BirthLength_;
      this->BirthWeight_ = x.BirthWeight_;
      this->HeadCircumference_ = x.HeadCircumference_;
      this->Mother_ = x.Mother_;
    }

    return *this;
  }

  NeonatalPatientDemographicsCoreData::
  ~NeonatalPatientDemographicsCoreData ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, NeonatalPatientDemographicsCoreData >
  _xsd_NeonatalPatientDemographicsCoreData_type_factory_init (
    "NeonatalPatientDemographicsCoreData",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // PatientContextState
  //

  PatientContextState::
  PatientContextState (const DescriptorHandleType& DescriptorHandle,
                       const HandleType& Handle)
  : ::CDM::AbstractContextState (DescriptorHandle,
                                 Handle),
    CoreData_ (this)
  {
  }

  PatientContextState::
  PatientContextState (const PatientContextState& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::AbstractContextState (x, f, c),
    CoreData_ (x.CoreData_, f, this)
  {
  }

  PatientContextState::
  PatientContextState (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::AbstractContextState (e, f | ::xml_schema::Flags::base, c),
    CoreData_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void PatientContextState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractContextState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CoreData
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CoreData",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< CoreDataType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CoreData_)
          {
            ::std::unique_ptr< CoreDataType > r (
              dynamic_cast< CoreDataType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CoreData_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  PatientContextState* PatientContextState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PatientContextState (*this, f, c);
  }

  PatientContextState& PatientContextState::
  operator= (const PatientContextState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractContextState& > (*this) = x;
      this->CoreData_ = x.CoreData_;
    }

    return *this;
  }

  PatientContextState::
  ~PatientContextState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, PatientContextState >
  _xsd_PatientContextState_type_factory_init (
    "PatientContextState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // LocationContextDescriptor
  //

  LocationContextDescriptor::
  LocationContextDescriptor (const HandleType& Handle)
  : ::CDM::AbstractContextDescriptor (Handle)
  {
  }

  LocationContextDescriptor::
  LocationContextDescriptor (const LocationContextDescriptor& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (x, f, c)
  {
  }

  LocationContextDescriptor::
  LocationContextDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (e, f, c)
  {
  }

  LocationContextDescriptor* LocationContextDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LocationContextDescriptor (*this, f, c);
  }

  LocationContextDescriptor::
  ~LocationContextDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LocationContextDescriptor >
  _xsd_LocationContextDescriptor_type_factory_init (
    "LocationContextDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // LocationContextState
  //

  LocationContextState::
  LocationContextState (const DescriptorHandleType& DescriptorHandle,
                        const HandleType& Handle)
  : ::CDM::AbstractContextState (DescriptorHandle,
                                 Handle),
    LocationDetail_ (this)
  {
  }

  LocationContextState::
  LocationContextState (const LocationContextState& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractContextState (x, f, c),
    LocationDetail_ (x.LocationDetail_, f, this)
  {
  }

  LocationContextState::
  LocationContextState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractContextState (e, f | ::xml_schema::Flags::base, c),
    LocationDetail_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void LocationContextState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractContextState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // LocationDetail
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "LocationDetail",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< LocationDetailType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->LocationDetail_)
          {
            ::std::unique_ptr< LocationDetailType > r (
              dynamic_cast< LocationDetailType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->LocationDetail_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  LocationContextState* LocationContextState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LocationContextState (*this, f, c);
  }

  LocationContextState& LocationContextState::
  operator= (const LocationContextState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractContextState& > (*this) = x;
      this->LocationDetail_ = x.LocationDetail_;
    }

    return *this;
  }

  LocationContextState::
  ~LocationContextState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LocationContextState >
  _xsd_LocationContextState_type_factory_init (
    "LocationContextState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // WorkflowContextDescriptor
  //

  WorkflowContextDescriptor::
  WorkflowContextDescriptor (const HandleType& Handle)
  : ::CDM::AbstractContextDescriptor (Handle)
  {
  }

  WorkflowContextDescriptor::
  WorkflowContextDescriptor (const WorkflowContextDescriptor& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (x, f, c)
  {
  }

  WorkflowContextDescriptor::
  WorkflowContextDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (e, f, c)
  {
  }

  WorkflowContextDescriptor* WorkflowContextDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class WorkflowContextDescriptor (*this, f, c);
  }

  WorkflowContextDescriptor::
  ~WorkflowContextDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, WorkflowContextDescriptor >
  _xsd_WorkflowContextDescriptor_type_factory_init (
    "WorkflowContextDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // ClinicalInfo
  //

  ClinicalInfo::
  ClinicalInfo ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Type_ (this),
    Code_ (this),
    Criticality_ (this),
    Description_ (this),
    RelatedMeasurement_ (this)
  {
  }

  ClinicalInfo::
  ClinicalInfo (const ClinicalInfo& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Type_ (x.Type_, f, this),
    Code_ (x.Code_, f, this),
    Criticality_ (x.Criticality_, f, this),
    Description_ (x.Description_, f, this),
    RelatedMeasurement_ (x.RelatedMeasurement_, f, this)
  {
  }

  ClinicalInfo::
  ClinicalInfo (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Type_ (this),
    Code_ (this),
    Criticality_ (this),
    Description_ (this),
    RelatedMeasurement_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ClinicalInfo::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // Type
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Type",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< TypeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Type_)
          {
            ::std::unique_ptr< TypeType > r (
              dynamic_cast< TypeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Type_.set (::std::move (r));
            continue;
          }
        }
      }

      // Code
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Code",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< CodeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Code_)
          {
            ::std::unique_ptr< CodeType > r (
              dynamic_cast< CodeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Code_.set (::std::move (r));
            continue;
          }
        }
      }

      // Criticality
      //
      if (n.name () == "Criticality" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< CriticalityType > r (
          CriticalityTraits::create (i, f, this));

        if (!this->Criticality_)
        {
          this->Criticality_.set (::std::move (r));
          continue;
        }
      }

      // Description
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Description",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< DescriptionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< DescriptionType > r (
            dynamic_cast< DescriptionType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Description_.push_back (::std::move (r));
          continue;
        }
      }

      // RelatedMeasurement
      //
      if (n.name () == "RelatedMeasurement" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< RelatedMeasurementType > r (
          RelatedMeasurementTraits::create (i, f, this));

        this->RelatedMeasurement_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ClinicalInfo* ClinicalInfo::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ClinicalInfo (*this, f, c);
  }

  ClinicalInfo& ClinicalInfo::
  operator= (const ClinicalInfo& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Type_ = x.Type_;
      this->Code_ = x.Code_;
      this->Criticality_ = x.Criticality_;
      this->Description_ = x.Description_;
      this->RelatedMeasurement_ = x.RelatedMeasurement_;
    }

    return *this;
  }

  ClinicalInfo::
  ~ClinicalInfo ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ClinicalInfo >
  _xsd_ClinicalInfo_type_factory_init (
    "ClinicalInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // ImagingProcedure
  //

  ImagingProcedure::
  ImagingProcedure (const AccessionIdentifierType& AccessionIdentifier,
                    const RequestedProcedureIdType& RequestedProcedureId,
                    const StudyInstanceUidType& StudyInstanceUid,
                    const ScheduledProcedureStepIdType& ScheduledProcedureStepId)
  : ::xml_schema::Type (),
    Extension_ (this),
    AccessionIdentifier_ (AccessionIdentifier, this),
    RequestedProcedureId_ (RequestedProcedureId, this),
    StudyInstanceUid_ (StudyInstanceUid, this),
    ScheduledProcedureStepId_ (ScheduledProcedureStepId, this),
    Modality_ (this),
    ProtocolCode_ (this)
  {
  }

  ImagingProcedure::
  ImagingProcedure (::std::unique_ptr< AccessionIdentifierType > AccessionIdentifier,
                    ::std::unique_ptr< RequestedProcedureIdType > RequestedProcedureId,
                    ::std::unique_ptr< StudyInstanceUidType > StudyInstanceUid,
                    ::std::unique_ptr< ScheduledProcedureStepIdType > ScheduledProcedureStepId)
  : ::xml_schema::Type (),
    Extension_ (this),
    AccessionIdentifier_ (std::move (AccessionIdentifier), this),
    RequestedProcedureId_ (std::move (RequestedProcedureId), this),
    StudyInstanceUid_ (std::move (StudyInstanceUid), this),
    ScheduledProcedureStepId_ (std::move (ScheduledProcedureStepId), this),
    Modality_ (this),
    ProtocolCode_ (this)
  {
  }

  ImagingProcedure::
  ImagingProcedure (const ImagingProcedure& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    AccessionIdentifier_ (x.AccessionIdentifier_, f, this),
    RequestedProcedureId_ (x.RequestedProcedureId_, f, this),
    StudyInstanceUid_ (x.StudyInstanceUid_, f, this),
    ScheduledProcedureStepId_ (x.ScheduledProcedureStepId_, f, this),
    Modality_ (x.Modality_, f, this),
    ProtocolCode_ (x.ProtocolCode_, f, this)
  {
  }

  ImagingProcedure::
  ImagingProcedure (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    AccessionIdentifier_ (this),
    RequestedProcedureId_ (this),
    StudyInstanceUid_ (this),
    ScheduledProcedureStepId_ (this),
    Modality_ (this),
    ProtocolCode_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ImagingProcedure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // AccessionIdentifier
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AccessionIdentifier",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< AccessionIdentifierType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!AccessionIdentifier_.present ())
          {
            ::std::unique_ptr< AccessionIdentifierType > r (
              dynamic_cast< AccessionIdentifierType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AccessionIdentifier_.set (::std::move (r));
            continue;
          }
        }
      }

      // RequestedProcedureId
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "RequestedProcedureId",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< RequestedProcedureIdType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!RequestedProcedureId_.present ())
          {
            ::std::unique_ptr< RequestedProcedureIdType > r (
              dynamic_cast< RequestedProcedureIdType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->RequestedProcedureId_.set (::std::move (r));
            continue;
          }
        }
      }

      // StudyInstanceUid
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "StudyInstanceUid",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< StudyInstanceUidType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!StudyInstanceUid_.present ())
          {
            ::std::unique_ptr< StudyInstanceUidType > r (
              dynamic_cast< StudyInstanceUidType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->StudyInstanceUid_.set (::std::move (r));
            continue;
          }
        }
      }

      // ScheduledProcedureStepId
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ScheduledProcedureStepId",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ScheduledProcedureStepIdType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ScheduledProcedureStepId_.present ())
          {
            ::std::unique_ptr< ScheduledProcedureStepIdType > r (
              dynamic_cast< ScheduledProcedureStepIdType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ScheduledProcedureStepId_.set (::std::move (r));
            continue;
          }
        }
      }

      // Modality
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Modality",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ModalityType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Modality_)
          {
            ::std::unique_ptr< ModalityType > r (
              dynamic_cast< ModalityType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Modality_.set (::std::move (r));
            continue;
          }
        }
      }

      // ProtocolCode
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ProtocolCode",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ProtocolCodeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ProtocolCode_)
          {
            ::std::unique_ptr< ProtocolCodeType > r (
              dynamic_cast< ProtocolCodeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ProtocolCode_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!AccessionIdentifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AccessionIdentifier",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }

    if (!RequestedProcedureId_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "RequestedProcedureId",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }

    if (!StudyInstanceUid_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "StudyInstanceUid",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }

    if (!ScheduledProcedureStepId_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ScheduledProcedureStepId",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }
  }

  ImagingProcedure* ImagingProcedure::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImagingProcedure (*this, f, c);
  }

  ImagingProcedure& ImagingProcedure::
  operator= (const ImagingProcedure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->AccessionIdentifier_ = x.AccessionIdentifier_;
      this->RequestedProcedureId_ = x.RequestedProcedureId_;
      this->StudyInstanceUid_ = x.StudyInstanceUid_;
      this->ScheduledProcedureStepId_ = x.ScheduledProcedureStepId_;
      this->Modality_ = x.Modality_;
      this->ProtocolCode_ = x.ProtocolCode_;
    }

    return *this;
  }

  ImagingProcedure::
  ~ImagingProcedure ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ImagingProcedure >
  _xsd_ImagingProcedure_type_factory_init (
    "ImagingProcedure",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // LocationReference
  //

  LocationReference::
  LocationReference ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Identification_ (this),
    LocationDetail_ (this)
  {
  }

  LocationReference::
  LocationReference (const LocationReference& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Identification_ (x.Identification_, f, this),
    LocationDetail_ (x.LocationDetail_, f, this)
  {
  }

  LocationReference::
  LocationReference (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Identification_ (this),
    LocationDetail_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LocationReference::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // Identification
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Identification",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< IdentificationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< IdentificationType > r (
            dynamic_cast< IdentificationType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Identification_.push_back (::std::move (r));
          continue;
        }
      }

      // LocationDetail
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "LocationDetail",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< LocationDetailType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->LocationDetail_)
          {
            ::std::unique_ptr< LocationDetailType > r (
              dynamic_cast< LocationDetailType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->LocationDetail_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  LocationReference* LocationReference::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LocationReference (*this, f, c);
  }

  LocationReference& LocationReference::
  operator= (const LocationReference& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Identification_ = x.Identification_;
      this->LocationDetail_ = x.LocationDetail_;
    }

    return *this;
  }

  LocationReference::
  ~LocationReference ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LocationReference >
  _xsd_LocationReference_type_factory_init (
    "LocationReference",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // OrderDetail
  //

  OrderDetail::
  OrderDetail ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Start_ (this),
    End_ (this),
    Performer_ (this),
    Service_ (this),
    ImagingProcedure_ (this)
  {
  }

  OrderDetail::
  OrderDetail (const OrderDetail& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Start_ (x.Start_, f, this),
    End_ (x.End_, f, this),
    Performer_ (x.Performer_, f, this),
    Service_ (x.Service_, f, this),
    ImagingProcedure_ (x.ImagingProcedure_, f, this)
  {
  }

  OrderDetail::
  OrderDetail (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Start_ (this),
    End_ (this),
    Performer_ (this),
    Service_ (this),
    ImagingProcedure_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void OrderDetail::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // Start
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Start",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< StartType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Start_)
          {
            ::std::unique_ptr< StartType > r (
              dynamic_cast< StartType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Start_.set (::std::move (r));
            continue;
          }
        }
      }

      // End
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "End",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< EndType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->End_)
          {
            ::std::unique_ptr< EndType > r (
              dynamic_cast< EndType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->End_.set (::std::move (r));
            continue;
          }
        }
      }

      // Performer
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Performer",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< PerformerType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< PerformerType > r (
            dynamic_cast< PerformerType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Performer_.push_back (::std::move (r));
          continue;
        }
      }

      // Service
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Service",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ServiceType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ServiceType > r (
            dynamic_cast< ServiceType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Service_.push_back (::std::move (r));
          continue;
        }
      }

      // ImagingProcedure
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ImagingProcedure",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ImagingProcedureType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ImagingProcedureType > r (
            dynamic_cast< ImagingProcedureType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ImagingProcedure_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  OrderDetail* OrderDetail::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OrderDetail (*this, f, c);
  }

  OrderDetail& OrderDetail::
  operator= (const OrderDetail& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Start_ = x.Start_;
      this->End_ = x.End_;
      this->Performer_ = x.Performer_;
      this->Service_ = x.Service_;
      this->ImagingProcedure_ = x.ImagingProcedure_;
    }

    return *this;
  }

  OrderDetail::
  ~OrderDetail ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OrderDetail >
  _xsd_OrderDetail_type_factory_init (
    "OrderDetail",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // PersonParticipation
  //

  PersonParticipation::
  PersonParticipation ()
  : ::CDM::PersonReference (),
    Role_ (this)
  {
  }

  PersonParticipation::
  PersonParticipation (const PersonParticipation& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::PersonReference (x, f, c),
    Role_ (x.Role_, f, this)
  {
  }

  PersonParticipation::
  PersonParticipation (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::PersonReference (e, f | ::xml_schema::Flags::base, c),
    Role_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PersonParticipation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::PersonReference::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Role
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Role",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< RoleType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< RoleType > r (
            dynamic_cast< RoleType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Role_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  PersonParticipation* PersonParticipation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PersonParticipation (*this, f, c);
  }

  PersonParticipation& PersonParticipation::
  operator= (const PersonParticipation& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::PersonReference& > (*this) = x;
      this->Role_ = x.Role_;
    }

    return *this;
  }

  PersonParticipation::
  ~PersonParticipation ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, PersonParticipation >
  _xsd_PersonParticipation_type_factory_init (
    "PersonParticipation",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // WorkflowContextState
  //

  WorkflowContextState::
  WorkflowContextState (const DescriptorHandleType& DescriptorHandle,
                        const HandleType& Handle)
  : ::CDM::AbstractContextState (DescriptorHandle,
                                 Handle),
    WorkflowDetail_ (this)
  {
  }

  WorkflowContextState::
  WorkflowContextState (const WorkflowContextState& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractContextState (x, f, c),
    WorkflowDetail_ (x.WorkflowDetail_, f, this)
  {
  }

  WorkflowContextState::
  WorkflowContextState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractContextState (e, f | ::xml_schema::Flags::base, c),
    WorkflowDetail_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void WorkflowContextState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractContextState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // WorkflowDetail
      //
      if (n.name () == "WorkflowDetail" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< WorkflowDetailType > r (
          WorkflowDetailTraits::create (i, f, this));

        if (!this->WorkflowDetail_)
        {
          this->WorkflowDetail_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  WorkflowContextState* WorkflowContextState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class WorkflowContextState (*this, f, c);
  }

  WorkflowContextState& WorkflowContextState::
  operator= (const WorkflowContextState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractContextState& > (*this) = x;
      this->WorkflowDetail_ = x.WorkflowDetail_;
    }

    return *this;
  }

  WorkflowContextState::
  ~WorkflowContextState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, WorkflowContextState >
  _xsd_WorkflowContextState_type_factory_init (
    "WorkflowContextState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // OperatorContextDescriptor
  //

  OperatorContextDescriptor::
  OperatorContextDescriptor (const HandleType& Handle)
  : ::CDM::AbstractContextDescriptor (Handle)
  {
  }

  OperatorContextDescriptor::
  OperatorContextDescriptor (const OperatorContextDescriptor& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (x, f, c)
  {
  }

  OperatorContextDescriptor::
  OperatorContextDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (e, f, c)
  {
  }

  OperatorContextDescriptor* OperatorContextDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OperatorContextDescriptor (*this, f, c);
  }

  OperatorContextDescriptor::
  ~OperatorContextDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OperatorContextDescriptor >
  _xsd_OperatorContextDescriptor_type_factory_init (
    "OperatorContextDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // OperatorContextState
  //

  OperatorContextState::
  OperatorContextState (const DescriptorHandleType& DescriptorHandle,
                        const HandleType& Handle)
  : ::CDM::AbstractContextState (DescriptorHandle,
                                 Handle),
    OperatorDetails_ (this)
  {
  }

  OperatorContextState::
  OperatorContextState (const OperatorContextState& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractContextState (x, f, c),
    OperatorDetails_ (x.OperatorDetails_, f, this)
  {
  }

  OperatorContextState::
  OperatorContextState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractContextState (e, f | ::xml_schema::Flags::base, c),
    OperatorDetails_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void OperatorContextState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractContextState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OperatorDetails
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OperatorDetails",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< OperatorDetailsType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->OperatorDetails_)
          {
            ::std::unique_ptr< OperatorDetailsType > r (
              dynamic_cast< OperatorDetailsType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OperatorDetails_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  OperatorContextState* OperatorContextState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OperatorContextState (*this, f, c);
  }

  OperatorContextState& OperatorContextState::
  operator= (const OperatorContextState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractContextState& > (*this) = x;
      this->OperatorDetails_ = x.OperatorDetails_;
    }

    return *this;
  }

  OperatorContextState::
  ~OperatorContextState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OperatorContextState >
  _xsd_OperatorContextState_type_factory_init (
    "OperatorContextState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // MeansContextDescriptor
  //

  MeansContextDescriptor::
  MeansContextDescriptor (const HandleType& Handle)
  : ::CDM::AbstractContextDescriptor (Handle)
  {
  }

  MeansContextDescriptor::
  MeansContextDescriptor (const MeansContextDescriptor& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (x, f, c)
  {
  }

  MeansContextDescriptor::
  MeansContextDescriptor (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (e, f, c)
  {
  }

  MeansContextDescriptor* MeansContextDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MeansContextDescriptor (*this, f, c);
  }

  MeansContextDescriptor::
  ~MeansContextDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MeansContextDescriptor >
  _xsd_MeansContextDescriptor_type_factory_init (
    "MeansContextDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // MeansContextState
  //

  MeansContextState::
  MeansContextState (const DescriptorHandleType& DescriptorHandle,
                     const HandleType& Handle)
  : ::CDM::AbstractContextState (DescriptorHandle,
                                 Handle)
  {
  }

  MeansContextState::
  MeansContextState (const MeansContextState& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::AbstractContextState (x, f, c)
  {
  }

  MeansContextState::
  MeansContextState (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::AbstractContextState (e, f, c)
  {
  }

  MeansContextState* MeansContextState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MeansContextState (*this, f, c);
  }

  MeansContextState::
  ~MeansContextState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MeansContextState >
  _xsd_MeansContextState_type_factory_init (
    "MeansContextState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // EnsembleContextDescriptor
  //

  EnsembleContextDescriptor::
  EnsembleContextDescriptor (const HandleType& Handle)
  : ::CDM::AbstractContextDescriptor (Handle)
  {
  }

  EnsembleContextDescriptor::
  EnsembleContextDescriptor (const EnsembleContextDescriptor& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (x, f, c)
  {
  }

  EnsembleContextDescriptor::
  EnsembleContextDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (e, f, c)
  {
  }

  EnsembleContextDescriptor* EnsembleContextDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EnsembleContextDescriptor (*this, f, c);
  }

  EnsembleContextDescriptor::
  ~EnsembleContextDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnsembleContextDescriptor >
  _xsd_EnsembleContextDescriptor_type_factory_init (
    "EnsembleContextDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // EnsembleContextState
  //

  EnsembleContextState::
  EnsembleContextState (const DescriptorHandleType& DescriptorHandle,
                        const HandleType& Handle)
  : ::CDM::AbstractContextState (DescriptorHandle,
                                 Handle)
  {
  }

  EnsembleContextState::
  EnsembleContextState (const EnsembleContextState& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractContextState (x, f, c)
  {
  }

  EnsembleContextState::
  EnsembleContextState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractContextState (e, f, c)
  {
  }

  EnsembleContextState* EnsembleContextState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EnsembleContextState (*this, f, c);
  }

  EnsembleContextState::
  ~EnsembleContextState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnsembleContextState >
  _xsd_EnsembleContextState_type_factory_init (
    "EnsembleContextState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // ContainmentTree
  //

  ContainmentTree::
  ContainmentTree ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Entry_ (this),
    HandleRef_ (this),
    ParentHandleRef_ (this),
    EntryType_ (this),
    ChildrenCount_ (this)
  {
  }

  ContainmentTree::
  ContainmentTree (const ContainmentTree& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Entry_ (x.Entry_, f, this),
    HandleRef_ (x.HandleRef_, f, this),
    ParentHandleRef_ (x.ParentHandleRef_, f, this),
    EntryType_ (x.EntryType_, f, this),
    ChildrenCount_ (x.ChildrenCount_, f, this)
  {
  }

  ContainmentTree::
  ContainmentTree (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Entry_ (this),
    HandleRef_ (this),
    ParentHandleRef_ (this),
    EntryType_ (this),
    ChildrenCount_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ContainmentTree::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // Entry
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Entry",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< EntryType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< EntryType > r (
            dynamic_cast< EntryType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Entry_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "HandleRef" && n.namespace_ ().empty ())
      {
        this->HandleRef_.set (HandleRefTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ParentHandleRef" && n.namespace_ ().empty ())
      {
        this->ParentHandleRef_.set (ParentHandleRefTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "EntryType" && n.namespace_ ().empty ())
      {
        this->EntryType_.set (EntryTypeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ChildrenCount" && n.namespace_ ().empty ())
      {
        this->ChildrenCount_.set (ChildrenCountTraits::create (i, f, this));
        continue;
      }
    }
  }

  ContainmentTree* ContainmentTree::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ContainmentTree (*this, f, c);
  }

  ContainmentTree& ContainmentTree::
  operator= (const ContainmentTree& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Entry_ = x.Entry_;
      this->HandleRef_ = x.HandleRef_;
      this->ParentHandleRef_ = x.ParentHandleRef_;
      this->EntryType_ = x.EntryType_;
      this->ChildrenCount_ = x.ChildrenCount_;
    }

    return *this;
  }

  ContainmentTree::
  ~ContainmentTree ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ContainmentTree >
  _xsd_ContainmentTree_type_factory_init (
    "ContainmentTree",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // ContainmentTreeEntry
  //

  ContainmentTreeEntry::
  ContainmentTreeEntry ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Type_ (this),
    HandleRef_ (this),
    ParentHandleRef_ (this),
    EntryType_ (this),
    ChildrenCount_ (this)
  {
  }

  ContainmentTreeEntry::
  ContainmentTreeEntry (const ContainmentTreeEntry& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Type_ (x.Type_, f, this),
    HandleRef_ (x.HandleRef_, f, this),
    ParentHandleRef_ (x.ParentHandleRef_, f, this),
    EntryType_ (x.EntryType_, f, this),
    ChildrenCount_ (x.ChildrenCount_, f, this)
  {
  }

  ContainmentTreeEntry::
  ContainmentTreeEntry (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Type_ (this),
    HandleRef_ (this),
    ParentHandleRef_ (this),
    EntryType_ (this),
    ChildrenCount_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ContainmentTreeEntry::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // Type
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Type",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< TypeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Type_)
          {
            ::std::unique_ptr< TypeType > r (
              dynamic_cast< TypeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Type_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "HandleRef" && n.namespace_ ().empty ())
      {
        this->HandleRef_.set (HandleRefTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ParentHandleRef" && n.namespace_ ().empty ())
      {
        this->ParentHandleRef_.set (ParentHandleRefTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "EntryType" && n.namespace_ ().empty ())
      {
        this->EntryType_.set (EntryTypeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ChildrenCount" && n.namespace_ ().empty ())
      {
        this->ChildrenCount_.set (ChildrenCountTraits::create (i, f, this));
        continue;
      }
    }
  }

  ContainmentTreeEntry* ContainmentTreeEntry::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ContainmentTreeEntry (*this, f, c);
  }

  ContainmentTreeEntry& ContainmentTreeEntry::
  operator= (const ContainmentTreeEntry& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Type_ = x.Type_;
      this->HandleRef_ = x.HandleRef_;
      this->ParentHandleRef_ = x.ParentHandleRef_;
      this->EntryType_ = x.EntryType_;
      this->ChildrenCount_ = x.ChildrenCount_;
    }

    return *this;
  }

  ContainmentTreeEntry::
  ~ContainmentTreeEntry ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ContainmentTreeEntry >
  _xsd_ContainmentTreeEntry_type_factory_init (
    "ContainmentTreeEntry",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");

  // Translation
  //

  Translation::
  Translation (const CodeType& Code)
  : ::xml_schema::Type (),
    Extension_ (this),
    Code_ (Code, this),
    CodingSystem_ (this),
    CodingSystemVersion_ (this)
  {
  }

  Translation::
  Translation (const Translation& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Code_ (x.Code_, f, this),
    CodingSystem_ (x.CodingSystem_, f, this),
    CodingSystemVersion_ (x.CodingSystemVersion_, f, this)
  {
  }

  Translation::
  Translation (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Code_ (this),
    CodingSystem_ (this),
    CodingSystemVersion_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Translation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Code" && n.namespace_ ().empty ())
      {
        this->Code_.set (CodeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "CodingSystem" && n.namespace_ ().empty ())
      {
        this->CodingSystem_.set (CodingSystemTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "CodingSystemVersion" && n.namespace_ ().empty ())
      {
        this->CodingSystemVersion_.set (CodingSystemVersionTraits::create (i, f, this));
        continue;
      }
    }

    if (!Code_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Code",
        "");
    }
  }

  Translation* Translation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Translation (*this, f, c);
  }

  Translation& Translation::
  operator= (const Translation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Code_ = x.Code_;
      this->CodingSystem_ = x.CodingSystem_;
      this->CodingSystemVersion_ = x.CodingSystemVersion_;
    }

    return *this;
  }

  Translation::
  ~Translation ()
  {
  }

  // Root
  //

  Root::
  Root (const ::xml_schema::Uri& _xsd_Uri_base)
  : ::xml_schema::Uri (_xsd_Uri_base)
  {
  }

  Root::
  Root (const Root& x,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Uri (x, f, c)
  {
  }

  Root::
  Root (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Uri (e, f, c)
  {
  }

  Root::
  Root (const ::xercesc::DOMAttr& a,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Uri (a, f, c)
  {
  }

  Root::
  Root (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Uri (s, e, f, c)
  {
  }

  Root* Root::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Root (*this, f, c);
  }

  Root::
  ~Root ()
  {
  }

  // Extension
  //

  Extension::
  Extension ()
  : ::xml_schema::String ()
  {
  }

  Extension::
  Extension (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  Extension::
  Extension (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  Extension::
  Extension (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  Extension::
  Extension (const Extension& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  Extension::
  Extension (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  Extension::
  Extension (const ::xercesc::DOMAttr& a,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  Extension::
  Extension (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  Extension* Extension::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Extension (*this, f, c);
  }

  Extension::
  ~Extension ()
  {
  }

  // ProductionSpecification
  //

  ProductionSpecification::
  ProductionSpecification (const SpecTypeType& SpecType,
                           const ProductionSpecType& ProductionSpec)
  : ::xml_schema::Type (),
    SpecType_ (SpecType, this),
    ProductionSpec_ (ProductionSpec, this),
    ComponentId_ (this)
  {
  }

  ProductionSpecification::
  ProductionSpecification (::std::unique_ptr< SpecTypeType > SpecType,
                           const ProductionSpecType& ProductionSpec)
  : ::xml_schema::Type (),
    SpecType_ (std::move (SpecType), this),
    ProductionSpec_ (ProductionSpec, this),
    ComponentId_ (this)
  {
  }

  ProductionSpecification::
  ProductionSpecification (::std::unique_ptr< SpecTypeType > SpecType,
                           ::std::unique_ptr< ProductionSpecType > ProductionSpec)
  : ::xml_schema::Type (),
    SpecType_ (std::move (SpecType), this),
    ProductionSpec_ (std::move (ProductionSpec), this),
    ComponentId_ (this)
  {
  }

  ProductionSpecification::
  ProductionSpecification (const ProductionSpecification& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    SpecType_ (x.SpecType_, f, this),
    ProductionSpec_ (x.ProductionSpec_, f, this),
    ComponentId_ (x.ComponentId_, f, this)
  {
  }

  ProductionSpecification::
  ProductionSpecification (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    SpecType_ (this),
    ProductionSpec_ (this),
    ComponentId_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ProductionSpecification::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SpecType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SpecType",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< SpecTypeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!SpecType_.present ())
          {
            ::std::unique_ptr< SpecTypeType > r (
              dynamic_cast< SpecTypeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SpecType_.set (::std::move (r));
            continue;
          }
        }
      }

      // ProductionSpec
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ProductionSpec",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ProductionSpecType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ProductionSpec_.present ())
          {
            ::std::unique_ptr< ProductionSpecType > r (
              dynamic_cast< ProductionSpecType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ProductionSpec_.set (::std::move (r));
            continue;
          }
        }
      }

      // ComponentId
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ComponentId",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ComponentIdType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ComponentId_)
          {
            ::std::unique_ptr< ComponentIdType > r (
              dynamic_cast< ComponentIdType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ComponentId_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!SpecType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SpecType",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }

    if (!ProductionSpec_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ProductionSpec",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }
  }

  ProductionSpecification* ProductionSpecification::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ProductionSpecification (*this, f, c);
  }

  ProductionSpecification& ProductionSpecification::
  operator= (const ProductionSpecification& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->SpecType_ = x.SpecType_;
      this->ProductionSpec_ = x.ProductionSpec_;
      this->ComponentId_ = x.ComponentId_;
    }

    return *this;
  }

  ProductionSpecification::
  ~ProductionSpecification ()
  {
  }

  // CalibrationDocumentation
  //

  CalibrationDocumentation::
  CalibrationDocumentation ()
  : ::xml_schema::Type (),
    Documentation_ (this),
    CalibrationResult_ (this)
  {
  }

  CalibrationDocumentation::
  CalibrationDocumentation (const CalibrationDocumentation& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Documentation_ (x.Documentation_, f, this),
    CalibrationResult_ (x.CalibrationResult_, f, this)
  {
  }

  CalibrationDocumentation::
  CalibrationDocumentation (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Documentation_ (this),
    CalibrationResult_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CalibrationDocumentation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Documentation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Documentation",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< DocumentationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< DocumentationType > r (
            dynamic_cast< DocumentationType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Documentation_.push_back (::std::move (r));
          continue;
        }
      }

      // CalibrationResult
      //
      if (n.name () == "CalibrationResult" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< CalibrationResultType > r (
          CalibrationResultTraits::create (i, f, this));

        this->CalibrationResult_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  CalibrationDocumentation* CalibrationDocumentation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CalibrationDocumentation (*this, f, c);
  }

  CalibrationDocumentation& CalibrationDocumentation::
  operator= (const CalibrationDocumentation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Documentation_ = x.Documentation_;
      this->CalibrationResult_ = x.CalibrationResult_;
    }

    return *this;
  }

  CalibrationDocumentation::
  ~CalibrationDocumentation ()
  {
  }

  // MetaData
  //

  MetaData::
  MetaData ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Udi_ (this),
    LotNumber_ (this),
    Manufacturer_ (this),
    ManufactureDate_ (this),
    ExpirationDate_ (this),
    ModelName_ (this),
    ModelNumber_ (this),
    SerialNumber_ (this)
  {
  }

  MetaData::
  MetaData (const MetaData& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Udi_ (x.Udi_, f, this),
    LotNumber_ (x.LotNumber_, f, this),
    Manufacturer_ (x.Manufacturer_, f, this),
    ManufactureDate_ (x.ManufactureDate_, f, this),
    ExpirationDate_ (x.ExpirationDate_, f, this),
    ModelName_ (x.ModelName_, f, this),
    ModelNumber_ (x.ModelNumber_, f, this),
    SerialNumber_ (x.SerialNumber_, f, this)
  {
  }

  MetaData::
  MetaData (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Udi_ (this),
    LotNumber_ (this),
    Manufacturer_ (this),
    ManufactureDate_ (this),
    ExpirationDate_ (this),
    ModelName_ (this),
    ModelNumber_ (this),
    SerialNumber_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void MetaData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // Udi
      //
      if (n.name () == "Udi" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< UdiType > r (
          UdiTraits::create (i, f, this));

        this->Udi_.push_back (::std::move (r));
        continue;
      }

      // LotNumber
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "LotNumber",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< LotNumberType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->LotNumber_)
          {
            ::std::unique_ptr< LotNumberType > r (
              dynamic_cast< LotNumberType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->LotNumber_.set (::std::move (r));
            continue;
          }
        }
      }

      // Manufacturer
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Manufacturer",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ManufacturerType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ManufacturerType > r (
            dynamic_cast< ManufacturerType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Manufacturer_.push_back (::std::move (r));
          continue;
        }
      }

      // ManufactureDate
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ManufactureDate",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ManufactureDateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ManufactureDate_)
          {
            ::std::unique_ptr< ManufactureDateType > r (
              dynamic_cast< ManufactureDateType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ManufactureDate_.set (::std::move (r));
            continue;
          }
        }
      }

      // ExpirationDate
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ExpirationDate",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ExpirationDateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ExpirationDate_)
          {
            ::std::unique_ptr< ExpirationDateType > r (
              dynamic_cast< ExpirationDateType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ExpirationDate_.set (::std::move (r));
            continue;
          }
        }
      }

      // ModelName
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ModelName",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ModelNameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ModelNameType > r (
            dynamic_cast< ModelNameType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ModelName_.push_back (::std::move (r));
          continue;
        }
      }

      // ModelNumber
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ModelNumber",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ModelNumberType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ModelNumber_)
          {
            ::std::unique_ptr< ModelNumberType > r (
              dynamic_cast< ModelNumberType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ModelNumber_.set (::std::move (r));
            continue;
          }
        }
      }

      // SerialNumber
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SerialNumber",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< SerialNumberType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< SerialNumberType > r (
            dynamic_cast< SerialNumberType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->SerialNumber_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  MetaData* MetaData::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MetaData (*this, f, c);
  }

  MetaData& MetaData::
  operator= (const MetaData& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Udi_ = x.Udi_;
      this->LotNumber_ = x.LotNumber_;
      this->Manufacturer_ = x.Manufacturer_;
      this->ManufactureDate_ = x.ManufactureDate_;
      this->ExpirationDate_ = x.ExpirationDate_;
      this->ModelName_ = x.ModelName_;
      this->ModelNumber_ = x.ModelNumber_;
      this->SerialNumber_ = x.SerialNumber_;
    }

    return *this;
  }

  MetaData::
  ~MetaData ()
  {
  }

  // CanEscalate
  //

  CanEscalate::
  CanEscalate (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::CDM::AlertConditionPriority (e, f, c)
  {
    _xsd_CanEscalate_convert ();
  }

  CanEscalate::
  CanEscalate (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::CDM::AlertConditionPriority (a, f, c)
  {
    _xsd_CanEscalate_convert ();
  }

  CanEscalate::
  CanEscalate (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::CDM::AlertConditionPriority (s, e, f, c)
  {
    _xsd_CanEscalate_convert ();
  }

  CanEscalate* CanEscalate::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CanEscalate (*this, f, c);
  }

  CanEscalate::Value CanEscalate::
  _xsd_CanEscalate_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CanEscalate_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_CanEscalate_indexes_,
                      _xsd_CanEscalate_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_CanEscalate_indexes_ + 3 || _xsd_CanEscalate_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const* CanEscalate::
  _xsd_CanEscalate_literals_ = ::CDM::AlertConditionPriority::_xsd_AlertConditionPriority_literals_;

  const CanEscalate::Value CanEscalate::
  _xsd_CanEscalate_indexes_[3] =
  {
    ::CDM::CanEscalate::Hi,
    ::CDM::CanEscalate::Lo,
    ::CDM::CanEscalate::Me
  };

  // CanDeescalate
  //

  CanDeescalate::
  CanDeescalate (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AlertConditionPriority (e, f, c)
  {
    _xsd_CanDeescalate_convert ();
  }

  CanDeescalate::
  CanDeescalate (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AlertConditionPriority (a, f, c)
  {
    _xsd_CanDeescalate_convert ();
  }

  CanDeescalate::
  CanDeescalate (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AlertConditionPriority (s, e, f, c)
  {
    _xsd_CanDeescalate_convert ();
  }

  CanDeescalate* CanDeescalate::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CanDeescalate (*this, f, c);
  }

  CanDeescalate::Value CanDeescalate::
  _xsd_CanDeescalate_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CanDeescalate_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_CanDeescalate_indexes_,
                      _xsd_CanDeescalate_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_CanDeescalate_indexes_ + 3 || _xsd_CanDeescalate_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const* CanDeescalate::
  _xsd_CanDeescalate_literals_ = ::CDM::AlertConditionPriority::_xsd_AlertConditionPriority_literals_;

  const CanDeescalate::Value CanDeescalate::
  _xsd_CanDeescalate_indexes_[3] =
  {
    ::CDM::CanDeescalate::Lo,
    ::CDM::CanDeescalate::Me,
    ::CDM::CanDeescalate::None
  };

  // MetricQuality
  //

  MetricQuality::
  MetricQuality (const ValidityType& Validity)
  : ::xml_schema::Type (),
    Extension_ (this),
    Validity_ (Validity, this),
    Mode_ (this),
    Qi_ (this)
  {
  }

  MetricQuality::
  MetricQuality (const MetricQuality& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Validity_ (x.Validity_, f, this),
    Mode_ (x.Mode_, f, this),
    Qi_ (x.Qi_, f, this)
  {
  }

  MetricQuality::
  MetricQuality (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Validity_ (this),
    Mode_ (this),
    Qi_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MetricQuality::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Validity" && n.namespace_ ().empty ())
      {
        this->Validity_.set (ValidityTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Mode" && n.namespace_ ().empty ())
      {
        this->Mode_.set (ModeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Qi" && n.namespace_ ().empty ())
      {
        this->Qi_.set (QiTraits::create (i, f, this));
        continue;
      }
    }

    if (!Validity_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Validity",
        "");
    }
  }

  MetricQuality* MetricQuality::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MetricQuality (*this, f, c);
  }

  MetricQuality& MetricQuality::
  operator= (const MetricQuality& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Validity_ = x.Validity_;
      this->Mode_ = x.Mode_;
      this->Qi_ = x.Qi_;
    }

    return *this;
  }

  MetricQuality::
  ~MetricQuality ()
  {
  }

  // Annotation
  //

  Annotation::
  Annotation (const TypeType& Type)
  : ::xml_schema::Type (),
    Extension_ (this),
    Type_ (Type, this)
  {
  }

  Annotation::
  Annotation (::std::unique_ptr< TypeType > Type)
  : ::xml_schema::Type (),
    Extension_ (this),
    Type_ (std::move (Type), this)
  {
  }

  Annotation::
  Annotation (const Annotation& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Type_ (x.Type_, f, this)
  {
  }

  Annotation::
  Annotation (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Type_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Annotation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // Type
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Type",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< TypeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Type_.present ())
          {
            ::std::unique_ptr< TypeType > r (
              dynamic_cast< TypeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Type_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Type",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }
  }

  Annotation* Annotation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Annotation (*this, f, c);
  }

  Annotation& Annotation::
  operator= (const Annotation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Type_ = x.Type_;
    }

    return *this;
  }

  Annotation::
  ~Annotation ()
  {
  }

  // ApplyAnnotation
  //

  ApplyAnnotation::
  ApplyAnnotation (const AnnotationIndexType& AnnotationIndex,
                   const SampleIndexType& SampleIndex)
  : ::xml_schema::Type (),
    AnnotationIndex_ (AnnotationIndex, this),
    SampleIndex_ (SampleIndex, this)
  {
  }

  ApplyAnnotation::
  ApplyAnnotation (const ApplyAnnotation& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AnnotationIndex_ (x.AnnotationIndex_, f, this),
    SampleIndex_ (x.SampleIndex_, f, this)
  {
  }

  ApplyAnnotation::
  ApplyAnnotation (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AnnotationIndex_ (this),
    SampleIndex_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ApplyAnnotation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "AnnotationIndex" && n.namespace_ ().empty ())
      {
        this->AnnotationIndex_.set (AnnotationIndexTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "SampleIndex" && n.namespace_ ().empty ())
      {
        this->SampleIndex_.set (SampleIndexTraits::create (i, f, this));
        continue;
      }
    }

    if (!AnnotationIndex_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "AnnotationIndex",
        "");
    }

    if (!SampleIndex_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "SampleIndex",
        "");
    }
  }

  ApplyAnnotation* ApplyAnnotation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ApplyAnnotation (*this, f, c);
  }

  ApplyAnnotation& ApplyAnnotation::
  operator= (const ApplyAnnotation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->AnnotationIndex_ = x.AnnotationIndex_;
      this->SampleIndex_ = x.SampleIndex_;
    }

    return *this;
  }

  ApplyAnnotation::
  ~ApplyAnnotation ()
  {
  }

  // Relation
  //

  Relation::
  Relation (const KindType& Kind,
            const EntriesType& Entries)
  : ::xml_schema::Type (),
    Extension_ (this),
    Code_ (this),
    Identification_ (this),
    Kind_ (Kind, this),
    Entries_ (Entries, this)
  {
  }

  Relation::
  Relation (const Relation& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Code_ (x.Code_, f, this),
    Identification_ (x.Identification_, f, this),
    Kind_ (x.Kind_, f, this),
    Entries_ (x.Entries_, f, this)
  {
  }

  Relation::
  Relation (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Code_ (this),
    Identification_ (this),
    Kind_ (this),
    Entries_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Relation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // Code
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Code",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< CodeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Code_)
          {
            ::std::unique_ptr< CodeType > r (
              dynamic_cast< CodeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Code_.set (::std::move (r));
            continue;
          }
        }
      }

      // Identification
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Identification",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< IdentificationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Identification_)
          {
            ::std::unique_ptr< IdentificationType > r (
              dynamic_cast< IdentificationType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Identification_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Kind" && n.namespace_ ().empty ())
      {
        this->Kind_.set (KindTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Entries" && n.namespace_ ().empty ())
      {
        this->Entries_.set (EntriesTraits::create (i, f, this));
        continue;
      }
    }

    if (!Kind_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Kind",
        "");
    }

    if (!Entries_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Entries",
        "");
    }
  }

  Relation* Relation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Relation (*this, f, c);
  }

  Relation& Relation::
  operator= (const Relation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Code_ = x.Code_;
      this->Identification_ = x.Identification_;
      this->Kind_ = x.Kind_;
      this->Entries_ = x.Entries_;
    }

    return *this;
  }

  Relation::
  ~Relation ()
  {
  }

  // AllowedValue
  //

  AllowedValue::
  AllowedValue (const ValueType& Value)
  : ::xml_schema::Type (),
    Value_ (Value, this),
    Type_ (this),
    Identification_ (this),
    Characteristic_ (this)
  {
  }

  AllowedValue::
  AllowedValue (::std::unique_ptr< ValueType > Value)
  : ::xml_schema::Type (),
    Value_ (std::move (Value), this),
    Type_ (this),
    Identification_ (this),
    Characteristic_ (this)
  {
  }

  AllowedValue::
  AllowedValue (const AllowedValue& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Value_ (x.Value_, f, this),
    Type_ (x.Type_, f, this),
    Identification_ (x.Identification_, f, this),
    Characteristic_ (x.Characteristic_, f, this)
  {
  }

  AllowedValue::
  AllowedValue (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Value_ (this),
    Type_ (this),
    Identification_ (this),
    Characteristic_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AllowedValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Value
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Value",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Value_.present ())
          {
            ::std::unique_ptr< ValueType > r (
              dynamic_cast< ValueType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Value_.set (::std::move (r));
            continue;
          }
        }
      }

      // Type
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Type",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< TypeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Type_)
          {
            ::std::unique_ptr< TypeType > r (
              dynamic_cast< TypeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Type_.set (::std::move (r));
            continue;
          }
        }
      }

      // Identification
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Identification",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< IdentificationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Identification_)
          {
            ::std::unique_ptr< IdentificationType > r (
              dynamic_cast< IdentificationType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Identification_.set (::std::move (r));
            continue;
          }
        }
      }

      // Characteristic
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Characteristic",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< CharacteristicType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Characteristic_)
          {
            ::std::unique_ptr< CharacteristicType > r (
              dynamic_cast< CharacteristicType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Characteristic_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Value",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }
  }

  AllowedValue* AllowedValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AllowedValue (*this, f, c);
  }

  AllowedValue& AllowedValue::
  operator= (const AllowedValue& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Value_ = x.Value_;
      this->Type_ = x.Type_;
      this->Identification_ = x.Identification_;
      this->Characteristic_ = x.Characteristic_;
    }

    return *this;
  }

  AllowedValue::
  ~AllowedValue ()
  {
  }

  // OperationGroup
  //

  OperationGroup::
  OperationGroup (const TypeType& Type)
  : ::xml_schema::Type (),
    Extension_ (this),
    Type_ (Type, this),
    OperatingMode_ (this),
    Operations_ (this)
  {
  }

  OperationGroup::
  OperationGroup (::std::unique_ptr< TypeType > Type)
  : ::xml_schema::Type (),
    Extension_ (this),
    Type_ (std::move (Type), this),
    OperatingMode_ (this),
    Operations_ (this)
  {
  }

  OperationGroup::
  OperationGroup (const OperationGroup& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Type_ (x.Type_, f, this),
    OperatingMode_ (x.OperatingMode_, f, this),
    Operations_ (x.Operations_, f, this)
  {
  }

  OperationGroup::
  OperationGroup (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Type_ (this),
    OperatingMode_ (this),
    Operations_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void OperationGroup::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // Type
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Type",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< TypeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Type_.present ())
          {
            ::std::unique_ptr< TypeType > r (
              dynamic_cast< TypeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Type_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Type",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "OperatingMode" && n.namespace_ ().empty ())
      {
        this->OperatingMode_.set (OperatingModeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Operations" && n.namespace_ ().empty ())
      {
        this->Operations_.set (OperationsTraits::create (i, f, this));
        continue;
      }
    }
  }

  OperationGroup* OperationGroup::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OperationGroup (*this, f, c);
  }

  OperationGroup& OperationGroup::
  operator= (const OperationGroup& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Type_ = x.Type_;
      this->OperatingMode_ = x.OperatingMode_;
      this->Operations_ = x.Operations_;
    }

    return *this;
  }

  OperationGroup::
  ~OperationGroup ()
  {
  }

  // AccessLevel
  //

  AccessLevel::
  AccessLevel (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_AccessLevel_convert ();
  }

  AccessLevel::
  AccessLevel (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_AccessLevel_convert ();
  }

  AccessLevel::
  AccessLevel (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_AccessLevel_convert ();
  }

  AccessLevel* AccessLevel::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AccessLevel (*this, f, c);
  }

  AccessLevel::Value AccessLevel::
  _xsd_AccessLevel_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AccessLevel_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_AccessLevel_indexes_,
                      _xsd_AccessLevel_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_AccessLevel_indexes_ + 5 || _xsd_AccessLevel_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const AccessLevel::
  _xsd_AccessLevel_literals_[5] =
  {
    "Usr",
    "CSUsr",
    "RO",
    "SP",
    "Oth"
  };

  const AccessLevel::Value AccessLevel::
  _xsd_AccessLevel_indexes_[5] =
  {
    ::CDM::AccessLevel::CSUsr,
    ::CDM::AccessLevel::Oth,
    ::CDM::AccessLevel::RO,
    ::CDM::AccessLevel::SP,
    ::CDM::AccessLevel::Usr
  };

  // AllowedValues
  //

  AllowedValues::
  AllowedValues ()
  : ::xml_schema::Type (),
    Value_ (this)
  {
  }

  AllowedValues::
  AllowedValues (const AllowedValues& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Value_ (x.Value_, f, this)
  {
  }

  AllowedValues::
  AllowedValues (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Value_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AllowedValues::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Value
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Value",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ValueType > r (
            dynamic_cast< ValueType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Value_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  AllowedValues* AllowedValues::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AllowedValues (*this, f, c);
  }

  AllowedValues& AllowedValues::
  operator= (const AllowedValues& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Value_ = x.Value_;
    }

    return *this;
  }

  AllowedValues::
  ~AllowedValues ()
  {
  }

  // Argument
  //

  Argument::
  Argument (const ArgNameType& ArgName,
            const ArgType& Arg)
  : ::xml_schema::Type (),
    ArgName_ (ArgName, this),
    Arg_ (Arg, this)
  {
  }

  Argument::
  Argument (::std::unique_ptr< ArgNameType > ArgName,
            const ArgType& Arg)
  : ::xml_schema::Type (),
    ArgName_ (std::move (ArgName), this),
    Arg_ (Arg, this)
  {
  }

  Argument::
  Argument (::std::unique_ptr< ArgNameType > ArgName,
            ::std::unique_ptr< ArgType > Arg)
  : ::xml_schema::Type (),
    ArgName_ (std::move (ArgName), this),
    Arg_ (std::move (Arg), this)
  {
  }

  Argument::
  Argument (const Argument& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ArgName_ (x.ArgName_, f, this),
    Arg_ (x.Arg_, f, this)
  {
  }

  Argument::
  Argument (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ArgName_ (this),
    Arg_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Argument::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ArgName
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ArgName",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ArgNameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ArgName_.present ())
          {
            ::std::unique_ptr< ArgNameType > r (
              dynamic_cast< ArgNameType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ArgName_.set (::std::move (r));
            continue;
          }
        }
      }

      // Arg
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Arg",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ArgType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Arg_.present ())
          {
            ::std::unique_ptr< ArgType > r (
              dynamic_cast< ArgType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Arg_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ArgName_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ArgName",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }

    if (!Arg_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Arg",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }
  }

  Argument* Argument::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Argument (*this, f, c);
  }

  Argument& Argument::
  operator= (const Argument& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->ArgName_ = x.ArgName_;
      this->Arg_ = x.Arg_;
    }

    return *this;
  }

  Argument::
  ~Argument ()
  {
  }

  // ChargeStatus
  //

  ChargeStatus::
  ChargeStatus (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_ChargeStatus_convert ();
  }

  ChargeStatus::
  ChargeStatus (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_ChargeStatus_convert ();
  }

  ChargeStatus::
  ChargeStatus (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_ChargeStatus_convert ();
  }

  ChargeStatus* ChargeStatus::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ChargeStatus (*this, f, c);
  }

  ChargeStatus::Value ChargeStatus::
  _xsd_ChargeStatus_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ChargeStatus_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_ChargeStatus_indexes_,
                      _xsd_ChargeStatus_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_ChargeStatus_indexes_ + 4 || _xsd_ChargeStatus_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ChargeStatus::
  _xsd_ChargeStatus_literals_[4] =
  {
    "Ful",
    "ChB",
    "DisChB",
    "DEB"
  };

  const ChargeStatus::Value ChargeStatus::
  _xsd_ChargeStatus_indexes_[4] =
  {
    ::CDM::ChargeStatus::ChB,
    ::CDM::ChargeStatus::DEB,
    ::CDM::ChargeStatus::DisChB,
    ::CDM::ChargeStatus::Ful
  };

  // DateOfBirth
  //

  DateOfBirth::
  DateOfBirth (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  DateOfBirth::
  DateOfBirth (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  DateOfBirth::
  DateOfBirth (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  DateOfBirth* DateOfBirth::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DateOfBirth (*this, f, c);
  }

  // Criticality
  //

  Criticality::
  Criticality (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Criticality_convert ();
  }

  Criticality::
  Criticality (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Criticality_convert ();
  }

  Criticality::
  Criticality (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Criticality_convert ();
  }

  Criticality* Criticality::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Criticality (*this, f, c);
  }

  Criticality::Value Criticality::
  _xsd_Criticality_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Criticality_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Criticality_indexes_,
                      _xsd_Criticality_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_Criticality_indexes_ + 2 || _xsd_Criticality_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Criticality::
  _xsd_Criticality_literals_[2] =
  {
    "Lo",
    "Hi"
  };

  const Criticality::Value Criticality::
  _xsd_Criticality_indexes_[2] =
  {
    ::CDM::Criticality::Hi,
    ::CDM::Criticality::Lo
  };

  // RelatedMeasurement
  //

  RelatedMeasurement::
  RelatedMeasurement (const ValueType& Value)
  : ::xml_schema::Type (),
    Value_ (Value, this),
    ReferenceRange_ (this),
    Validity_ (this)
  {
  }

  RelatedMeasurement::
  RelatedMeasurement (::std::unique_ptr< ValueType > Value)
  : ::xml_schema::Type (),
    Value_ (std::move (Value), this),
    ReferenceRange_ (this),
    Validity_ (this)
  {
  }

  RelatedMeasurement::
  RelatedMeasurement (const RelatedMeasurement& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Value_ (x.Value_, f, this),
    ReferenceRange_ (x.ReferenceRange_, f, this),
    Validity_ (x.Validity_, f, this)
  {
  }

  RelatedMeasurement::
  RelatedMeasurement (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Value_ (this),
    ReferenceRange_ (this),
    Validity_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void RelatedMeasurement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Value
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Value",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Value_.present ())
          {
            ::std::unique_ptr< ValueType > r (
              dynamic_cast< ValueType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Value_.set (::std::move (r));
            continue;
          }
        }
      }

      // ReferenceRange
      //
      if (n.name () == "ReferenceRange" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< ReferenceRangeType > r (
          ReferenceRangeTraits::create (i, f, this));

        this->ReferenceRange_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!Value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Value",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Validity" && n.namespace_ ().empty ())
      {
        this->Validity_.set (ValidityTraits::create (i, f, this));
        continue;
      }
    }
  }

  RelatedMeasurement* RelatedMeasurement::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RelatedMeasurement (*this, f, c);
  }

  RelatedMeasurement& RelatedMeasurement::
  operator= (const RelatedMeasurement& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Value_ = x.Value_;
      this->ReferenceRange_ = x.ReferenceRange_;
      this->Validity_ = x.Validity_;
    }

    return *this;
  }

  RelatedMeasurement::
  ~RelatedMeasurement ()
  {
  }

  // WorkflowDetail
  //

  WorkflowDetail::
  WorkflowDetail (const PatientType& Patient)
  : ::xml_schema::Type (),
    Extension_ (this),
    Patient_ (Patient, this),
    AssignedLocation_ (this),
    VisitNumber_ (this),
    DangerCode_ (this),
    RelevantClinicalInfo_ (this),
    RequestedOrderDetail_ (this),
    PerformedOrderDetail_ (this)
  {
  }

  WorkflowDetail::
  WorkflowDetail (::std::unique_ptr< PatientType > Patient)
  : ::xml_schema::Type (),
    Extension_ (this),
    Patient_ (std::move (Patient), this),
    AssignedLocation_ (this),
    VisitNumber_ (this),
    DangerCode_ (this),
    RelevantClinicalInfo_ (this),
    RequestedOrderDetail_ (this),
    PerformedOrderDetail_ (this)
  {
  }

  WorkflowDetail::
  WorkflowDetail (const WorkflowDetail& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Patient_ (x.Patient_, f, this),
    AssignedLocation_ (x.AssignedLocation_, f, this),
    VisitNumber_ (x.VisitNumber_, f, this),
    DangerCode_ (x.DangerCode_, f, this),
    RelevantClinicalInfo_ (x.RelevantClinicalInfo_, f, this),
    RequestedOrderDetail_ (x.RequestedOrderDetail_, f, this),
    PerformedOrderDetail_ (x.PerformedOrderDetail_, f, this)
  {
  }

  WorkflowDetail::
  WorkflowDetail (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Patient_ (this),
    AssignedLocation_ (this),
    VisitNumber_ (this),
    DangerCode_ (this),
    RelevantClinicalInfo_ (this),
    RequestedOrderDetail_ (this),
    PerformedOrderDetail_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void WorkflowDetail::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // Patient
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Patient",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< PatientType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Patient_.present ())
          {
            ::std::unique_ptr< PatientType > r (
              dynamic_cast< PatientType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Patient_.set (::std::move (r));
            continue;
          }
        }
      }

      // AssignedLocation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AssignedLocation",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< AssignedLocationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AssignedLocation_)
          {
            ::std::unique_ptr< AssignedLocationType > r (
              dynamic_cast< AssignedLocationType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AssignedLocation_.set (::std::move (r));
            continue;
          }
        }
      }

      // VisitNumber
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "VisitNumber",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< VisitNumberType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->VisitNumber_)
          {
            ::std::unique_ptr< VisitNumberType > r (
              dynamic_cast< VisitNumberType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->VisitNumber_.set (::std::move (r));
            continue;
          }
        }
      }

      // DangerCode
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DangerCode",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< DangerCodeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< DangerCodeType > r (
            dynamic_cast< DangerCodeType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->DangerCode_.push_back (::std::move (r));
          continue;
        }
      }

      // RelevantClinicalInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "RelevantClinicalInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< RelevantClinicalInfoType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< RelevantClinicalInfoType > r (
            dynamic_cast< RelevantClinicalInfoType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RelevantClinicalInfo_.push_back (::std::move (r));
          continue;
        }
      }

      // RequestedOrderDetail
      //
      if (n.name () == "RequestedOrderDetail" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< RequestedOrderDetailType > r (
          RequestedOrderDetailTraits::create (i, f, this));

        if (!this->RequestedOrderDetail_)
        {
          this->RequestedOrderDetail_.set (::std::move (r));
          continue;
        }
      }

      // PerformedOrderDetail
      //
      if (n.name () == "PerformedOrderDetail" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        ::std::unique_ptr< PerformedOrderDetailType > r (
          PerformedOrderDetailTraits::create (i, f, this));

        if (!this->PerformedOrderDetail_)
        {
          this->PerformedOrderDetail_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!Patient_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Patient",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }
  }

  WorkflowDetail* WorkflowDetail::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class WorkflowDetail (*this, f, c);
  }

  WorkflowDetail& WorkflowDetail::
  operator= (const WorkflowDetail& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Patient_ = x.Patient_;
      this->AssignedLocation_ = x.AssignedLocation_;
      this->VisitNumber_ = x.VisitNumber_;
      this->DangerCode_ = x.DangerCode_;
      this->RelevantClinicalInfo_ = x.RelevantClinicalInfo_;
      this->RequestedOrderDetail_ = x.RequestedOrderDetail_;
      this->PerformedOrderDetail_ = x.PerformedOrderDetail_;
    }

    return *this;
  }

  WorkflowDetail::
  ~WorkflowDetail ()
  {
  }

  // CalibrationResult
  //

  CalibrationResult::
  CalibrationResult (const CodeType& Code,
                     const ValueType& Value)
  : ::xml_schema::Type (),
    Code_ (Code, this),
    Value_ (Value, this)
  {
  }

  CalibrationResult::
  CalibrationResult (::std::unique_ptr< CodeType > Code,
                     ::std::unique_ptr< ValueType > Value)
  : ::xml_schema::Type (),
    Code_ (std::move (Code), this),
    Value_ (std::move (Value), this)
  {
  }

  CalibrationResult::
  CalibrationResult (const CalibrationResult& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Code_ (x.Code_, f, this),
    Value_ (x.Value_, f, this)
  {
  }

  CalibrationResult::
  CalibrationResult (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Code_ (this),
    Value_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CalibrationResult::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Code
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Code",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< CodeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Code_.present ())
          {
            ::std::unique_ptr< CodeType > r (
              dynamic_cast< CodeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Code_.set (::std::move (r));
            continue;
          }
        }
      }

      // Value
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Value",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Value_.present ())
          {
            ::std::unique_ptr< ValueType > r (
              dynamic_cast< ValueType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Value_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Code_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Code",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }

    if (!Value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Value",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }
  }

  CalibrationResult* CalibrationResult::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CalibrationResult (*this, f, c);
  }

  CalibrationResult& CalibrationResult::
  operator= (const CalibrationResult& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Code_ = x.Code_;
      this->Value_ = x.Value_;
    }

    return *this;
  }

  CalibrationResult::
  ~CalibrationResult ()
  {
  }

  // Udi
  //

  Udi::
  Udi (const DeviceIdentifierType& DeviceIdentifier,
       const HumanReadableFormType& HumanReadableForm,
       const IssuerType& Issuer)
  : ::xml_schema::Type (),
    Extension_ (this),
    DeviceIdentifier_ (DeviceIdentifier, this),
    HumanReadableForm_ (HumanReadableForm, this),
    Issuer_ (Issuer, this),
    Jurisdiction_ (this)
  {
  }

  Udi::
  Udi (const DeviceIdentifierType& DeviceIdentifier,
       const HumanReadableFormType& HumanReadableForm,
       ::std::unique_ptr< IssuerType > Issuer)
  : ::xml_schema::Type (),
    Extension_ (this),
    DeviceIdentifier_ (DeviceIdentifier, this),
    HumanReadableForm_ (HumanReadableForm, this),
    Issuer_ (std::move (Issuer), this),
    Jurisdiction_ (this)
  {
  }

  Udi::
  Udi (::std::unique_ptr< DeviceIdentifierType > DeviceIdentifier,
       ::std::unique_ptr< HumanReadableFormType > HumanReadableForm,
       ::std::unique_ptr< IssuerType > Issuer)
  : ::xml_schema::Type (),
    Extension_ (this),
    DeviceIdentifier_ (std::move (DeviceIdentifier), this),
    HumanReadableForm_ (std::move (HumanReadableForm), this),
    Issuer_ (std::move (Issuer), this),
    Jurisdiction_ (this)
  {
  }

  Udi::
  Udi (const Udi& x,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    DeviceIdentifier_ (x.DeviceIdentifier_, f, this),
    HumanReadableForm_ (x.HumanReadableForm_, f, this),
    Issuer_ (x.Issuer_, f, this),
    Jurisdiction_ (x.Jurisdiction_, f, this)
  {
  }

  Udi::
  Udi (const ::xercesc::DOMElement& e,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    DeviceIdentifier_ (this),
    HumanReadableForm_ (this),
    Issuer_ (this),
    Jurisdiction_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Udi::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // DeviceIdentifier
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DeviceIdentifier",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< DeviceIdentifierType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!DeviceIdentifier_.present ())
          {
            ::std::unique_ptr< DeviceIdentifierType > r (
              dynamic_cast< DeviceIdentifierType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DeviceIdentifier_.set (::std::move (r));
            continue;
          }
        }
      }

      // HumanReadableForm
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "HumanReadableForm",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< HumanReadableFormType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!HumanReadableForm_.present ())
          {
            ::std::unique_ptr< HumanReadableFormType > r (
              dynamic_cast< HumanReadableFormType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->HumanReadableForm_.set (::std::move (r));
            continue;
          }
        }
      }

      // Issuer
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Issuer",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< IssuerType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Issuer_.present ())
          {
            ::std::unique_ptr< IssuerType > r (
              dynamic_cast< IssuerType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Issuer_.set (::std::move (r));
            continue;
          }
        }
      }

      // Jurisdiction
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Jurisdiction",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< JurisdictionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Jurisdiction_)
          {
            ::std::unique_ptr< JurisdictionType > r (
              dynamic_cast< JurisdictionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Jurisdiction_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!DeviceIdentifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DeviceIdentifier",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }

    if (!HumanReadableForm_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "HumanReadableForm",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }

    if (!Issuer_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Issuer",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }
  }

  Udi* Udi::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Udi (*this, f, c);
  }

  Udi& Udi::
  operator= (const Udi& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->DeviceIdentifier_ = x.DeviceIdentifier_;
      this->HumanReadableForm_ = x.HumanReadableForm_;
      this->Issuer_ = x.Issuer_;
      this->Jurisdiction_ = x.Jurisdiction_;
    }

    return *this;
  }

  Udi::
  ~Udi ()
  {
  }

  // Kind
  //

  Kind::
  Kind (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Kind_convert ();
  }

  Kind::
  Kind (const ::xercesc::DOMAttr& a,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Kind_convert ();
  }

  Kind::
  Kind (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Kind_convert ();
  }

  Kind* Kind::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Kind (*this, f, c);
  }

  Kind::Value Kind::
  _xsd_Kind_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Kind_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Kind_indexes_,
                      _xsd_Kind_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_Kind_indexes_ + 6 || _xsd_Kind_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Kind::
  _xsd_Kind_literals_[6] =
  {
    "Rcm",
    "PS",
    "SST",
    "ECE",
    "DCE",
    "Oth"
  };

  const Kind::Value Kind::
  _xsd_Kind_indexes_[6] =
  {
    ::CDM::Kind::DCE,
    ::CDM::Kind::ECE,
    ::CDM::Kind::Oth,
    ::CDM::Kind::PS,
    ::CDM::Kind::Rcm,
    ::CDM::Kind::SST
  };

  // ReferenceRange
  //

  ReferenceRange::
  ReferenceRange (const RangeType& Range)
  : ::xml_schema::Type (),
    Range_ (Range, this),
    Meaning_ (this)
  {
  }

  ReferenceRange::
  ReferenceRange (::std::unique_ptr< RangeType > Range)
  : ::xml_schema::Type (),
    Range_ (std::move (Range), this),
    Meaning_ (this)
  {
  }

  ReferenceRange::
  ReferenceRange (const ReferenceRange& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Range_ (x.Range_, f, this),
    Meaning_ (x.Meaning_, f, this)
  {
  }

  ReferenceRange::
  ReferenceRange (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Range_ (this),
    Meaning_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ReferenceRange::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Range
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Range",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< RangeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Range_.present ())
          {
            ::std::unique_ptr< RangeType > r (
              dynamic_cast< RangeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Range_.set (::std::move (r));
            continue;
          }
        }
      }

      // Meaning
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Meaning",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< MeaningType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Meaning_)
          {
            ::std::unique_ptr< MeaningType > r (
              dynamic_cast< MeaningType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Meaning_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Range_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Range",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }
  }

  ReferenceRange* ReferenceRange::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReferenceRange (*this, f, c);
  }

  ReferenceRange& ReferenceRange::
  operator= (const ReferenceRange& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Range_ = x.Range_;
      this->Meaning_ = x.Meaning_;
    }

    return *this;
  }

  ReferenceRange::
  ~ReferenceRange ()
  {
  }

  // RequestedOrderDetail
  //

  RequestedOrderDetail::
  RequestedOrderDetail (const PlacerOrderNumberType& PlacerOrderNumber)
  : ::CDM::OrderDetail (),
    ReferringPhysician_ (this),
    RequestingPhysician_ (this),
    PlacerOrderNumber_ (PlacerOrderNumber, this)
  {
  }

  RequestedOrderDetail::
  RequestedOrderDetail (::std::unique_ptr< PlacerOrderNumberType > PlacerOrderNumber)
  : ::CDM::OrderDetail (),
    ReferringPhysician_ (this),
    RequestingPhysician_ (this),
    PlacerOrderNumber_ (std::move (PlacerOrderNumber), this)
  {
  }

  RequestedOrderDetail::
  RequestedOrderDetail (const RequestedOrderDetail& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::OrderDetail (x, f, c),
    ReferringPhysician_ (x.ReferringPhysician_, f, this),
    RequestingPhysician_ (x.RequestingPhysician_, f, this),
    PlacerOrderNumber_ (x.PlacerOrderNumber_, f, this)
  {
  }

  RequestedOrderDetail::
  RequestedOrderDetail (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::OrderDetail (e, f | ::xml_schema::Flags::base, c),
    ReferringPhysician_ (this),
    RequestingPhysician_ (this),
    PlacerOrderNumber_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void RequestedOrderDetail::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::OrderDetail::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReferringPhysician
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ReferringPhysician",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ReferringPhysicianType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ReferringPhysician_)
          {
            ::std::unique_ptr< ReferringPhysicianType > r (
              dynamic_cast< ReferringPhysicianType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ReferringPhysician_.set (::std::move (r));
            continue;
          }
        }
      }

      // RequestingPhysician
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "RequestingPhysician",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< RequestingPhysicianType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->RequestingPhysician_)
          {
            ::std::unique_ptr< RequestingPhysicianType > r (
              dynamic_cast< RequestingPhysicianType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->RequestingPhysician_.set (::std::move (r));
            continue;
          }
        }
      }

      // PlacerOrderNumber
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "PlacerOrderNumber",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< PlacerOrderNumberType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!PlacerOrderNumber_.present ())
          {
            ::std::unique_ptr< PlacerOrderNumberType > r (
              dynamic_cast< PlacerOrderNumberType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->PlacerOrderNumber_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!PlacerOrderNumber_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PlacerOrderNumber",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
    }
  }

  RequestedOrderDetail* RequestedOrderDetail::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RequestedOrderDetail (*this, f, c);
  }

  RequestedOrderDetail& RequestedOrderDetail::
  operator= (const RequestedOrderDetail& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::OrderDetail& > (*this) = x;
      this->ReferringPhysician_ = x.ReferringPhysician_;
      this->RequestingPhysician_ = x.RequestingPhysician_;
      this->PlacerOrderNumber_ = x.PlacerOrderNumber_;
    }

    return *this;
  }

  RequestedOrderDetail::
  ~RequestedOrderDetail ()
  {
  }

  // PerformedOrderDetail
  //

  PerformedOrderDetail::
  PerformedOrderDetail ()
  : ::CDM::OrderDetail (),
    FillerOrderNumber_ (this),
    ResultingClinicalInfo_ (this)
  {
  }

  PerformedOrderDetail::
  PerformedOrderDetail (const PerformedOrderDetail& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::OrderDetail (x, f, c),
    FillerOrderNumber_ (x.FillerOrderNumber_, f, this),
    ResultingClinicalInfo_ (x.ResultingClinicalInfo_, f, this)
  {
  }

  PerformedOrderDetail::
  PerformedOrderDetail (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::OrderDetail (e, f | ::xml_schema::Flags::base, c),
    FillerOrderNumber_ (this),
    ResultingClinicalInfo_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PerformedOrderDetail::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::OrderDetail::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FillerOrderNumber
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "FillerOrderNumber",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< FillerOrderNumberType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->FillerOrderNumber_)
          {
            ::std::unique_ptr< FillerOrderNumberType > r (
              dynamic_cast< FillerOrderNumberType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FillerOrderNumber_.set (::std::move (r));
            continue;
          }
        }
      }

      // ResultingClinicalInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ResultingClinicalInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            &::xsd::cxx::tree::factory_impl< ResultingClinicalInfoType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ResultingClinicalInfoType > r (
            dynamic_cast< ResultingClinicalInfoType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ResultingClinicalInfo_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  PerformedOrderDetail* PerformedOrderDetail::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PerformedOrderDetail (*this, f, c);
  }

  PerformedOrderDetail& PerformedOrderDetail::
  operator= (const PerformedOrderDetail& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::OrderDetail& > (*this) = x;
      this->FillerOrderNumber_ = x.FillerOrderNumber_;
      this->ResultingClinicalInfo_ = x.ResultingClinicalInfo_;
    }

    return *this;
  }

  PerformedOrderDetail::
  ~PerformedOrderDetail ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace CDM
{
  ::std::unique_ptr< ::CDM::Mdib >
  MdibContainer (const ::std::string& u,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::Mdib > (
      ::CDM::MdibContainer (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::Mdib >
  MdibContainer (const ::std::string& u,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::Mdib > (
      ::CDM::MdibContainer (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::Mdib >
  MdibContainer (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::Mdib > (
      ::CDM::MdibContainer (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::Mdib >
  MdibContainer (::std::istream& is,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::MdibContainer (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::Mdib >
  MdibContainer (::std::istream& is,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::MdibContainer (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::Mdib >
  MdibContainer (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::MdibContainer (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::Mdib >
  MdibContainer (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::MdibContainer (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::Mdib >
  MdibContainer (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::MdibContainer (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::Mdib >
  MdibContainer (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::MdibContainer (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::Mdib >
  MdibContainer (::xercesc::InputSource& i,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::Mdib > (
      ::CDM::MdibContainer (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::Mdib >
  MdibContainer (::xercesc::InputSource& i,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::Mdib > (
      ::CDM::MdibContainer (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::Mdib >
  MdibContainer (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::Mdib > (
      ::CDM::MdibContainer (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::Mdib >
  MdibContainer (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::CDM::Mdib > (
        ::CDM::MdibContainer (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "MdibContainer",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
        &::xsd::cxx::tree::factory_impl< ::CDM::Mdib >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {
      ::std::unique_ptr< ::CDM::Mdib > r (
        dynamic_cast< ::CDM::Mdib* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MdibContainer",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
  }

  ::std::unique_ptr< ::CDM::Mdib >
  MdibContainer (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "MdibContainer",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
        &::xsd::cxx::tree::factory_impl< ::CDM::Mdib >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {

      ::std::unique_ptr< ::CDM::Mdib > r (
        dynamic_cast< ::CDM::Mdib* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MdibContainer",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace CDM
{
  void
  operator<< (::xercesc::DOMElement& e, const Mdib& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const Mdib::ExtensionType& x (*i.Extension ());
        if (typeid (Mdib::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // MdDescription
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.MdDescription ())
      {
        const Mdib::MdDescriptionType& x (*i.MdDescription ());
        if (typeid (Mdib::MdDescriptionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MdDescription",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "MdDescription",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // MdState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.MdState ())
      {
        const Mdib::MdStateType& x (*i.MdState ());
        if (typeid (Mdib::MdStateType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MdState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "MdState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // MdibVersion
    //
    if (i.MdibVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MdibVersion",
          e));

      a << *i.MdibVersion ();
    }

    // SequenceId
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "SequenceId",
          e));

      a << i.SequenceId ();
    }

    // InstanceId
    //
    if (i.InstanceId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "InstanceId",
          e));

      a << *i.InstanceId ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Mdib >
  _xsd_Mdib_type_serializer_init (
    "Mdib",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const MdDescription& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const MdDescription::ExtensionType& x (*i.Extension ());
        if (typeid (MdDescription::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Mds
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (MdDescription::MdsConstIterator
           b (i.Mds ().begin ()), n (i.Mds ().end ());
           b != n; ++b)
      {
        if (typeid (MdDescription::MdsType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Mds",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Mds",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // DescriptionVersion
    //
    if (i.DescriptionVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "DescriptionVersion",
          e));

      a << *i.DescriptionVersion ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MdDescription >
  _xsd_MdDescription_type_serializer_init (
    "MdDescription",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const MdState& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const MdState::ExtensionType& x (*i.Extension ());
        if (typeid (MdState::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // State
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (MdState::StateConstIterator
           b (i.State ().begin ()), n (i.State ().end ());
           b != n; ++b)
      {
        if (typeid (MdState::StateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "State",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "State",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // StateVersion
    //
    if (i.StateVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "StateVersion",
          e));

      a << *i.StateVersion ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MdState >
  _xsd_MdState_type_serializer_init (
    "MdState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const MeasurementValidity& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const MeasurementValidity& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const MeasurementValidity& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MeasurementValidity >
  _xsd_MeasurementValidity_type_serializer_init (
    "MeasurementValidity",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const Timestamp& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Timestamp& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Timestamp& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Timestamp >
  _xsd_Timestamp_type_serializer_init (
    "Timestamp",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const VersionCounter& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const VersionCounter& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const VersionCounter& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, VersionCounter >
  _xsd_VersionCounter_type_serializer_init (
    "VersionCounter",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const ReferencedVersion& i)
  {
    e << static_cast< const ::CDM::VersionCounter& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ReferencedVersion& i)
  {
    a << static_cast< const ::CDM::VersionCounter& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const ReferencedVersion& i)
  {
    l << static_cast< const ::CDM::VersionCounter& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ReferencedVersion >
  _xsd_ReferencedVersion_type_serializer_init (
    "ReferencedVersion",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const CodeIdentifier& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CodeIdentifier& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CodeIdentifier& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CodeIdentifier >
  _xsd_CodeIdentifier_type_serializer_init (
    "CodeIdentifier",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SymbolicCodeName& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const SymbolicCodeName& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const SymbolicCodeName& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SymbolicCodeName >
  _xsd_SymbolicCodeName_type_serializer_init (
    "SymbolicCodeName",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const LocalizedTextRef& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const LocalizedTextRef& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const LocalizedTextRef& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LocalizedTextRef >
  _xsd_LocalizedTextRef_type_serializer_init (
    "LocalizedTextRef",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const LocalizedTextContent& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const LocalizedTextContent& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const LocalizedTextContent& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LocalizedTextContent >
  _xsd_LocalizedTextContent_type_serializer_init (
    "LocalizedTextContent",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const LocalizedTextWidth& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const LocalizedTextWidth& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const LocalizedTextWidth& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LocalizedTextWidth >
  _xsd_LocalizedTextWidth_type_serializer_init (
    "LocalizedTextWidth",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const LocalizedText& i)
  {
    e << static_cast< const ::CDM::LocalizedTextContent& > (i);

    // Ref
    //
    if (i.Ref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Ref",
          e));

      a << *i.Ref ();
    }

    // Lang
    //
    if (i.Lang ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Lang",
          e));

      a << *i.Lang ();
    }

    // Version
    //
    if (i.Version ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Version",
          e));

      a << *i.Version ();
    }

    // TextWidth
    //
    if (i.TextWidth ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "TextWidth",
          e));

      a << *i.TextWidth ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LocalizedText >
  _xsd_LocalizedText_type_serializer_init (
    "LocalizedText",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const CodedValue& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const CodedValue::ExtensionType& x (*i.Extension ());
        if (typeid (CodedValue::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // CodingSystemName
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (CodedValue::CodingSystemNameConstIterator
           b (i.CodingSystemName ().begin ()), n (i.CodingSystemName ().end ());
           b != n; ++b)
      {
        if (typeid (CodedValue::CodingSystemNameType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CodingSystemName",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "CodingSystemName",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // ConceptDescription
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (CodedValue::ConceptDescriptionConstIterator
           b (i.ConceptDescription ().begin ()), n (i.ConceptDescription ().end ());
           b != n; ++b)
      {
        if (typeid (CodedValue::ConceptDescriptionType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ConceptDescription",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ConceptDescription",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // Translation
    //
    for (CodedValue::TranslationConstIterator
         b (i.Translation ().begin ()), n (i.Translation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Translation",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *b;
    }

    // Code
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Code",
          e));

      a << i.Code ();
    }

    // CodingSystem
    //
    if (i.CodingSystem ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "CodingSystem",
          e));

      a << *i.CodingSystem ();
    }

    // CodingSystemVersion
    //
    if (i.CodingSystemVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "CodingSystemVersion",
          e));

      a << *i.CodingSystemVersion ();
    }

    // SymbolicCodeName
    //
    if (i.SymbolicCodeName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "SymbolicCodeName",
          e));

      a << *i.SymbolicCodeName ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CodedValue >
  _xsd_CodedValue_type_serializer_init (
    "CodedValue",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const InstanceIdentifier& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const InstanceIdentifier::ExtensionType& x (*i.Extension ());
        if (typeid (InstanceIdentifier::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Type
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Type ())
      {
        const InstanceIdentifier::TypeType& x (*i.Type ());
        if (typeid (InstanceIdentifier::TypeType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Type",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Type",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // IdentifierName
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (InstanceIdentifier::IdentifierNameConstIterator
           b (i.IdentifierName ().begin ()), n (i.IdentifierName ().end ());
           b != n; ++b)
      {
        if (typeid (InstanceIdentifier::IdentifierNameType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "IdentifierName",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "IdentifierName",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // Root
    //
    if (i.Root ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Root",
          e));

      a << *i.Root ();
    }

    // Extension
    //
    if (i.Extension1 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Extension",
          e));

      a << *i.Extension1 ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, InstanceIdentifier >
  _xsd_InstanceIdentifier_type_serializer_init (
    "InstanceIdentifier",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const Range& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const Range::ExtensionType& x (*i.Extension ());
        if (typeid (Range::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Lower
    //
    if (i.Lower ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Lower",
          e));

      a << ::xml_schema::AsDecimal(*i.Lower ());
    }

    // Upper
    //
    if (i.Upper ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Upper",
          e));

      a << ::xml_schema::AsDecimal(*i.Upper ());
    }

    // StepWidth
    //
    if (i.StepWidth ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "StepWidth",
          e));

      a << ::xml_schema::AsDecimal(*i.StepWidth ());
    }

    // RelativeAccuracy
    //
    if (i.RelativeAccuracy ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "RelativeAccuracy",
          e));

      a << ::xml_schema::AsDecimal(*i.RelativeAccuracy ());
    }

    // AbsoluteAccuracy
    //
    if (i.AbsoluteAccuracy ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "AbsoluteAccuracy",
          e));

      a << ::xml_schema::AsDecimal(*i.AbsoluteAccuracy ());
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Range >
  _xsd_Range_type_serializer_init (
    "Range",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const Measurement& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const Measurement::ExtensionType& x (*i.Extension ());
        if (typeid (Measurement::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // MeasurementUnit
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const Measurement::MeasurementUnitType& x (i.MeasurementUnit ());
      if (typeid (Measurement::MeasurementUnitType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MeasurementUnit",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MeasurementUnit",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // MeasuredValue
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MeasuredValue",
          e));

      a << ::xml_schema::AsDecimal(i.MeasuredValue ());
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Measurement >
  _xsd_Measurement_type_serializer_init (
    "Measurement",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SafetyClassification& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const SafetyClassification& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const SafetyClassification& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SafetyClassification >
  _xsd_SafetyClassification_type_serializer_init (
    "SafetyClassification",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const ComponentActivation& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ComponentActivation& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const ComponentActivation& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ComponentActivation >
  _xsd_ComponentActivation_type_serializer_init (
    "ComponentActivation",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const ApprovedJurisdictions& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // ApprovedJurisdiction
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ApprovedJurisdictions::ApprovedJurisdictionConstIterator
           b (i.ApprovedJurisdiction ().begin ()), n (i.ApprovedJurisdiction ().end ());
           b != n; ++b)
      {
        if (typeid (ApprovedJurisdictions::ApprovedJurisdictionType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ApprovedJurisdiction",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ApprovedJurisdiction",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ApprovedJurisdictions >
  _xsd_ApprovedJurisdictions_type_serializer_init (
    "ApprovedJurisdictions",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const OperatingJurisdiction& i)
  {
    e << static_cast< const ::CDM::InstanceIdentifier& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OperatingJurisdiction >
  _xsd_OperatingJurisdiction_type_serializer_init (
    "OperatingJurisdiction",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const Handle& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Handle& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Handle& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Handle >
  _xsd_Handle_type_serializer_init (
    "Handle",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const HandleRef& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const HandleRef& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const HandleRef& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, HandleRef >
  _xsd_HandleRef_type_serializer_init (
    "HandleRef",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const PhysicalConnectorInfo& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const PhysicalConnectorInfo::ExtensionType& x (*i.Extension ());
        if (typeid (PhysicalConnectorInfo::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Label
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (PhysicalConnectorInfo::LabelConstIterator
           b (i.Label ().begin ()), n (i.Label ().end ());
           b != n; ++b)
      {
        if (typeid (PhysicalConnectorInfo::LabelType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Label",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Label",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // Number
    //
    if (i.Number ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Number",
          e));

      a << *i.Number ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PhysicalConnectorInfo >
  _xsd_PhysicalConnectorInfo_type_serializer_init (
    "PhysicalConnectorInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractDescriptor& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const AbstractDescriptor::ExtensionType& x (*i.Extension ());
        if (typeid (AbstractDescriptor::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Type
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Type ())
      {
        const AbstractDescriptor::TypeType& x (*i.Type ());
        if (typeid (AbstractDescriptor::TypeType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Type",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Type",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Handle
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Handle",
          e));

      a << i.Handle ();
    }

    // DescriptorVersion
    //
    if (i.DescriptorVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "DescriptorVersion",
          e));

      a << *i.DescriptorVersion ();
    }

    // SafetyClassification
    //
    if (i.SafetyClassification ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "SafetyClassification",
          e));

      a << *i.SafetyClassification ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractDescriptor >
  _xsd_AbstractDescriptor_type_serializer_init (
    "AbstractDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractState& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const AbstractState::ExtensionType& x (*i.Extension ());
        if (typeid (AbstractState::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // StateVersion
    //
    if (i.StateVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "StateVersion",
          e));

      a << *i.StateVersion ();
    }

    // DescriptorHandle
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "DescriptorHandle",
          e));

      a << i.DescriptorHandle ();
    }

    // DescriptorVersion
    //
    if (i.DescriptorVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "DescriptorVersion",
          e));

      a << *i.DescriptorVersion ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractState >
  _xsd_AbstractState_type_serializer_init (
    "AbstractState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractMultiState& i)
  {
    e << static_cast< const ::CDM::AbstractState& > (i);

    // Category
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Category ())
      {
        const AbstractMultiState::CategoryType& x (*i.Category ());
        if (typeid (AbstractMultiState::CategoryType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Category",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Category",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Handle
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Handle",
          e));

      a << i.Handle ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractMultiState >
  _xsd_AbstractMultiState_type_serializer_init (
    "AbstractMultiState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractDeviceComponentDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDescriptor& > (i);

    // ProductionSpecification
    //
    for (AbstractDeviceComponentDescriptor::ProductionSpecificationConstIterator
         b (i.ProductionSpecification ().begin ()), n (i.ProductionSpecification ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ProductionSpecification",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *b;
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractDeviceComponentDescriptor >
  _xsd_AbstractDeviceComponentDescriptor_type_serializer_init (
    "AbstractDeviceComponentDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractComplexDeviceComponentDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDeviceComponentDescriptor& > (i);

    // AlertSystem
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AlertSystem ())
      {
        const AbstractComplexDeviceComponentDescriptor::AlertSystemType& x (*i.AlertSystem ());
        if (typeid (AbstractComplexDeviceComponentDescriptor::AlertSystemType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AlertSystem",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AlertSystem",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Sco
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Sco ())
      {
        const AbstractComplexDeviceComponentDescriptor::ScoType& x (*i.Sco ());
        if (typeid (AbstractComplexDeviceComponentDescriptor::ScoType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Sco",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Sco",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractComplexDeviceComponentDescriptor >
  _xsd_AbstractComplexDeviceComponentDescriptor_type_serializer_init (
    "AbstractComplexDeviceComponentDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const CalibrationState& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CalibrationState& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CalibrationState& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CalibrationState >
  _xsd_CalibrationState_type_serializer_init (
    "CalibrationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const CalibrationType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CalibrationType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CalibrationType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CalibrationType >
  _xsd_CalibrationType_type_serializer_init (
    "CalibrationType",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const CalibrationInfo& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const CalibrationInfo::ExtensionType& x (*i.Extension ());
        if (typeid (CalibrationInfo::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // CalibrationDocumentation
    //
    for (CalibrationInfo::CalibrationDocumentationConstIterator
         b (i.CalibrationDocumentation ().begin ()), n (i.CalibrationDocumentation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CalibrationDocumentation",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *b;
    }

    // ComponentCalibrationState
    //
    if (i.ComponentCalibrationState ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ComponentCalibrationState",
          e));

      a << *i.ComponentCalibrationState ();
    }

    // Type
    //
    if (i.Type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Type",
          e));

      a << *i.Type ();
    }

    // Time
    //
    if (i.Time ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Time",
          e));

      a << *i.Time ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CalibrationInfo >
  _xsd_CalibrationInfo_type_serializer_init (
    "CalibrationInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractDeviceComponentState& i)
  {
    e << static_cast< const ::CDM::AbstractState& > (i);

    // CalibrationInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CalibrationInfo ())
      {
        const AbstractDeviceComponentState::CalibrationInfoType& x (*i.CalibrationInfo ());
        if (typeid (AbstractDeviceComponentState::CalibrationInfoType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CalibrationInfo",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CalibrationInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // NextCalibration
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.NextCalibration ())
      {
        const AbstractDeviceComponentState::NextCalibrationType& x (*i.NextCalibration ());
        if (typeid (AbstractDeviceComponentState::NextCalibrationType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "NextCalibration",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "NextCalibration",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // PhysicalConnector
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.PhysicalConnector ())
      {
        const AbstractDeviceComponentState::PhysicalConnectorType& x (*i.PhysicalConnector ());
        if (typeid (AbstractDeviceComponentState::PhysicalConnectorType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PhysicalConnector",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "PhysicalConnector",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // ActivationState
    //
    if (i.ActivationState ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ActivationState",
          e));

      a << *i.ActivationState ();
    }

    // OperatingHours
    //
    if (i.OperatingHours ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "OperatingHours",
          e));

      a << *i.OperatingHours ();
    }

    // OperatingCycles
    //
    if (i.OperatingCycles ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "OperatingCycles",
          e));

      a << *i.OperatingCycles ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractDeviceComponentState >
  _xsd_AbstractDeviceComponentState_type_serializer_init (
    "AbstractDeviceComponentState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractComplexDeviceComponentState& i)
  {
    e << static_cast< const ::CDM::AbstractDeviceComponentState& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractComplexDeviceComponentState >
  _xsd_AbstractComplexDeviceComponentState_type_serializer_init (
    "AbstractComplexDeviceComponentState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const MdsDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractComplexDeviceComponentDescriptor& > (i);

    // MetaData
    //
    if (i.MetaData ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MetaData",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *i.MetaData ();
    }

    // SystemContext
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.SystemContext ())
      {
        const MdsDescriptor::SystemContextType& x (*i.SystemContext ());
        if (typeid (MdsDescriptor::SystemContextType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SystemContext",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "SystemContext",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Clock
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Clock ())
      {
        const MdsDescriptor::ClockType& x (*i.Clock ());
        if (typeid (MdsDescriptor::ClockType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Clock",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Clock",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Battery
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (MdsDescriptor::BatteryConstIterator
           b (i.Battery ().begin ()), n (i.Battery ().end ());
           b != n; ++b)
      {
        if (typeid (MdsDescriptor::BatteryType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Battery",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Battery",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // ApprovedJurisdictions
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ApprovedJurisdictions ())
      {
        const MdsDescriptor::ApprovedJurisdictionsType& x (*i.ApprovedJurisdictions ());
        if (typeid (MdsDescriptor::ApprovedJurisdictionsType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ApprovedJurisdictions",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ApprovedJurisdictions",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Vmd
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (MdsDescriptor::VmdConstIterator
           b (i.Vmd ().begin ()), n (i.Vmd ().end ());
           b != n; ++b)
      {
        if (typeid (MdsDescriptor::VmdType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Vmd",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Vmd",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MdsDescriptor >
  _xsd_MdsDescriptor_type_serializer_init (
    "MdsDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const MdsOperatingMode& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const MdsOperatingMode& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const MdsOperatingMode& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MdsOperatingMode >
  _xsd_MdsOperatingMode_type_serializer_init (
    "MdsOperatingMode",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const MdsState& i)
  {
    e << static_cast< const ::CDM::AbstractComplexDeviceComponentState& > (i);

    // OperatingJurisdiction
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.OperatingJurisdiction ())
      {
        const MdsState::OperatingJurisdictionType& x (*i.OperatingJurisdiction ());
        if (typeid (MdsState::OperatingJurisdictionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OperatingJurisdiction",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "OperatingJurisdiction",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Lang
    //
    if (i.Lang ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Lang",
          e));

      a << *i.Lang ();
    }

    // OperatingMode
    //
    if (i.OperatingMode ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "OperatingMode",
          e));

      a << *i.OperatingMode ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MdsState >
  _xsd_MdsState_type_serializer_init (
    "MdsState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const VmdDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractComplexDeviceComponentDescriptor& > (i);

    // ApprovedJurisdictions
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ApprovedJurisdictions ())
      {
        const VmdDescriptor::ApprovedJurisdictionsType& x (*i.ApprovedJurisdictions ());
        if (typeid (VmdDescriptor::ApprovedJurisdictionsType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ApprovedJurisdictions",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ApprovedJurisdictions",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Channel
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (VmdDescriptor::ChannelConstIterator
           b (i.Channel ().begin ()), n (i.Channel ().end ());
           b != n; ++b)
      {
        if (typeid (VmdDescriptor::ChannelType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Channel",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Channel",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, VmdDescriptor >
  _xsd_VmdDescriptor_type_serializer_init (
    "VmdDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const VmdState& i)
  {
    e << static_cast< const ::CDM::AbstractComplexDeviceComponentState& > (i);

    // OperatingJurisdiction
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.OperatingJurisdiction ())
      {
        const VmdState::OperatingJurisdictionType& x (*i.OperatingJurisdiction ());
        if (typeid (VmdState::OperatingJurisdictionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OperatingJurisdiction",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "OperatingJurisdiction",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, VmdState >
  _xsd_VmdState_type_serializer_init (
    "VmdState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const ChannelDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDeviceComponentDescriptor& > (i);

    // Metric
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ChannelDescriptor::MetricConstIterator
           b (i.Metric ().begin ()), n (i.Metric ().end ());
           b != n; ++b)
      {
        if (typeid (ChannelDescriptor::MetricType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Metric",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Metric",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ChannelDescriptor >
  _xsd_ChannelDescriptor_type_serializer_init (
    "ChannelDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const ChannelState& i)
  {
    e << static_cast< const ::CDM::AbstractDeviceComponentState& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ChannelState >
  _xsd_ChannelState_type_serializer_init (
    "ChannelState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractAlertDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractAlertDescriptor >
  _xsd_AbstractAlertDescriptor_type_serializer_init (
    "AbstractAlertDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractAlertState& i)
  {
    e << static_cast< const ::CDM::AbstractState& > (i);

    // ActivationState
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ActivationState",
          e));

      a << i.ActivationState ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractAlertState >
  _xsd_AbstractAlertState_type_serializer_init (
    "AbstractAlertState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AlertActivation& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AlertActivation& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const AlertActivation& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertActivation >
  _xsd_AlertActivation_type_serializer_init (
    "AlertActivation",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SystemSignalActivation& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Manifestation
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Manifestation",
          e));

      a << i.Manifestation ();
    }

    // State
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "State",
          e));

      a << i.State ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SystemSignalActivation >
  _xsd_SystemSignalActivation_type_serializer_init (
    "SystemSignalActivation",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AlertSystemDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractAlertDescriptor& > (i);

    // AlertCondition
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AlertSystemDescriptor::AlertConditionConstIterator
           b (i.AlertCondition ().begin ()), n (i.AlertCondition ().end ());
           b != n; ++b)
      {
        if (typeid (AlertSystemDescriptor::AlertConditionType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AlertCondition",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "AlertCondition",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // AlertSignal
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AlertSystemDescriptor::AlertSignalConstIterator
           b (i.AlertSignal ().begin ()), n (i.AlertSignal ().end ());
           b != n; ++b)
      {
        if (typeid (AlertSystemDescriptor::AlertSignalType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AlertSignal",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "AlertSignal",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // MaxPhysiologicalParallelAlarms
    //
    if (i.MaxPhysiologicalParallelAlarms ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MaxPhysiologicalParallelAlarms",
          e));

      a << *i.MaxPhysiologicalParallelAlarms ();
    }

    // MaxTechnicalParallelAlarms
    //
    if (i.MaxTechnicalParallelAlarms ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MaxTechnicalParallelAlarms",
          e));

      a << *i.MaxTechnicalParallelAlarms ();
    }

    // SelfCheckPeriod
    //
    if (i.SelfCheckPeriod ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "SelfCheckPeriod",
          e));

      a << *i.SelfCheckPeriod ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertSystemDescriptor >
  _xsd_AlertSystemDescriptor_type_serializer_init (
    "AlertSystemDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AlertSystemState& i)
  {
    e << static_cast< const ::CDM::AbstractAlertState& > (i);

    // SystemSignalActivation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AlertSystemState::SystemSignalActivationConstIterator
           b (i.SystemSignalActivation ().begin ()), n (i.SystemSignalActivation ().end ());
           b != n; ++b)
      {
        if (typeid (AlertSystemState::SystemSignalActivationType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SystemSignalActivation",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "SystemSignalActivation",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // LastSelfCheck
    //
    if (i.LastSelfCheck ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "LastSelfCheck",
          e));

      a << *i.LastSelfCheck ();
    }

    // SelfCheckCount
    //
    if (i.SelfCheckCount ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "SelfCheckCount",
          e));

      a << *i.SelfCheckCount ();
    }

    // PresentPhysiologicalAlarmConditions
    //
    if (i.PresentPhysiologicalAlarmConditions ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "PresentPhysiologicalAlarmConditions",
          e));

      a << *i.PresentPhysiologicalAlarmConditions ();
    }

    // PresentTechnicalAlarmConditions
    //
    if (i.PresentTechnicalAlarmConditions ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "PresentTechnicalAlarmConditions",
          e));

      a << *i.PresentTechnicalAlarmConditions ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertSystemState >
  _xsd_AlertSystemState_type_serializer_init (
    "AlertSystemState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const CauseInfo& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const CauseInfo::ExtensionType& x (*i.Extension ());
        if (typeid (CauseInfo::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // RemedyInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.RemedyInfo ())
      {
        const CauseInfo::RemedyInfoType& x (*i.RemedyInfo ());
        if (typeid (CauseInfo::RemedyInfoType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "RemedyInfo",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "RemedyInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Description
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (CauseInfo::DescriptionConstIterator
           b (i.Description ().begin ()), n (i.Description ().end ());
           b != n; ++b)
      {
        if (typeid (CauseInfo::DescriptionType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Description",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Description",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CauseInfo >
  _xsd_CauseInfo_type_serializer_init (
    "CauseInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const RemedyInfo& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const RemedyInfo::ExtensionType& x (*i.Extension ());
        if (typeid (RemedyInfo::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Description
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (RemedyInfo::DescriptionConstIterator
           b (i.Description ().begin ()), n (i.Description ().end ());
           b != n; ++b)
      {
        if (typeid (RemedyInfo::DescriptionType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Description",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Description",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RemedyInfo >
  _xsd_RemedyInfo_type_serializer_init (
    "RemedyInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AlertConditionKind& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AlertConditionKind& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const AlertConditionKind& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertConditionKind >
  _xsd_AlertConditionKind_type_serializer_init (
    "AlertConditionKind",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AlertConditionPriority& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AlertConditionPriority& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const AlertConditionPriority& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertConditionPriority >
  _xsd_AlertConditionPriority_type_serializer_init (
    "AlertConditionPriority",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AlertConditionDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractAlertDescriptor& > (i);

    // Source
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AlertConditionDescriptor::SourceConstIterator
           b (i.Source ().begin ()), n (i.Source ().end ());
           b != n; ++b)
      {
        if (typeid (AlertConditionDescriptor::SourceType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Source",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Source",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // CauseInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AlertConditionDescriptor::CauseInfoConstIterator
           b (i.CauseInfo ().begin ()), n (i.CauseInfo ().end ());
           b != n; ++b)
      {
        if (typeid (AlertConditionDescriptor::CauseInfoType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CauseInfo",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "CauseInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // Kind
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Kind",
          e));

      a << i.Kind ();
    }

    // Priority
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Priority",
          e));

      a << i.Priority ();
    }

    // DefaultConditionGenerationDelay
    //
    if (i.DefaultConditionGenerationDelay ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "DefaultConditionGenerationDelay",
          e));

      a << *i.DefaultConditionGenerationDelay ();
    }

    // CanEscalate
    //
    if (i.CanEscalate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "CanEscalate",
          e));

      a << *i.CanEscalate ();
    }

    // CanDeescalate
    //
    if (i.CanDeescalate ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "CanDeescalate",
          e));

      a << *i.CanDeescalate ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertConditionDescriptor >
  _xsd_AlertConditionDescriptor_type_serializer_init (
    "AlertConditionDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AlertConditionReference& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::CDM::HandleRef, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AlertConditionReference& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::CDM::HandleRef, char >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const AlertConditionReference& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::CDM::HandleRef, char >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertConditionReference >
  _xsd_AlertConditionReference_type_serializer_init (
    "AlertConditionReference",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AlertConditionState& i)
  {
    e << static_cast< const ::CDM::AbstractAlertState& > (i);

    // ActualConditionGenerationDelay
    //
    if (i.ActualConditionGenerationDelay ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ActualConditionGenerationDelay",
          e));

      a << *i.ActualConditionGenerationDelay ();
    }

    // ActualPriority
    //
    if (i.ActualPriority ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ActualPriority",
          e));

      a << *i.ActualPriority ();
    }

    // Rank
    //
    if (i.Rank ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Rank",
          e));

      a << *i.Rank ();
    }

    // Presence
    //
    if (i.Presence ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Presence",
          e));

      a << *i.Presence ();
    }

    // DeterminationTime
    //
    if (i.DeterminationTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "DeterminationTime",
          e));

      a << *i.DeterminationTime ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertConditionState >
  _xsd_AlertConditionState_type_serializer_init (
    "AlertConditionState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const LimitAlertConditionDescriptor& i)
  {
    e << static_cast< const ::CDM::AlertConditionDescriptor& > (i);

    // MaxLimits
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const LimitAlertConditionDescriptor::MaxLimitsType& x (i.MaxLimits ());
      if (typeid (LimitAlertConditionDescriptor::MaxLimitsType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxLimits",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MaxLimits",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // AutoLimitSupported
    //
    if (i.AutoLimitSupported ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "AutoLimitSupported",
          e));

      a << *i.AutoLimitSupported ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LimitAlertConditionDescriptor >
  _xsd_LimitAlertConditionDescriptor_type_serializer_init (
    "LimitAlertConditionDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AlertConditionMonitoredLimits& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AlertConditionMonitoredLimits& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const AlertConditionMonitoredLimits& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertConditionMonitoredLimits >
  _xsd_AlertConditionMonitoredLimits_type_serializer_init (
    "AlertConditionMonitoredLimits",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const LimitAlertConditionState& i)
  {
    e << static_cast< const ::CDM::AlertConditionState& > (i);

    // Limits
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const LimitAlertConditionState::LimitsType& x (i.Limits ());
      if (typeid (LimitAlertConditionState::LimitsType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Limits",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Limits",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // MonitoredAlertLimits
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MonitoredAlertLimits",
          e));

      a << i.MonitoredAlertLimits ();
    }

    // AutoLimitActivationState
    //
    if (i.AutoLimitActivationState ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "AutoLimitActivationState",
          e));

      a << *i.AutoLimitActivationState ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LimitAlertConditionState >
  _xsd_LimitAlertConditionState_type_serializer_init (
    "LimitAlertConditionState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AlertSignalManifestation& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AlertSignalManifestation& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const AlertSignalManifestation& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertSignalManifestation >
  _xsd_AlertSignalManifestation_type_serializer_init (
    "AlertSignalManifestation",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AlertSignalDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractAlertDescriptor& > (i);

    // ConditionSignaled
    //
    if (i.ConditionSignaled ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ConditionSignaled",
          e));

      a << *i.ConditionSignaled ();
    }

    // Manifestation
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Manifestation",
          e));

      a << i.Manifestation ();
    }

    // Latching
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Latching",
          e));

      a << i.Latching ();
    }

    // DefaultSignalGenerationDelay
    //
    if (i.DefaultSignalGenerationDelay ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "DefaultSignalGenerationDelay",
          e));

      a << *i.DefaultSignalGenerationDelay ();
    }

    // MinSignalGenerationDelay
    //
    if (i.MinSignalGenerationDelay ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MinSignalGenerationDelay",
          e));

      a << *i.MinSignalGenerationDelay ();
    }

    // MaxSignalGenerationDelay
    //
    if (i.MaxSignalGenerationDelay ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MaxSignalGenerationDelay",
          e));

      a << *i.MaxSignalGenerationDelay ();
    }

    // SignalDelegationSupported
    //
    if (i.SignalDelegationSupported ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "SignalDelegationSupported",
          e));

      a << *i.SignalDelegationSupported ();
    }

    // AcknowledgementSupported
    //
    if (i.AcknowledgementSupported ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "AcknowledgementSupported",
          e));

      a << *i.AcknowledgementSupported ();
    }

    // AcknowledgeTimeout
    //
    if (i.AcknowledgeTimeout ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "AcknowledgeTimeout",
          e));

      a << *i.AcknowledgeTimeout ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertSignalDescriptor >
  _xsd_AlertSignalDescriptor_type_serializer_init (
    "AlertSignalDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AlertSignalPresence& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AlertSignalPresence& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const AlertSignalPresence& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertSignalPresence >
  _xsd_AlertSignalPresence_type_serializer_init (
    "AlertSignalPresence",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AlertSignalPrimaryLocation& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AlertSignalPrimaryLocation& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const AlertSignalPrimaryLocation& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertSignalPrimaryLocation >
  _xsd_AlertSignalPrimaryLocation_type_serializer_init (
    "AlertSignalPrimaryLocation",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AlertSignalState& i)
  {
    e << static_cast< const ::CDM::AbstractAlertState& > (i);

    // ActualSignalGenerationDelay
    //
    if (i.ActualSignalGenerationDelay ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ActualSignalGenerationDelay",
          e));

      a << *i.ActualSignalGenerationDelay ();
    }

    // Presence
    //
    if (i.Presence ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Presence",
          e));

      a << *i.Presence ();
    }

    // Location
    //
    if (i.Location ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Location",
          e));

      a << *i.Location ();
    }

    // Slot
    //
    if (i.Slot ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Slot",
          e));

      a << *i.Slot ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertSignalState >
  _xsd_AlertSignalState_type_serializer_init (
    "AlertSignalState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const QualityIndicator& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const QualityIndicator& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const QualityIndicator& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, QualityIndicator >
  _xsd_QualityIndicator_type_serializer_init (
    "QualityIndicator",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const GenerationMode& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const GenerationMode& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const GenerationMode& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GenerationMode >
  _xsd_GenerationMode_type_serializer_init (
    "GenerationMode",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractMetricValue& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const AbstractMetricValue::ExtensionType& x (*i.Extension ());
        if (typeid (AbstractMetricValue::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // MetricQuality
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MetricQuality",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << i.MetricQuality ();
    }

    // Annotation
    //
    for (AbstractMetricValue::AnnotationConstIterator
         b (i.Annotation ().begin ()), n (i.Annotation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Annotation",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *b;
    }

    // StartTime
    //
    if (i.StartTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "StartTime",
          e));

      a << *i.StartTime ();
    }

    // StopTime
    //
    if (i.StopTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "StopTime",
          e));

      a << *i.StopTime ();
    }

    // DeterminationTime
    //
    if (i.DeterminationTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "DeterminationTime",
          e));

      a << *i.DeterminationTime ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractMetricValue >
  _xsd_AbstractMetricValue_type_serializer_init (
    "AbstractMetricValue",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const NumericMetricValue& i)
  {
    e << static_cast< const ::CDM::AbstractMetricValue& > (i);

    // Value
    //
    if (i.Value ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Value",
          e));

      a << ::xml_schema::AsDecimal(*i.Value ());
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, NumericMetricValue >
  _xsd_NumericMetricValue_type_serializer_init (
    "NumericMetricValue",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const StringMetricValue& i)
  {
    e << static_cast< const ::CDM::AbstractMetricValue& > (i);

    // Value
    //
    if (i.Value ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Value",
          e));

      a << *i.Value ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StringMetricValue >
  _xsd_StringMetricValue_type_serializer_init (
    "StringMetricValue",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const RealTimeValueType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const RealTimeValueType& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const RealTimeValueType& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RealTimeValueType >
  _xsd_RealTimeValueType_type_serializer_init (
    "RealTimeValueType",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SampleArrayValue& i)
  {
    e << static_cast< const ::CDM::AbstractMetricValue& > (i);

    // ApplyAnnotation
    //
    for (SampleArrayValue::ApplyAnnotationConstIterator
         b (i.ApplyAnnotation ().begin ()), n (i.ApplyAnnotation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ApplyAnnotation",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *b;
    }

    // Samples
    //
    if (i.Samples ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Samples",
          e));

      a << *i.Samples ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SampleArrayValue >
  _xsd_SampleArrayValue_type_serializer_init (
    "SampleArrayValue",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const MetricCategory& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const MetricCategory& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const MetricCategory& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MetricCategory >
  _xsd_MetricCategory_type_serializer_init (
    "MetricCategory",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const DerivationMethod& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DerivationMethod& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const DerivationMethod& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DerivationMethod >
  _xsd_DerivationMethod_type_serializer_init (
    "DerivationMethod",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const MetricAvailability& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const MetricAvailability& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const MetricAvailability& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MetricAvailability >
  _xsd_MetricAvailability_type_serializer_init (
    "MetricAvailability",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const EntryRef& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::CDM::HandleRef, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const EntryRef& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::CDM::HandleRef, char >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const EntryRef& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::CDM::HandleRef, char >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EntryRef >
  _xsd_EntryRef_type_serializer_init (
    "EntryRef",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractMetricDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDescriptor& > (i);

    // Unit
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AbstractMetricDescriptor::UnitType& x (i.Unit ());
      if (typeid (AbstractMetricDescriptor::UnitType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Unit",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Unit",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // BodySite
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AbstractMetricDescriptor::BodySiteConstIterator
           b (i.BodySite ().begin ()), n (i.BodySite ().end ());
           b != n; ++b)
      {
        if (typeid (AbstractMetricDescriptor::BodySiteType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "BodySite",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "BodySite",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // Relation
    //
    for (AbstractMetricDescriptor::RelationConstIterator
         b (i.Relation ().begin ()), n (i.Relation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Relation",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *b;
    }

    // MetricCategory
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MetricCategory",
          e));

      a << i.MetricCategory ();
    }

    // DerivationMethod
    //
    if (i.DerivationMethod ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "DerivationMethod",
          e));

      a << *i.DerivationMethod ();
    }

    // MetricAvailability
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MetricAvailability",
          e));

      a << i.MetricAvailability ();
    }

    // MaxMeasurementTime
    //
    if (i.MaxMeasurementTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MaxMeasurementTime",
          e));

      a << *i.MaxMeasurementTime ();
    }

    // MaxDelayTime
    //
    if (i.MaxDelayTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MaxDelayTime",
          e));

      a << *i.MaxDelayTime ();
    }

    // DeterminationPeriod
    //
    if (i.DeterminationPeriod ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "DeterminationPeriod",
          e));

      a << *i.DeterminationPeriod ();
    }

    // LifeTimePeriod
    //
    if (i.LifeTimePeriod ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "LifeTimePeriod",
          e));

      a << *i.LifeTimePeriod ();
    }

    // ActivationDuration
    //
    if (i.ActivationDuration ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ActivationDuration",
          e));

      a << *i.ActivationDuration ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractMetricDescriptor >
  _xsd_AbstractMetricDescriptor_type_serializer_init (
    "AbstractMetricDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractMetricState& i)
  {
    e << static_cast< const ::CDM::AbstractState& > (i);

    // BodySite
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AbstractMetricState::BodySiteConstIterator
           b (i.BodySite ().begin ()), n (i.BodySite ().end ());
           b != n; ++b)
      {
        if (typeid (AbstractMetricState::BodySiteType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "BodySite",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "BodySite",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // PhysicalConnector
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.PhysicalConnector ())
      {
        const AbstractMetricState::PhysicalConnectorType& x (*i.PhysicalConnector ());
        if (typeid (AbstractMetricState::PhysicalConnectorType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PhysicalConnector",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "PhysicalConnector",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // ActivationState
    //
    if (i.ActivationState ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ActivationState",
          e));

      a << *i.ActivationState ();
    }

    // ActiveDeterminationPeriod
    //
    if (i.ActiveDeterminationPeriod ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ActiveDeterminationPeriod",
          e));

      a << *i.ActiveDeterminationPeriod ();
    }

    // LifeTimePeriod
    //
    if (i.LifeTimePeriod ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "LifeTimePeriod",
          e));

      a << *i.LifeTimePeriod ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractMetricState >
  _xsd_AbstractMetricState_type_serializer_init (
    "AbstractMetricState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const NumericMetricDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractMetricDescriptor& > (i);

    // TechnicalRange
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (NumericMetricDescriptor::TechnicalRangeConstIterator
           b (i.TechnicalRange ().begin ()), n (i.TechnicalRange ().end ());
           b != n; ++b)
      {
        if (typeid (NumericMetricDescriptor::TechnicalRangeType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TechnicalRange",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "TechnicalRange",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // Resolution
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Resolution",
          e));

      a << ::xml_schema::AsDecimal(i.Resolution ());
    }

    // AveragingPeriod
    //
    if (i.AveragingPeriod ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "AveragingPeriod",
          e));

      a << *i.AveragingPeriod ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, NumericMetricDescriptor >
  _xsd_NumericMetricDescriptor_type_serializer_init (
    "NumericMetricDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const NumericMetricState& i)
  {
    e << static_cast< const ::CDM::AbstractMetricState& > (i);

    // MetricValue
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.MetricValue ())
      {
        const NumericMetricState::MetricValueType& x (*i.MetricValue ());
        if (typeid (NumericMetricState::MetricValueType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MetricValue",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "MetricValue",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // PhysiologicalRange
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (NumericMetricState::PhysiologicalRangeConstIterator
           b (i.PhysiologicalRange ().begin ()), n (i.PhysiologicalRange ().end ());
           b != n; ++b)
      {
        if (typeid (NumericMetricState::PhysiologicalRangeType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PhysiologicalRange",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "PhysiologicalRange",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // ActiveAveragingPeriod
    //
    if (i.ActiveAveragingPeriod ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ActiveAveragingPeriod",
          e));

      a << *i.ActiveAveragingPeriod ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, NumericMetricState >
  _xsd_NumericMetricState_type_serializer_init (
    "NumericMetricState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const StringMetricDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractMetricDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StringMetricDescriptor >
  _xsd_StringMetricDescriptor_type_serializer_init (
    "StringMetricDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const StringMetricState& i)
  {
    e << static_cast< const ::CDM::AbstractMetricState& > (i);

    // MetricValue
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.MetricValue ())
      {
        const StringMetricState::MetricValueType& x (*i.MetricValue ());
        if (typeid (StringMetricState::MetricValueType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MetricValue",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "MetricValue",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StringMetricState >
  _xsd_StringMetricState_type_serializer_init (
    "StringMetricState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const EnumStringMetricDescriptor& i)
  {
    e << static_cast< const ::CDM::StringMetricDescriptor& > (i);

    // AllowedValue
    //
    for (EnumStringMetricDescriptor::AllowedValueConstIterator
         b (i.AllowedValue ().begin ()), n (i.AllowedValue ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AllowedValue",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *b;
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumStringMetricDescriptor >
  _xsd_EnumStringMetricDescriptor_type_serializer_init (
    "EnumStringMetricDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const EnumStringMetricState& i)
  {
    e << static_cast< const ::CDM::StringMetricState& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumStringMetricState >
  _xsd_EnumStringMetricState_type_serializer_init (
    "EnumStringMetricState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const RealTimeSampleArrayMetricDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractMetricDescriptor& > (i);

    // TechnicalRange
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (RealTimeSampleArrayMetricDescriptor::TechnicalRangeConstIterator
           b (i.TechnicalRange ().begin ()), n (i.TechnicalRange ().end ());
           b != n; ++b)
      {
        if (typeid (RealTimeSampleArrayMetricDescriptor::TechnicalRangeType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TechnicalRange",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "TechnicalRange",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // Resolution
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Resolution",
          e));

      a << ::xml_schema::AsDecimal(i.Resolution ());
    }

    // SamplePeriod
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "SamplePeriod",
          e));

      a << i.SamplePeriod ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RealTimeSampleArrayMetricDescriptor >
  _xsd_RealTimeSampleArrayMetricDescriptor_type_serializer_init (
    "RealTimeSampleArrayMetricDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const RealTimeSampleArrayMetricState& i)
  {
    e << static_cast< const ::CDM::AbstractMetricState& > (i);

    // MetricValue
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.MetricValue ())
      {
        const RealTimeSampleArrayMetricState::MetricValueType& x (*i.MetricValue ());
        if (typeid (RealTimeSampleArrayMetricState::MetricValueType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MetricValue",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "MetricValue",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // PhysiologicalRange
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (RealTimeSampleArrayMetricState::PhysiologicalRangeConstIterator
           b (i.PhysiologicalRange ().begin ()), n (i.PhysiologicalRange ().end ());
           b != n; ++b)
      {
        if (typeid (RealTimeSampleArrayMetricState::PhysiologicalRangeType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PhysiologicalRange",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "PhysiologicalRange",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RealTimeSampleArrayMetricState >
  _xsd_RealTimeSampleArrayMetricState_type_serializer_init (
    "RealTimeSampleArrayMetricState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const DistributionSampleArrayMetricDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractMetricDescriptor& > (i);

    // TechnicalRange
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (DistributionSampleArrayMetricDescriptor::TechnicalRangeConstIterator
           b (i.TechnicalRange ().begin ()), n (i.TechnicalRange ().end ());
           b != n; ++b)
      {
        if (typeid (DistributionSampleArrayMetricDescriptor::TechnicalRangeType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TechnicalRange",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "TechnicalRange",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // DomainUnit
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const DistributionSampleArrayMetricDescriptor::DomainUnitType& x (i.DomainUnit ());
      if (typeid (DistributionSampleArrayMetricDescriptor::DomainUnitType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DomainUnit",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "DomainUnit",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // DistributionRange
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const DistributionSampleArrayMetricDescriptor::DistributionRangeType& x (i.DistributionRange ());
      if (typeid (DistributionSampleArrayMetricDescriptor::DistributionRangeType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DistributionRange",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "DistributionRange",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // Resolution
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Resolution",
          e));

      a << ::xml_schema::AsDecimal(i.Resolution ());
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DistributionSampleArrayMetricDescriptor >
  _xsd_DistributionSampleArrayMetricDescriptor_type_serializer_init (
    "DistributionSampleArrayMetricDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const DistributionSampleArrayMetricState& i)
  {
    e << static_cast< const ::CDM::AbstractMetricState& > (i);

    // MetricValue
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.MetricValue ())
      {
        const DistributionSampleArrayMetricState::MetricValueType& x (*i.MetricValue ());
        if (typeid (DistributionSampleArrayMetricState::MetricValueType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MetricValue",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "MetricValue",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // PhysiologicalRange
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (DistributionSampleArrayMetricState::PhysiologicalRangeConstIterator
           b (i.PhysiologicalRange ().begin ()), n (i.PhysiologicalRange ().end ());
           b != n; ++b)
      {
        if (typeid (DistributionSampleArrayMetricState::PhysiologicalRangeType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PhysiologicalRange",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "PhysiologicalRange",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DistributionSampleArrayMetricState >
  _xsd_DistributionSampleArrayMetricState_type_serializer_init (
    "DistributionSampleArrayMetricState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const OperationRef& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::CDM::HandleRef, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const OperationRef& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::CDM::HandleRef, char >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const OperationRef& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::CDM::HandleRef, char >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OperationRef >
  _xsd_OperationRef_type_serializer_init (
    "OperationRef",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const ScoDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDeviceComponentDescriptor& > (i);

    // Operation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ScoDescriptor::OperationConstIterator
           b (i.Operation ().begin ()), n (i.Operation ().end ());
           b != n; ++b)
      {
        if (typeid (ScoDescriptor::OperationType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Operation",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Operation",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ScoDescriptor >
  _xsd_ScoDescriptor_type_serializer_init (
    "ScoDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const ScoState& i)
  {
    e << static_cast< const ::CDM::AbstractDeviceComponentState& > (i);

    // OperationGroup
    //
    for (ScoState::OperationGroupConstIterator
         b (i.OperationGroup ().begin ()), n (i.OperationGroup ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "OperationGroup",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *b;
    }

    // InvocationRequested
    //
    if (i.InvocationRequested ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "InvocationRequested",
          e));

      a << *i.InvocationRequested ();
    }

    // InvocationRequired
    //
    if (i.InvocationRequired ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "InvocationRequired",
          e));

      a << *i.InvocationRequired ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ScoState >
  _xsd_ScoState_type_serializer_init (
    "ScoState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractOperationDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDescriptor& > (i);

    // OperationTarget
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "OperationTarget",
          e));

      a << i.OperationTarget ();
    }

    // MaxTimeToFinish
    //
    if (i.MaxTimeToFinish ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MaxTimeToFinish",
          e));

      a << *i.MaxTimeToFinish ();
    }

    // InvocationEffectiveTimeout
    //
    if (i.InvocationEffectiveTimeout ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "InvocationEffectiveTimeout",
          e));

      a << *i.InvocationEffectiveTimeout ();
    }

    // Retriggerable
    //
    if (i.Retriggerable ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Retriggerable",
          e));

      a << *i.Retriggerable ();
    }

    // AccessLevel
    //
    if (i.AccessLevel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "AccessLevel",
          e));

      a << *i.AccessLevel ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractOperationDescriptor >
  _xsd_AbstractOperationDescriptor_type_serializer_init (
    "AbstractOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractSetStateOperationDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractOperationDescriptor& > (i);

    // ModifiableData
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AbstractSetStateOperationDescriptor::ModifiableDataConstIterator
           b (i.ModifiableData ().begin ()), n (i.ModifiableData ().end ());
           b != n; ++b)
      {
        if (typeid (AbstractSetStateOperationDescriptor::ModifiableDataType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ModifiableData",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ModifiableData",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractSetStateOperationDescriptor >
  _xsd_AbstractSetStateOperationDescriptor_type_serializer_init (
    "AbstractSetStateOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const OperatingMode& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const OperatingMode& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const OperatingMode& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OperatingMode >
  _xsd_OperatingMode_type_serializer_init (
    "OperatingMode",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractOperationState& i)
  {
    e << static_cast< const ::CDM::AbstractState& > (i);

    // OperatingMode
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "OperatingMode",
          e));

      a << i.OperatingMode ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractOperationState >
  _xsd_AbstractOperationState_type_serializer_init (
    "AbstractOperationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SetValueOperationDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractOperationDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetValueOperationDescriptor >
  _xsd_SetValueOperationDescriptor_type_serializer_init (
    "SetValueOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SetValueOperationState& i)
  {
    e << static_cast< const ::CDM::AbstractOperationState& > (i);

    // AllowedRange
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SetValueOperationState::AllowedRangeConstIterator
           b (i.AllowedRange ().begin ()), n (i.AllowedRange ().end ());
           b != n; ++b)
      {
        if (typeid (SetValueOperationState::AllowedRangeType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AllowedRange",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "AllowedRange",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetValueOperationState >
  _xsd_SetValueOperationState_type_serializer_init (
    "SetValueOperationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SetStringOperationDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractOperationDescriptor& > (i);

    // MaxLength
    //
    if (i.MaxLength ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MaxLength",
          e));

      a << *i.MaxLength ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetStringOperationDescriptor >
  _xsd_SetStringOperationDescriptor_type_serializer_init (
    "SetStringOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SetStringOperationState& i)
  {
    e << static_cast< const ::CDM::AbstractOperationState& > (i);

    // AllowedValues
    //
    if (i.AllowedValues ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AllowedValues",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *i.AllowedValues ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetStringOperationState >
  _xsd_SetStringOperationState_type_serializer_init (
    "SetStringOperationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const ActivateOperationDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractSetStateOperationDescriptor& > (i);

    // Argument
    //
    for (ActivateOperationDescriptor::ArgumentConstIterator
         b (i.Argument ().begin ()), n (i.Argument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Argument",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *b;
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ActivateOperationDescriptor >
  _xsd_ActivateOperationDescriptor_type_serializer_init (
    "ActivateOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const ActivateOperationState& i)
  {
    e << static_cast< const ::CDM::AbstractOperationState& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ActivateOperationState >
  _xsd_ActivateOperationState_type_serializer_init (
    "ActivateOperationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SetContextStateOperationDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractSetStateOperationDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetContextStateOperationDescriptor >
  _xsd_SetContextStateOperationDescriptor_type_serializer_init (
    "SetContextStateOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SetContextStateOperationState& i)
  {
    e << static_cast< const ::CDM::AbstractOperationState& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetContextStateOperationState >
  _xsd_SetContextStateOperationState_type_serializer_init (
    "SetContextStateOperationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SetMetricStateOperationDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractSetStateOperationDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetMetricStateOperationDescriptor >
  _xsd_SetMetricStateOperationDescriptor_type_serializer_init (
    "SetMetricStateOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SetMetricStateOperationState& i)
  {
    e << static_cast< const ::CDM::AbstractOperationState& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetMetricStateOperationState >
  _xsd_SetMetricStateOperationState_type_serializer_init (
    "SetMetricStateOperationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SetComponentStateOperationDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractSetStateOperationDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetComponentStateOperationDescriptor >
  _xsd_SetComponentStateOperationDescriptor_type_serializer_init (
    "SetComponentStateOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SetComponentStateOperationState& i)
  {
    e << static_cast< const ::CDM::AbstractOperationState& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetComponentStateOperationState >
  _xsd_SetComponentStateOperationState_type_serializer_init (
    "SetComponentStateOperationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SetAlertStateOperationDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractSetStateOperationDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetAlertStateOperationDescriptor >
  _xsd_SetAlertStateOperationDescriptor_type_serializer_init (
    "SetAlertStateOperationDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SetAlertStateOperationState& i)
  {
    e << static_cast< const ::CDM::AbstractOperationState& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetAlertStateOperationState >
  _xsd_SetAlertStateOperationState_type_serializer_init (
    "SetAlertStateOperationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const TimeZone& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const TimeZone& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const TimeZone& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TimeZone >
  _xsd_TimeZone_type_serializer_init (
    "TimeZone",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const ClockDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDeviceComponentDescriptor& > (i);

    // TimeProtocol
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ClockDescriptor::TimeProtocolConstIterator
           b (i.TimeProtocol ().begin ()), n (i.TimeProtocol ().end ());
           b != n; ++b)
      {
        if (typeid (ClockDescriptor::TimeProtocolType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TimeProtocol",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "TimeProtocol",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // Resolution
    //
    if (i.Resolution ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Resolution",
          e));

      a << *i.Resolution ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ClockDescriptor >
  _xsd_ClockDescriptor_type_serializer_init (
    "ClockDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const ClockState& i)
  {
    e << static_cast< const ::CDM::AbstractDeviceComponentState& > (i);

    // ActiveSyncProtocol
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ActiveSyncProtocol ())
      {
        const ClockState::ActiveSyncProtocolType& x (*i.ActiveSyncProtocol ());
        if (typeid (ClockState::ActiveSyncProtocolType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ActiveSyncProtocol",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ActiveSyncProtocol",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // ReferenceSource
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ClockState::ReferenceSourceConstIterator
           b (i.ReferenceSource ().begin ()), n (i.ReferenceSource ().end ());
           b != n; ++b)
      {
        if (typeid (ClockState::ReferenceSourceType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ReferenceSource",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ReferenceSource",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // DateAndTime
    //
    if (i.DateAndTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "DateAndTime",
          e));

      a << *i.DateAndTime ();
    }

    // RemoteSync
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "RemoteSync",
          e));

      a << i.RemoteSync ();
    }

    // Accuracy
    //
    if (i.Accuracy ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Accuracy",
          e));

      a << ::xml_schema::AsDecimal(*i.Accuracy ());
    }

    // LastSet
    //
    if (i.LastSet ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "LastSet",
          e));

      a << *i.LastSet ();
    }

    // TimeZone
    //
    if (i.TimeZone ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "TimeZone",
          e));

      a << *i.TimeZone ();
    }

    // CriticalUse
    //
    if (i.CriticalUse ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "CriticalUse",
          e));

      a << *i.CriticalUse ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ClockState >
  _xsd_ClockState_type_serializer_init (
    "ClockState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const BatteryDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDeviceComponentDescriptor& > (i);

    // CapacityFullCharge
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CapacityFullCharge ())
      {
        const BatteryDescriptor::CapacityFullChargeType& x (*i.CapacityFullCharge ());
        if (typeid (BatteryDescriptor::CapacityFullChargeType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CapacityFullCharge",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CapacityFullCharge",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // CapacitySpecified
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CapacitySpecified ())
      {
        const BatteryDescriptor::CapacitySpecifiedType& x (*i.CapacitySpecified ());
        if (typeid (BatteryDescriptor::CapacitySpecifiedType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CapacitySpecified",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CapacitySpecified",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // VoltageSpecified
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.VoltageSpecified ())
      {
        const BatteryDescriptor::VoltageSpecifiedType& x (*i.VoltageSpecified ());
        if (typeid (BatteryDescriptor::VoltageSpecifiedType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "VoltageSpecified",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "VoltageSpecified",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BatteryDescriptor >
  _xsd_BatteryDescriptor_type_serializer_init (
    "BatteryDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const BatteryState& i)
  {
    e << static_cast< const ::CDM::AbstractDeviceComponentState& > (i);

    // CapacityRemaining
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CapacityRemaining ())
      {
        const BatteryState::CapacityRemainingType& x (*i.CapacityRemaining ());
        if (typeid (BatteryState::CapacityRemainingType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CapacityRemaining",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CapacityRemaining",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Voltage
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Voltage ())
      {
        const BatteryState::VoltageType& x (*i.Voltage ());
        if (typeid (BatteryState::VoltageType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Voltage",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Voltage",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Current
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Current ())
      {
        const BatteryState::CurrentType& x (*i.Current ());
        if (typeid (BatteryState::CurrentType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Current",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Current",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Temperature
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Temperature ())
      {
        const BatteryState::TemperatureType& x (*i.Temperature ());
        if (typeid (BatteryState::TemperatureType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Temperature",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Temperature",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // RemainingBatteryTime
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.RemainingBatteryTime ())
      {
        const BatteryState::RemainingBatteryTimeType& x (*i.RemainingBatteryTime ());
        if (typeid (BatteryState::RemainingBatteryTimeType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "RemainingBatteryTime",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "RemainingBatteryTime",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // ChargeStatus
    //
    if (i.ChargeStatus ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ChargeStatus",
          e));

      a << *i.ChargeStatus ();
    }

    // ChargeCycles
    //
    if (i.ChargeCycles ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ChargeCycles",
          e));

      a << *i.ChargeCycles ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BatteryState >
  _xsd_BatteryState_type_serializer_init (
    "BatteryState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SystemContextDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDeviceComponentDescriptor& > (i);

    // PatientContext
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.PatientContext ())
      {
        const SystemContextDescriptor::PatientContextType& x (*i.PatientContext ());
        if (typeid (SystemContextDescriptor::PatientContextType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PatientContext",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "PatientContext",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // LocationContext
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.LocationContext ())
      {
        const SystemContextDescriptor::LocationContextType& x (*i.LocationContext ());
        if (typeid (SystemContextDescriptor::LocationContextType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "LocationContext",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "LocationContext",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // EnsembleContext
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SystemContextDescriptor::EnsembleContextConstIterator
           b (i.EnsembleContext ().begin ()), n (i.EnsembleContext ().end ());
           b != n; ++b)
      {
        if (typeid (SystemContextDescriptor::EnsembleContextType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EnsembleContext",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "EnsembleContext",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // OperatorContext
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SystemContextDescriptor::OperatorContextConstIterator
           b (i.OperatorContext ().begin ()), n (i.OperatorContext ().end ());
           b != n; ++b)
      {
        if (typeid (SystemContextDescriptor::OperatorContextType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OperatorContext",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "OperatorContext",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // WorkflowContext
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SystemContextDescriptor::WorkflowContextConstIterator
           b (i.WorkflowContext ().begin ()), n (i.WorkflowContext ().end ());
           b != n; ++b)
      {
        if (typeid (SystemContextDescriptor::WorkflowContextType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "WorkflowContext",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "WorkflowContext",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // MeansContext
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SystemContextDescriptor::MeansContextConstIterator
           b (i.MeansContext ().begin ()), n (i.MeansContext ().end ());
           b != n; ++b)
      {
        if (typeid (SystemContextDescriptor::MeansContextType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MeansContext",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "MeansContext",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SystemContextDescriptor >
  _xsd_SystemContextDescriptor_type_serializer_init (
    "SystemContextDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const SystemContextState& i)
  {
    e << static_cast< const ::CDM::AbstractDeviceComponentState& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SystemContextState >
  _xsd_SystemContextState_type_serializer_init (
    "SystemContextState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractContextDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractContextDescriptor >
  _xsd_AbstractContextDescriptor_type_serializer_init (
    "AbstractContextDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const ContextAssociation& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ContextAssociation& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const ContextAssociation& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ContextAssociation >
  _xsd_ContextAssociation_type_serializer_init (
    "ContextAssociation",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractContextState& i)
  {
    e << static_cast< const ::CDM::AbstractMultiState& > (i);

    // Validator
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AbstractContextState::ValidatorConstIterator
           b (i.Validator ().begin ()), n (i.Validator ().end ());
           b != n; ++b)
      {
        if (typeid (AbstractContextState::ValidatorType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Validator",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Validator",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // Identification
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AbstractContextState::IdentificationConstIterator
           b (i.Identification ().begin ()), n (i.Identification ().end ());
           b != n; ++b)
      {
        if (typeid (AbstractContextState::IdentificationType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Identification",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Identification",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // ContextAssociation
    //
    if (i.ContextAssociation ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ContextAssociation",
          e));

      a << *i.ContextAssociation ();
    }

    // BindingMdibVersion
    //
    if (i.BindingMdibVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "BindingMdibVersion",
          e));

      a << *i.BindingMdibVersion ();
    }

    // UnbindingMdibVersion
    //
    if (i.UnbindingMdibVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "UnbindingMdibVersion",
          e));

      a << *i.UnbindingMdibVersion ();
    }

    // BindingStartTime
    //
    if (i.BindingStartTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "BindingStartTime",
          e));

      a << *i.BindingStartTime ();
    }

    // BindingEndTime
    //
    if (i.BindingEndTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "BindingEndTime",
          e));

      a << *i.BindingEndTime ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractContextState >
  _xsd_AbstractContextState_type_serializer_init (
    "AbstractContextState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const BaseDemographics& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const BaseDemographics::ExtensionType& x (*i.Extension ());
        if (typeid (BaseDemographics::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Givenname
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Givenname ())
      {
        const BaseDemographics::GivennameType& x (*i.Givenname ());
        if (typeid (BaseDemographics::GivennameType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Givenname",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Givenname",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Middlename
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (BaseDemographics::MiddlenameConstIterator
           b (i.Middlename ().begin ()), n (i.Middlename ().end ());
           b != n; ++b)
      {
        if (typeid (BaseDemographics::MiddlenameType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Middlename",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Middlename",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // Familyname
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Familyname ())
      {
        const BaseDemographics::FamilynameType& x (*i.Familyname ());
        if (typeid (BaseDemographics::FamilynameType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Familyname",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Familyname",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Birthname
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Birthname ())
      {
        const BaseDemographics::BirthnameType& x (*i.Birthname ());
        if (typeid (BaseDemographics::BirthnameType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Birthname",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Birthname",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Title
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Title ())
      {
        const BaseDemographics::TitleType& x (*i.Title ());
        if (typeid (BaseDemographics::TitleType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Title",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Title",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BaseDemographics >
  _xsd_BaseDemographics_type_serializer_init (
    "BaseDemographics",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const PersonReference& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const PersonReference::ExtensionType& x (*i.Extension ());
        if (typeid (PersonReference::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Identification
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (PersonReference::IdentificationConstIterator
           b (i.Identification ().begin ()), n (i.Identification ().end ());
           b != n; ++b)
      {
        if (typeid (PersonReference::IdentificationType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Identification",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Identification",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // Name
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Name ())
      {
        const PersonReference::NameType& x (*i.Name ());
        if (typeid (PersonReference::NameType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Name",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Name",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PersonReference >
  _xsd_PersonReference_type_serializer_init (
    "PersonReference",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const LocationDetail& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const LocationDetail::ExtensionType& x (*i.Extension ());
        if (typeid (LocationDetail::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // PoC
    //
    if (i.PoC ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "PoC",
          e));

      a << *i.PoC ();
    }

    // Room
    //
    if (i.Room ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Room",
          e));

      a << *i.Room ();
    }

    // Bed
    //
    if (i.Bed ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Bed",
          e));

      a << *i.Bed ();
    }

    // Facility
    //
    if (i.Facility ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Facility",
          e));

      a << *i.Facility ();
    }

    // Building
    //
    if (i.Building ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Building",
          e));

      a << *i.Building ();
    }

    // Floor
    //
    if (i.Floor ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Floor",
          e));

      a << *i.Floor ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LocationDetail >
  _xsd_LocationDetail_type_serializer_init (
    "LocationDetail",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const PatientContextDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractContextDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PatientContextDescriptor >
  _xsd_PatientContextDescriptor_type_serializer_init (
    "PatientContextDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const Sex& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Sex& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Sex& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Sex >
  _xsd_Sex_type_serializer_init (
    "Sex",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const PatientType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const PatientType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const PatientType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PatientType >
  _xsd_PatientType_type_serializer_init (
    "PatientType",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const PatientDemographicsCoreData& i)
  {
    e << static_cast< const ::CDM::BaseDemographics& > (i);

    // Sex
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Sex ())
      {
        const PatientDemographicsCoreData::SexType& x (*i.Sex ());
        if (typeid (PatientDemographicsCoreData::SexType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Sex",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Sex",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // PatientType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.PatientType ())
      {
        const PatientDemographicsCoreData::PatientTypeType& x (*i.PatientType ());
        if (typeid (PatientDemographicsCoreData::PatientTypeType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PatientType",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "PatientType",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // DateOfBirth
    //
    if (i.DateOfBirth ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DateOfBirth",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *i.DateOfBirth ();
    }

    // Height
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Height ())
      {
        const PatientDemographicsCoreData::HeightType& x (*i.Height ());
        if (typeid (PatientDemographicsCoreData::HeightType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Height",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Height",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Weight
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Weight ())
      {
        const PatientDemographicsCoreData::WeightType& x (*i.Weight ());
        if (typeid (PatientDemographicsCoreData::WeightType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Weight",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Weight",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Race
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Race ())
      {
        const PatientDemographicsCoreData::RaceType& x (*i.Race ());
        if (typeid (PatientDemographicsCoreData::RaceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Race",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Race",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PatientDemographicsCoreData >
  _xsd_PatientDemographicsCoreData_type_serializer_init (
    "PatientDemographicsCoreData",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const NeonatalPatientDemographicsCoreData& i)
  {
    e << static_cast< const ::CDM::PatientDemographicsCoreData& > (i);

    // GestationalAge
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.GestationalAge ())
      {
        const NeonatalPatientDemographicsCoreData::GestationalAgeType& x (*i.GestationalAge ());
        if (typeid (NeonatalPatientDemographicsCoreData::GestationalAgeType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "GestationalAge",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "GestationalAge",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // BirthLength
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.BirthLength ())
      {
        const NeonatalPatientDemographicsCoreData::BirthLengthType& x (*i.BirthLength ());
        if (typeid (NeonatalPatientDemographicsCoreData::BirthLengthType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "BirthLength",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "BirthLength",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // BirthWeight
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.BirthWeight ())
      {
        const NeonatalPatientDemographicsCoreData::BirthWeightType& x (*i.BirthWeight ());
        if (typeid (NeonatalPatientDemographicsCoreData::BirthWeightType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "BirthWeight",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "BirthWeight",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // HeadCircumference
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.HeadCircumference ())
      {
        const NeonatalPatientDemographicsCoreData::HeadCircumferenceType& x (*i.HeadCircumference ());
        if (typeid (NeonatalPatientDemographicsCoreData::HeadCircumferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "HeadCircumference",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "HeadCircumference",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Mother
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Mother ())
      {
        const NeonatalPatientDemographicsCoreData::MotherType& x (*i.Mother ());
        if (typeid (NeonatalPatientDemographicsCoreData::MotherType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Mother",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Mother",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, NeonatalPatientDemographicsCoreData >
  _xsd_NeonatalPatientDemographicsCoreData_type_serializer_init (
    "NeonatalPatientDemographicsCoreData",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const PatientContextState& i)
  {
    e << static_cast< const ::CDM::AbstractContextState& > (i);

    // CoreData
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CoreData ())
      {
        const PatientContextState::CoreDataType& x (*i.CoreData ());
        if (typeid (PatientContextState::CoreDataType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CoreData",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CoreData",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PatientContextState >
  _xsd_PatientContextState_type_serializer_init (
    "PatientContextState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const LocationContextDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractContextDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LocationContextDescriptor >
  _xsd_LocationContextDescriptor_type_serializer_init (
    "LocationContextDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const LocationContextState& i)
  {
    e << static_cast< const ::CDM::AbstractContextState& > (i);

    // LocationDetail
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.LocationDetail ())
      {
        const LocationContextState::LocationDetailType& x (*i.LocationDetail ());
        if (typeid (LocationContextState::LocationDetailType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "LocationDetail",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "LocationDetail",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LocationContextState >
  _xsd_LocationContextState_type_serializer_init (
    "LocationContextState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const WorkflowContextDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractContextDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, WorkflowContextDescriptor >
  _xsd_WorkflowContextDescriptor_type_serializer_init (
    "WorkflowContextDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const ClinicalInfo& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const ClinicalInfo::ExtensionType& x (*i.Extension ());
        if (typeid (ClinicalInfo::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Type
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Type ())
      {
        const ClinicalInfo::TypeType& x (*i.Type ());
        if (typeid (ClinicalInfo::TypeType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Type",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Type",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Code
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Code ())
      {
        const ClinicalInfo::CodeType& x (*i.Code ());
        if (typeid (ClinicalInfo::CodeType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Code",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Code",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Criticality
    //
    if (i.Criticality ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Criticality",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *i.Criticality ();
    }

    // Description
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ClinicalInfo::DescriptionConstIterator
           b (i.Description ().begin ()), n (i.Description ().end ());
           b != n; ++b)
      {
        if (typeid (ClinicalInfo::DescriptionType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Description",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Description",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // RelatedMeasurement
    //
    for (ClinicalInfo::RelatedMeasurementConstIterator
         b (i.RelatedMeasurement ().begin ()), n (i.RelatedMeasurement ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RelatedMeasurement",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *b;
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ClinicalInfo >
  _xsd_ClinicalInfo_type_serializer_init (
    "ClinicalInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const ImagingProcedure& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const ImagingProcedure::ExtensionType& x (*i.Extension ());
        if (typeid (ImagingProcedure::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // AccessionIdentifier
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ImagingProcedure::AccessionIdentifierType& x (i.AccessionIdentifier ());
      if (typeid (ImagingProcedure::AccessionIdentifierType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AccessionIdentifier",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "AccessionIdentifier",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // RequestedProcedureId
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ImagingProcedure::RequestedProcedureIdType& x (i.RequestedProcedureId ());
      if (typeid (ImagingProcedure::RequestedProcedureIdType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RequestedProcedureId",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "RequestedProcedureId",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // StudyInstanceUid
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ImagingProcedure::StudyInstanceUidType& x (i.StudyInstanceUid ());
      if (typeid (ImagingProcedure::StudyInstanceUidType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "StudyInstanceUid",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "StudyInstanceUid",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // ScheduledProcedureStepId
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ImagingProcedure::ScheduledProcedureStepIdType& x (i.ScheduledProcedureStepId ());
      if (typeid (ImagingProcedure::ScheduledProcedureStepIdType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ScheduledProcedureStepId",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ScheduledProcedureStepId",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // Modality
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Modality ())
      {
        const ImagingProcedure::ModalityType& x (*i.Modality ());
        if (typeid (ImagingProcedure::ModalityType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Modality",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Modality",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // ProtocolCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ProtocolCode ())
      {
        const ImagingProcedure::ProtocolCodeType& x (*i.ProtocolCode ());
        if (typeid (ImagingProcedure::ProtocolCodeType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ProtocolCode",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ProtocolCode",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ImagingProcedure >
  _xsd_ImagingProcedure_type_serializer_init (
    "ImagingProcedure",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const LocationReference& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const LocationReference::ExtensionType& x (*i.Extension ());
        if (typeid (LocationReference::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Identification
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (LocationReference::IdentificationConstIterator
           b (i.Identification ().begin ()), n (i.Identification ().end ());
           b != n; ++b)
      {
        if (typeid (LocationReference::IdentificationType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Identification",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Identification",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // LocationDetail
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.LocationDetail ())
      {
        const LocationReference::LocationDetailType& x (*i.LocationDetail ());
        if (typeid (LocationReference::LocationDetailType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "LocationDetail",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "LocationDetail",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LocationReference >
  _xsd_LocationReference_type_serializer_init (
    "LocationReference",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const OrderDetail& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const OrderDetail::ExtensionType& x (*i.Extension ());
        if (typeid (OrderDetail::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Start
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Start ())
      {
        const OrderDetail::StartType& x (*i.Start ());
        if (typeid (OrderDetail::StartType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Start",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Start",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // End
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.End ())
      {
        const OrderDetail::EndType& x (*i.End ());
        if (typeid (OrderDetail::EndType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "End",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "End",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Performer
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (OrderDetail::PerformerConstIterator
           b (i.Performer ().begin ()), n (i.Performer ().end ());
           b != n; ++b)
      {
        if (typeid (OrderDetail::PerformerType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Performer",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Performer",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // Service
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (OrderDetail::ServiceConstIterator
           b (i.Service ().begin ()), n (i.Service ().end ());
           b != n; ++b)
      {
        if (typeid (OrderDetail::ServiceType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Service",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Service",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // ImagingProcedure
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (OrderDetail::ImagingProcedureConstIterator
           b (i.ImagingProcedure ().begin ()), n (i.ImagingProcedure ().end ());
           b != n; ++b)
      {
        if (typeid (OrderDetail::ImagingProcedureType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ImagingProcedure",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ImagingProcedure",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OrderDetail >
  _xsd_OrderDetail_type_serializer_init (
    "OrderDetail",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const PersonParticipation& i)
  {
    e << static_cast< const ::CDM::PersonReference& > (i);

    // Role
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (PersonParticipation::RoleConstIterator
           b (i.Role ().begin ()), n (i.Role ().end ());
           b != n; ++b)
      {
        if (typeid (PersonParticipation::RoleType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Role",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Role",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PersonParticipation >
  _xsd_PersonParticipation_type_serializer_init (
    "PersonParticipation",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const WorkflowContextState& i)
  {
    e << static_cast< const ::CDM::AbstractContextState& > (i);

    // WorkflowDetail
    //
    if (i.WorkflowDetail ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "WorkflowDetail",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *i.WorkflowDetail ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, WorkflowContextState >
  _xsd_WorkflowContextState_type_serializer_init (
    "WorkflowContextState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const OperatorContextDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractContextDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OperatorContextDescriptor >
  _xsd_OperatorContextDescriptor_type_serializer_init (
    "OperatorContextDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const OperatorContextState& i)
  {
    e << static_cast< const ::CDM::AbstractContextState& > (i);

    // OperatorDetails
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.OperatorDetails ())
      {
        const OperatorContextState::OperatorDetailsType& x (*i.OperatorDetails ());
        if (typeid (OperatorContextState::OperatorDetailsType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OperatorDetails",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "OperatorDetails",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OperatorContextState >
  _xsd_OperatorContextState_type_serializer_init (
    "OperatorContextState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const MeansContextDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractContextDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MeansContextDescriptor >
  _xsd_MeansContextDescriptor_type_serializer_init (
    "MeansContextDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const MeansContextState& i)
  {
    e << static_cast< const ::CDM::AbstractContextState& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MeansContextState >
  _xsd_MeansContextState_type_serializer_init (
    "MeansContextState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const EnsembleContextDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractContextDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnsembleContextDescriptor >
  _xsd_EnsembleContextDescriptor_type_serializer_init (
    "EnsembleContextDescriptor",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const EnsembleContextState& i)
  {
    e << static_cast< const ::CDM::AbstractContextState& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnsembleContextState >
  _xsd_EnsembleContextState_type_serializer_init (
    "EnsembleContextState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const ContainmentTree& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const ContainmentTree::ExtensionType& x (*i.Extension ());
        if (typeid (ContainmentTree::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Entry
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ContainmentTree::EntryConstIterator
           b (i.Entry ().begin ()), n (i.Entry ().end ());
           b != n; ++b)
      {
        if (typeid (ContainmentTree::EntryType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Entry",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Entry",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // HandleRef
    //
    if (i.HandleRef ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "HandleRef",
          e));

      a << *i.HandleRef ();
    }

    // ParentHandleRef
    //
    if (i.ParentHandleRef ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ParentHandleRef",
          e));

      a << *i.ParentHandleRef ();
    }

    // EntryType
    //
    if (i.EntryType1 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "EntryType",
          e));

      a << *i.EntryType1 ();
    }

    // ChildrenCount
    //
    if (i.ChildrenCount ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ChildrenCount",
          e));

      a << *i.ChildrenCount ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ContainmentTree >
  _xsd_ContainmentTree_type_serializer_init (
    "ContainmentTree",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  operator<< (::xercesc::DOMElement& e, const ContainmentTreeEntry& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const ContainmentTreeEntry::ExtensionType& x (*i.Extension ());
        if (typeid (ContainmentTreeEntry::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Type
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Type ())
      {
        const ContainmentTreeEntry::TypeType& x (*i.Type ());
        if (typeid (ContainmentTreeEntry::TypeType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Type",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Type",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // HandleRef
    //
    if (i.HandleRef ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "HandleRef",
          e));

      a << *i.HandleRef ();
    }

    // ParentHandleRef
    //
    if (i.ParentHandleRef ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ParentHandleRef",
          e));

      a << *i.ParentHandleRef ();
    }

    // EntryType
    //
    if (i.EntryType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "EntryType",
          e));

      a << *i.EntryType ();
    }

    // ChildrenCount
    //
    if (i.ChildrenCount ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ChildrenCount",
          e));

      a << *i.ChildrenCount ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ContainmentTreeEntry >
  _xsd_ContainmentTreeEntry_type_serializer_init (
    "ContainmentTreeEntry",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");


  void
  MdibContainer (::std::ostream& o,
                 const ::CDM::Mdib& s,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MdibContainer (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  MdibContainer (::std::ostream& o,
                 const ::CDM::Mdib& s,
                 ::xml_schema::ErrorHandler& h,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MdibContainer (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MdibContainer (::std::ostream& o,
                 const ::CDM::Mdib& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MdibContainer (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MdibContainer (::xercesc::XMLFormatTarget& t,
                 const ::CDM::Mdib& s,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MdibContainer (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  MdibContainer (::xercesc::XMLFormatTarget& t,
                 const ::CDM::Mdib& s,
                 ::xml_schema::ErrorHandler& h,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MdibContainer (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MdibContainer (::xercesc::XMLFormatTarget& t,
                 const ::CDM::Mdib& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MdibContainer (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MdibContainer (::xercesc::DOMDocument& d,
                 const ::CDM::Mdib& s,
                 ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (typeid (::CDM::Mdib) == typeid (s))
    {
      if (n.name () == "MdibContainer" &&
          n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "MdibContainer",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant");
      }
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "MdibContainer",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
        e, n, s);
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  MdibContainer (const ::CDM::Mdib& s,
                 const ::xml_schema::NamespaceInfomap& m,
                 ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

    if (typeid (::CDM::Mdib) == typeid (s))
    {
      d = ::xsd::cxx::xml::dom::serialize< char > (
        "MdibContainer",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
        m, f);
    }
    else
    {
      d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "MdibContainer",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
        m, s, f);
    }

    ::CDM::MdibContainer (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const Translation& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const Translation::ExtensionType& x (*i.Extension ());
        if (typeid (Translation::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Code
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Code",
          e));

      a << i.Code ();
    }

    // CodingSystem
    //
    if (i.CodingSystem ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "CodingSystem",
          e));

      a << *i.CodingSystem ();
    }

    // CodingSystemVersion
    //
    if (i.CodingSystemVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "CodingSystemVersion",
          e));

      a << *i.CodingSystemVersion ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Root& i)
  {
    e << static_cast< const ::xml_schema::Uri& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Root& i)
  {
    a << static_cast< const ::xml_schema::Uri& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Root& i)
  {
    l << static_cast< const ::xml_schema::Uri& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Extension& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Extension& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Extension& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ProductionSpecification& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // SpecType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ProductionSpecification::SpecTypeType& x (i.SpecType ());
      if (typeid (ProductionSpecification::SpecTypeType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SpecType",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "SpecType",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // ProductionSpec
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ProductionSpecification::ProductionSpecType& x (i.ProductionSpec ());
      if (typeid (ProductionSpecification::ProductionSpecType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProductionSpec",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ProductionSpec",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // ComponentId
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ComponentId ())
      {
        const ProductionSpecification::ComponentIdType& x (*i.ComponentId ());
        if (typeid (ProductionSpecification::ComponentIdType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ComponentId",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ComponentId",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CalibrationDocumentation& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Documentation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (CalibrationDocumentation::DocumentationConstIterator
           b (i.Documentation ().begin ()), n (i.Documentation ().end ());
           b != n; ++b)
      {
        if (typeid (CalibrationDocumentation::DocumentationType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Documentation",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Documentation",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // CalibrationResult
    //
    for (CalibrationDocumentation::CalibrationResultConstIterator
         b (i.CalibrationResult ().begin ()), n (i.CalibrationResult ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CalibrationResult",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MetaData& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const MetaData::ExtensionType& x (*i.Extension ());
        if (typeid (MetaData::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Udi
    //
    for (MetaData::UdiConstIterator
         b (i.Udi ().begin ()), n (i.Udi ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Udi",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *b;
    }

    // LotNumber
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.LotNumber ())
      {
        const MetaData::LotNumberType& x (*i.LotNumber ());
        if (typeid (MetaData::LotNumberType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "LotNumber",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "LotNumber",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Manufacturer
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (MetaData::ManufacturerConstIterator
           b (i.Manufacturer ().begin ()), n (i.Manufacturer ().end ());
           b != n; ++b)
      {
        if (typeid (MetaData::ManufacturerType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Manufacturer",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Manufacturer",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // ManufactureDate
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ManufactureDate ())
      {
        const MetaData::ManufactureDateType& x (*i.ManufactureDate ());
        if (typeid (MetaData::ManufactureDateType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ManufactureDate",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ManufactureDate",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // ExpirationDate
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ExpirationDate ())
      {
        const MetaData::ExpirationDateType& x (*i.ExpirationDate ());
        if (typeid (MetaData::ExpirationDateType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ExpirationDate",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ExpirationDate",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // ModelName
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (MetaData::ModelNameConstIterator
           b (i.ModelName ().begin ()), n (i.ModelName ().end ());
           b != n; ++b)
      {
        if (typeid (MetaData::ModelNameType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ModelName",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ModelName",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // ModelNumber
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ModelNumber ())
      {
        const MetaData::ModelNumberType& x (*i.ModelNumber ());
        if (typeid (MetaData::ModelNumberType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ModelNumber",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ModelNumber",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // SerialNumber
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (MetaData::SerialNumberConstIterator
           b (i.SerialNumber ().begin ()), n (i.SerialNumber ().end ());
           b != n; ++b)
      {
        if (typeid (MetaData::SerialNumberType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SerialNumber",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "SerialNumber",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CanEscalate& i)
  {
    e << static_cast< const ::CDM::AlertConditionPriority& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CanEscalate& i)
  {
    a << static_cast< const ::CDM::AlertConditionPriority& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CanEscalate& i)
  {
    l << static_cast< const ::CDM::AlertConditionPriority& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const CanDeescalate& i)
  {
    e << static_cast< const ::CDM::AlertConditionPriority& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CanDeescalate& i)
  {
    a << static_cast< const ::CDM::AlertConditionPriority& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CanDeescalate& i)
  {
    l << static_cast< const ::CDM::AlertConditionPriority& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const MetricQuality& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const MetricQuality::ExtensionType& x (*i.Extension ());
        if (typeid (MetricQuality::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Validity
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Validity",
          e));

      a << i.Validity ();
    }

    // Mode
    //
    if (i.Mode ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Mode",
          e));

      a << *i.Mode ();
    }

    // Qi
    //
    if (i.Qi ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Qi",
          e));

      a << *i.Qi ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Annotation& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const Annotation::ExtensionType& x (*i.Extension ());
        if (typeid (Annotation::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Type
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const Annotation::TypeType& x (i.Type ());
      if (typeid (Annotation::TypeType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Type",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Type",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ApplyAnnotation& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AnnotationIndex
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "AnnotationIndex",
          e));

      a << i.AnnotationIndex ();
    }

    // SampleIndex
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "SampleIndex",
          e));

      a << i.SampleIndex ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Relation& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const Relation::ExtensionType& x (*i.Extension ());
        if (typeid (Relation::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Code
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Code ())
      {
        const Relation::CodeType& x (*i.Code ());
        if (typeid (Relation::CodeType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Code",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Code",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Identification
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Identification ())
      {
        const Relation::IdentificationType& x (*i.Identification ());
        if (typeid (Relation::IdentificationType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Identification",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Identification",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Kind
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Kind",
          e));

      a << i.Kind ();
    }

    // Entries
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Entries",
          e));

      a << i.Entries ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AllowedValue& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Value
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AllowedValue::ValueType& x (i.Value ());
      if (typeid (AllowedValue::ValueType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Value",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Value",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // Type
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Type ())
      {
        const AllowedValue::TypeType& x (*i.Type ());
        if (typeid (AllowedValue::TypeType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Type",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Type",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Identification
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Identification ())
      {
        const AllowedValue::IdentificationType& x (*i.Identification ());
        if (typeid (AllowedValue::IdentificationType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Identification",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Identification",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // Characteristic
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Characteristic ())
      {
        const AllowedValue::CharacteristicType& x (*i.Characteristic ());
        if (typeid (AllowedValue::CharacteristicType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Characteristic",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Characteristic",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const OperationGroup& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const OperationGroup::ExtensionType& x (*i.Extension ());
        if (typeid (OperationGroup::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Type
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const OperationGroup::TypeType& x (i.Type ());
      if (typeid (OperationGroup::TypeType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Type",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Type",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // OperatingMode
    //
    if (i.OperatingMode ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "OperatingMode",
          e));

      a << *i.OperatingMode ();
    }

    // Operations
    //
    if (i.Operations ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Operations",
          e));

      a << *i.Operations ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AccessLevel& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AccessLevel& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const AccessLevel& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const AllowedValues& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Value
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AllowedValues::ValueConstIterator
           b (i.Value ().begin ()), n (i.Value ().end ());
           b != n; ++b)
      {
        if (typeid (AllowedValues::ValueType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Value",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Value",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Argument& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // ArgName
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const Argument::ArgNameType& x (i.ArgName ());
      if (typeid (Argument::ArgNameType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ArgName",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ArgName",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // Arg
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const Argument::ArgType& x (i.Arg ());
      if (typeid (Argument::ArgType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Arg",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Arg",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ChargeStatus& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ChargeStatus& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const ChargeStatus& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const DateOfBirth& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DateOfBirth& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const DateOfBirth& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Criticality& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Criticality& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Criticality& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const RelatedMeasurement& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Value
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const RelatedMeasurement::ValueType& x (i.Value ());
      if (typeid (RelatedMeasurement::ValueType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Value",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Value",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // ReferenceRange
    //
    for (RelatedMeasurement::ReferenceRangeConstIterator
         b (i.ReferenceRange ().begin ()), n (i.ReferenceRange ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReferenceRange",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *b;
    }

    // Validity
    //
    if (i.Validity ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Validity",
          e));

      a << *i.Validity ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const WorkflowDetail& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const WorkflowDetail::ExtensionType& x (*i.Extension ());
        if (typeid (WorkflowDetail::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Patient
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const WorkflowDetail::PatientType& x (i.Patient ());
      if (typeid (WorkflowDetail::PatientType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Patient",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Patient",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // AssignedLocation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AssignedLocation ())
      {
        const WorkflowDetail::AssignedLocationType& x (*i.AssignedLocation ());
        if (typeid (WorkflowDetail::AssignedLocationType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AssignedLocation",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AssignedLocation",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // VisitNumber
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.VisitNumber ())
      {
        const WorkflowDetail::VisitNumberType& x (*i.VisitNumber ());
        if (typeid (WorkflowDetail::VisitNumberType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "VisitNumber",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "VisitNumber",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // DangerCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (WorkflowDetail::DangerCodeConstIterator
           b (i.DangerCode ().begin ()), n (i.DangerCode ().end ());
           b != n; ++b)
      {
        if (typeid (WorkflowDetail::DangerCodeType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DangerCode",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "DangerCode",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // RelevantClinicalInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (WorkflowDetail::RelevantClinicalInfoConstIterator
           b (i.RelevantClinicalInfo ().begin ()), n (i.RelevantClinicalInfo ().end ());
           b != n; ++b)
      {
        if (typeid (WorkflowDetail::RelevantClinicalInfoType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "RelevantClinicalInfo",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "RelevantClinicalInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }

    // RequestedOrderDetail
    //
    if (i.RequestedOrderDetail ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RequestedOrderDetail",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *i.RequestedOrderDetail ();
    }

    // PerformedOrderDetail
    //
    if (i.PerformedOrderDetail ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PerformedOrderDetail",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          e));

      s << *i.PerformedOrderDetail ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CalibrationResult& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Code
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const CalibrationResult::CodeType& x (i.Code ());
      if (typeid (CalibrationResult::CodeType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Code",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Code",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // Value
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const CalibrationResult::ValueType& x (i.Value ());
      if (typeid (CalibrationResult::ValueType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Value",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Value",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Udi& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const Udi::ExtensionType& x (*i.Extension ());
        if (typeid (Udi::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // DeviceIdentifier
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const Udi::DeviceIdentifierType& x (i.DeviceIdentifier ());
      if (typeid (Udi::DeviceIdentifierType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeviceIdentifier",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "DeviceIdentifier",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // HumanReadableForm
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const Udi::HumanReadableFormType& x (i.HumanReadableForm ());
      if (typeid (Udi::HumanReadableFormType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "HumanReadableForm",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "HumanReadableForm",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // Issuer
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const Udi::IssuerType& x (i.Issuer ());
      if (typeid (Udi::IssuerType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Issuer",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Issuer",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // Jurisdiction
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Jurisdiction ())
      {
        const Udi::JurisdictionType& x (*i.Jurisdiction ());
        if (typeid (Udi::JurisdictionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Jurisdiction",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Jurisdiction",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Kind& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Kind& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Kind& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReferenceRange& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Range
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ReferenceRange::RangeType& x (i.Range ());
      if (typeid (ReferenceRange::RangeType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Range",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Range",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }

    // Meaning
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Meaning ())
      {
        const ReferenceRange::MeaningType& x (*i.Meaning ());
        if (typeid (ReferenceRange::MeaningType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Meaning",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Meaning",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RequestedOrderDetail& i)
  {
    e << static_cast< const ::CDM::OrderDetail& > (i);

    // ReferringPhysician
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ReferringPhysician ())
      {
        const RequestedOrderDetail::ReferringPhysicianType& x (*i.ReferringPhysician ());
        if (typeid (RequestedOrderDetail::ReferringPhysicianType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ReferringPhysician",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ReferringPhysician",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // RequestingPhysician
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.RequestingPhysician ())
      {
        const RequestedOrderDetail::RequestingPhysicianType& x (*i.RequestingPhysician ());
        if (typeid (RequestedOrderDetail::RequestingPhysicianType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "RequestingPhysician",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "RequestingPhysician",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // PlacerOrderNumber
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const RequestedOrderDetail::PlacerOrderNumberType& x (i.PlacerOrderNumber ());
      if (typeid (RequestedOrderDetail::PlacerOrderNumberType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PlacerOrderNumber",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "PlacerOrderNumber",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PerformedOrderDetail& i)
  {
    e << static_cast< const ::CDM::OrderDetail& > (i);

    // FillerOrderNumber
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.FillerOrderNumber ())
      {
        const PerformedOrderDetail::FillerOrderNumberType& x (*i.FillerOrderNumber ());
        if (typeid (PerformedOrderDetail::FillerOrderNumberType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "FillerOrderNumber",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "FillerOrderNumber",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, x);
      }
    }

    // ResultingClinicalInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (PerformedOrderDetail::ResultingClinicalInfoConstIterator
           b (i.ResultingClinicalInfo ().begin ()), n (i.ResultingClinicalInfo ().end ());
           b != n; ++b)
      {
        if (typeid (PerformedOrderDetail::ResultingClinicalInfoType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ResultingClinicalInfo",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ResultingClinicalInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/participant",
            false, true, e, *b);
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

