// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "DataModel/wsdd-discovery-1.1-schema-os.hxx"

namespace WS
{
  namespace DISCOVERY
  {
    // HelloType
    // 

    const HelloType::EndpointReferenceType& HelloType::
    getEndpointReference () const
    {
      return this->EndpointReference_.get ();
    }

    HelloType::EndpointReferenceType& HelloType::
    getEndpointReference ()
    {
      return this->EndpointReference_.get ();
    }

    void HelloType::
    setEndpointReference (const EndpointReferenceType& x)
    {
      this->EndpointReference_.set (x);
    }

    void HelloType::
    setEndpointReference (::std::unique_ptr< EndpointReferenceType > x)
    {
      this->EndpointReference_.set (std::move (x));
    }

    const HelloType::TypesOptional& HelloType::
    getTypes () const
    {
      return this->Types_;
    }

    HelloType::TypesOptional& HelloType::
    getTypes ()
    {
      return this->Types_;
    }

    void HelloType::
    setTypes (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void HelloType::
    setTypes (const TypesOptional& x)
    {
      this->Types_ = x;
    }

    void HelloType::
    setTypes (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }

    const HelloType::ScopesOptional& HelloType::
    getScopes () const
    {
      return this->Scopes_;
    }

    HelloType::ScopesOptional& HelloType::
    getScopes ()
    {
      return this->Scopes_;
    }

    void HelloType::
    setScopes (const ScopesType& x)
    {
      this->Scopes_.set (x);
    }

    void HelloType::
    setScopes (const ScopesOptional& x)
    {
      this->Scopes_ = x;
    }

    void HelloType::
    setScopes (::std::unique_ptr< ScopesType > x)
    {
      this->Scopes_.set (std::move (x));
    }

    const HelloType::XAddrsOptional& HelloType::
    getXAddrs () const
    {
      return this->XAddrs_;
    }

    HelloType::XAddrsOptional& HelloType::
    getXAddrs ()
    {
      return this->XAddrs_;
    }

    void HelloType::
    setXAddrs (const XAddrsType& x)
    {
      this->XAddrs_.set (x);
    }

    void HelloType::
    setXAddrs (const XAddrsOptional& x)
    {
      this->XAddrs_ = x;
    }

    void HelloType::
    setXAddrs (::std::unique_ptr< XAddrsType > x)
    {
      this->XAddrs_.set (std::move (x));
    }

    const HelloType::MetadataVersionType& HelloType::
    getMetadataVersion () const
    {
      return this->MetadataVersion_.get ();
    }

    HelloType::MetadataVersionType& HelloType::
    getMetadataVersion ()
    {
      return this->MetadataVersion_.get ();
    }

    void HelloType::
    setMetadataVersion (const MetadataVersionType& x)
    {
      this->MetadataVersion_.set (x);
    }


    // ByeType
    // 

    const ByeType::EndpointReferenceType& ByeType::
    getEndpointReference () const
    {
      return this->EndpointReference_.get ();
    }

    ByeType::EndpointReferenceType& ByeType::
    getEndpointReference ()
    {
      return this->EndpointReference_.get ();
    }

    void ByeType::
    setEndpointReference (const EndpointReferenceType& x)
    {
      this->EndpointReference_.set (x);
    }

    void ByeType::
    setEndpointReference (::std::unique_ptr< EndpointReferenceType > x)
    {
      this->EndpointReference_.set (std::move (x));
    }

    const ByeType::TypesOptional& ByeType::
    getTypes () const
    {
      return this->Types_;
    }

    ByeType::TypesOptional& ByeType::
    getTypes ()
    {
      return this->Types_;
    }

    void ByeType::
    setTypes (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void ByeType::
    setTypes (const TypesOptional& x)
    {
      this->Types_ = x;
    }

    void ByeType::
    setTypes (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }

    const ByeType::ScopesOptional& ByeType::
    getScopes () const
    {
      return this->Scopes_;
    }

    ByeType::ScopesOptional& ByeType::
    getScopes ()
    {
      return this->Scopes_;
    }

    void ByeType::
    setScopes (const ScopesType& x)
    {
      this->Scopes_.set (x);
    }

    void ByeType::
    setScopes (const ScopesOptional& x)
    {
      this->Scopes_ = x;
    }

    void ByeType::
    setScopes (::std::unique_ptr< ScopesType > x)
    {
      this->Scopes_.set (std::move (x));
    }

    const ByeType::XAddrsOptional& ByeType::
    getXAddrs () const
    {
      return this->XAddrs_;
    }

    ByeType::XAddrsOptional& ByeType::
    getXAddrs ()
    {
      return this->XAddrs_;
    }

    void ByeType::
    setXAddrs (const XAddrsType& x)
    {
      this->XAddrs_.set (x);
    }

    void ByeType::
    setXAddrs (const XAddrsOptional& x)
    {
      this->XAddrs_ = x;
    }

    void ByeType::
    setXAddrs (::std::unique_ptr< XAddrsType > x)
    {
      this->XAddrs_.set (std::move (x));
    }

    const ByeType::MetadataVersionOptional& ByeType::
    getMetadataVersion () const
    {
      return this->MetadataVersion_;
    }

    ByeType::MetadataVersionOptional& ByeType::
    getMetadataVersion ()
    {
      return this->MetadataVersion_;
    }

    void ByeType::
    setMetadataVersion (const MetadataVersionType& x)
    {
      this->MetadataVersion_.set (x);
    }

    void ByeType::
    setMetadataVersion (const MetadataVersionOptional& x)
    {
      this->MetadataVersion_ = x;
    }


    // ProbeType
    // 

    const ProbeType::TypesOptional& ProbeType::
    getTypes () const
    {
      return this->Types_;
    }

    ProbeType::TypesOptional& ProbeType::
    getTypes ()
    {
      return this->Types_;
    }

    void ProbeType::
    setTypes (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void ProbeType::
    setTypes (const TypesOptional& x)
    {
      this->Types_ = x;
    }

    void ProbeType::
    setTypes (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }

    const ProbeType::ScopesOptional& ProbeType::
    getScopes () const
    {
      return this->Scopes_;
    }

    ProbeType::ScopesOptional& ProbeType::
    getScopes ()
    {
      return this->Scopes_;
    }

    void ProbeType::
    setScopes (const ScopesType& x)
    {
      this->Scopes_.set (x);
    }

    void ProbeType::
    setScopes (const ScopesOptional& x)
    {
      this->Scopes_ = x;
    }

    void ProbeType::
    setScopes (::std::unique_ptr< ScopesType > x)
    {
      this->Scopes_.set (std::move (x));
    }


    // ProbeMatchesType
    // 

    const ProbeMatchesType::ProbeMatchSequence& ProbeMatchesType::
    getProbeMatch () const
    {
      return this->ProbeMatch_;
    }

    ProbeMatchesType::ProbeMatchSequence& ProbeMatchesType::
    getProbeMatch ()
    {
      return this->ProbeMatch_;
    }

    void ProbeMatchesType::
    setProbeMatch (const ProbeMatchSequence& s)
    {
      this->ProbeMatch_ = s;
    }


    // ProbeMatchType
    // 

    const ProbeMatchType::EndpointReferenceType& ProbeMatchType::
    getEndpointReference () const
    {
      return this->EndpointReference_.get ();
    }

    ProbeMatchType::EndpointReferenceType& ProbeMatchType::
    getEndpointReference ()
    {
      return this->EndpointReference_.get ();
    }

    void ProbeMatchType::
    setEndpointReference (const EndpointReferenceType& x)
    {
      this->EndpointReference_.set (x);
    }

    void ProbeMatchType::
    setEndpointReference (::std::unique_ptr< EndpointReferenceType > x)
    {
      this->EndpointReference_.set (std::move (x));
    }

    const ProbeMatchType::TypesOptional& ProbeMatchType::
    getTypes () const
    {
      return this->Types_;
    }

    ProbeMatchType::TypesOptional& ProbeMatchType::
    getTypes ()
    {
      return this->Types_;
    }

    void ProbeMatchType::
    setTypes (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void ProbeMatchType::
    setTypes (const TypesOptional& x)
    {
      this->Types_ = x;
    }

    void ProbeMatchType::
    setTypes (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }

    const ProbeMatchType::ScopesOptional& ProbeMatchType::
    getScopes () const
    {
      return this->Scopes_;
    }

    ProbeMatchType::ScopesOptional& ProbeMatchType::
    getScopes ()
    {
      return this->Scopes_;
    }

    void ProbeMatchType::
    setScopes (const ScopesType& x)
    {
      this->Scopes_.set (x);
    }

    void ProbeMatchType::
    setScopes (const ScopesOptional& x)
    {
      this->Scopes_ = x;
    }

    void ProbeMatchType::
    setScopes (::std::unique_ptr< ScopesType > x)
    {
      this->Scopes_.set (std::move (x));
    }

    const ProbeMatchType::XAddrsOptional& ProbeMatchType::
    getXAddrs () const
    {
      return this->XAddrs_;
    }

    ProbeMatchType::XAddrsOptional& ProbeMatchType::
    getXAddrs ()
    {
      return this->XAddrs_;
    }

    void ProbeMatchType::
    setXAddrs (const XAddrsType& x)
    {
      this->XAddrs_.set (x);
    }

    void ProbeMatchType::
    setXAddrs (const XAddrsOptional& x)
    {
      this->XAddrs_ = x;
    }

    void ProbeMatchType::
    setXAddrs (::std::unique_ptr< XAddrsType > x)
    {
      this->XAddrs_.set (std::move (x));
    }

    const ProbeMatchType::MetadataVersionType& ProbeMatchType::
    getMetadataVersion () const
    {
      return this->MetadataVersion_.get ();
    }

    ProbeMatchType::MetadataVersionType& ProbeMatchType::
    getMetadataVersion ()
    {
      return this->MetadataVersion_.get ();
    }

    void ProbeMatchType::
    setMetadataVersion (const MetadataVersionType& x)
    {
      this->MetadataVersion_.set (x);
    }


    // ResolveType
    // 

    const ResolveType::EndpointReferenceType& ResolveType::
    getEndpointReference () const
    {
      return this->EndpointReference_.get ();
    }

    ResolveType::EndpointReferenceType& ResolveType::
    getEndpointReference ()
    {
      return this->EndpointReference_.get ();
    }

    void ResolveType::
    setEndpointReference (const EndpointReferenceType& x)
    {
      this->EndpointReference_.set (x);
    }

    void ResolveType::
    setEndpointReference (::std::unique_ptr< EndpointReferenceType > x)
    {
      this->EndpointReference_.set (std::move (x));
    }


    // ResolveMatchesType
    // 

    const ResolveMatchesType::ResolveMatchOptional& ResolveMatchesType::
    getResolveMatch () const
    {
      return this->ResolveMatch_;
    }

    ResolveMatchesType::ResolveMatchOptional& ResolveMatchesType::
    getResolveMatch ()
    {
      return this->ResolveMatch_;
    }

    void ResolveMatchesType::
    setResolveMatch (const ResolveMatchType& x)
    {
      this->ResolveMatch_.set (x);
    }

    void ResolveMatchesType::
    setResolveMatch (const ResolveMatchOptional& x)
    {
      this->ResolveMatch_ = x;
    }

    void ResolveMatchesType::
    setResolveMatch (::std::unique_ptr< ResolveMatchType > x)
    {
      this->ResolveMatch_.set (std::move (x));
    }


    // ResolveMatchType
    // 

    const ResolveMatchType::EndpointReferenceType& ResolveMatchType::
    getEndpointReference () const
    {
      return this->EndpointReference_.get ();
    }

    ResolveMatchType::EndpointReferenceType& ResolveMatchType::
    getEndpointReference ()
    {
      return this->EndpointReference_.get ();
    }

    void ResolveMatchType::
    setEndpointReference (const EndpointReferenceType& x)
    {
      this->EndpointReference_.set (x);
    }

    void ResolveMatchType::
    setEndpointReference (::std::unique_ptr< EndpointReferenceType > x)
    {
      this->EndpointReference_.set (std::move (x));
    }

    const ResolveMatchType::TypesOptional& ResolveMatchType::
    getTypes () const
    {
      return this->Types_;
    }

    ResolveMatchType::TypesOptional& ResolveMatchType::
    getTypes ()
    {
      return this->Types_;
    }

    void ResolveMatchType::
    setTypes (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void ResolveMatchType::
    setTypes (const TypesOptional& x)
    {
      this->Types_ = x;
    }

    void ResolveMatchType::
    setTypes (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }

    const ResolveMatchType::ScopesOptional& ResolveMatchType::
    getScopes () const
    {
      return this->Scopes_;
    }

    ResolveMatchType::ScopesOptional& ResolveMatchType::
    getScopes ()
    {
      return this->Scopes_;
    }

    void ResolveMatchType::
    setScopes (const ScopesType& x)
    {
      this->Scopes_.set (x);
    }

    void ResolveMatchType::
    setScopes (const ScopesOptional& x)
    {
      this->Scopes_ = x;
    }

    void ResolveMatchType::
    setScopes (::std::unique_ptr< ScopesType > x)
    {
      this->Scopes_.set (std::move (x));
    }

    const ResolveMatchType::XAddrsOptional& ResolveMatchType::
    getXAddrs () const
    {
      return this->XAddrs_;
    }

    ResolveMatchType::XAddrsOptional& ResolveMatchType::
    getXAddrs ()
    {
      return this->XAddrs_;
    }

    void ResolveMatchType::
    setXAddrs (const XAddrsType& x)
    {
      this->XAddrs_.set (x);
    }

    void ResolveMatchType::
    setXAddrs (const XAddrsOptional& x)
    {
      this->XAddrs_ = x;
    }

    void ResolveMatchType::
    setXAddrs (::std::unique_ptr< XAddrsType > x)
    {
      this->XAddrs_.set (std::move (x));
    }

    const ResolveMatchType::MetadataVersionType& ResolveMatchType::
    getMetadataVersion () const
    {
      return this->MetadataVersion_.get ();
    }

    ResolveMatchType::MetadataVersionType& ResolveMatchType::
    getMetadataVersion ()
    {
      return this->MetadataVersion_.get ();
    }

    void ResolveMatchType::
    setMetadataVersion (const MetadataVersionType& x)
    {
      this->MetadataVersion_.set (x);
    }


    // QNameListType
    //

    QNameListType::
    QNameListType ()
    : ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (this)
    {
    }

    QNameListType::
    QNameListType (size_type n, const ::xml_schema::Qname& x)
    : ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (n, x, this)
    {
    }

    QNameListType::
    QNameListType (const QNameListType& o,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (o, f, this)
    {
    }

    // UriListType
    //

    UriListType::
    UriListType ()
    : ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (this)
    {
    }

    UriListType::
    UriListType (size_type n, const ::xml_schema::Uri& x)
    : ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (n, x, this)
    {
    }

    UriListType::
    UriListType (const UriListType& o,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (o, f, this)
    {
    }

    // ScopesType
    // 

    const ScopesType::MatchByOptional& ScopesType::
    getMatchBy () const
    {
      return this->MatchBy_;
    }

    ScopesType::MatchByOptional& ScopesType::
    getMatchBy ()
    {
      return this->MatchBy_;
    }

    void ScopesType::
    setMatchBy (const MatchByType& x)
    {
      this->MatchBy_.set (x);
    }

    void ScopesType::
    setMatchBy (const MatchByOptional& x)
    {
      this->MatchBy_ = x;
    }

    void ScopesType::
    setMatchBy (::std::unique_ptr< MatchByType > x)
    {
      this->MatchBy_.set (std::move (x));
    }


    // FaultCodeType
    // 

    FaultCodeType::
    FaultCodeType (const ::xml_schema::Qname& v)
    : ::xml_schema::Qname (v)
    {
    }

    FaultCodeType::
    FaultCodeType (const FaultCodeType& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Qname (v, f, c)
    {
    }


    // FaultCodeOpenType
    //

    FaultCodeOpenType::
    FaultCodeOpenType (const char* s)
    : ::xml_schema::String (s)
    {
    }

    FaultCodeOpenType::
    FaultCodeOpenType (const ::std::string& s)
    : ::xml_schema::String (s)
    {
    }

    FaultCodeOpenType::
    FaultCodeOpenType (const FaultCodeOpenType& o,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (o, f, c)
    {
    }

    // SecurityType
    // 

    const SecurityType::SigOptional& SecurityType::
    getSig () const
    {
      return this->Sig_;
    }

    SecurityType::SigOptional& SecurityType::
    getSig ()
    {
      return this->Sig_;
    }

    void SecurityType::
    setSig (const SigType& x)
    {
      this->Sig_.set (x);
    }

    void SecurityType::
    setSig (const SigOptional& x)
    {
      this->Sig_ = x;
    }

    void SecurityType::
    setSig (::std::unique_ptr< SigType > x)
    {
      this->Sig_.set (std::move (x));
    }


    // SigType
    // 

    const SigType::SchemeType& SigType::
    getScheme () const
    {
      return this->Scheme_.get ();
    }

    SigType::SchemeType& SigType::
    getScheme ()
    {
      return this->Scheme_.get ();
    }

    void SigType::
    setScheme (const SchemeType& x)
    {
      this->Scheme_.set (x);
    }

    void SigType::
    setScheme (::std::unique_ptr< SchemeType > x)
    {
      this->Scheme_.set (std::move (x));
    }

    const SigType::KeyIdOptional& SigType::
    getKeyId () const
    {
      return this->KeyId_;
    }

    SigType::KeyIdOptional& SigType::
    getKeyId ()
    {
      return this->KeyId_;
    }

    void SigType::
    setKeyId (const KeyIdType& x)
    {
      this->KeyId_.set (x);
    }

    void SigType::
    setKeyId (const KeyIdOptional& x)
    {
      this->KeyId_ = x;
    }

    void SigType::
    setKeyId (::std::unique_ptr< KeyIdType > x)
    {
      this->KeyId_.set (std::move (x));
    }

    const SigType::RefsType& SigType::
    getRefs () const
    {
      return this->Refs_.get ();
    }

    SigType::RefsType& SigType::
    getRefs ()
    {
      return this->Refs_.get ();
    }

    void SigType::
    setRefs (const RefsType& x)
    {
      this->Refs_.set (x);
    }

    void SigType::
    setRefs (::std::unique_ptr< RefsType > x)
    {
      this->Refs_.set (std::move (x));
    }

    const SigType::SigType1& SigType::
    getSig () const
    {
      return this->Sig_.get ();
    }

    SigType::SigType1& SigType::
    getSig ()
    {
      return this->Sig_.get ();
    }

    void SigType::
    setSig (const SigType1& x)
    {
      this->Sig_.set (x);
    }

    void SigType::
    setSig (::std::unique_ptr< SigType1 > x)
    {
      this->Sig_.set (std::move (x));
    }


    // AppSequenceType
    // 

    const AppSequenceType::InstanceIdType& AppSequenceType::
    getInstanceId () const
    {
      return this->InstanceId_.get ();
    }

    AppSequenceType::InstanceIdType& AppSequenceType::
    getInstanceId ()
    {
      return this->InstanceId_.get ();
    }

    void AppSequenceType::
    setInstanceId (const InstanceIdType& x)
    {
      this->InstanceId_.set (x);
    }

    const AppSequenceType::SequenceIdOptional& AppSequenceType::
    getSequenceId () const
    {
      return this->SequenceId_;
    }

    AppSequenceType::SequenceIdOptional& AppSequenceType::
    getSequenceId ()
    {
      return this->SequenceId_;
    }

    void AppSequenceType::
    setSequenceId (const SequenceIdType& x)
    {
      this->SequenceId_.set (x);
    }

    void AppSequenceType::
    setSequenceId (const SequenceIdOptional& x)
    {
      this->SequenceId_ = x;
    }

    void AppSequenceType::
    setSequenceId (::std::unique_ptr< SequenceIdType > x)
    {
      this->SequenceId_.set (std::move (x));
    }

    const AppSequenceType::MessageNumberType& AppSequenceType::
    getMessageNumber () const
    {
      return this->MessageNumber_.get ();
    }

    AppSequenceType::MessageNumberType& AppSequenceType::
    getMessageNumber ()
    {
      return this->MessageNumber_.get ();
    }

    void AppSequenceType::
    setMessageNumber (const MessageNumberType& x)
    {
      this->MessageNumber_.set (x);
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace WS
{
  namespace DISCOVERY
  {
    // HelloType
    //

    HelloType::
    HelloType (const EndpointReferenceType& EndpointReference,
               const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (EndpointReference, this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    HelloType::
    HelloType (::std::unique_ptr< EndpointReferenceType > EndpointReference,
               const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (std::move (EndpointReference), this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    HelloType::
    HelloType (const HelloType& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this),
      Types_ (x.Types_, f, this),
      Scopes_ (x.Scopes_, f, this),
      XAddrs_ (x.XAddrs_, f, this),
      MetadataVersion_ (x.MetadataVersion_, f, this)
    {
    }

    HelloType::
    HelloType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void HelloType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EndpointReference_.present ())
            {
              ::std::unique_ptr< EndpointReferenceType > r (
                dynamic_cast< EndpointReferenceType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->EndpointReference_.set (::std::move (r));
              continue;
            }
          }
        }

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Types_)
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        // Scopes
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ScopesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Scopes_)
            {
              ::std::unique_ptr< ScopesType > r (
                dynamic_cast< ScopesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Scopes_.set (::std::move (r));
              continue;
            }
          }
        }

        // XAddrs
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< XAddrsType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->XAddrs_)
            {
              ::std::unique_ptr< XAddrsType > r (
                dynamic_cast< XAddrsType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->XAddrs_.set (::std::move (r));
              continue;
            }
          }
        }

        // MetadataVersion
        //
        if (n.name () == "MetadataVersion" && n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          if (!MetadataVersion_.present ())
          {
            this->MetadataVersion_.set (MetadataVersionTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!EndpointReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndpointReference",
          "http://www.w3.org/2005/08/addressing");
      }

      if (!MetadataVersion_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MetadataVersion",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
      }
    }

    HelloType* HelloType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class HelloType (*this, f, c);
    }

    HelloType& HelloType::
    operator= (const HelloType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
        this->Types_ = x.Types_;
        this->Scopes_ = x.Scopes_;
        this->XAddrs_ = x.XAddrs_;
        this->MetadataVersion_ = x.MetadataVersion_;
      }

      return *this;
    }

    HelloType::
    ~HelloType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, HelloType >
    _xsd_HelloType_type_factory_init (
      "HelloType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ByeType
    //

    ByeType::
    ByeType (const EndpointReferenceType& EndpointReference)
    : ::xml_schema::Type (),
      EndpointReference_ (EndpointReference, this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
    }

    ByeType::
    ByeType (::std::unique_ptr< EndpointReferenceType > EndpointReference)
    : ::xml_schema::Type (),
      EndpointReference_ (std::move (EndpointReference), this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
    }

    ByeType::
    ByeType (const ByeType& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this),
      Types_ (x.Types_, f, this),
      Scopes_ (x.Scopes_, f, this),
      XAddrs_ (x.XAddrs_, f, this),
      MetadataVersion_ (x.MetadataVersion_, f, this)
    {
    }

    ByeType::
    ByeType (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ByeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EndpointReference_.present ())
            {
              ::std::unique_ptr< EndpointReferenceType > r (
                dynamic_cast< EndpointReferenceType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->EndpointReference_.set (::std::move (r));
              continue;
            }
          }
        }

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Types_)
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        // Scopes
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ScopesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Scopes_)
            {
              ::std::unique_ptr< ScopesType > r (
                dynamic_cast< ScopesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Scopes_.set (::std::move (r));
              continue;
            }
          }
        }

        // XAddrs
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< XAddrsType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->XAddrs_)
            {
              ::std::unique_ptr< XAddrsType > r (
                dynamic_cast< XAddrsType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->XAddrs_.set (::std::move (r));
              continue;
            }
          }
        }

        // MetadataVersion
        //
        if (n.name () == "MetadataVersion" && n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          if (!this->MetadataVersion_)
          {
            this->MetadataVersion_.set (MetadataVersionTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!EndpointReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndpointReference",
          "http://www.w3.org/2005/08/addressing");
      }
    }

    ByeType* ByeType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ByeType (*this, f, c);
    }

    ByeType& ByeType::
    operator= (const ByeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
        this->Types_ = x.Types_;
        this->Scopes_ = x.Scopes_;
        this->XAddrs_ = x.XAddrs_;
        this->MetadataVersion_ = x.MetadataVersion_;
      }

      return *this;
    }

    ByeType::
    ~ByeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ByeType >
    _xsd_ByeType_type_factory_init (
      "ByeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ProbeType
    //

    ProbeType::
    ProbeType ()
    : ::xml_schema::Type (),
      Types_ (this),
      Scopes_ (this)
    {
    }

    ProbeType::
    ProbeType (const ProbeType& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Types_ (x.Types_, f, this),
      Scopes_ (x.Scopes_, f, this)
    {
    }

    ProbeType::
    ProbeType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Types_ (this),
      Scopes_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ProbeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Types_)
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        // Scopes
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ScopesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Scopes_)
            {
              ::std::unique_ptr< ScopesType > r (
                dynamic_cast< ScopesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Scopes_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    ProbeType* ProbeType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ProbeType (*this, f, c);
    }

    ProbeType& ProbeType::
    operator= (const ProbeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->Types_ = x.Types_;
        this->Scopes_ = x.Scopes_;
      }

      return *this;
    }

    ProbeType::
    ~ProbeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ProbeType >
    _xsd_ProbeType_type_factory_init (
      "ProbeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ProbeMatchesType
    //

    ProbeMatchesType::
    ProbeMatchesType ()
    : ::xml_schema::Type (),
      ProbeMatch_ (this)
    {
    }

    ProbeMatchesType::
    ProbeMatchesType (const ProbeMatchesType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      ProbeMatch_ (x.ProbeMatch_, f, this)
    {
    }

    ProbeMatchesType::
    ProbeMatchesType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      ProbeMatch_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ProbeMatchesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ProbeMatch
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ProbeMatch",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ProbeMatchType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ProbeMatchType > r (
              dynamic_cast< ProbeMatchType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ProbeMatch_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ProbeMatchesType* ProbeMatchesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ProbeMatchesType (*this, f, c);
    }

    ProbeMatchesType& ProbeMatchesType::
    operator= (const ProbeMatchesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->ProbeMatch_ = x.ProbeMatch_;
      }

      return *this;
    }

    ProbeMatchesType::
    ~ProbeMatchesType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ProbeMatchesType >
    _xsd_ProbeMatchesType_type_factory_init (
      "ProbeMatchesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ProbeMatchType
    //

    ProbeMatchType::
    ProbeMatchType (const EndpointReferenceType& EndpointReference,
                    const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (EndpointReference, this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    ProbeMatchType::
    ProbeMatchType (::std::unique_ptr< EndpointReferenceType > EndpointReference,
                    const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (std::move (EndpointReference), this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    ProbeMatchType::
    ProbeMatchType (const ProbeMatchType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this),
      Types_ (x.Types_, f, this),
      Scopes_ (x.Scopes_, f, this),
      XAddrs_ (x.XAddrs_, f, this),
      MetadataVersion_ (x.MetadataVersion_, f, this)
    {
    }

    ProbeMatchType::
    ProbeMatchType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ProbeMatchType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EndpointReference_.present ())
            {
              ::std::unique_ptr< EndpointReferenceType > r (
                dynamic_cast< EndpointReferenceType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->EndpointReference_.set (::std::move (r));
              continue;
            }
          }
        }

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Types_)
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        // Scopes
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ScopesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Scopes_)
            {
              ::std::unique_ptr< ScopesType > r (
                dynamic_cast< ScopesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Scopes_.set (::std::move (r));
              continue;
            }
          }
        }

        // XAddrs
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< XAddrsType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->XAddrs_)
            {
              ::std::unique_ptr< XAddrsType > r (
                dynamic_cast< XAddrsType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->XAddrs_.set (::std::move (r));
              continue;
            }
          }
        }

        // MetadataVersion
        //
        if (n.name () == "MetadataVersion" && n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          if (!MetadataVersion_.present ())
          {
            this->MetadataVersion_.set (MetadataVersionTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!EndpointReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndpointReference",
          "http://www.w3.org/2005/08/addressing");
      }

      if (!MetadataVersion_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MetadataVersion",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
      }
    }

    ProbeMatchType* ProbeMatchType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ProbeMatchType (*this, f, c);
    }

    ProbeMatchType& ProbeMatchType::
    operator= (const ProbeMatchType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
        this->Types_ = x.Types_;
        this->Scopes_ = x.Scopes_;
        this->XAddrs_ = x.XAddrs_;
        this->MetadataVersion_ = x.MetadataVersion_;
      }

      return *this;
    }

    ProbeMatchType::
    ~ProbeMatchType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ProbeMatchType >
    _xsd_ProbeMatchType_type_factory_init (
      "ProbeMatchType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ResolveType
    //

    ResolveType::
    ResolveType (const EndpointReferenceType& EndpointReference)
    : ::xml_schema::Type (),
      EndpointReference_ (EndpointReference, this)
    {
    }

    ResolveType::
    ResolveType (::std::unique_ptr< EndpointReferenceType > EndpointReference)
    : ::xml_schema::Type (),
      EndpointReference_ (std::move (EndpointReference), this)
    {
    }

    ResolveType::
    ResolveType (const ResolveType& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this)
    {
    }

    ResolveType::
    ResolveType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ResolveType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EndpointReference_.present ())
            {
              ::std::unique_ptr< EndpointReferenceType > r (
                dynamic_cast< EndpointReferenceType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->EndpointReference_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!EndpointReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndpointReference",
          "http://www.w3.org/2005/08/addressing");
      }
    }

    ResolveType* ResolveType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ResolveType (*this, f, c);
    }

    ResolveType& ResolveType::
    operator= (const ResolveType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
      }

      return *this;
    }

    ResolveType::
    ~ResolveType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ResolveType >
    _xsd_ResolveType_type_factory_init (
      "ResolveType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ResolveMatchesType
    //

    ResolveMatchesType::
    ResolveMatchesType ()
    : ::xml_schema::Type (),
      ResolveMatch_ (this)
    {
    }

    ResolveMatchesType::
    ResolveMatchesType (const ResolveMatchesType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      ResolveMatch_ (x.ResolveMatch_, f, this)
    {
    }

    ResolveMatchesType::
    ResolveMatchesType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      ResolveMatch_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ResolveMatchesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ResolveMatch
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ResolveMatch",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ResolveMatchType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->ResolveMatch_)
            {
              ::std::unique_ptr< ResolveMatchType > r (
                dynamic_cast< ResolveMatchType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->ResolveMatch_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    ResolveMatchesType* ResolveMatchesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ResolveMatchesType (*this, f, c);
    }

    ResolveMatchesType& ResolveMatchesType::
    operator= (const ResolveMatchesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->ResolveMatch_ = x.ResolveMatch_;
      }

      return *this;
    }

    ResolveMatchesType::
    ~ResolveMatchesType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ResolveMatchesType >
    _xsd_ResolveMatchesType_type_factory_init (
      "ResolveMatchesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ResolveMatchType
    //

    ResolveMatchType::
    ResolveMatchType (const EndpointReferenceType& EndpointReference,
                      const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (EndpointReference, this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    ResolveMatchType::
    ResolveMatchType (::std::unique_ptr< EndpointReferenceType > EndpointReference,
                      const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (std::move (EndpointReference), this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    ResolveMatchType::
    ResolveMatchType (const ResolveMatchType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this),
      Types_ (x.Types_, f, this),
      Scopes_ (x.Scopes_, f, this),
      XAddrs_ (x.XAddrs_, f, this),
      MetadataVersion_ (x.MetadataVersion_, f, this)
    {
    }

    ResolveMatchType::
    ResolveMatchType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ResolveMatchType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EndpointReference_.present ())
            {
              ::std::unique_ptr< EndpointReferenceType > r (
                dynamic_cast< EndpointReferenceType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->EndpointReference_.set (::std::move (r));
              continue;
            }
          }
        }

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Types_)
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        // Scopes
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ScopesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Scopes_)
            {
              ::std::unique_ptr< ScopesType > r (
                dynamic_cast< ScopesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Scopes_.set (::std::move (r));
              continue;
            }
          }
        }

        // XAddrs
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< XAddrsType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->XAddrs_)
            {
              ::std::unique_ptr< XAddrsType > r (
                dynamic_cast< XAddrsType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->XAddrs_.set (::std::move (r));
              continue;
            }
          }
        }

        // MetadataVersion
        //
        if (n.name () == "MetadataVersion" && n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          if (!MetadataVersion_.present ())
          {
            this->MetadataVersion_.set (MetadataVersionTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!EndpointReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndpointReference",
          "http://www.w3.org/2005/08/addressing");
      }

      if (!MetadataVersion_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MetadataVersion",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
      }
    }

    ResolveMatchType* ResolveMatchType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ResolveMatchType (*this, f, c);
    }

    ResolveMatchType& ResolveMatchType::
    operator= (const ResolveMatchType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
        this->Types_ = x.Types_;
        this->Scopes_ = x.Scopes_;
        this->XAddrs_ = x.XAddrs_;
        this->MetadataVersion_ = x.MetadataVersion_;
      }

      return *this;
    }

    ResolveMatchType::
    ~ResolveMatchType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ResolveMatchType >
    _xsd_ResolveMatchType_type_factory_init (
      "ResolveMatchType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // QNameListType
    //

    QNameListType::
    QNameListType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (e, f, this)
    {
    }

    QNameListType::
    QNameListType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (a, f, this)
    {
    }

    QNameListType::
    QNameListType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (s, e, f, this)
    {
    }

    QNameListType* QNameListType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class QNameListType (*this, f, c);
    }

    QNameListType::
    ~QNameListType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, QNameListType >
    _xsd_QNameListType_type_factory_init (
      "QNameListType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // UriListType
    //

    UriListType::
    UriListType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (e, f, this)
    {
    }

    UriListType::
    UriListType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (a, f, this)
    {
    }

    UriListType::
    UriListType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (s, e, f, this)
    {
    }

    UriListType* UriListType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class UriListType (*this, f, c);
    }

    UriListType::
    ~UriListType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, UriListType >
    _xsd_UriListType_type_factory_init (
      "UriListType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ScopesType
    //

    ScopesType::
    ScopesType ()
    : ::WS::DISCOVERY::UriListType (),
      MatchBy_ (this)
    {
    }

    ScopesType::
    ScopesType (const ::WS::DISCOVERY::UriListType& _xsd_UriListType_base)
    : ::WS::DISCOVERY::UriListType (_xsd_UriListType_base),
      MatchBy_ (this)
    {
    }

    ScopesType::
    ScopesType (const ScopesType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::WS::DISCOVERY::UriListType (x, f, c),
      MatchBy_ (x.MatchBy_, f, this)
    {
    }

    ScopesType::
    ScopesType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::WS::DISCOVERY::UriListType (e, f | ::xml_schema::Flags::base, c),
      MatchBy_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ScopesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "MatchBy" && n.namespace_ ().empty ())
        {
          this->MatchBy_.set (MatchByTraits::create (i, f, this));
          continue;
        }
      }
    }

    ScopesType* ScopesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ScopesType (*this, f, c);
    }

    ScopesType& ScopesType::
    operator= (const ScopesType& x)
    {
      if (this != &x)
      {
        static_cast< ::WS::DISCOVERY::UriListType& > (*this) = x;
        this->MatchBy_ = x.MatchBy_;
      }

      return *this;
    }

    ScopesType::
    ~ScopesType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ScopesType >
    _xsd_ScopesType_type_factory_init (
      "ScopesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // FaultCodeType
    //

    FaultCodeType::
    FaultCodeType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Qname (e, f, c)
    {
    }

    FaultCodeType::
    FaultCodeType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Qname (a, f, c)
    {
    }

    FaultCodeType::
    FaultCodeType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Qname (s, e, f, c)
    {
    }

    FaultCodeType* FaultCodeType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FaultCodeType (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, FaultCodeType >
    _xsd_FaultCodeType_type_factory_init (
      "FaultCodeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // FaultCodeOpenType
    //

    FaultCodeOpenType::
    FaultCodeOpenType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    FaultCodeOpenType::
    FaultCodeOpenType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    FaultCodeOpenType::
    FaultCodeOpenType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    FaultCodeOpenType* FaultCodeOpenType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FaultCodeOpenType (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, FaultCodeOpenType >
    _xsd_FaultCodeOpenType_type_factory_init (
      "FaultCodeOpenType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // SecurityType
    //

    SecurityType::
    SecurityType ()
    : ::xml_schema::Type (),
      Sig_ (this)
    {
    }

    SecurityType::
    SecurityType (const SecurityType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Sig_ (x.Sig_, f, this)
    {
    }

    SecurityType::
    SecurityType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Sig_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SecurityType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Sig
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Sig",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< SigType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Sig_)
            {
              ::std::unique_ptr< SigType > r (
                dynamic_cast< SigType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Sig_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    SecurityType* SecurityType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SecurityType (*this, f, c);
    }

    SecurityType& SecurityType::
    operator= (const SecurityType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->Sig_ = x.Sig_;
      }

      return *this;
    }

    SecurityType::
    ~SecurityType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SecurityType >
    _xsd_SecurityType_type_factory_init (
      "SecurityType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // SigType
    //

    SigType::
    SigType (const SchemeType& Scheme,
             const RefsType& Refs,
             const SigType1& Sig)
    : ::xml_schema::Type (),
      Scheme_ (Scheme, this),
      KeyId_ (this),
      Refs_ (Refs, this),
      Sig_ (Sig, this)
    {
    }

    SigType::
    SigType (const SigType& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Scheme_ (x.Scheme_, f, this),
      KeyId_ (x.KeyId_, f, this),
      Refs_ (x.Refs_, f, this),
      Sig_ (x.Sig_, f, this)
    {
    }

    SigType::
    SigType (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Scheme_ (this),
      KeyId_ (this),
      Refs_ (this),
      Sig_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SigType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Scheme" && n.namespace_ ().empty ())
        {
          this->Scheme_.set (SchemeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "KeyId" && n.namespace_ ().empty ())
        {
          this->KeyId_.set (KeyIdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "Refs" && n.namespace_ ().empty ())
        {
          this->Refs_.set (RefsTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "Sig" && n.namespace_ ().empty ())
        {
          this->Sig_.set (SigTraits::create (i, f, this));
          continue;
        }
      }

      if (!Scheme_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "Scheme",
          "");
      }

      if (!Refs_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "Refs",
          "");
      }

      if (!Sig_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "Sig",
          "");
      }
    }

    SigType* SigType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SigType (*this, f, c);
    }

    SigType& SigType::
    operator= (const SigType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->Scheme_ = x.Scheme_;
        this->KeyId_ = x.KeyId_;
        this->Refs_ = x.Refs_;
        this->Sig_ = x.Sig_;
      }

      return *this;
    }

    SigType::
    ~SigType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SigType >
    _xsd_SigType_type_factory_init (
      "SigType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // AppSequenceType
    //

    AppSequenceType::
    AppSequenceType (const InstanceIdType& InstanceId,
                     const MessageNumberType& MessageNumber)
    : ::xml_schema::Type (),
      InstanceId_ (InstanceId, this),
      SequenceId_ (this),
      MessageNumber_ (MessageNumber, this)
    {
    }

    AppSequenceType::
    AppSequenceType (const ::xml_schema::Type& _xsd_Type_base,
                     const InstanceIdType& InstanceId,
                     const MessageNumberType& MessageNumber)
    : ::xml_schema::Type (_xsd_Type_base),
      InstanceId_ (InstanceId, this),
      SequenceId_ (this),
      MessageNumber_ (MessageNumber, this)
    {
    }

    AppSequenceType::
    AppSequenceType (const AppSequenceType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      InstanceId_ (x.InstanceId_, f, this),
      SequenceId_ (x.SequenceId_, f, this),
      MessageNumber_ (x.MessageNumber_, f, this)
    {
    }

    AppSequenceType::
    AppSequenceType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      InstanceId_ (this),
      SequenceId_ (this),
      MessageNumber_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AppSequenceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "InstanceId" && n.namespace_ ().empty ())
        {
          this->InstanceId_.set (InstanceIdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "SequenceId" && n.namespace_ ().empty ())
        {
          this->SequenceId_.set (SequenceIdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "MessageNumber" && n.namespace_ ().empty ())
        {
          this->MessageNumber_.set (MessageNumberTraits::create (i, f, this));
          continue;
        }
      }

      if (!InstanceId_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "InstanceId",
          "");
      }

      if (!MessageNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "MessageNumber",
          "");
      }
    }

    AppSequenceType* AppSequenceType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class AppSequenceType (*this, f, c);
    }

    AppSequenceType& AppSequenceType::
    operator= (const AppSequenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->InstanceId_ = x.InstanceId_;
        this->SequenceId_ = x.SequenceId_;
        this->MessageNumber_ = x.MessageNumber_;
      }

      return *this;
    }

    AppSequenceType::
    ~AppSequenceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, AppSequenceType >
    _xsd_AppSequenceType_type_factory_init (
      "AppSequenceType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace WS
{
  namespace DISCOVERY
  {
    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    parseHello (const ::std::string& u,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::HelloType > (
        ::WS::DISCOVERY::parseHello (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    parseHello (const ::std::string& u,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::HelloType > (
        ::WS::DISCOVERY::parseHello (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    parseHello (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::HelloType > (
        ::WS::DISCOVERY::parseHello (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    parseHello (::std::istream& is,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseHello (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    parseHello (::std::istream& is,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseHello (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    parseHello (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseHello (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    parseHello (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseHello (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    parseHello (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseHello (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    parseHello (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseHello (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    parseHello (::xercesc::InputSource& i,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::HelloType > (
        ::WS::DISCOVERY::parseHello (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    parseHello (::xercesc::InputSource& i,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::HelloType > (
        ::WS::DISCOVERY::parseHello (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    parseHello (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::HelloType > (
        ::WS::DISCOVERY::parseHello (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    parseHello (const ::xercesc::DOMDocument& doc,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::HelloType > (
          ::WS::DISCOVERY::parseHello (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Hello",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::HelloType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::HelloType > r (
          dynamic_cast< ::WS::DISCOVERY::HelloType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Hello",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    parseHello (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Hello",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::HelloType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::HelloType > r (
          dynamic_cast< ::WS::DISCOVERY::HelloType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Hello",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    parseBye (const ::std::string& u,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ByeType > (
        ::WS::DISCOVERY::parseBye (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    parseBye (const ::std::string& u,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ByeType > (
        ::WS::DISCOVERY::parseBye (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    parseBye (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ByeType > (
        ::WS::DISCOVERY::parseBye (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    parseBye (::std::istream& is,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseBye (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    parseBye (::std::istream& is,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseBye (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    parseBye (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseBye (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    parseBye (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseBye (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    parseBye (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseBye (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    parseBye (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseBye (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    parseBye (::xercesc::InputSource& i,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ByeType > (
        ::WS::DISCOVERY::parseBye (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    parseBye (::xercesc::InputSource& i,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ByeType > (
        ::WS::DISCOVERY::parseBye (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    parseBye (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ByeType > (
        ::WS::DISCOVERY::parseBye (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    parseBye (const ::xercesc::DOMDocument& doc,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::ByeType > (
          ::WS::DISCOVERY::parseBye (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Bye",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ByeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::ByeType > r (
          dynamic_cast< ::WS::DISCOVERY::ByeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Bye",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    parseBye (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Bye",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ByeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::ByeType > r (
          dynamic_cast< ::WS::DISCOVERY::ByeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Bye",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    parseProbe (const ::std::string& u,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > (
        ::WS::DISCOVERY::parseProbe (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    parseProbe (const ::std::string& u,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > (
        ::WS::DISCOVERY::parseProbe (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    parseProbe (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > (
        ::WS::DISCOVERY::parseProbe (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    parseProbe (::std::istream& is,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseProbe (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    parseProbe (::std::istream& is,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseProbe (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    parseProbe (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseProbe (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    parseProbe (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseProbe (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    parseProbe (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseProbe (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    parseProbe (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseProbe (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    parseProbe (::xercesc::InputSource& i,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > (
        ::WS::DISCOVERY::parseProbe (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    parseProbe (::xercesc::InputSource& i,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > (
        ::WS::DISCOVERY::parseProbe (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    parseProbe (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > (
        ::WS::DISCOVERY::parseProbe (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    parseProbe (const ::xercesc::DOMDocument& doc,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > (
          ::WS::DISCOVERY::parseProbe (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Probe",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ProbeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > r (
          dynamic_cast< ::WS::DISCOVERY::ProbeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Probe",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    parseProbe (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Probe",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ProbeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > r (
          dynamic_cast< ::WS::DISCOVERY::ProbeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Probe",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    parseProbeMatches (const ::std::string& u,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > (
        ::WS::DISCOVERY::parseProbeMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    parseProbeMatches (const ::std::string& u,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > (
        ::WS::DISCOVERY::parseProbeMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    parseProbeMatches (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > (
        ::WS::DISCOVERY::parseProbeMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    parseProbeMatches (::std::istream& is,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseProbeMatches (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    parseProbeMatches (::std::istream& is,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseProbeMatches (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    parseProbeMatches (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseProbeMatches (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    parseProbeMatches (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseProbeMatches (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    parseProbeMatches (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseProbeMatches (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    parseProbeMatches (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseProbeMatches (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    parseProbeMatches (::xercesc::InputSource& i,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > (
        ::WS::DISCOVERY::parseProbeMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    parseProbeMatches (::xercesc::InputSource& i,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > (
        ::WS::DISCOVERY::parseProbeMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    parseProbeMatches (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > (
        ::WS::DISCOVERY::parseProbeMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    parseProbeMatches (const ::xercesc::DOMDocument& doc,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > (
          ::WS::DISCOVERY::parseProbeMatches (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ProbeMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ProbeMatchesType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > r (
          dynamic_cast< ::WS::DISCOVERY::ProbeMatchesType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ProbeMatches",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    parseProbeMatches (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ProbeMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ProbeMatchesType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > r (
          dynamic_cast< ::WS::DISCOVERY::ProbeMatchesType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ProbeMatches",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    parseResolve (const ::std::string& u,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > (
        ::WS::DISCOVERY::parseResolve (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    parseResolve (const ::std::string& u,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > (
        ::WS::DISCOVERY::parseResolve (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    parseResolve (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > (
        ::WS::DISCOVERY::parseResolve (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    parseResolve (::std::istream& is,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseResolve (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    parseResolve (::std::istream& is,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseResolve (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    parseResolve (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseResolve (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    parseResolve (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseResolve (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    parseResolve (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseResolve (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    parseResolve (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseResolve (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    parseResolve (::xercesc::InputSource& i,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > (
        ::WS::DISCOVERY::parseResolve (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    parseResolve (::xercesc::InputSource& i,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > (
        ::WS::DISCOVERY::parseResolve (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    parseResolve (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > (
        ::WS::DISCOVERY::parseResolve (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    parseResolve (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > (
          ::WS::DISCOVERY::parseResolve (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Resolve",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ResolveType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > r (
          dynamic_cast< ::WS::DISCOVERY::ResolveType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Resolve",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    parseResolve (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Resolve",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ResolveType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > r (
          dynamic_cast< ::WS::DISCOVERY::ResolveType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Resolve",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    parseResolveMatches (const ::std::string& u,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > (
        ::WS::DISCOVERY::parseResolveMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    parseResolveMatches (const ::std::string& u,
                         ::xml_schema::ErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > (
        ::WS::DISCOVERY::parseResolveMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    parseResolveMatches (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > (
        ::WS::DISCOVERY::parseResolveMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    parseResolveMatches (::std::istream& is,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseResolveMatches (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    parseResolveMatches (::std::istream& is,
                         ::xml_schema::ErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseResolveMatches (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    parseResolveMatches (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseResolveMatches (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    parseResolveMatches (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseResolveMatches (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    parseResolveMatches (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::ErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseResolveMatches (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    parseResolveMatches (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseResolveMatches (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    parseResolveMatches (::xercesc::InputSource& i,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > (
        ::WS::DISCOVERY::parseResolveMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    parseResolveMatches (::xercesc::InputSource& i,
                         ::xml_schema::ErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > (
        ::WS::DISCOVERY::parseResolveMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    parseResolveMatches (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > (
        ::WS::DISCOVERY::parseResolveMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    parseResolveMatches (const ::xercesc::DOMDocument& doc,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > (
          ::WS::DISCOVERY::parseResolveMatches (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ResolveMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ResolveMatchesType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > r (
          dynamic_cast< ::WS::DISCOVERY::ResolveMatchesType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ResolveMatches",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    parseResolveMatches (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ResolveMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ResolveMatchesType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > r (
          dynamic_cast< ::WS::DISCOVERY::ResolveMatchesType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ResolveMatches",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    parseTypes (const ::std::string& u,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > (
        ::WS::DISCOVERY::parseTypes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    parseTypes (const ::std::string& u,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > (
        ::WS::DISCOVERY::parseTypes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    parseTypes (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > (
        ::WS::DISCOVERY::parseTypes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    parseTypes (::std::istream& is,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseTypes (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    parseTypes (::std::istream& is,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseTypes (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    parseTypes (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseTypes (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    parseTypes (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseTypes (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    parseTypes (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseTypes (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    parseTypes (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseTypes (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    parseTypes (::xercesc::InputSource& i,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > (
        ::WS::DISCOVERY::parseTypes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    parseTypes (::xercesc::InputSource& i,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > (
        ::WS::DISCOVERY::parseTypes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    parseTypes (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > (
        ::WS::DISCOVERY::parseTypes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    parseTypes (const ::xercesc::DOMDocument& doc,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > (
          ::WS::DISCOVERY::parseTypes (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Types",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::QNameListType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > r (
          dynamic_cast< ::WS::DISCOVERY::QNameListType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Types",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    parseTypes (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Types",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::QNameListType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > r (
          dynamic_cast< ::WS::DISCOVERY::QNameListType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Types",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    parseScopes (const ::std::string& u,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > (
        ::WS::DISCOVERY::parseScopes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    parseScopes (const ::std::string& u,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > (
        ::WS::DISCOVERY::parseScopes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    parseScopes (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > (
        ::WS::DISCOVERY::parseScopes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    parseScopes (::std::istream& is,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseScopes (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    parseScopes (::std::istream& is,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseScopes (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    parseScopes (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseScopes (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    parseScopes (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseScopes (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    parseScopes (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseScopes (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    parseScopes (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseScopes (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    parseScopes (::xercesc::InputSource& i,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > (
        ::WS::DISCOVERY::parseScopes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    parseScopes (::xercesc::InputSource& i,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > (
        ::WS::DISCOVERY::parseScopes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    parseScopes (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > (
        ::WS::DISCOVERY::parseScopes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    parseScopes (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > (
          ::WS::DISCOVERY::parseScopes (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Scopes",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ScopesType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > r (
          dynamic_cast< ::WS::DISCOVERY::ScopesType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Scopes",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    parseScopes (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Scopes",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ScopesType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > r (
          dynamic_cast< ::WS::DISCOVERY::ScopesType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Scopes",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseXAddrs (const ::std::string& u,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::parseXAddrs (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseXAddrs (const ::std::string& u,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::parseXAddrs (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseXAddrs (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::parseXAddrs (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseXAddrs (::std::istream& is,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseXAddrs (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseXAddrs (::std::istream& is,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseXAddrs (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseXAddrs (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseXAddrs (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseXAddrs (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseXAddrs (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseXAddrs (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseXAddrs (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseXAddrs (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseXAddrs (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseXAddrs (::xercesc::InputSource& i,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::parseXAddrs (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseXAddrs (::xercesc::InputSource& i,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::parseXAddrs (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseXAddrs (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::parseXAddrs (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseXAddrs (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
          ::WS::DISCOVERY::parseXAddrs (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "XAddrs",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::UriListType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::UriListType > r (
          dynamic_cast< ::WS::DISCOVERY::UriListType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "XAddrs",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseXAddrs (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "XAddrs",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::UriListType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::UriListType > r (
          dynamic_cast< ::WS::DISCOVERY::UriListType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "XAddrs",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    parseMetadataVersion (const ::std::string& u,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::xml_schema::UnsignedInt > (
        ::WS::DISCOVERY::parseMetadataVersion (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    parseMetadataVersion (const ::std::string& u,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::xml_schema::UnsignedInt > (
        ::WS::DISCOVERY::parseMetadataVersion (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    parseMetadataVersion (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::xml_schema::UnsignedInt > (
        ::WS::DISCOVERY::parseMetadataVersion (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    parseMetadataVersion (::std::istream& is,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseMetadataVersion (isrc, f, p);
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    parseMetadataVersion (::std::istream& is,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseMetadataVersion (isrc, h, f, p);
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    parseMetadataVersion (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseMetadataVersion (isrc, h, f, p);
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    parseMetadataVersion (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseMetadataVersion (isrc, f, p);
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    parseMetadataVersion (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseMetadataVersion (isrc, h, f, p);
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    parseMetadataVersion (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseMetadataVersion (isrc, h, f, p);
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    parseMetadataVersion (::xercesc::InputSource& i,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::xml_schema::UnsignedInt > (
        ::WS::DISCOVERY::parseMetadataVersion (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    parseMetadataVersion (::xercesc::InputSource& i,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::xml_schema::UnsignedInt > (
        ::WS::DISCOVERY::parseMetadataVersion (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    parseMetadataVersion (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::xml_schema::UnsignedInt > (
        ::WS::DISCOVERY::parseMetadataVersion (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    parseMetadataVersion (const ::xercesc::DOMDocument& doc,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::xml_schema::UnsignedInt > (
          ::WS::DISCOVERY::parseMetadataVersion (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "MetadataVersion" &&
          n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
      {
        ::std::unique_ptr< ::xml_schema::UnsignedInt > r (
          new ::xml_schema::UnsignedInt (
            ::xsd::cxx::tree::traits< ::xml_schema::UnsignedInt, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "MetadataVersion",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    parseMetadataVersion (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "MetadataVersion" &&
          n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
      {
        ::std::unique_ptr< ::xml_schema::UnsignedInt > r (
          new ::xml_schema::UnsignedInt (
            ::xsd::cxx::tree::traits< ::xml_schema::UnsignedInt, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "MetadataVersion",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseSupportedMatchingRules (const ::std::string& u,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::parseSupportedMatchingRules (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseSupportedMatchingRules (const ::std::string& u,
                                 ::xml_schema::ErrorHandler& h,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::parseSupportedMatchingRules (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseSupportedMatchingRules (const ::std::string& u,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::parseSupportedMatchingRules (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseSupportedMatchingRules (::std::istream& is,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseSupportedMatchingRules (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseSupportedMatchingRules (::std::istream& is,
                                 ::xml_schema::ErrorHandler& h,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseSupportedMatchingRules (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseSupportedMatchingRules (::std::istream& is,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseSupportedMatchingRules (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseSupportedMatchingRules (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseSupportedMatchingRules (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseSupportedMatchingRules (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::ErrorHandler& h,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseSupportedMatchingRules (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseSupportedMatchingRules (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseSupportedMatchingRules (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseSupportedMatchingRules (::xercesc::InputSource& i,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::parseSupportedMatchingRules (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseSupportedMatchingRules (::xercesc::InputSource& i,
                                 ::xml_schema::ErrorHandler& h,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::parseSupportedMatchingRules (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseSupportedMatchingRules (::xercesc::InputSource& i,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::parseSupportedMatchingRules (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseSupportedMatchingRules (const ::xercesc::DOMDocument& doc,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
          ::WS::DISCOVERY::parseSupportedMatchingRules (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "SupportedMatchingRules",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::UriListType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::UriListType > r (
          dynamic_cast< ::WS::DISCOVERY::UriListType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SupportedMatchingRules",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    parseSupportedMatchingRules (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "SupportedMatchingRules",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::UriListType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::UriListType > r (
          dynamic_cast< ::WS::DISCOVERY::UriListType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SupportedMatchingRules",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    parseSecurity (const ::std::string& u,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > (
        ::WS::DISCOVERY::parseSecurity (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    parseSecurity (const ::std::string& u,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > (
        ::WS::DISCOVERY::parseSecurity (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    parseSecurity (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > (
        ::WS::DISCOVERY::parseSecurity (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    parseSecurity (::std::istream& is,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseSecurity (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    parseSecurity (::std::istream& is,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseSecurity (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    parseSecurity (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseSecurity (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    parseSecurity (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseSecurity (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    parseSecurity (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseSecurity (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    parseSecurity (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseSecurity (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    parseSecurity (::xercesc::InputSource& i,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > (
        ::WS::DISCOVERY::parseSecurity (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    parseSecurity (::xercesc::InputSource& i,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > (
        ::WS::DISCOVERY::parseSecurity (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    parseSecurity (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > (
        ::WS::DISCOVERY::parseSecurity (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    parseSecurity (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > (
          ::WS::DISCOVERY::parseSecurity (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Security",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::SecurityType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > r (
          dynamic_cast< ::WS::DISCOVERY::SecurityType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Security",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    parseSecurity (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Security",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::SecurityType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > r (
          dynamic_cast< ::WS::DISCOVERY::SecurityType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Security",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    parseSig (const ::std::string& u,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SigType > (
        ::WS::DISCOVERY::parseSig (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    parseSig (const ::std::string& u,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SigType > (
        ::WS::DISCOVERY::parseSig (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    parseSig (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SigType > (
        ::WS::DISCOVERY::parseSig (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    parseSig (::std::istream& is,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseSig (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    parseSig (::std::istream& is,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseSig (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    parseSig (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseSig (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    parseSig (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseSig (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    parseSig (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseSig (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    parseSig (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseSig (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    parseSig (::xercesc::InputSource& i,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SigType > (
        ::WS::DISCOVERY::parseSig (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    parseSig (::xercesc::InputSource& i,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SigType > (
        ::WS::DISCOVERY::parseSig (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    parseSig (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SigType > (
        ::WS::DISCOVERY::parseSig (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    parseSig (const ::xercesc::DOMDocument& doc,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::SigType > (
          ::WS::DISCOVERY::parseSig (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Sig",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::SigType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::SigType > r (
          dynamic_cast< ::WS::DISCOVERY::SigType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Sig",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    parseSig (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Sig",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::SigType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::SigType > r (
          dynamic_cast< ::WS::DISCOVERY::SigType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Sig",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    parseAppSequence (const ::std::string& u,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > (
        ::WS::DISCOVERY::parseAppSequence (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    parseAppSequence (const ::std::string& u,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > (
        ::WS::DISCOVERY::parseAppSequence (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    parseAppSequence (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > (
        ::WS::DISCOVERY::parseAppSequence (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    parseAppSequence (::std::istream& is,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseAppSequence (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    parseAppSequence (::std::istream& is,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseAppSequence (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    parseAppSequence (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::parseAppSequence (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    parseAppSequence (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseAppSequence (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    parseAppSequence (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseAppSequence (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    parseAppSequence (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::parseAppSequence (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    parseAppSequence (::xercesc::InputSource& i,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > (
        ::WS::DISCOVERY::parseAppSequence (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    parseAppSequence (::xercesc::InputSource& i,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > (
        ::WS::DISCOVERY::parseAppSequence (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    parseAppSequence (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > (
        ::WS::DISCOVERY::parseAppSequence (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    parseAppSequence (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > (
          ::WS::DISCOVERY::parseAppSequence (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "AppSequence",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::AppSequenceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > r (
          dynamic_cast< ::WS::DISCOVERY::AppSequenceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AppSequence",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    parseAppSequence (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "AppSequence",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::AppSequenceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > r (
          dynamic_cast< ::WS::DISCOVERY::AppSequenceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AppSequence",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace WS
{
  namespace DISCOVERY
  {
    void
    serializeHello (::std::ostream& o,
                    const ::WS::DISCOVERY::HelloType& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeHello (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeHello (::std::ostream& o,
                    const ::WS::DISCOVERY::HelloType& s,
                    ::xml_schema::ErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeHello (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeHello (::std::ostream& o,
                    const ::WS::DISCOVERY::HelloType& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeHello (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeHello (::xercesc::XMLFormatTarget& t,
                    const ::WS::DISCOVERY::HelloType& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeHello (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeHello (::xercesc::XMLFormatTarget& t,
                    const ::WS::DISCOVERY::HelloType& s,
                    ::xml_schema::ErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeHello (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeHello (::xercesc::XMLFormatTarget& t,
                    const ::WS::DISCOVERY::HelloType& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeHello (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeHello (::xercesc::DOMDocument& d,
                    const ::WS::DISCOVERY::HelloType& s,
                    ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::HelloType) == typeid (s))
      {
        if (n.name () == "Hello" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Hello",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Hello",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeHello (const ::WS::DISCOVERY::HelloType& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::HelloType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Hello",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Hello",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::serializeHello (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const HelloType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const HelloType::EndpointReferenceType& x (i.getEndpointReference ());
        if (typeid (HelloType::EndpointReferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EndpointReference",
            "http://www.w3.org/2005/08/addressing",
            true, true, e, x);
      }

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getTypes ())
        {
          const HelloType::TypesType& x (*i.getTypes ());
          if (typeid (HelloType::TypesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Types",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // Scopes
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getScopes ())
        {
          const HelloType::ScopesType& x (*i.getScopes ());
          if (typeid (HelloType::ScopesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Scopes",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // XAddrs
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getXAddrs ())
        {
          const HelloType::XAddrsType& x (*i.getXAddrs ());
          if (typeid (HelloType::XAddrsType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "XAddrs",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // MetadataVersion
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MetadataVersion",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
            e));

        s << i.getMetadataVersion ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, HelloType >
    _xsd_HelloType_type_serializer_init (
      "HelloType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    serializeBye (::std::ostream& o,
                  const ::WS::DISCOVERY::ByeType& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeBye (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeBye (::std::ostream& o,
                  const ::WS::DISCOVERY::ByeType& s,
                  ::xml_schema::ErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeBye (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeBye (::std::ostream& o,
                  const ::WS::DISCOVERY::ByeType& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeBye (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeBye (::xercesc::XMLFormatTarget& t,
                  const ::WS::DISCOVERY::ByeType& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeBye (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeBye (::xercesc::XMLFormatTarget& t,
                  const ::WS::DISCOVERY::ByeType& s,
                  ::xml_schema::ErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeBye (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeBye (::xercesc::XMLFormatTarget& t,
                  const ::WS::DISCOVERY::ByeType& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeBye (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeBye (::xercesc::DOMDocument& d,
                  const ::WS::DISCOVERY::ByeType& s,
                  ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::ByeType) == typeid (s))
      {
        if (n.name () == "Bye" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Bye",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Bye",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeBye (const ::WS::DISCOVERY::ByeType& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::ByeType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Bye",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Bye",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::serializeBye (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const ByeType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ByeType::EndpointReferenceType& x (i.getEndpointReference ());
        if (typeid (ByeType::EndpointReferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EndpointReference",
            "http://www.w3.org/2005/08/addressing",
            true, true, e, x);
      }

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getTypes ())
        {
          const ByeType::TypesType& x (*i.getTypes ());
          if (typeid (ByeType::TypesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Types",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // Scopes
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getScopes ())
        {
          const ByeType::ScopesType& x (*i.getScopes ());
          if (typeid (ByeType::ScopesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Scopes",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // XAddrs
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getXAddrs ())
        {
          const ByeType::XAddrsType& x (*i.getXAddrs ());
          if (typeid (ByeType::XAddrsType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "XAddrs",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // MetadataVersion
      //
      if (i.getMetadataVersion ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MetadataVersion",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
            e));

        s << *i.getMetadataVersion ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ByeType >
    _xsd_ByeType_type_serializer_init (
      "ByeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    serializeProbe (::std::ostream& o,
                    const ::WS::DISCOVERY::ProbeType& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeProbe (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeProbe (::std::ostream& o,
                    const ::WS::DISCOVERY::ProbeType& s,
                    ::xml_schema::ErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeProbe (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeProbe (::std::ostream& o,
                    const ::WS::DISCOVERY::ProbeType& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeProbe (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeProbe (::xercesc::XMLFormatTarget& t,
                    const ::WS::DISCOVERY::ProbeType& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeProbe (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeProbe (::xercesc::XMLFormatTarget& t,
                    const ::WS::DISCOVERY::ProbeType& s,
                    ::xml_schema::ErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeProbe (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeProbe (::xercesc::XMLFormatTarget& t,
                    const ::WS::DISCOVERY::ProbeType& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeProbe (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeProbe (::xercesc::DOMDocument& d,
                    const ::WS::DISCOVERY::ProbeType& s,
                    ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::ProbeType) == typeid (s))
      {
        if (n.name () == "Probe" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Probe",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Probe",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeProbe (const ::WS::DISCOVERY::ProbeType& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::ProbeType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Probe",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Probe",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::serializeProbe (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const ProbeType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getTypes ())
        {
          const ProbeType::TypesType& x (*i.getTypes ());
          if (typeid (ProbeType::TypesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Types",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // Scopes
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getScopes ())
        {
          const ProbeType::ScopesType& x (*i.getScopes ());
          if (typeid (ProbeType::ScopesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Scopes",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ProbeType >
    _xsd_ProbeType_type_serializer_init (
      "ProbeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    serializeProbeMatches (::std::ostream& o,
                           const ::WS::DISCOVERY::ProbeMatchesType& s,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeProbeMatches (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeProbeMatches (::std::ostream& o,
                           const ::WS::DISCOVERY::ProbeMatchesType& s,
                           ::xml_schema::ErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeProbeMatches (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeProbeMatches (::std::ostream& o,
                           const ::WS::DISCOVERY::ProbeMatchesType& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeProbeMatches (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeProbeMatches (::xercesc::XMLFormatTarget& t,
                           const ::WS::DISCOVERY::ProbeMatchesType& s,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeProbeMatches (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeProbeMatches (::xercesc::XMLFormatTarget& t,
                           const ::WS::DISCOVERY::ProbeMatchesType& s,
                           ::xml_schema::ErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeProbeMatches (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeProbeMatches (::xercesc::XMLFormatTarget& t,
                           const ::WS::DISCOVERY::ProbeMatchesType& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeProbeMatches (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeProbeMatches (::xercesc::DOMDocument& d,
                           const ::WS::DISCOVERY::ProbeMatchesType& s,
                           ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::ProbeMatchesType) == typeid (s))
      {
        if (n.name () == "ProbeMatches" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "ProbeMatches",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ProbeMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeProbeMatches (const ::WS::DISCOVERY::ProbeMatchesType& s,
                           const ::xml_schema::NamespaceInfomap& m,
                           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::ProbeMatchesType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "ProbeMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ProbeMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::serializeProbeMatches (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const ProbeMatchesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // ProbeMatch
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (ProbeMatchesType::ProbeMatchConstIterator
             b (i.getProbeMatch ().begin ()), n (i.getProbeMatch ().end ());
             b != n; ++b)
        {
          if (typeid (ProbeMatchesType::ProbeMatchType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ProbeMatch",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "ProbeMatch",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              false, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ProbeMatchesType >
    _xsd_ProbeMatchesType_type_serializer_init (
      "ProbeMatchesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const ProbeMatchType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ProbeMatchType::EndpointReferenceType& x (i.getEndpointReference ());
        if (typeid (ProbeMatchType::EndpointReferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EndpointReference",
            "http://www.w3.org/2005/08/addressing",
            true, true, e, x);
      }

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getTypes ())
        {
          const ProbeMatchType::TypesType& x (*i.getTypes ());
          if (typeid (ProbeMatchType::TypesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Types",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // Scopes
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getScopes ())
        {
          const ProbeMatchType::ScopesType& x (*i.getScopes ());
          if (typeid (ProbeMatchType::ScopesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Scopes",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // XAddrs
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getXAddrs ())
        {
          const ProbeMatchType::XAddrsType& x (*i.getXAddrs ());
          if (typeid (ProbeMatchType::XAddrsType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "XAddrs",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // MetadataVersion
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MetadataVersion",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
            e));

        s << i.getMetadataVersion ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ProbeMatchType >
    _xsd_ProbeMatchType_type_serializer_init (
      "ProbeMatchType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    serializeResolve (::std::ostream& o,
                      const ::WS::DISCOVERY::ResolveType& s,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeResolve (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeResolve (::std::ostream& o,
                      const ::WS::DISCOVERY::ResolveType& s,
                      ::xml_schema::ErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeResolve (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeResolve (::std::ostream& o,
                      const ::WS::DISCOVERY::ResolveType& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeResolve (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeResolve (::xercesc::XMLFormatTarget& t,
                      const ::WS::DISCOVERY::ResolveType& s,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeResolve (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeResolve (::xercesc::XMLFormatTarget& t,
                      const ::WS::DISCOVERY::ResolveType& s,
                      ::xml_schema::ErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeResolve (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeResolve (::xercesc::XMLFormatTarget& t,
                      const ::WS::DISCOVERY::ResolveType& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeResolve (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeResolve (::xercesc::DOMDocument& d,
                      const ::WS::DISCOVERY::ResolveType& s,
                      ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::ResolveType) == typeid (s))
      {
        if (n.name () == "Resolve" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Resolve",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Resolve",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeResolve (const ::WS::DISCOVERY::ResolveType& s,
                      const ::xml_schema::NamespaceInfomap& m,
                      ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::ResolveType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Resolve",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Resolve",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::serializeResolve (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const ResolveType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ResolveType::EndpointReferenceType& x (i.getEndpointReference ());
        if (typeid (ResolveType::EndpointReferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EndpointReference",
            "http://www.w3.org/2005/08/addressing",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ResolveType >
    _xsd_ResolveType_type_serializer_init (
      "ResolveType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    serializeResolveMatches (::std::ostream& o,
                             const ::WS::DISCOVERY::ResolveMatchesType& s,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeResolveMatches (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeResolveMatches (::std::ostream& o,
                             const ::WS::DISCOVERY::ResolveMatchesType& s,
                             ::xml_schema::ErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeResolveMatches (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeResolveMatches (::std::ostream& o,
                             const ::WS::DISCOVERY::ResolveMatchesType& s,
                             ::xercesc::DOMErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeResolveMatches (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeResolveMatches (::xercesc::XMLFormatTarget& t,
                             const ::WS::DISCOVERY::ResolveMatchesType& s,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeResolveMatches (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeResolveMatches (::xercesc::XMLFormatTarget& t,
                             const ::WS::DISCOVERY::ResolveMatchesType& s,
                             ::xml_schema::ErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeResolveMatches (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeResolveMatches (::xercesc::XMLFormatTarget& t,
                             const ::WS::DISCOVERY::ResolveMatchesType& s,
                             ::xercesc::DOMErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeResolveMatches (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeResolveMatches (::xercesc::DOMDocument& d,
                             const ::WS::DISCOVERY::ResolveMatchesType& s,
                             ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::ResolveMatchesType) == typeid (s))
      {
        if (n.name () == "ResolveMatches" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "ResolveMatches",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ResolveMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeResolveMatches (const ::WS::DISCOVERY::ResolveMatchesType& s,
                             const ::xml_schema::NamespaceInfomap& m,
                             ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::ResolveMatchesType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "ResolveMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ResolveMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::serializeResolveMatches (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const ResolveMatchesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // ResolveMatch
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getResolveMatch ())
        {
          const ResolveMatchesType::ResolveMatchType& x (*i.getResolveMatch ());
          if (typeid (ResolveMatchesType::ResolveMatchType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ResolveMatch",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "ResolveMatch",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              false, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ResolveMatchesType >
    _xsd_ResolveMatchesType_type_serializer_init (
      "ResolveMatchesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const ResolveMatchType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ResolveMatchType::EndpointReferenceType& x (i.getEndpointReference ());
        if (typeid (ResolveMatchType::EndpointReferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EndpointReference",
            "http://www.w3.org/2005/08/addressing",
            true, true, e, x);
      }

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getTypes ())
        {
          const ResolveMatchType::TypesType& x (*i.getTypes ());
          if (typeid (ResolveMatchType::TypesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Types",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // Scopes
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getScopes ())
        {
          const ResolveMatchType::ScopesType& x (*i.getScopes ());
          if (typeid (ResolveMatchType::ScopesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Scopes",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // XAddrs
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getXAddrs ())
        {
          const ResolveMatchType::XAddrsType& x (*i.getXAddrs ());
          if (typeid (ResolveMatchType::XAddrsType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "XAddrs",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // MetadataVersion
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MetadataVersion",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
            e));

        s << i.getMetadataVersion ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ResolveMatchType >
    _xsd_ResolveMatchType_type_serializer_init (
      "ResolveMatchType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    serializeTypes (::std::ostream& o,
                    const ::WS::DISCOVERY::QNameListType& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeTypes (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeTypes (::std::ostream& o,
                    const ::WS::DISCOVERY::QNameListType& s,
                    ::xml_schema::ErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeTypes (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeTypes (::std::ostream& o,
                    const ::WS::DISCOVERY::QNameListType& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeTypes (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeTypes (::xercesc::XMLFormatTarget& t,
                    const ::WS::DISCOVERY::QNameListType& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeTypes (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeTypes (::xercesc::XMLFormatTarget& t,
                    const ::WS::DISCOVERY::QNameListType& s,
                    ::xml_schema::ErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeTypes (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeTypes (::xercesc::XMLFormatTarget& t,
                    const ::WS::DISCOVERY::QNameListType& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeTypes (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeTypes (::xercesc::DOMDocument& d,
                    const ::WS::DISCOVERY::QNameListType& s,
                    ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::QNameListType) == typeid (s))
      {
        if (n.name () == "Types" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Types",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Types",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeTypes (const ::WS::DISCOVERY::QNameListType& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::QNameListType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Types",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Types",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::serializeTypes (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const QNameListType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Qname, char >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const QNameListType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Qname, char >& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const QNameListType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Qname, char >& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, QNameListType >
    _xsd_QNameListType_type_serializer_init (
      "QNameListType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    serializeScopes (::std::ostream& o,
                     const ::WS::DISCOVERY::ScopesType& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeScopes (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeScopes (::std::ostream& o,
                     const ::WS::DISCOVERY::ScopesType& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeScopes (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeScopes (::std::ostream& o,
                     const ::WS::DISCOVERY::ScopesType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeScopes (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeScopes (::xercesc::XMLFormatTarget& t,
                     const ::WS::DISCOVERY::ScopesType& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeScopes (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeScopes (::xercesc::XMLFormatTarget& t,
                     const ::WS::DISCOVERY::ScopesType& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeScopes (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeScopes (::xercesc::XMLFormatTarget& t,
                     const ::WS::DISCOVERY::ScopesType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeScopes (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeScopes (::xercesc::DOMDocument& d,
                     const ::WS::DISCOVERY::ScopesType& s,
                     ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::ScopesType) == typeid (s))
      {
        if (n.name () == "Scopes" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Scopes",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Scopes",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeScopes (const ::WS::DISCOVERY::ScopesType& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::ScopesType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Scopes",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Scopes",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::serializeScopes (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const UriListType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Uri, char >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const UriListType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Uri, char >& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const UriListType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Uri, char >& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, UriListType >
    _xsd_UriListType_type_serializer_init (
      "UriListType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const ScopesType& i)
    {
      e << static_cast< const ::WS::DISCOVERY::UriListType& > (i);

      // MatchBy
      //
      if (i.getMatchBy ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "MatchBy",
            e));

        a << *i.getMatchBy ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ScopesType >
    _xsd_ScopesType_type_serializer_init (
      "ScopesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    serializeXAddrs (::std::ostream& o,
                     const ::WS::DISCOVERY::UriListType& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeXAddrs (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeXAddrs (::std::ostream& o,
                     const ::WS::DISCOVERY::UriListType& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeXAddrs (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeXAddrs (::std::ostream& o,
                     const ::WS::DISCOVERY::UriListType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeXAddrs (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeXAddrs (::xercesc::XMLFormatTarget& t,
                     const ::WS::DISCOVERY::UriListType& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeXAddrs (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeXAddrs (::xercesc::XMLFormatTarget& t,
                     const ::WS::DISCOVERY::UriListType& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeXAddrs (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeXAddrs (::xercesc::XMLFormatTarget& t,
                     const ::WS::DISCOVERY::UriListType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeXAddrs (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeXAddrs (::xercesc::DOMDocument& d,
                     const ::WS::DISCOVERY::UriListType& s,
                     ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::UriListType) == typeid (s))
      {
        if (n.name () == "XAddrs" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "XAddrs",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "XAddrs",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeXAddrs (const ::WS::DISCOVERY::UriListType& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::UriListType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "XAddrs",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "XAddrs",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::serializeXAddrs (*d, s, f);
      return d;
    }

    void
    serializeMetadataVersion (::std::ostream& o,
                              const ::xml_schema::UnsignedInt& s,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeMetadataVersion (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeMetadataVersion (::std::ostream& o,
                              const ::xml_schema::UnsignedInt& s,
                              ::xml_schema::ErrorHandler& h,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeMetadataVersion (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeMetadataVersion (::std::ostream& o,
                              const ::xml_schema::UnsignedInt& s,
                              ::xercesc::DOMErrorHandler& h,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeMetadataVersion (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeMetadataVersion (::xercesc::XMLFormatTarget& t,
                              const ::xml_schema::UnsignedInt& s,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeMetadataVersion (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeMetadataVersion (::xercesc::XMLFormatTarget& t,
                              const ::xml_schema::UnsignedInt& s,
                              ::xml_schema::ErrorHandler& h,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeMetadataVersion (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeMetadataVersion (::xercesc::XMLFormatTarget& t,
                              const ::xml_schema::UnsignedInt& s,
                              ::xercesc::DOMErrorHandler& h,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeMetadataVersion (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeMetadataVersion (::xercesc::DOMDocument& d,
                              const ::xml_schema::UnsignedInt& s,
                              ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "MetadataVersion" &&
          n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "MetadataVersion",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeMetadataVersion (const ::xml_schema::UnsignedInt& s,
                              const ::xml_schema::NamespaceInfomap& m,
                              ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "MetadataVersion",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f));

      ::WS::DISCOVERY::serializeMetadataVersion (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const FaultCodeType& i)
    {
      e << static_cast< const ::xml_schema::Qname& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const FaultCodeType& i)
    {
      a << static_cast< const ::xml_schema::Qname& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const FaultCodeType& i)
    {
      l << static_cast< const ::xml_schema::Qname& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FaultCodeType >
    _xsd_FaultCodeType_type_serializer_init (
      "FaultCodeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const FaultCodeOpenType& i)
    {
      e << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const FaultCodeOpenType& i)
    {
      a << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const FaultCodeOpenType& i)
    {
      l << static_cast< const ::xml_schema::String& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FaultCodeOpenType >
    _xsd_FaultCodeOpenType_type_serializer_init (
      "FaultCodeOpenType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    serializeSupportedMatchingRules (::std::ostream& o,
                                     const ::WS::DISCOVERY::UriListType& s,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSupportedMatchingRules (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeSupportedMatchingRules (::std::ostream& o,
                                     const ::WS::DISCOVERY::UriListType& s,
                                     ::xml_schema::ErrorHandler& h,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSupportedMatchingRules (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeSupportedMatchingRules (::std::ostream& o,
                                     const ::WS::DISCOVERY::UriListType& s,
                                     ::xercesc::DOMErrorHandler& h,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSupportedMatchingRules (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeSupportedMatchingRules (::xercesc::XMLFormatTarget& t,
                                     const ::WS::DISCOVERY::UriListType& s,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSupportedMatchingRules (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeSupportedMatchingRules (::xercesc::XMLFormatTarget& t,
                                     const ::WS::DISCOVERY::UriListType& s,
                                     ::xml_schema::ErrorHandler& h,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSupportedMatchingRules (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeSupportedMatchingRules (::xercesc::XMLFormatTarget& t,
                                     const ::WS::DISCOVERY::UriListType& s,
                                     ::xercesc::DOMErrorHandler& h,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSupportedMatchingRules (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeSupportedMatchingRules (::xercesc::DOMDocument& d,
                                     const ::WS::DISCOVERY::UriListType& s,
                                     ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::UriListType) == typeid (s))
      {
        if (n.name () == "SupportedMatchingRules" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "SupportedMatchingRules",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "SupportedMatchingRules",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeSupportedMatchingRules (const ::WS::DISCOVERY::UriListType& s,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::UriListType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "SupportedMatchingRules",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "SupportedMatchingRules",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::serializeSupportedMatchingRules (*d, s, f);
      return d;
    }

    void
    serializeSecurity (::std::ostream& o,
                       const ::WS::DISCOVERY::SecurityType& s,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSecurity (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeSecurity (::std::ostream& o,
                       const ::WS::DISCOVERY::SecurityType& s,
                       ::xml_schema::ErrorHandler& h,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSecurity (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeSecurity (::std::ostream& o,
                       const ::WS::DISCOVERY::SecurityType& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSecurity (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeSecurity (::xercesc::XMLFormatTarget& t,
                       const ::WS::DISCOVERY::SecurityType& s,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSecurity (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeSecurity (::xercesc::XMLFormatTarget& t,
                       const ::WS::DISCOVERY::SecurityType& s,
                       ::xml_schema::ErrorHandler& h,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSecurity (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeSecurity (::xercesc::XMLFormatTarget& t,
                       const ::WS::DISCOVERY::SecurityType& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSecurity (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeSecurity (::xercesc::DOMDocument& d,
                       const ::WS::DISCOVERY::SecurityType& s,
                       ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::SecurityType) == typeid (s))
      {
        if (n.name () == "Security" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Security",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Security",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeSecurity (const ::WS::DISCOVERY::SecurityType& s,
                       const ::xml_schema::NamespaceInfomap& m,
                       ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::SecurityType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Security",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Security",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::serializeSecurity (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const SecurityType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Sig
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getSig ())
        {
          const SecurityType::SigType& x (*i.getSig ());
          if (typeid (SecurityType::SigType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Sig",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Sig",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SecurityType >
    _xsd_SecurityType_type_serializer_init (
      "SecurityType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    serializeSig (::std::ostream& o,
                  const ::WS::DISCOVERY::SigType& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSig (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeSig (::std::ostream& o,
                  const ::WS::DISCOVERY::SigType& s,
                  ::xml_schema::ErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSig (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeSig (::std::ostream& o,
                  const ::WS::DISCOVERY::SigType& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSig (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeSig (::xercesc::XMLFormatTarget& t,
                  const ::WS::DISCOVERY::SigType& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSig (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeSig (::xercesc::XMLFormatTarget& t,
                  const ::WS::DISCOVERY::SigType& s,
                  ::xml_schema::ErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSig (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeSig (::xercesc::XMLFormatTarget& t,
                  const ::WS::DISCOVERY::SigType& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeSig (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeSig (::xercesc::DOMDocument& d,
                  const ::WS::DISCOVERY::SigType& s,
                  ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::SigType) == typeid (s))
      {
        if (n.name () == "Sig" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Sig",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Sig",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeSig (const ::WS::DISCOVERY::SigType& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::SigType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Sig",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Sig",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::serializeSig (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const SigType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Scheme
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Scheme",
            e));

        a << i.getScheme ();
      }

      // KeyId
      //
      if (i.getKeyId ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "KeyId",
            e));

        a << *i.getKeyId ();
      }

      // Refs
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Refs",
            e));

        a << i.getRefs ();
      }

      // Sig
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Sig",
            e));

        a << i.getSig ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SigType >
    _xsd_SigType_type_serializer_init (
      "SigType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    serializeAppSequence (::std::ostream& o,
                          const ::WS::DISCOVERY::AppSequenceType& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeAppSequence (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeAppSequence (::std::ostream& o,
                          const ::WS::DISCOVERY::AppSequenceType& s,
                          ::xml_schema::ErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeAppSequence (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeAppSequence (::std::ostream& o,
                          const ::WS::DISCOVERY::AppSequenceType& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeAppSequence (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeAppSequence (::xercesc::XMLFormatTarget& t,
                          const ::WS::DISCOVERY::AppSequenceType& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeAppSequence (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    serializeAppSequence (::xercesc::XMLFormatTarget& t,
                          const ::WS::DISCOVERY::AppSequenceType& s,
                          ::xml_schema::ErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeAppSequence (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeAppSequence (::xercesc::XMLFormatTarget& t,
                          const ::WS::DISCOVERY::AppSequenceType& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::serializeAppSequence (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    serializeAppSequence (::xercesc::DOMDocument& d,
                          const ::WS::DISCOVERY::AppSequenceType& s,
                          ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::AppSequenceType) == typeid (s))
      {
        if (n.name () == "AppSequence" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "AppSequence",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "AppSequence",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    serializeAppSequence (const ::WS::DISCOVERY::AppSequenceType& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::AppSequenceType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "AppSequence",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "AppSequence",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::serializeAppSequence (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const AppSequenceType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // InstanceId
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "InstanceId",
            e));

        a << i.getInstanceId ();
      }

      // SequenceId
      //
      if (i.getSequenceId ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "SequenceId",
            e));

        a << *i.getSequenceId ();
      }

      // MessageNumber
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "MessageNumber",
            e));

        a << i.getMessageNumber ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AppSequenceType >
    _xsd_AppSequenceType_type_serializer_init (
      "AppSequenceType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

