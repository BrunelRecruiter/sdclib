// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "DataModel/wsdd-discovery-1.1-schema-os.hxx"

namespace WS
{
  namespace DISCOVERY
  {
    // HelloType
    // 

    const HelloType::EndpointReferenceType& HelloType::
    getEndpointReference () const
    {
      return this->EndpointReference_.get ();
    }

    HelloType::EndpointReferenceType& HelloType::
    getEndpointReference ()
    {
      return this->EndpointReference_.get ();
    }

    void HelloType::
    setEndpointReference (const EndpointReferenceType& x)
    {
      this->EndpointReference_.set (x);
    }

    void HelloType::
    setEndpointReference (::std::unique_ptr< EndpointReferenceType > x)
    {
      this->EndpointReference_.set (std::move (x));
    }

    const HelloType::TypesOptional& HelloType::
    getTypes () const
    {
      return this->Types_;
    }

    HelloType::TypesOptional& HelloType::
    getTypes ()
    {
      return this->Types_;
    }

    void HelloType::
    setTypes (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void HelloType::
    setTypes (const TypesOptional& x)
    {
      this->Types_ = x;
    }

    void HelloType::
    setTypes (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }

    const HelloType::ScopesOptional& HelloType::
    getScopes () const
    {
      return this->Scopes_;
    }

    HelloType::ScopesOptional& HelloType::
    getScopes ()
    {
      return this->Scopes_;
    }

    void HelloType::
    setScopes (const ScopesType& x)
    {
      this->Scopes_.set (x);
    }

    void HelloType::
    setScopes (const ScopesOptional& x)
    {
      this->Scopes_ = x;
    }

    void HelloType::
    setScopes (::std::unique_ptr< ScopesType > x)
    {
      this->Scopes_.set (std::move (x));
    }

    const HelloType::XAddrsOptional& HelloType::
    getXAddrs () const
    {
      return this->XAddrs_;
    }

    HelloType::XAddrsOptional& HelloType::
    getXAddrs ()
    {
      return this->XAddrs_;
    }

    void HelloType::
    setXAddrs (const XAddrsType& x)
    {
      this->XAddrs_.set (x);
    }

    void HelloType::
    setXAddrs (const XAddrsOptional& x)
    {
      this->XAddrs_ = x;
    }

    void HelloType::
    setXAddrs (::std::unique_ptr< XAddrsType > x)
    {
      this->XAddrs_.set (std::move (x));
    }

    const HelloType::MetadataVersionType& HelloType::
    getMetadataVersion () const
    {
      return this->MetadataVersion_.get ();
    }

    HelloType::MetadataVersionType& HelloType::
    getMetadataVersion ()
    {
      return this->MetadataVersion_.get ();
    }

    void HelloType::
    setMetadataVersion (const MetadataVersionType& x)
    {
      this->MetadataVersion_.set (x);
    }


    // ByeType
    // 

    const ByeType::EndpointReferenceType& ByeType::
    getEndpointReference () const
    {
      return this->EndpointReference_.get ();
    }

    ByeType::EndpointReferenceType& ByeType::
    getEndpointReference ()
    {
      return this->EndpointReference_.get ();
    }

    void ByeType::
    setEndpointReference (const EndpointReferenceType& x)
    {
      this->EndpointReference_.set (x);
    }

    void ByeType::
    setEndpointReference (::std::unique_ptr< EndpointReferenceType > x)
    {
      this->EndpointReference_.set (std::move (x));
    }

    const ByeType::TypesOptional& ByeType::
    getTypes () const
    {
      return this->Types_;
    }

    ByeType::TypesOptional& ByeType::
    getTypes ()
    {
      return this->Types_;
    }

    void ByeType::
    setTypes (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void ByeType::
    setTypes (const TypesOptional& x)
    {
      this->Types_ = x;
    }

    void ByeType::
    setTypes (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }

    const ByeType::ScopesOptional& ByeType::
    getScopes () const
    {
      return this->Scopes_;
    }

    ByeType::ScopesOptional& ByeType::
    getScopes ()
    {
      return this->Scopes_;
    }

    void ByeType::
    setScopes (const ScopesType& x)
    {
      this->Scopes_.set (x);
    }

    void ByeType::
    setScopes (const ScopesOptional& x)
    {
      this->Scopes_ = x;
    }

    void ByeType::
    setScopes (::std::unique_ptr< ScopesType > x)
    {
      this->Scopes_.set (std::move (x));
    }

    const ByeType::XAddrsOptional& ByeType::
    getXAddrs () const
    {
      return this->XAddrs_;
    }

    ByeType::XAddrsOptional& ByeType::
    getXAddrs ()
    {
      return this->XAddrs_;
    }

    void ByeType::
    setXAddrs (const XAddrsType& x)
    {
      this->XAddrs_.set (x);
    }

    void ByeType::
    setXAddrs (const XAddrsOptional& x)
    {
      this->XAddrs_ = x;
    }

    void ByeType::
    setXAddrs (::std::unique_ptr< XAddrsType > x)
    {
      this->XAddrs_.set (std::move (x));
    }

    const ByeType::MetadataVersionOptional& ByeType::
    getMetadataVersion () const
    {
      return this->MetadataVersion_;
    }

    ByeType::MetadataVersionOptional& ByeType::
    getMetadataVersion ()
    {
      return this->MetadataVersion_;
    }

    void ByeType::
    setMetadataVersion (const MetadataVersionType& x)
    {
      this->MetadataVersion_.set (x);
    }

    void ByeType::
    setMetadataVersion (const MetadataVersionOptional& x)
    {
      this->MetadataVersion_ = x;
    }


    // ProbeType
    // 

    const ProbeType::TypesOptional& ProbeType::
    getTypes () const
    {
      return this->Types_;
    }

    ProbeType::TypesOptional& ProbeType::
    getTypes ()
    {
      return this->Types_;
    }

    void ProbeType::
    setTypes (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void ProbeType::
    setTypes (const TypesOptional& x)
    {
      this->Types_ = x;
    }

    void ProbeType::
    setTypes (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }

    const ProbeType::ScopesOptional& ProbeType::
    getScopes () const
    {
      return this->Scopes_;
    }

    ProbeType::ScopesOptional& ProbeType::
    getScopes ()
    {
      return this->Scopes_;
    }

    void ProbeType::
    setScopes (const ScopesType& x)
    {
      this->Scopes_.set (x);
    }

    void ProbeType::
    setScopes (const ScopesOptional& x)
    {
      this->Scopes_ = x;
    }

    void ProbeType::
    setScopes (::std::unique_ptr< ScopesType > x)
    {
      this->Scopes_.set (std::move (x));
    }


    // ProbeMatchesType
    // 

    const ProbeMatchesType::ProbeMatchSequence& ProbeMatchesType::
    getProbeMatch () const
    {
      return this->ProbeMatch_;
    }

    ProbeMatchesType::ProbeMatchSequence& ProbeMatchesType::
    getProbeMatch ()
    {
      return this->ProbeMatch_;
    }

    void ProbeMatchesType::
    setProbeMatch (const ProbeMatchSequence& s)
    {
      this->ProbeMatch_ = s;
    }


    // ProbeMatchType
    // 

    const ProbeMatchType::EndpointReferenceType& ProbeMatchType::
    getEndpointReference () const
    {
      return this->EndpointReference_.get ();
    }

    ProbeMatchType::EndpointReferenceType& ProbeMatchType::
    getEndpointReference ()
    {
      return this->EndpointReference_.get ();
    }

    void ProbeMatchType::
    setEndpointReference (const EndpointReferenceType& x)
    {
      this->EndpointReference_.set (x);
    }

    void ProbeMatchType::
    setEndpointReference (::std::unique_ptr< EndpointReferenceType > x)
    {
      this->EndpointReference_.set (std::move (x));
    }

    const ProbeMatchType::TypesOptional& ProbeMatchType::
    getTypes () const
    {
      return this->Types_;
    }

    ProbeMatchType::TypesOptional& ProbeMatchType::
    getTypes ()
    {
      return this->Types_;
    }

    void ProbeMatchType::
    setTypes (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void ProbeMatchType::
    setTypes (const TypesOptional& x)
    {
      this->Types_ = x;
    }

    void ProbeMatchType::
    setTypes (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }

    const ProbeMatchType::ScopesOptional& ProbeMatchType::
    getScopes () const
    {
      return this->Scopes_;
    }

    ProbeMatchType::ScopesOptional& ProbeMatchType::
    getScopes ()
    {
      return this->Scopes_;
    }

    void ProbeMatchType::
    setScopes (const ScopesType& x)
    {
      this->Scopes_.set (x);
    }

    void ProbeMatchType::
    setScopes (const ScopesOptional& x)
    {
      this->Scopes_ = x;
    }

    void ProbeMatchType::
    setScopes (::std::unique_ptr< ScopesType > x)
    {
      this->Scopes_.set (std::move (x));
    }

    const ProbeMatchType::XAddrsOptional& ProbeMatchType::
    getXAddrs () const
    {
      return this->XAddrs_;
    }

    ProbeMatchType::XAddrsOptional& ProbeMatchType::
    getXAddrs ()
    {
      return this->XAddrs_;
    }

    void ProbeMatchType::
    setXAddrs (const XAddrsType& x)
    {
      this->XAddrs_.set (x);
    }

    void ProbeMatchType::
    setXAddrs (const XAddrsOptional& x)
    {
      this->XAddrs_ = x;
    }

    void ProbeMatchType::
    setXAddrs (::std::unique_ptr< XAddrsType > x)
    {
      this->XAddrs_.set (std::move (x));
    }

    const ProbeMatchType::MetadataVersionType& ProbeMatchType::
    getMetadataVersion () const
    {
      return this->MetadataVersion_.get ();
    }

    ProbeMatchType::MetadataVersionType& ProbeMatchType::
    getMetadataVersion ()
    {
      return this->MetadataVersion_.get ();
    }

    void ProbeMatchType::
    setMetadataVersion (const MetadataVersionType& x)
    {
      this->MetadataVersion_.set (x);
    }


    // ResolveType
    // 

    const ResolveType::EndpointReferenceType& ResolveType::
    getEndpointReference () const
    {
      return this->EndpointReference_.get ();
    }

    ResolveType::EndpointReferenceType& ResolveType::
    getEndpointReference ()
    {
      return this->EndpointReference_.get ();
    }

    void ResolveType::
    setEndpointReference (const EndpointReferenceType& x)
    {
      this->EndpointReference_.set (x);
    }

    void ResolveType::
    setEndpointReference (::std::unique_ptr< EndpointReferenceType > x)
    {
      this->EndpointReference_.set (std::move (x));
    }


    // ResolveMatchesType
    // 

    const ResolveMatchesType::ResolveMatchOptional& ResolveMatchesType::
    getResolveMatch () const
    {
      return this->ResolveMatch_;
    }

    ResolveMatchesType::ResolveMatchOptional& ResolveMatchesType::
    getResolveMatch ()
    {
      return this->ResolveMatch_;
    }

    void ResolveMatchesType::
    setResolveMatch (const ResolveMatchType& x)
    {
      this->ResolveMatch_.set (x);
    }

    void ResolveMatchesType::
    setResolveMatch (const ResolveMatchOptional& x)
    {
      this->ResolveMatch_ = x;
    }

    void ResolveMatchesType::
    setResolveMatch (::std::unique_ptr< ResolveMatchType > x)
    {
      this->ResolveMatch_.set (std::move (x));
    }


    // ResolveMatchType
    // 

    const ResolveMatchType::EndpointReferenceType& ResolveMatchType::
    getEndpointReference () const
    {
      return this->EndpointReference_.get ();
    }

    ResolveMatchType::EndpointReferenceType& ResolveMatchType::
    getEndpointReference ()
    {
      return this->EndpointReference_.get ();
    }

    void ResolveMatchType::
    setEndpointReference (const EndpointReferenceType& x)
    {
      this->EndpointReference_.set (x);
    }

    void ResolveMatchType::
    setEndpointReference (::std::unique_ptr< EndpointReferenceType > x)
    {
      this->EndpointReference_.set (std::move (x));
    }

    const ResolveMatchType::TypesOptional& ResolveMatchType::
    getTypes () const
    {
      return this->Types_;
    }

    ResolveMatchType::TypesOptional& ResolveMatchType::
    getTypes ()
    {
      return this->Types_;
    }

    void ResolveMatchType::
    setTypes (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void ResolveMatchType::
    setTypes (const TypesOptional& x)
    {
      this->Types_ = x;
    }

    void ResolveMatchType::
    setTypes (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }

    const ResolveMatchType::ScopesOptional& ResolveMatchType::
    getScopes () const
    {
      return this->Scopes_;
    }

    ResolveMatchType::ScopesOptional& ResolveMatchType::
    getScopes ()
    {
      return this->Scopes_;
    }

    void ResolveMatchType::
    setScopes (const ScopesType& x)
    {
      this->Scopes_.set (x);
    }

    void ResolveMatchType::
    setScopes (const ScopesOptional& x)
    {
      this->Scopes_ = x;
    }

    void ResolveMatchType::
    setScopes (::std::unique_ptr< ScopesType > x)
    {
      this->Scopes_.set (std::move (x));
    }

    const ResolveMatchType::XAddrsOptional& ResolveMatchType::
    getXAddrs () const
    {
      return this->XAddrs_;
    }

    ResolveMatchType::XAddrsOptional& ResolveMatchType::
    getXAddrs ()
    {
      return this->XAddrs_;
    }

    void ResolveMatchType::
    setXAddrs (const XAddrsType& x)
    {
      this->XAddrs_.set (x);
    }

    void ResolveMatchType::
    setXAddrs (const XAddrsOptional& x)
    {
      this->XAddrs_ = x;
    }

    void ResolveMatchType::
    setXAddrs (::std::unique_ptr< XAddrsType > x)
    {
      this->XAddrs_.set (std::move (x));
    }

    const ResolveMatchType::MetadataVersionType& ResolveMatchType::
    getMetadataVersion () const
    {
      return this->MetadataVersion_.get ();
    }

    ResolveMatchType::MetadataVersionType& ResolveMatchType::
    getMetadataVersion ()
    {
      return this->MetadataVersion_.get ();
    }

    void ResolveMatchType::
    setMetadataVersion (const MetadataVersionType& x)
    {
      this->MetadataVersion_.set (x);
    }


    // QNameListType
    //

    QNameListType::
    QNameListType ()
    : ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (this)
    {
    }

    QNameListType::
    QNameListType (size_type n, const ::xml_schema::Qname& x)
    : ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (n, x, this)
    {
    }

    QNameListType::
    QNameListType (const QNameListType& o,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (o, f, this)
    {
    }

    // UriListType
    //

    UriListType::
    UriListType ()
    : ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (this)
    {
    }

    UriListType::
    UriListType (size_type n, const ::xml_schema::Uri& x)
    : ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (n, x, this)
    {
    }

    UriListType::
    UriListType (const UriListType& o,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (o, f, this)
    {
    }

    // ScopesType
    // 

    const ScopesType::MatchByOptional& ScopesType::
    getMatchBy () const
    {
      return this->MatchBy_;
    }

    ScopesType::MatchByOptional& ScopesType::
    getMatchBy ()
    {
      return this->MatchBy_;
    }

    void ScopesType::
    setMatchBy (const MatchByType& x)
    {
      this->MatchBy_.set (x);
    }

    void ScopesType::
    setMatchBy (const MatchByOptional& x)
    {
      this->MatchBy_ = x;
    }

    void ScopesType::
    setMatchBy (::std::unique_ptr< MatchByType > x)
    {
      this->MatchBy_.set (std::move (x));
    }


    // FaultCodeType
    // 

    FaultCodeType::
    FaultCodeType (const ::xml_schema::Qname& v)
    : ::xml_schema::Qname (v)
    {
    }

    FaultCodeType::
    FaultCodeType (const FaultCodeType& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Qname (v, f, c)
    {
    }


    // FaultCodeOpenType
    //

    FaultCodeOpenType::
    FaultCodeOpenType (const char* s)
    : ::xml_schema::String (s)
    {
    }

    FaultCodeOpenType::
    FaultCodeOpenType (const ::std::string& s)
    : ::xml_schema::String (s)
    {
    }

    FaultCodeOpenType::
    FaultCodeOpenType (const FaultCodeOpenType& o,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (o, f, c)
    {
    }

    // SecurityType
    // 

    const SecurityType::SigOptional& SecurityType::
    getSig () const
    {
      return this->Sig_;
    }

    SecurityType::SigOptional& SecurityType::
    getSig ()
    {
      return this->Sig_;
    }

    void SecurityType::
    setSig (const SigType& x)
    {
      this->Sig_.set (x);
    }

    void SecurityType::
    setSig (const SigOptional& x)
    {
      this->Sig_ = x;
    }

    void SecurityType::
    setSig (::std::unique_ptr< SigType > x)
    {
      this->Sig_.set (std::move (x));
    }


    // SigType
    // 

    const SigType::SchemeType& SigType::
    getScheme () const
    {
      return this->Scheme_.get ();
    }

    SigType::SchemeType& SigType::
    getScheme ()
    {
      return this->Scheme_.get ();
    }

    void SigType::
    setScheme (const SchemeType& x)
    {
      this->Scheme_.set (x);
    }

    void SigType::
    setScheme (::std::unique_ptr< SchemeType > x)
    {
      this->Scheme_.set (std::move (x));
    }

    const SigType::KeyIdOptional& SigType::
    getKeyId () const
    {
      return this->KeyId_;
    }

    SigType::KeyIdOptional& SigType::
    getKeyId ()
    {
      return this->KeyId_;
    }

    void SigType::
    setKeyId (const KeyIdType& x)
    {
      this->KeyId_.set (x);
    }

    void SigType::
    setKeyId (const KeyIdOptional& x)
    {
      this->KeyId_ = x;
    }

    void SigType::
    setKeyId (::std::unique_ptr< KeyIdType > x)
    {
      this->KeyId_.set (std::move (x));
    }

    const SigType::RefsType& SigType::
    getRefs () const
    {
      return this->Refs_.get ();
    }

    SigType::RefsType& SigType::
    getRefs ()
    {
      return this->Refs_.get ();
    }

    void SigType::
    setRefs (const RefsType& x)
    {
      this->Refs_.set (x);
    }

    void SigType::
    setRefs (::std::unique_ptr< RefsType > x)
    {
      this->Refs_.set (std::move (x));
    }

    const SigType::SigType1& SigType::
    getSig () const
    {
      return this->Sig_.get ();
    }

    SigType::SigType1& SigType::
    getSig ()
    {
      return this->Sig_.get ();
    }

    void SigType::
    setSig (const SigType1& x)
    {
      this->Sig_.set (x);
    }

    void SigType::
    setSig (::std::unique_ptr< SigType1 > x)
    {
      this->Sig_.set (std::move (x));
    }


    // AppSequenceType
    // 

    const AppSequenceType::InstanceIdType& AppSequenceType::
    getInstanceId () const
    {
      return this->InstanceId_.get ();
    }

    AppSequenceType::InstanceIdType& AppSequenceType::
    getInstanceId ()
    {
      return this->InstanceId_.get ();
    }

    void AppSequenceType::
    setInstanceId (const InstanceIdType& x)
    {
      this->InstanceId_.set (x);
    }

    const AppSequenceType::SequenceIdOptional& AppSequenceType::
    getSequenceId () const
    {
      return this->SequenceId_;
    }

    AppSequenceType::SequenceIdOptional& AppSequenceType::
    getSequenceId ()
    {
      return this->SequenceId_;
    }

    void AppSequenceType::
    setSequenceId (const SequenceIdType& x)
    {
      this->SequenceId_.set (x);
    }

    void AppSequenceType::
    setSequenceId (const SequenceIdOptional& x)
    {
      this->SequenceId_ = x;
    }

    void AppSequenceType::
    setSequenceId (::std::unique_ptr< SequenceIdType > x)
    {
      this->SequenceId_.set (std::move (x));
    }

    const AppSequenceType::MessageNumberType& AppSequenceType::
    getMessageNumber () const
    {
      return this->MessageNumber_.get ();
    }

    AppSequenceType::MessageNumberType& AppSequenceType::
    getMessageNumber ()
    {
      return this->MessageNumber_.get ();
    }

    void AppSequenceType::
    setMessageNumber (const MessageNumberType& x)
    {
      this->MessageNumber_.set (x);
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace WS
{
  namespace DISCOVERY
  {
    // HelloType
    //

    HelloType::
    HelloType (const EndpointReferenceType& EndpointReference,
               const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (EndpointReference, this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    HelloType::
    HelloType (::std::unique_ptr< EndpointReferenceType > EndpointReference,
               const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (std::move (EndpointReference), this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    HelloType::
    HelloType (const HelloType& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this),
      Types_ (x.Types_, f, this),
      Scopes_ (x.Scopes_, f, this),
      XAddrs_ (x.XAddrs_, f, this),
      MetadataVersion_ (x.MetadataVersion_, f, this)
    {
    }

    HelloType::
    HelloType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void HelloType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EndpointReference_.present ())
            {
              ::std::unique_ptr< EndpointReferenceType > r (
                dynamic_cast< EndpointReferenceType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->EndpointReference_.set (::std::move (r));
              continue;
            }
          }
        }

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Types_)
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        // Scopes
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ScopesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Scopes_)
            {
              ::std::unique_ptr< ScopesType > r (
                dynamic_cast< ScopesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Scopes_.set (::std::move (r));
              continue;
            }
          }
        }

        // XAddrs
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< XAddrsType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->XAddrs_)
            {
              ::std::unique_ptr< XAddrsType > r (
                dynamic_cast< XAddrsType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->XAddrs_.set (::std::move (r));
              continue;
            }
          }
        }

        // MetadataVersion
        //
        if (n.name () == "MetadataVersion" && n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          if (!MetadataVersion_.present ())
          {
            this->MetadataVersion_.set (MetadataVersionTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!EndpointReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndpointReference",
          "http://www.w3.org/2005/08/addressing");
      }

      if (!MetadataVersion_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MetadataVersion",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
      }
    }

    HelloType* HelloType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class HelloType (*this, f, c);
    }

    HelloType& HelloType::
    operator= (const HelloType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
        this->Types_ = x.Types_;
        this->Scopes_ = x.Scopes_;
        this->XAddrs_ = x.XAddrs_;
        this->MetadataVersion_ = x.MetadataVersion_;
      }

      return *this;
    }

    HelloType::
    ~HelloType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, HelloType >
    _xsd_HelloType_type_factory_init (
      "HelloType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ByeType
    //

    ByeType::
    ByeType (const EndpointReferenceType& EndpointReference)
    : ::xml_schema::Type (),
      EndpointReference_ (EndpointReference, this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
    }

    ByeType::
    ByeType (::std::unique_ptr< EndpointReferenceType > EndpointReference)
    : ::xml_schema::Type (),
      EndpointReference_ (std::move (EndpointReference), this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
    }

    ByeType::
    ByeType (const ByeType& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this),
      Types_ (x.Types_, f, this),
      Scopes_ (x.Scopes_, f, this),
      XAddrs_ (x.XAddrs_, f, this),
      MetadataVersion_ (x.MetadataVersion_, f, this)
    {
    }

    ByeType::
    ByeType (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ByeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EndpointReference_.present ())
            {
              ::std::unique_ptr< EndpointReferenceType > r (
                dynamic_cast< EndpointReferenceType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->EndpointReference_.set (::std::move (r));
              continue;
            }
          }
        }

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Types_)
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        // Scopes
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ScopesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Scopes_)
            {
              ::std::unique_ptr< ScopesType > r (
                dynamic_cast< ScopesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Scopes_.set (::std::move (r));
              continue;
            }
          }
        }

        // XAddrs
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< XAddrsType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->XAddrs_)
            {
              ::std::unique_ptr< XAddrsType > r (
                dynamic_cast< XAddrsType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->XAddrs_.set (::std::move (r));
              continue;
            }
          }
        }

        // MetadataVersion
        //
        if (n.name () == "MetadataVersion" && n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          if (!this->MetadataVersion_)
          {
            this->MetadataVersion_.set (MetadataVersionTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!EndpointReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndpointReference",
          "http://www.w3.org/2005/08/addressing");
      }
    }

    ByeType* ByeType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ByeType (*this, f, c);
    }

    ByeType& ByeType::
    operator= (const ByeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
        this->Types_ = x.Types_;
        this->Scopes_ = x.Scopes_;
        this->XAddrs_ = x.XAddrs_;
        this->MetadataVersion_ = x.MetadataVersion_;
      }

      return *this;
    }

    ByeType::
    ~ByeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ByeType >
    _xsd_ByeType_type_factory_init (
      "ByeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ProbeType
    //

    ProbeType::
    ProbeType ()
    : ::xml_schema::Type (),
      Types_ (this),
      Scopes_ (this)
    {
    }

    ProbeType::
    ProbeType (const ProbeType& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Types_ (x.Types_, f, this),
      Scopes_ (x.Scopes_, f, this)
    {
    }

    ProbeType::
    ProbeType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Types_ (this),
      Scopes_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ProbeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Types_)
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        // Scopes
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ScopesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Scopes_)
            {
              ::std::unique_ptr< ScopesType > r (
                dynamic_cast< ScopesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Scopes_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    ProbeType* ProbeType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ProbeType (*this, f, c);
    }

    ProbeType& ProbeType::
    operator= (const ProbeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->Types_ = x.Types_;
        this->Scopes_ = x.Scopes_;
      }

      return *this;
    }

    ProbeType::
    ~ProbeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ProbeType >
    _xsd_ProbeType_type_factory_init (
      "ProbeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ProbeMatchesType
    //

    ProbeMatchesType::
    ProbeMatchesType ()
    : ::xml_schema::Type (),
      ProbeMatch_ (this)
    {
    }

    ProbeMatchesType::
    ProbeMatchesType (const ProbeMatchesType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      ProbeMatch_ (x.ProbeMatch_, f, this)
    {
    }

    ProbeMatchesType::
    ProbeMatchesType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      ProbeMatch_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ProbeMatchesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ProbeMatch
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ProbeMatch",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ProbeMatchType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ProbeMatchType > r (
              dynamic_cast< ProbeMatchType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ProbeMatch_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ProbeMatchesType* ProbeMatchesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ProbeMatchesType (*this, f, c);
    }

    ProbeMatchesType& ProbeMatchesType::
    operator= (const ProbeMatchesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->ProbeMatch_ = x.ProbeMatch_;
      }

      return *this;
    }

    ProbeMatchesType::
    ~ProbeMatchesType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ProbeMatchesType >
    _xsd_ProbeMatchesType_type_factory_init (
      "ProbeMatchesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ProbeMatchType
    //

    ProbeMatchType::
    ProbeMatchType (const EndpointReferenceType& EndpointReference,
                    const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (EndpointReference, this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    ProbeMatchType::
    ProbeMatchType (::std::unique_ptr< EndpointReferenceType > EndpointReference,
                    const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (std::move (EndpointReference), this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    ProbeMatchType::
    ProbeMatchType (const ProbeMatchType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this),
      Types_ (x.Types_, f, this),
      Scopes_ (x.Scopes_, f, this),
      XAddrs_ (x.XAddrs_, f, this),
      MetadataVersion_ (x.MetadataVersion_, f, this)
    {
    }

    ProbeMatchType::
    ProbeMatchType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ProbeMatchType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EndpointReference_.present ())
            {
              ::std::unique_ptr< EndpointReferenceType > r (
                dynamic_cast< EndpointReferenceType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->EndpointReference_.set (::std::move (r));
              continue;
            }
          }
        }

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Types_)
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        // Scopes
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ScopesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Scopes_)
            {
              ::std::unique_ptr< ScopesType > r (
                dynamic_cast< ScopesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Scopes_.set (::std::move (r));
              continue;
            }
          }
        }

        // XAddrs
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< XAddrsType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->XAddrs_)
            {
              ::std::unique_ptr< XAddrsType > r (
                dynamic_cast< XAddrsType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->XAddrs_.set (::std::move (r));
              continue;
            }
          }
        }

        // MetadataVersion
        //
        if (n.name () == "MetadataVersion" && n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          if (!MetadataVersion_.present ())
          {
            this->MetadataVersion_.set (MetadataVersionTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!EndpointReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndpointReference",
          "http://www.w3.org/2005/08/addressing");
      }

      if (!MetadataVersion_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MetadataVersion",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
      }
    }

    ProbeMatchType* ProbeMatchType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ProbeMatchType (*this, f, c);
    }

    ProbeMatchType& ProbeMatchType::
    operator= (const ProbeMatchType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
        this->Types_ = x.Types_;
        this->Scopes_ = x.Scopes_;
        this->XAddrs_ = x.XAddrs_;
        this->MetadataVersion_ = x.MetadataVersion_;
      }

      return *this;
    }

    ProbeMatchType::
    ~ProbeMatchType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ProbeMatchType >
    _xsd_ProbeMatchType_type_factory_init (
      "ProbeMatchType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ResolveType
    //

    ResolveType::
    ResolveType (const EndpointReferenceType& EndpointReference)
    : ::xml_schema::Type (),
      EndpointReference_ (EndpointReference, this)
    {
    }

    ResolveType::
    ResolveType (::std::unique_ptr< EndpointReferenceType > EndpointReference)
    : ::xml_schema::Type (),
      EndpointReference_ (std::move (EndpointReference), this)
    {
    }

    ResolveType::
    ResolveType (const ResolveType& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this)
    {
    }

    ResolveType::
    ResolveType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ResolveType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EndpointReference_.present ())
            {
              ::std::unique_ptr< EndpointReferenceType > r (
                dynamic_cast< EndpointReferenceType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->EndpointReference_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!EndpointReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndpointReference",
          "http://www.w3.org/2005/08/addressing");
      }
    }

    ResolveType* ResolveType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ResolveType (*this, f, c);
    }

    ResolveType& ResolveType::
    operator= (const ResolveType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
      }

      return *this;
    }

    ResolveType::
    ~ResolveType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ResolveType >
    _xsd_ResolveType_type_factory_init (
      "ResolveType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ResolveMatchesType
    //

    ResolveMatchesType::
    ResolveMatchesType ()
    : ::xml_schema::Type (),
      ResolveMatch_ (this)
    {
    }

    ResolveMatchesType::
    ResolveMatchesType (const ResolveMatchesType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      ResolveMatch_ (x.ResolveMatch_, f, this)
    {
    }

    ResolveMatchesType::
    ResolveMatchesType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      ResolveMatch_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ResolveMatchesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ResolveMatch
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ResolveMatch",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ResolveMatchType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->ResolveMatch_)
            {
              ::std::unique_ptr< ResolveMatchType > r (
                dynamic_cast< ResolveMatchType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->ResolveMatch_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    ResolveMatchesType* ResolveMatchesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ResolveMatchesType (*this, f, c);
    }

    ResolveMatchesType& ResolveMatchesType::
    operator= (const ResolveMatchesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->ResolveMatch_ = x.ResolveMatch_;
      }

      return *this;
    }

    ResolveMatchesType::
    ~ResolveMatchesType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ResolveMatchesType >
    _xsd_ResolveMatchesType_type_factory_init (
      "ResolveMatchesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ResolveMatchType
    //

    ResolveMatchType::
    ResolveMatchType (const EndpointReferenceType& EndpointReference,
                      const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (EndpointReference, this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    ResolveMatchType::
    ResolveMatchType (::std::unique_ptr< EndpointReferenceType > EndpointReference,
                      const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (std::move (EndpointReference), this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    ResolveMatchType::
    ResolveMatchType (const ResolveMatchType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this),
      Types_ (x.Types_, f, this),
      Scopes_ (x.Scopes_, f, this),
      XAddrs_ (x.XAddrs_, f, this),
      MetadataVersion_ (x.MetadataVersion_, f, this)
    {
    }

    ResolveMatchType::
    ResolveMatchType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ResolveMatchType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EndpointReference_.present ())
            {
              ::std::unique_ptr< EndpointReferenceType > r (
                dynamic_cast< EndpointReferenceType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->EndpointReference_.set (::std::move (r));
              continue;
            }
          }
        }

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Types_)
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        // Scopes
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ScopesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Scopes_)
            {
              ::std::unique_ptr< ScopesType > r (
                dynamic_cast< ScopesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Scopes_.set (::std::move (r));
              continue;
            }
          }
        }

        // XAddrs
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< XAddrsType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->XAddrs_)
            {
              ::std::unique_ptr< XAddrsType > r (
                dynamic_cast< XAddrsType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->XAddrs_.set (::std::move (r));
              continue;
            }
          }
        }

        // MetadataVersion
        //
        if (n.name () == "MetadataVersion" && n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          if (!MetadataVersion_.present ())
          {
            this->MetadataVersion_.set (MetadataVersionTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!EndpointReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndpointReference",
          "http://www.w3.org/2005/08/addressing");
      }

      if (!MetadataVersion_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MetadataVersion",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
      }
    }

    ResolveMatchType* ResolveMatchType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ResolveMatchType (*this, f, c);
    }

    ResolveMatchType& ResolveMatchType::
    operator= (const ResolveMatchType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
        this->Types_ = x.Types_;
        this->Scopes_ = x.Scopes_;
        this->XAddrs_ = x.XAddrs_;
        this->MetadataVersion_ = x.MetadataVersion_;
      }

      return *this;
    }

    ResolveMatchType::
    ~ResolveMatchType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ResolveMatchType >
    _xsd_ResolveMatchType_type_factory_init (
      "ResolveMatchType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // QNameListType
    //

    QNameListType::
    QNameListType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (e, f, this)
    {
    }

    QNameListType::
    QNameListType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (a, f, this)
    {
    }

    QNameListType::
    QNameListType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (s, e, f, this)
    {
    }

    QNameListType* QNameListType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class QNameListType (*this, f, c);
    }

    QNameListType::
    ~QNameListType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, QNameListType >
    _xsd_QNameListType_type_factory_init (
      "QNameListType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // UriListType
    //

    UriListType::
    UriListType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (e, f, this)
    {
    }

    UriListType::
    UriListType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (a, f, this)
    {
    }

    UriListType::
    UriListType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (s, e, f, this)
    {
    }

    UriListType* UriListType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class UriListType (*this, f, c);
    }

    UriListType::
    ~UriListType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, UriListType >
    _xsd_UriListType_type_factory_init (
      "UriListType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ScopesType
    //

    ScopesType::
    ScopesType ()
    : ::WS::DISCOVERY::UriListType (),
      MatchBy_ (this)
    {
    }

    ScopesType::
    ScopesType (const ::WS::DISCOVERY::UriListType& _xsd_UriListType_base)
    : ::WS::DISCOVERY::UriListType (_xsd_UriListType_base),
      MatchBy_ (this)
    {
    }

    ScopesType::
    ScopesType (const ScopesType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::WS::DISCOVERY::UriListType (x, f, c),
      MatchBy_ (x.MatchBy_, f, this)
    {
    }

    ScopesType::
    ScopesType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::WS::DISCOVERY::UriListType (e, f | ::xml_schema::Flags::base, c),
      MatchBy_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ScopesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "MatchBy" && n.namespace_ ().empty ())
        {
          this->MatchBy_.set (MatchByTraits::create (i, f, this));
          continue;
        }
      }
    }

    ScopesType* ScopesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ScopesType (*this, f, c);
    }

    ScopesType& ScopesType::
    operator= (const ScopesType& x)
    {
      if (this != &x)
      {
        static_cast< ::WS::DISCOVERY::UriListType& > (*this) = x;
        this->MatchBy_ = x.MatchBy_;
      }

      return *this;
    }

    ScopesType::
    ~ScopesType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ScopesType >
    _xsd_ScopesType_type_factory_init (
      "ScopesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // FaultCodeType
    //

    FaultCodeType::
    FaultCodeType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Qname (e, f, c)
    {
    }

    FaultCodeType::
    FaultCodeType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Qname (a, f, c)
    {
    }

    FaultCodeType::
    FaultCodeType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Qname (s, e, f, c)
    {
    }

    FaultCodeType* FaultCodeType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FaultCodeType (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, FaultCodeType >
    _xsd_FaultCodeType_type_factory_init (
      "FaultCodeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // FaultCodeOpenType
    //

    FaultCodeOpenType::
    FaultCodeOpenType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    FaultCodeOpenType::
    FaultCodeOpenType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    FaultCodeOpenType::
    FaultCodeOpenType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    FaultCodeOpenType* FaultCodeOpenType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FaultCodeOpenType (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, FaultCodeOpenType >
    _xsd_FaultCodeOpenType_type_factory_init (
      "FaultCodeOpenType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // SecurityType
    //

    SecurityType::
    SecurityType ()
    : ::xml_schema::Type (),
      Sig_ (this)
    {
    }

    SecurityType::
    SecurityType (const SecurityType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Sig_ (x.Sig_, f, this)
    {
    }

    SecurityType::
    SecurityType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Sig_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SecurityType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Sig
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Sig",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< SigType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Sig_)
            {
              ::std::unique_ptr< SigType > r (
                dynamic_cast< SigType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Sig_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    SecurityType* SecurityType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SecurityType (*this, f, c);
    }

    SecurityType& SecurityType::
    operator= (const SecurityType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->Sig_ = x.Sig_;
      }

      return *this;
    }

    SecurityType::
    ~SecurityType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SecurityType >
    _xsd_SecurityType_type_factory_init (
      "SecurityType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // SigType
    //

    SigType::
    SigType (const SchemeType& Scheme,
             const RefsType& Refs,
             const SigType1& Sig)
    : ::xml_schema::Type (),
      Scheme_ (Scheme, this),
      KeyId_ (this),
      Refs_ (Refs, this),
      Sig_ (Sig, this)
    {
    }

    SigType::
    SigType (const SigType& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Scheme_ (x.Scheme_, f, this),
      KeyId_ (x.KeyId_, f, this),
      Refs_ (x.Refs_, f, this),
      Sig_ (x.Sig_, f, this)
    {
    }

    SigType::
    SigType (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Scheme_ (this),
      KeyId_ (this),
      Refs_ (this),
      Sig_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SigType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Scheme" && n.namespace_ ().empty ())
        {
          this->Scheme_.set (SchemeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "KeyId" && n.namespace_ ().empty ())
        {
          this->KeyId_.set (KeyIdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "Refs" && n.namespace_ ().empty ())
        {
          this->Refs_.set (RefsTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "Sig" && n.namespace_ ().empty ())
        {
          this->Sig_.set (SigTraits::create (i, f, this));
          continue;
        }
      }

      if (!Scheme_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "Scheme",
          "");
      }

      if (!Refs_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "Refs",
          "");
      }

      if (!Sig_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "Sig",
          "");
      }
    }

    SigType* SigType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SigType (*this, f, c);
    }

    SigType& SigType::
    operator= (const SigType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->Scheme_ = x.Scheme_;
        this->KeyId_ = x.KeyId_;
        this->Refs_ = x.Refs_;
        this->Sig_ = x.Sig_;
      }

      return *this;
    }

    SigType::
    ~SigType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SigType >
    _xsd_SigType_type_factory_init (
      "SigType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // AppSequenceType
    //

    AppSequenceType::
    AppSequenceType (const InstanceIdType& InstanceId,
                     const MessageNumberType& MessageNumber)
    : ::xml_schema::Type (),
      InstanceId_ (InstanceId, this),
      SequenceId_ (this),
      MessageNumber_ (MessageNumber, this)
    {
    }

    AppSequenceType::
    AppSequenceType (const ::xml_schema::Type& _xsd_Type_base,
                     const InstanceIdType& InstanceId,
                     const MessageNumberType& MessageNumber)
    : ::xml_schema::Type (_xsd_Type_base),
      InstanceId_ (InstanceId, this),
      SequenceId_ (this),
      MessageNumber_ (MessageNumber, this)
    {
    }

    AppSequenceType::
    AppSequenceType (const AppSequenceType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      InstanceId_ (x.InstanceId_, f, this),
      SequenceId_ (x.SequenceId_, f, this),
      MessageNumber_ (x.MessageNumber_, f, this)
    {
    }

    AppSequenceType::
    AppSequenceType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      InstanceId_ (this),
      SequenceId_ (this),
      MessageNumber_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AppSequenceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "InstanceId" && n.namespace_ ().empty ())
        {
          this->InstanceId_.set (InstanceIdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "SequenceId" && n.namespace_ ().empty ())
        {
          this->SequenceId_.set (SequenceIdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "MessageNumber" && n.namespace_ ().empty ())
        {
          this->MessageNumber_.set (MessageNumberTraits::create (i, f, this));
          continue;
        }
      }

      if (!InstanceId_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "InstanceId",
          "");
      }

      if (!MessageNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "MessageNumber",
          "");
      }
    }

    AppSequenceType* AppSequenceType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class AppSequenceType (*this, f, c);
    }

    AppSequenceType& AppSequenceType::
    operator= (const AppSequenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->InstanceId_ = x.InstanceId_;
        this->SequenceId_ = x.SequenceId_;
        this->MessageNumber_ = x.MessageNumber_;
      }

      return *this;
    }

    AppSequenceType::
    ~AppSequenceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, AppSequenceType >
    _xsd_AppSequenceType_type_factory_init (
      "AppSequenceType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace WS
{
  namespace DISCOVERY
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace WS
{
  namespace DISCOVERY
  {
    void
    operator<< (::xercesc::DOMElement& e, const HelloType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const HelloType::EndpointReferenceType& x (i.getEndpointReference ());
        if (typeid (HelloType::EndpointReferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EndpointReference",
            "http://www.w3.org/2005/08/addressing",
            true, true, e, x);
      }

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getTypes ())
        {
          const HelloType::TypesType& x (*i.getTypes ());
          if (typeid (HelloType::TypesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Types",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // Scopes
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getScopes ())
        {
          const HelloType::ScopesType& x (*i.getScopes ());
          if (typeid (HelloType::ScopesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Scopes",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // XAddrs
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getXAddrs ())
        {
          const HelloType::XAddrsType& x (*i.getXAddrs ());
          if (typeid (HelloType::XAddrsType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "XAddrs",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // MetadataVersion
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MetadataVersion",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
            e));

        s << i.getMetadataVersion ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, HelloType >
    _xsd_HelloType_type_serializer_init (
      "HelloType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const ByeType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ByeType::EndpointReferenceType& x (i.getEndpointReference ());
        if (typeid (ByeType::EndpointReferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EndpointReference",
            "http://www.w3.org/2005/08/addressing",
            true, true, e, x);
      }

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getTypes ())
        {
          const ByeType::TypesType& x (*i.getTypes ());
          if (typeid (ByeType::TypesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Types",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // Scopes
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getScopes ())
        {
          const ByeType::ScopesType& x (*i.getScopes ());
          if (typeid (ByeType::ScopesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Scopes",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // XAddrs
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getXAddrs ())
        {
          const ByeType::XAddrsType& x (*i.getXAddrs ());
          if (typeid (ByeType::XAddrsType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "XAddrs",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // MetadataVersion
      //
      if (i.getMetadataVersion ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MetadataVersion",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
            e));

        s << *i.getMetadataVersion ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ByeType >
    _xsd_ByeType_type_serializer_init (
      "ByeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const ProbeType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getTypes ())
        {
          const ProbeType::TypesType& x (*i.getTypes ());
          if (typeid (ProbeType::TypesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Types",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // Scopes
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getScopes ())
        {
          const ProbeType::ScopesType& x (*i.getScopes ());
          if (typeid (ProbeType::ScopesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Scopes",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ProbeType >
    _xsd_ProbeType_type_serializer_init (
      "ProbeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const ProbeMatchesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // ProbeMatch
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (ProbeMatchesType::ProbeMatchConstIterator
             b (i.getProbeMatch ().begin ()), n (i.getProbeMatch ().end ());
             b != n; ++b)
        {
          if (typeid (ProbeMatchesType::ProbeMatchType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ProbeMatch",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "ProbeMatch",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              false, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ProbeMatchesType >
    _xsd_ProbeMatchesType_type_serializer_init (
      "ProbeMatchesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const ProbeMatchType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ProbeMatchType::EndpointReferenceType& x (i.getEndpointReference ());
        if (typeid (ProbeMatchType::EndpointReferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EndpointReference",
            "http://www.w3.org/2005/08/addressing",
            true, true, e, x);
      }

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getTypes ())
        {
          const ProbeMatchType::TypesType& x (*i.getTypes ());
          if (typeid (ProbeMatchType::TypesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Types",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // Scopes
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getScopes ())
        {
          const ProbeMatchType::ScopesType& x (*i.getScopes ());
          if (typeid (ProbeMatchType::ScopesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Scopes",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // XAddrs
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getXAddrs ())
        {
          const ProbeMatchType::XAddrsType& x (*i.getXAddrs ());
          if (typeid (ProbeMatchType::XAddrsType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "XAddrs",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // MetadataVersion
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MetadataVersion",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
            e));

        s << i.getMetadataVersion ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ProbeMatchType >
    _xsd_ProbeMatchType_type_serializer_init (
      "ProbeMatchType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const ResolveType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ResolveType::EndpointReferenceType& x (i.getEndpointReference ());
        if (typeid (ResolveType::EndpointReferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EndpointReference",
            "http://www.w3.org/2005/08/addressing",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ResolveType >
    _xsd_ResolveType_type_serializer_init (
      "ResolveType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const ResolveMatchesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // ResolveMatch
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getResolveMatch ())
        {
          const ResolveMatchesType::ResolveMatchType& x (*i.getResolveMatch ());
          if (typeid (ResolveMatchesType::ResolveMatchType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ResolveMatch",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "ResolveMatch",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              false, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ResolveMatchesType >
    _xsd_ResolveMatchesType_type_serializer_init (
      "ResolveMatchesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const ResolveMatchType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ResolveMatchType::EndpointReferenceType& x (i.getEndpointReference ());
        if (typeid (ResolveMatchType::EndpointReferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EndpointReference",
            "http://www.w3.org/2005/08/addressing",
            true, true, e, x);
      }

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getTypes ())
        {
          const ResolveMatchType::TypesType& x (*i.getTypes ());
          if (typeid (ResolveMatchType::TypesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Types",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // Scopes
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getScopes ())
        {
          const ResolveMatchType::ScopesType& x (*i.getScopes ());
          if (typeid (ResolveMatchType::ScopesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Scopes",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // XAddrs
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getXAddrs ())
        {
          const ResolveMatchType::XAddrsType& x (*i.getXAddrs ());
          if (typeid (ResolveMatchType::XAddrsType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "XAddrs",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // MetadataVersion
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MetadataVersion",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
            e));

        s << i.getMetadataVersion ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ResolveMatchType >
    _xsd_ResolveMatchType_type_serializer_init (
      "ResolveMatchType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const QNameListType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Qname, char >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const QNameListType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Qname, char >& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const QNameListType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Qname, char >& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, QNameListType >
    _xsd_QNameListType_type_serializer_init (
      "QNameListType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const UriListType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Uri, char >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const UriListType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Uri, char >& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const UriListType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Uri, char >& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, UriListType >
    _xsd_UriListType_type_serializer_init (
      "UriListType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const ScopesType& i)
    {
      e << static_cast< const ::WS::DISCOVERY::UriListType& > (i);

      // MatchBy
      //
      if (i.getMatchBy ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "MatchBy",
            e));

        a << *i.getMatchBy ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ScopesType >
    _xsd_ScopesType_type_serializer_init (
      "ScopesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const FaultCodeType& i)
    {
      e << static_cast< const ::xml_schema::Qname& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const FaultCodeType& i)
    {
      a << static_cast< const ::xml_schema::Qname& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const FaultCodeType& i)
    {
      l << static_cast< const ::xml_schema::Qname& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FaultCodeType >
    _xsd_FaultCodeType_type_serializer_init (
      "FaultCodeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const FaultCodeOpenType& i)
    {
      e << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const FaultCodeOpenType& i)
    {
      a << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const FaultCodeOpenType& i)
    {
      l << static_cast< const ::xml_schema::String& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FaultCodeOpenType >
    _xsd_FaultCodeOpenType_type_serializer_init (
      "FaultCodeOpenType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const SecurityType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Sig
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getSig ())
        {
          const SecurityType::SigType& x (*i.getSig ());
          if (typeid (SecurityType::SigType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Sig",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Sig",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SecurityType >
    _xsd_SecurityType_type_serializer_init (
      "SecurityType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const SigType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Scheme
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Scheme",
            e));

        a << i.getScheme ();
      }

      // KeyId
      //
      if (i.getKeyId ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "KeyId",
            e));

        a << *i.getKeyId ();
      }

      // Refs
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Refs",
            e));

        a << i.getRefs ();
      }

      // Sig
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Sig",
            e));

        a << i.getSig ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SigType >
    _xsd_SigType_type_serializer_init (
      "SigType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const AppSequenceType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // InstanceId
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "InstanceId",
            e));

        a << i.getInstanceId ();
      }

      // SequenceId
      //
      if (i.getSequenceId ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "SequenceId",
            e));

        a << *i.getSequenceId ();
      }

      // MessageNumber
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "MessageNumber",
            e));

        a << i.getMessageNumber ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AppSequenceType >
    _xsd_AppSequenceType_type_serializer_init (
      "AppSequenceType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

