// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "DataModel/wsdl-soap-binding.hxx"

namespace WS
{
  namespace WSDL
  {
    namespace SOAP_BINDING
    {
      // BindingType
      // 

      const BindingType::TransportOptional& BindingType::
      getTransport () const
      {
        return this->transport_;
      }

      BindingType::TransportOptional& BindingType::
      getTransport ()
      {
        return this->transport_;
      }

      void BindingType::
      setTransport (const TransportType& x)
      {
        this->transport_.set (x);
      }

      void BindingType::
      setTransport (const TransportOptional& x)
      {
        this->transport_ = x;
      }

      void BindingType::
      setTransport (::std::unique_ptr< TransportType > x)
      {
        this->transport_.set (std::move (x));
      }

      const BindingType::StyleOptional& BindingType::
      getStyle () const
      {
        return this->style_;
      }

      BindingType::StyleOptional& BindingType::
      getStyle ()
      {
        return this->style_;
      }

      void BindingType::
      setStyle (const StyleType& x)
      {
        this->style_.set (x);
      }

      void BindingType::
      setStyle (const StyleOptional& x)
      {
        this->style_ = x;
      }

      void BindingType::
      setStyle (::std::unique_ptr< StyleType > x)
      {
        this->style_.set (std::move (x));
      }


      // StyleChoice
      // 

      StyleChoice::
      StyleChoice (Value v)
      : ::xml_schema::String (_xsd_StyleChoice_literals_[v])
      {
      }

      StyleChoice::
      StyleChoice (const char* v)
      : ::xml_schema::String (v)
      {
      }

      StyleChoice::
      StyleChoice (const ::std::string& v)
      : ::xml_schema::String (v)
      {
      }

      StyleChoice::
      StyleChoice (const ::xml_schema::String& v)
      : ::xml_schema::String (v)
      {
      }

      StyleChoice::
      StyleChoice (const StyleChoice& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
      : ::xml_schema::String (v, f, c)
      {
      }

      StyleChoice& StyleChoice::
      operator= (Value v)
      {
        static_cast< ::xml_schema::String& > (*this) = 
        ::xml_schema::String (_xsd_StyleChoice_literals_[v]);

        return *this;
      }


      // OperationType
      // 

      const OperationType::SoapActionOptional& OperationType::
      getSoapAction () const
      {
        return this->soapAction_;
      }

      OperationType::SoapActionOptional& OperationType::
      getSoapAction ()
      {
        return this->soapAction_;
      }

      void OperationType::
      setSoapAction (const SoapActionType& x)
      {
        this->soapAction_.set (x);
      }

      void OperationType::
      setSoapAction (const SoapActionOptional& x)
      {
        this->soapAction_ = x;
      }

      void OperationType::
      setSoapAction (::std::unique_ptr< SoapActionType > x)
      {
        this->soapAction_.set (std::move (x));
      }

      const OperationType::StyleOptional& OperationType::
      getStyle () const
      {
        return this->style_;
      }

      OperationType::StyleOptional& OperationType::
      getStyle ()
      {
        return this->style_;
      }

      void OperationType::
      setStyle (const StyleType& x)
      {
        this->style_.set (x);
      }

      void OperationType::
      setStyle (const StyleOptional& x)
      {
        this->style_ = x;
      }

      void OperationType::
      setStyle (::std::unique_ptr< StyleType > x)
      {
        this->style_.set (std::move (x));
      }


      // BodyType
      // 

      const BodyType::EncodingStyleOptional& BodyType::
      getEncodingStyle () const
      {
        return this->encodingStyle_;
      }

      BodyType::EncodingStyleOptional& BodyType::
      getEncodingStyle ()
      {
        return this->encodingStyle_;
      }

      void BodyType::
      setEncodingStyle (const EncodingStyleType& x)
      {
        this->encodingStyle_.set (x);
      }

      void BodyType::
      setEncodingStyle (const EncodingStyleOptional& x)
      {
        this->encodingStyle_ = x;
      }

      void BodyType::
      setEncodingStyle (::std::unique_ptr< EncodingStyleType > x)
      {
        this->encodingStyle_.set (std::move (x));
      }

      const BodyType::PartsOptional& BodyType::
      getParts () const
      {
        return this->parts_;
      }

      BodyType::PartsOptional& BodyType::
      getParts ()
      {
        return this->parts_;
      }

      void BodyType::
      setParts (const PartsType& x)
      {
        this->parts_.set (x);
      }

      void BodyType::
      setParts (const PartsOptional& x)
      {
        this->parts_ = x;
      }

      void BodyType::
      setParts (::std::unique_ptr< PartsType > x)
      {
        this->parts_.set (std::move (x));
      }

      const BodyType::UseOptional& BodyType::
      getUse () const
      {
        return this->use_;
      }

      BodyType::UseOptional& BodyType::
      getUse ()
      {
        return this->use_;
      }

      void BodyType::
      setUse (const UseType& x)
      {
        this->use_.set (x);
      }

      void BodyType::
      setUse (const UseOptional& x)
      {
        this->use_ = x;
      }

      void BodyType::
      setUse (::std::unique_ptr< UseType > x)
      {
        this->use_.set (std::move (x));
      }

      const BodyType::NamespaceOptional& BodyType::
      getNamespace () const
      {
        return this->namespace__;
      }

      BodyType::NamespaceOptional& BodyType::
      getNamespace ()
      {
        return this->namespace__;
      }

      void BodyType::
      setNamespace (const NamespaceType& x)
      {
        this->namespace__.set (x);
      }

      void BodyType::
      setNamespace (const NamespaceOptional& x)
      {
        this->namespace__ = x;
      }

      void BodyType::
      setNamespace (::std::unique_ptr< NamespaceType > x)
      {
        this->namespace__.set (std::move (x));
      }


      // UseChoice
      // 

      UseChoice::
      UseChoice (Value v)
      : ::xml_schema::String (_xsd_UseChoice_literals_[v])
      {
      }

      UseChoice::
      UseChoice (const char* v)
      : ::xml_schema::String (v)
      {
      }

      UseChoice::
      UseChoice (const ::std::string& v)
      : ::xml_schema::String (v)
      {
      }

      UseChoice::
      UseChoice (const ::xml_schema::String& v)
      : ::xml_schema::String (v)
      {
      }

      UseChoice::
      UseChoice (const UseChoice& v,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::xml_schema::String (v, f, c)
      {
      }

      UseChoice& UseChoice::
      operator= (Value v)
      {
        static_cast< ::xml_schema::String& > (*this) = 
        ::xml_schema::String (_xsd_UseChoice_literals_[v]);

        return *this;
      }


      // FaultType
      // 


      // HeaderType
      // 

      const HeaderType::HeaderfaultType& HeaderType::
      getHeaderfault () const
      {
        return this->headerfault_.get ();
      }

      HeaderType::HeaderfaultType& HeaderType::
      getHeaderfault ()
      {
        return this->headerfault_.get ();
      }

      void HeaderType::
      setHeaderfault (const HeaderfaultType& x)
      {
        this->headerfault_.set (x);
      }

      void HeaderType::
      setHeaderfault (::std::unique_ptr< HeaderfaultType > x)
      {
        this->headerfault_.set (std::move (x));
      }

      const HeaderType::MessageType& HeaderType::
      getMessage () const
      {
        return this->message_.get ();
      }

      HeaderType::MessageType& HeaderType::
      getMessage ()
      {
        return this->message_.get ();
      }

      void HeaderType::
      setMessage (const MessageType& x)
      {
        this->message_.set (x);
      }

      void HeaderType::
      setMessage (::std::unique_ptr< MessageType > x)
      {
        this->message_.set (std::move (x));
      }

      const HeaderType::PartsType& HeaderType::
      getParts () const
      {
        return this->parts_.get ();
      }

      HeaderType::PartsType& HeaderType::
      getParts ()
      {
        return this->parts_.get ();
      }

      void HeaderType::
      setParts (const PartsType& x)
      {
        this->parts_.set (x);
      }

      void HeaderType::
      setParts (::std::unique_ptr< PartsType > x)
      {
        this->parts_.set (std::move (x));
      }

      const HeaderType::UseType& HeaderType::
      getUse () const
      {
        return this->use_.get ();
      }

      HeaderType::UseType& HeaderType::
      getUse ()
      {
        return this->use_.get ();
      }

      void HeaderType::
      setUse (const UseType& x)
      {
        this->use_.set (x);
      }

      void HeaderType::
      setUse (::std::unique_ptr< UseType > x)
      {
        this->use_.set (std::move (x));
      }

      const HeaderType::EncodingStyleOptional& HeaderType::
      getEncodingStyle () const
      {
        return this->encodingStyle_;
      }

      HeaderType::EncodingStyleOptional& HeaderType::
      getEncodingStyle ()
      {
        return this->encodingStyle_;
      }

      void HeaderType::
      setEncodingStyle (const EncodingStyleType& x)
      {
        this->encodingStyle_.set (x);
      }

      void HeaderType::
      setEncodingStyle (const EncodingStyleOptional& x)
      {
        this->encodingStyle_ = x;
      }

      void HeaderType::
      setEncodingStyle (::std::unique_ptr< EncodingStyleType > x)
      {
        this->encodingStyle_.set (std::move (x));
      }

      const HeaderType::NamespaceOptional& HeaderType::
      getNamespace () const
      {
        return this->namespace__;
      }

      HeaderType::NamespaceOptional& HeaderType::
      getNamespace ()
      {
        return this->namespace__;
      }

      void HeaderType::
      setNamespace (const NamespaceType& x)
      {
        this->namespace__.set (x);
      }

      void HeaderType::
      setNamespace (const NamespaceOptional& x)
      {
        this->namespace__ = x;
      }

      void HeaderType::
      setNamespace (::std::unique_ptr< NamespaceType > x)
      {
        this->namespace__.set (std::move (x));
      }


      // HeaderfaultType
      // 

      const HeaderfaultType::MessageType& HeaderfaultType::
      getMessage () const
      {
        return this->message_.get ();
      }

      HeaderfaultType::MessageType& HeaderfaultType::
      getMessage ()
      {
        return this->message_.get ();
      }

      void HeaderfaultType::
      setMessage (const MessageType& x)
      {
        this->message_.set (x);
      }

      void HeaderfaultType::
      setMessage (::std::unique_ptr< MessageType > x)
      {
        this->message_.set (std::move (x));
      }

      const HeaderfaultType::PartsType& HeaderfaultType::
      getParts () const
      {
        return this->parts_.get ();
      }

      HeaderfaultType::PartsType& HeaderfaultType::
      getParts ()
      {
        return this->parts_.get ();
      }

      void HeaderfaultType::
      setParts (const PartsType& x)
      {
        this->parts_.set (x);
      }

      void HeaderfaultType::
      setParts (::std::unique_ptr< PartsType > x)
      {
        this->parts_.set (std::move (x));
      }

      const HeaderfaultType::UseType& HeaderfaultType::
      getUse () const
      {
        return this->use_.get ();
      }

      HeaderfaultType::UseType& HeaderfaultType::
      getUse ()
      {
        return this->use_.get ();
      }

      void HeaderfaultType::
      setUse (const UseType& x)
      {
        this->use_.set (x);
      }

      void HeaderfaultType::
      setUse (::std::unique_ptr< UseType > x)
      {
        this->use_.set (std::move (x));
      }

      const HeaderfaultType::EncodingStyleOptional& HeaderfaultType::
      getEncodingStyle () const
      {
        return this->encodingStyle_;
      }

      HeaderfaultType::EncodingStyleOptional& HeaderfaultType::
      getEncodingStyle ()
      {
        return this->encodingStyle_;
      }

      void HeaderfaultType::
      setEncodingStyle (const EncodingStyleType& x)
      {
        this->encodingStyle_.set (x);
      }

      void HeaderfaultType::
      setEncodingStyle (const EncodingStyleOptional& x)
      {
        this->encodingStyle_ = x;
      }

      void HeaderfaultType::
      setEncodingStyle (::std::unique_ptr< EncodingStyleType > x)
      {
        this->encodingStyle_.set (std::move (x));
      }

      const HeaderfaultType::NamespaceOptional& HeaderfaultType::
      getNamespace () const
      {
        return this->namespace__;
      }

      HeaderfaultType::NamespaceOptional& HeaderfaultType::
      getNamespace ()
      {
        return this->namespace__;
      }

      void HeaderfaultType::
      setNamespace (const NamespaceType& x)
      {
        this->namespace__.set (x);
      }

      void HeaderfaultType::
      setNamespace (const NamespaceOptional& x)
      {
        this->namespace__ = x;
      }

      void HeaderfaultType::
      setNamespace (::std::unique_ptr< NamespaceType > x)
      {
        this->namespace__.set (std::move (x));
      }


      // AddressType
      // 

      const AddressType::LocationType& AddressType::
      getLocation () const
      {
        return this->location_.get ();
      }

      AddressType::LocationType& AddressType::
      getLocation ()
      {
        return this->location_.get ();
      }

      void AddressType::
      setLocation (const LocationType& x)
      {
        this->location_.set (x);
      }

      void AddressType::
      setLocation (::std::unique_ptr< LocationType > x)
      {
        this->location_.set (std::move (x));
      }
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace WS
{
  namespace WSDL
  {
    namespace SOAP_BINDING
    {
      // BindingType
      //

      BindingType::
      BindingType ()
      : ::xml_schema::Type (),
        transport_ (this),
        style_ (this)
      {
      }

      BindingType::
      BindingType (const BindingType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        transport_ (x.transport_, f, this),
        style_ (x.style_, f, this)
      {
      }

      BindingType::
      BindingType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        transport_ (this),
        style_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void BindingType::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "transport" && n.namespace_ ().empty ())
          {
            this->transport_.set (TransportTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "style" && n.namespace_ ().empty ())
          {
            this->style_.set (StyleTraits::create (i, f, this));
            continue;
          }
        }
      }

      BindingType* BindingType::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class BindingType (*this, f, c);
      }

      BindingType& BindingType::
      operator= (const BindingType& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->transport_ = x.transport_;
          this->style_ = x.style_;
        }

        return *this;
      }

      BindingType::
      ~BindingType ()
      {
      }

      static
      const ::xsd::cxx::tree::type_factory_initializer< 0, char, BindingType >
      _xsd_BindingType_type_factory_init (
        "bindingType",
        "http://schemas.xmlsoap.org/wsdl/soap12/");

      // StyleChoice
      //

      StyleChoice::
      StyleChoice (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
      : ::xml_schema::String (e, f, c)
      {
        _xsd_StyleChoice_convert ();
      }

      StyleChoice::
      StyleChoice (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
      : ::xml_schema::String (a, f, c)
      {
        _xsd_StyleChoice_convert ();
      }

      StyleChoice::
      StyleChoice (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
      : ::xml_schema::String (s, e, f, c)
      {
        _xsd_StyleChoice_convert ();
      }

      StyleChoice* StyleChoice::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class StyleChoice (*this, f, c);
      }

      StyleChoice::Value StyleChoice::
      _xsd_StyleChoice_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_StyleChoice_literals_);
        const Value* i (::std::lower_bound (
                          _xsd_StyleChoice_indexes_,
                          _xsd_StyleChoice_indexes_ + 2,
                          *this,
                          c));

        if (i == _xsd_StyleChoice_indexes_ + 2 || _xsd_StyleChoice_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const StyleChoice::
      _xsd_StyleChoice_literals_[2] =
      {
        "rpc",
        "document"
      };

      const StyleChoice::Value StyleChoice::
      _xsd_StyleChoice_indexes_[2] =
      {
        ::WS::WSDL::SOAP_BINDING::StyleChoice::document,
        ::WS::WSDL::SOAP_BINDING::StyleChoice::rpc
      };

      static
      const ::xsd::cxx::tree::type_factory_initializer< 0, char, StyleChoice >
      _xsd_StyleChoice_type_factory_init (
        "styleChoice",
        "http://schemas.xmlsoap.org/wsdl/soap12/");

      // OperationType
      //

      OperationType::
      OperationType ()
      : ::xml_schema::Type (),
        soapAction_ (this),
        style_ (this)
      {
      }

      OperationType::
      OperationType (const OperationType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        soapAction_ (x.soapAction_, f, this),
        style_ (x.style_, f, this)
      {
      }

      OperationType::
      OperationType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        soapAction_ (this),
        style_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void OperationType::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "soapAction" && n.namespace_ ().empty ())
          {
            this->soapAction_.set (SoapActionTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "style" && n.namespace_ ().empty ())
          {
            this->style_.set (StyleTraits::create (i, f, this));
            continue;
          }
        }
      }

      OperationType* OperationType::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class OperationType (*this, f, c);
      }

      OperationType& OperationType::
      operator= (const OperationType& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->soapAction_ = x.soapAction_;
          this->style_ = x.style_;
        }

        return *this;
      }

      OperationType::
      ~OperationType ()
      {
      }

      static
      const ::xsd::cxx::tree::type_factory_initializer< 0, char, OperationType >
      _xsd_OperationType_type_factory_init (
        "operationType",
        "http://schemas.xmlsoap.org/wsdl/soap12/");

      // BodyType
      //

      BodyType::
      BodyType ()
      : ::xml_schema::Type (),
        encodingStyle_ (this),
        parts_ (this),
        use_ (this),
        namespace__ (this)
      {
      }

      BodyType::
      BodyType (const BodyType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        encodingStyle_ (x.encodingStyle_, f, this),
        parts_ (x.parts_, f, this),
        use_ (x.use_, f, this),
        namespace__ (x.namespace__, f, this)
      {
      }

      BodyType::
      BodyType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        encodingStyle_ (this),
        parts_ (this),
        use_ (this),
        namespace__ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void BodyType::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "encodingStyle" && n.namespace_ ().empty ())
          {
            this->encodingStyle_.set (EncodingStyleTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "parts" && n.namespace_ ().empty ())
          {
            this->parts_.set (PartsTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "use" && n.namespace_ ().empty ())
          {
            this->use_.set (UseTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "namespace" && n.namespace_ ().empty ())
          {
            this->namespace__.set (NamespaceTraits::create (i, f, this));
            continue;
          }
        }
      }

      BodyType* BodyType::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class BodyType (*this, f, c);
      }

      BodyType& BodyType::
      operator= (const BodyType& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->encodingStyle_ = x.encodingStyle_;
          this->parts_ = x.parts_;
          this->use_ = x.use_;
          this->namespace__ = x.namespace__;
        }

        return *this;
      }

      BodyType::
      ~BodyType ()
      {
      }

      static
      const ::xsd::cxx::tree::type_factory_initializer< 0, char, BodyType >
      _xsd_BodyType_type_factory_init (
        "bodyType",
        "http://schemas.xmlsoap.org/wsdl/soap12/");

      // UseChoice
      //

      UseChoice::
      UseChoice (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::xml_schema::String (e, f, c)
      {
        _xsd_UseChoice_convert ();
      }

      UseChoice::
      UseChoice (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::xml_schema::String (a, f, c)
      {
        _xsd_UseChoice_convert ();
      }

      UseChoice::
      UseChoice (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::xml_schema::String (s, e, f, c)
      {
        _xsd_UseChoice_convert ();
      }

      UseChoice* UseChoice::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class UseChoice (*this, f, c);
      }

      UseChoice::Value UseChoice::
      _xsd_UseChoice_convert () const
      {
        ::xsd::cxx::tree::enum_comparator< char > c (_xsd_UseChoice_literals_);
        const Value* i (::std::lower_bound (
                          _xsd_UseChoice_indexes_,
                          _xsd_UseChoice_indexes_ + 2,
                          *this,
                          c));

        if (i == _xsd_UseChoice_indexes_ + 2 || _xsd_UseChoice_literals_[*i] != *this)
        {
          throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
        }

        return *i;
      }

      const char* const UseChoice::
      _xsd_UseChoice_literals_[2] =
      {
        "literal",
        "encoded"
      };

      const UseChoice::Value UseChoice::
      _xsd_UseChoice_indexes_[2] =
      {
        ::WS::WSDL::SOAP_BINDING::UseChoice::encoded,
        ::WS::WSDL::SOAP_BINDING::UseChoice::literal
      };

      static
      const ::xsd::cxx::tree::type_factory_initializer< 0, char, UseChoice >
      _xsd_UseChoice_type_factory_init (
        "useChoice",
        "http://schemas.xmlsoap.org/wsdl/soap12/");

      // FaultType
      //

      FaultType::
      FaultType ()
      : ::WS::WSDL::SOAP_BINDING::BodyType ()
      {
      }

      FaultType::
      FaultType (const FaultType& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::WS::WSDL::SOAP_BINDING::BodyType (x, f, c)
      {
      }

      FaultType::
      FaultType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
      : ::WS::WSDL::SOAP_BINDING::BodyType (e, f, c)
      {
      }

      FaultType* FaultType::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class FaultType (*this, f, c);
      }

      FaultType::
      ~FaultType ()
      {
      }

      static
      const ::xsd::cxx::tree::type_factory_initializer< 0, char, FaultType >
      _xsd_FaultType_type_factory_init (
        "faultType",
        "http://schemas.xmlsoap.org/wsdl/soap12/");

      // HeaderType
      //

      HeaderType::
      HeaderType (const HeaderfaultType& headerfault,
                  const MessageType& message,
                  const PartsType& parts,
                  const UseType& use)
      : ::xml_schema::Type (),
        headerfault_ (headerfault, this),
        message_ (message, this),
        parts_ (parts, this),
        use_ (use, this),
        encodingStyle_ (this),
        namespace__ (this)
      {
      }

      HeaderType::
      HeaderType (::std::unique_ptr< HeaderfaultType > headerfault,
                  const MessageType& message,
                  const PartsType& parts,
                  const UseType& use)
      : ::xml_schema::Type (),
        headerfault_ (std::move (headerfault), this),
        message_ (message, this),
        parts_ (parts, this),
        use_ (use, this),
        encodingStyle_ (this),
        namespace__ (this)
      {
      }

      HeaderType::
      HeaderType (const HeaderType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        headerfault_ (x.headerfault_, f, this),
        message_ (x.message_, f, this),
        parts_ (x.parts_, f, this),
        use_ (x.use_, f, this),
        encodingStyle_ (x.encodingStyle_, f, this),
        namespace__ (x.namespace__, f, this)
      {
      }

      HeaderType::
      HeaderType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        headerfault_ (this),
        message_ (this),
        parts_ (this),
        use_ (this),
        encodingStyle_ (this),
        namespace__ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
          this->parse (p, f);
        }
      }

      void HeaderType::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        for (; p.more_content (); p.next_content (false))
        {
          const ::xercesc::DOMElement& i (p.cur_element ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          // headerfault
          //
          {
            ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
              ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
                "headerfault",
                "http://schemas.xmlsoap.org/wsdl/soap12/",
                &::xsd::cxx::tree::factory_impl< HeaderfaultType >,
                true, true, i, n, f, this));

            if (tmp.get () != 0)
            {
              if (!headerfault_.present ())
              {
                ::std::unique_ptr< HeaderfaultType > r (
                  dynamic_cast< HeaderfaultType* > (tmp.get ()));

                if (r.get ())
                  tmp.release ();
                else
                  throw ::xsd::cxx::tree::not_derived< char > ();

                this->headerfault_.set (::std::move (r));
                continue;
              }
            }
          }

          break;
        }

        if (!headerfault_.present ())
        {
          throw ::xsd::cxx::tree::expected_element< char > (
            "headerfault",
            "http://schemas.xmlsoap.org/wsdl/soap12/");
        }

        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "message" && n.namespace_ ().empty ())
          {
            this->message_.set (MessageTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "parts" && n.namespace_ ().empty ())
          {
            this->parts_.set (PartsTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "use" && n.namespace_ ().empty ())
          {
            this->use_.set (UseTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "encodingStyle" && n.namespace_ ().empty ())
          {
            this->encodingStyle_.set (EncodingStyleTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "namespace" && n.namespace_ ().empty ())
          {
            this->namespace__.set (NamespaceTraits::create (i, f, this));
            continue;
          }
        }

        if (!message_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "message",
            "");
        }

        if (!parts_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "parts",
            "");
        }

        if (!use_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "use",
            "");
        }
      }

      HeaderType* HeaderType::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class HeaderType (*this, f, c);
      }

      HeaderType& HeaderType::
      operator= (const HeaderType& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->headerfault_ = x.headerfault_;
          this->message_ = x.message_;
          this->parts_ = x.parts_;
          this->use_ = x.use_;
          this->encodingStyle_ = x.encodingStyle_;
          this->namespace__ = x.namespace__;
        }

        return *this;
      }

      HeaderType::
      ~HeaderType ()
      {
      }

      static
      const ::xsd::cxx::tree::type_factory_initializer< 0, char, HeaderType >
      _xsd_HeaderType_type_factory_init (
        "headerType",
        "http://schemas.xmlsoap.org/wsdl/soap12/");

      // HeaderfaultType
      //

      HeaderfaultType::
      HeaderfaultType (const MessageType& message,
                       const PartsType& parts,
                       const UseType& use)
      : ::xml_schema::Type (),
        message_ (message, this),
        parts_ (parts, this),
        use_ (use, this),
        encodingStyle_ (this),
        namespace__ (this)
      {
      }

      HeaderfaultType::
      HeaderfaultType (const HeaderfaultType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        message_ (x.message_, f, this),
        parts_ (x.parts_, f, this),
        use_ (x.use_, f, this),
        encodingStyle_ (x.encodingStyle_, f, this),
        namespace__ (x.namespace__, f, this)
      {
      }

      HeaderfaultType::
      HeaderfaultType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        message_ (this),
        parts_ (this),
        use_ (this),
        encodingStyle_ (this),
        namespace__ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void HeaderfaultType::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "message" && n.namespace_ ().empty ())
          {
            this->message_.set (MessageTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "parts" && n.namespace_ ().empty ())
          {
            this->parts_.set (PartsTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "use" && n.namespace_ ().empty ())
          {
            this->use_.set (UseTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "encodingStyle" && n.namespace_ ().empty ())
          {
            this->encodingStyle_.set (EncodingStyleTraits::create (i, f, this));
            continue;
          }

          if (n.name () == "namespace" && n.namespace_ ().empty ())
          {
            this->namespace__.set (NamespaceTraits::create (i, f, this));
            continue;
          }
        }

        if (!message_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "message",
            "");
        }

        if (!parts_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "parts",
            "");
        }

        if (!use_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "use",
            "");
        }
      }

      HeaderfaultType* HeaderfaultType::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class HeaderfaultType (*this, f, c);
      }

      HeaderfaultType& HeaderfaultType::
      operator= (const HeaderfaultType& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->message_ = x.message_;
          this->parts_ = x.parts_;
          this->use_ = x.use_;
          this->encodingStyle_ = x.encodingStyle_;
          this->namespace__ = x.namespace__;
        }

        return *this;
      }

      HeaderfaultType::
      ~HeaderfaultType ()
      {
      }

      static
      const ::xsd::cxx::tree::type_factory_initializer< 0, char, HeaderfaultType >
      _xsd_HeaderfaultType_type_factory_init (
        "headerfaultType",
        "http://schemas.xmlsoap.org/wsdl/soap12/");

      // AddressType
      //

      AddressType::
      AddressType (const LocationType& location)
      : ::xml_schema::Type (),
        location_ (location, this)
      {
      }

      AddressType::
      AddressType (const AddressType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
      : ::xml_schema::Type (x, f, c),
        location_ (x.location_, f, this)
      {
      }

      AddressType::
      AddressType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
      : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
        location_ (this)
      {
        if ((f & ::xml_schema::Flags::base) == 0)
        {
          ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
          this->parse (p, f);
        }
      }

      void AddressType::
      parse (::xsd::cxx::xml::dom::parser< char >& p,
             ::xml_schema::Flags f)
      {
        while (p.more_attributes ())
        {
          const ::xercesc::DOMAttr& i (p.next_attribute ());
          const ::xsd::cxx::xml::qualified_name< char > n (
            ::xsd::cxx::xml::dom::name< char > (i));

          if (n.name () == "location" && n.namespace_ ().empty ())
          {
            this->location_.set (LocationTraits::create (i, f, this));
            continue;
          }
        }

        if (!location_.present ())
        {
          throw ::xsd::cxx::tree::expected_attribute< char > (
            "location",
            "");
        }
      }

      AddressType* AddressType::
      _clone (::xml_schema::Flags f,
              ::xml_schema::Container* c) const
      {
        return new class AddressType (*this, f, c);
      }

      AddressType& AddressType::
      operator= (const AddressType& x)
      {
        if (this != &x)
        {
          static_cast< ::xml_schema::Type& > (*this) = x;
          this->location_ = x.location_;
        }

        return *this;
      }

      AddressType::
      ~AddressType ()
      {
      }

      static
      const ::xsd::cxx::tree::type_factory_initializer< 0, char, AddressType >
      _xsd_AddressType_type_factory_init (
        "addressType",
        "http://schemas.xmlsoap.org/wsdl/soap12/");
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace WS
{
  namespace WSDL
  {
    namespace SOAP_BINDING
    {
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace WS
{
  namespace WSDL
  {
    namespace SOAP_BINDING
    {
      void
      operator<< (::xercesc::DOMElement& e, const BindingType& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // transport
        //
        if (i.getTransport ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "transport",
              e));

          a << *i.getTransport ();
        }

        // style
        //
        if (i.getStyle ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "style",
              e));

          a << *i.getStyle ();
        }
      }

      static
      const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BindingType >
      _xsd_BindingType_type_serializer_init (
        "bindingType",
        "http://schemas.xmlsoap.org/wsdl/soap12/");


      void
      operator<< (::xercesc::DOMElement& e, const StyleChoice& i)
      {
        e << static_cast< const ::xml_schema::String& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const StyleChoice& i)
      {
        a << static_cast< const ::xml_schema::String& > (i);
      }

      void
      operator<< (::xml_schema::ListStream& l,
                  const StyleChoice& i)
      {
        l << static_cast< const ::xml_schema::String& > (i);
      }

      static
      const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StyleChoice >
      _xsd_StyleChoice_type_serializer_init (
        "styleChoice",
        "http://schemas.xmlsoap.org/wsdl/soap12/");


      void
      operator<< (::xercesc::DOMElement& e, const OperationType& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // soapAction
        //
        if (i.getSoapAction ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "soapAction",
              e));

          a << *i.getSoapAction ();
        }

        // style
        //
        if (i.getStyle ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "style",
              e));

          a << *i.getStyle ();
        }
      }

      static
      const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OperationType >
      _xsd_OperationType_type_serializer_init (
        "operationType",
        "http://schemas.xmlsoap.org/wsdl/soap12/");


      void
      operator<< (::xercesc::DOMElement& e, const BodyType& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // encodingStyle
        //
        if (i.getEncodingStyle ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "encodingStyle",
              e));

          a << *i.getEncodingStyle ();
        }

        // parts
        //
        if (i.getParts ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "parts",
              e));

          a << *i.getParts ();
        }

        // use
        //
        if (i.getUse ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "use",
              e));

          a << *i.getUse ();
        }

        // namespace
        //
        if (i.getNamespace ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "namespace",
              e));

          a << *i.getNamespace ();
        }
      }

      static
      const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BodyType >
      _xsd_BodyType_type_serializer_init (
        "bodyType",
        "http://schemas.xmlsoap.org/wsdl/soap12/");


      void
      operator<< (::xercesc::DOMElement& e, const UseChoice& i)
      {
        e << static_cast< const ::xml_schema::String& > (i);
      }

      void
      operator<< (::xercesc::DOMAttr& a, const UseChoice& i)
      {
        a << static_cast< const ::xml_schema::String& > (i);
      }

      void
      operator<< (::xml_schema::ListStream& l,
                  const UseChoice& i)
      {
        l << static_cast< const ::xml_schema::String& > (i);
      }

      static
      const ::xsd::cxx::tree::type_serializer_initializer< 0, char, UseChoice >
      _xsd_UseChoice_type_serializer_init (
        "useChoice",
        "http://schemas.xmlsoap.org/wsdl/soap12/");


      void
      operator<< (::xercesc::DOMElement& e, const FaultType& i)
      {
        e << static_cast< const ::WS::WSDL::SOAP_BINDING::BodyType& > (i);
      }

      static
      const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FaultType >
      _xsd_FaultType_type_serializer_init (
        "faultType",
        "http://schemas.xmlsoap.org/wsdl/soap12/");


      void
      operator<< (::xercesc::DOMElement& e, const HeaderType& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // headerfault
        //
        {
          ::xsd::cxx::tree::type_serializer_map< char >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

          const HeaderType::HeaderfaultType& x (i.getHeaderfault ());
          if (typeid (HeaderType::HeaderfaultType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "headerfault",
                "http://schemas.xmlsoap.org/wsdl/soap12/",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "headerfault",
              "http://schemas.xmlsoap.org/wsdl/soap12/",
              true, true, e, x);
        }

        // message
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "message",
              e));

          a << i.getMessage ();
        }

        // parts
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "parts",
              e));

          a << i.getParts ();
        }

        // use
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "use",
              e));

          a << i.getUse ();
        }

        // encodingStyle
        //
        if (i.getEncodingStyle ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "encodingStyle",
              e));

          a << *i.getEncodingStyle ();
        }

        // namespace
        //
        if (i.getNamespace ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "namespace",
              e));

          a << *i.getNamespace ();
        }
      }

      static
      const ::xsd::cxx::tree::type_serializer_initializer< 0, char, HeaderType >
      _xsd_HeaderType_type_serializer_init (
        "headerType",
        "http://schemas.xmlsoap.org/wsdl/soap12/");


      void
      operator<< (::xercesc::DOMElement& e, const HeaderfaultType& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // message
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "message",
              e));

          a << i.getMessage ();
        }

        // parts
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "parts",
              e));

          a << i.getParts ();
        }

        // use
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "use",
              e));

          a << i.getUse ();
        }

        // encodingStyle
        //
        if (i.getEncodingStyle ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "encodingStyle",
              e));

          a << *i.getEncodingStyle ();
        }

        // namespace
        //
        if (i.getNamespace ())
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "namespace",
              e));

          a << *i.getNamespace ();
        }
      }

      static
      const ::xsd::cxx::tree::type_serializer_initializer< 0, char, HeaderfaultType >
      _xsd_HeaderfaultType_type_serializer_init (
        "headerfaultType",
        "http://schemas.xmlsoap.org/wsdl/soap12/");


      void
      operator<< (::xercesc::DOMElement& e, const AddressType& i)
      {
        e << static_cast< const ::xml_schema::Type& > (i);

        // location
        //
        {
          ::xercesc::DOMAttr& a (
            ::xsd::cxx::xml::dom::create_attribute (
              "location",
              e));

          a << i.getLocation ();
        }
      }

      static
      const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AddressType >
      _xsd_AddressType_type_serializer_init (
        "addressType",
        "http://schemas.xmlsoap.org/wsdl/soap12/");
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

