// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "DataModel/wsdl-custom.hxx"

namespace WS
{
  namespace WSDL
  {
    // TDocumentation
    // 


    // TDocumented
    // 

    const TDocumented::DocumentationOptional& TDocumented::
    getDocumentation () const
    {
      return this->documentation_;
    }

    TDocumented::DocumentationOptional& TDocumented::
    getDocumentation ()
    {
      return this->documentation_;
    }

    void TDocumented::
    setDocumentation (const DocumentationType& x)
    {
      this->documentation_.set (x);
    }

    void TDocumented::
    setDocumentation (const DocumentationOptional& x)
    {
      this->documentation_ = x;
    }

    void TDocumented::
    setDocumentation (::std::unique_ptr< DocumentationType > x)
    {
      this->documentation_.set (std::move (x));
    }


    // TExtensibleAttributesDocumented
    // 


    // TExtensibleDocumented
    // 


    // TDefinitions
    // 

    const TDefinitions::ImportSequence& TDefinitions::
    getImport () const
    {
      return this->import_;
    }

    TDefinitions::ImportSequence& TDefinitions::
    getImport ()
    {
      return this->import_;
    }

    void TDefinitions::
    setImport (const ImportSequence& s)
    {
      this->import_ = s;
    }

    const TDefinitions::TypesSequence& TDefinitions::
    getTypes () const
    {
      return this->types_;
    }

    TDefinitions::TypesSequence& TDefinitions::
    getTypes ()
    {
      return this->types_;
    }

    void TDefinitions::
    setTypes (const TypesSequence& s)
    {
      this->types_ = s;
    }

    const TDefinitions::MessageSequence& TDefinitions::
    getMessage () const
    {
      return this->message_;
    }

    TDefinitions::MessageSequence& TDefinitions::
    getMessage ()
    {
      return this->message_;
    }

    void TDefinitions::
    setMessage (const MessageSequence& s)
    {
      this->message_ = s;
    }

    const TDefinitions::PortTypeSequence& TDefinitions::
    getPortType () const
    {
      return this->portType_;
    }

    TDefinitions::PortTypeSequence& TDefinitions::
    getPortType ()
    {
      return this->portType_;
    }

    void TDefinitions::
    setPortType (const PortTypeSequence& s)
    {
      this->portType_ = s;
    }

    const TDefinitions::BindingSequence& TDefinitions::
    getBinding () const
    {
      return this->binding_;
    }

    TDefinitions::BindingSequence& TDefinitions::
    getBinding ()
    {
      return this->binding_;
    }

    void TDefinitions::
    setBinding (const BindingSequence& s)
    {
      this->binding_ = s;
    }

    const TDefinitions::ServiceSequence& TDefinitions::
    getService () const
    {
      return this->service_;
    }

    TDefinitions::ServiceSequence& TDefinitions::
    getService ()
    {
      return this->service_;
    }

    void TDefinitions::
    setService (const ServiceSequence& s)
    {
      this->service_ = s;
    }

    const TDefinitions::TargetNamespaceOptional& TDefinitions::
    getTargetNamespace () const
    {
      return this->targetNamespace_;
    }

    TDefinitions::TargetNamespaceOptional& TDefinitions::
    getTargetNamespace ()
    {
      return this->targetNamespace_;
    }

    void TDefinitions::
    setTargetNamespace (const TargetNamespaceType& x)
    {
      this->targetNamespace_.set (x);
    }

    void TDefinitions::
    setTargetNamespace (const TargetNamespaceOptional& x)
    {
      this->targetNamespace_ = x;
    }

    void TDefinitions::
    setTargetNamespace (::std::unique_ptr< TargetNamespaceType > x)
    {
      this->targetNamespace_.set (std::move (x));
    }

    const TDefinitions::NameOptional& TDefinitions::
    getName () const
    {
      return this->name_;
    }

    TDefinitions::NameOptional& TDefinitions::
    getName ()
    {
      return this->name_;
    }

    void TDefinitions::
    setName (const NameType& x)
    {
      this->name_.set (x);
    }

    void TDefinitions::
    setName (const NameOptional& x)
    {
      this->name_ = x;
    }

    void TDefinitions::
    setName (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }


    // TImport
    // 

    const TImport::NamespaceType& TImport::
    getNamespace () const
    {
      return this->namespace__.get ();
    }

    TImport::NamespaceType& TImport::
    getNamespace ()
    {
      return this->namespace__.get ();
    }

    void TImport::
    setNamespace (const NamespaceType& x)
    {
      this->namespace__.set (x);
    }

    void TImport::
    setNamespace (::std::unique_ptr< NamespaceType > x)
    {
      this->namespace__.set (std::move (x));
    }

    const TImport::LocationType& TImport::
    getLocation () const
    {
      return this->location_.get ();
    }

    TImport::LocationType& TImport::
    getLocation ()
    {
      return this->location_.get ();
    }

    void TImport::
    setLocation (const LocationType& x)
    {
      this->location_.set (x);
    }

    void TImport::
    setLocation (::std::unique_ptr< LocationType > x)
    {
      this->location_.set (std::move (x));
    }


    // TTypes
    // 


    // TMessage
    // 

    const TMessage::PartSequence& TMessage::
    getPart () const
    {
      return this->part_;
    }

    TMessage::PartSequence& TMessage::
    getPart ()
    {
      return this->part_;
    }

    void TMessage::
    setPart (const PartSequence& s)
    {
      this->part_ = s;
    }

    const TMessage::NameType& TMessage::
    getName () const
    {
      return this->name_.get ();
    }

    TMessage::NameType& TMessage::
    getName ()
    {
      return this->name_.get ();
    }

    void TMessage::
    setName (const NameType& x)
    {
      this->name_.set (x);
    }

    void TMessage::
    setName (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }


    // TPart
    // 

    const TPart::NameType& TPart::
    getName () const
    {
      return this->name_.get ();
    }

    TPart::NameType& TPart::
    getName ()
    {
      return this->name_.get ();
    }

    void TPart::
    setName (const NameType& x)
    {
      this->name_.set (x);
    }

    void TPart::
    setName (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const TPart::ElementOptional& TPart::
    getElement () const
    {
      return this->element_;
    }

    TPart::ElementOptional& TPart::
    getElement ()
    {
      return this->element_;
    }

    void TPart::
    setElement (const ElementType& x)
    {
      this->element_.set (x);
    }

    void TPart::
    setElement (const ElementOptional& x)
    {
      this->element_ = x;
    }

    void TPart::
    setElement (::std::unique_ptr< ElementType > x)
    {
      this->element_.set (std::move (x));
    }

    const TPart::TypeOptional& TPart::
    getType () const
    {
      return this->type_;
    }

    TPart::TypeOptional& TPart::
    getType ()
    {
      return this->type_;
    }

    void TPart::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void TPart::
    setType (const TypeOptional& x)
    {
      this->type_ = x;
    }

    void TPart::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }


    // TPortType
    // 

    const TPortType::OperationSequence& TPortType::
    getOperation () const
    {
      return this->operation_;
    }

    TPortType::OperationSequence& TPortType::
    getOperation ()
    {
      return this->operation_;
    }

    void TPortType::
    setOperation (const OperationSequence& s)
    {
      this->operation_ = s;
    }

    const TPortType::PolicyOptional& TPortType::
    getPolicy () const
    {
      return this->Policy_;
    }

    TPortType::PolicyOptional& TPortType::
    getPolicy ()
    {
      return this->Policy_;
    }

    void TPortType::
    setPolicy (const PolicyType& x)
    {
      this->Policy_.set (x);
    }

    void TPortType::
    setPolicy (const PolicyOptional& x)
    {
      this->Policy_ = x;
    }

    void TPortType::
    setPolicy (::std::unique_ptr< PolicyType > x)
    {
      this->Policy_.set (std::move (x));
    }

    const TPortType::NameType& TPortType::
    getName () const
    {
      return this->name_.get ();
    }

    TPortType::NameType& TPortType::
    getName ()
    {
      return this->name_.get ();
    }

    void TPortType::
    setName (const NameType& x)
    {
      this->name_.set (x);
    }

    void TPortType::
    setName (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const TPortType::EventSourceOptional& TPortType::
    getEventSource () const
    {
      return this->EventSource_;
    }

    TPortType::EventSourceOptional& TPortType::
    getEventSource ()
    {
      return this->EventSource_;
    }

    void TPortType::
    setEventSource (const EventSourceType& x)
    {
      this->EventSource_.set (x);
    }

    void TPortType::
    setEventSource (const EventSourceOptional& x)
    {
      this->EventSource_ = x;
    }


    // TOperation
    // 

    const TOperation::InputOptional& TOperation::
    getInput () const
    {
      return this->input_;
    }

    TOperation::InputOptional& TOperation::
    getInput ()
    {
      return this->input_;
    }

    void TOperation::
    setInput (const InputType& x)
    {
      this->input_.set (x);
    }

    void TOperation::
    setInput (const InputOptional& x)
    {
      this->input_ = x;
    }

    void TOperation::
    setInput (::std::unique_ptr< InputType > x)
    {
      this->input_.set (std::move (x));
    }

    const TOperation::OutputOptional& TOperation::
    getOutput () const
    {
      return this->output_;
    }

    TOperation::OutputOptional& TOperation::
    getOutput ()
    {
      return this->output_;
    }

    void TOperation::
    setOutput (const OutputType& x)
    {
      this->output_.set (x);
    }

    void TOperation::
    setOutput (const OutputOptional& x)
    {
      this->output_ = x;
    }

    void TOperation::
    setOutput (::std::unique_ptr< OutputType > x)
    {
      this->output_.set (std::move (x));
    }

    const TOperation::FaultSequence& TOperation::
    getFault () const
    {
      return this->fault_;
    }

    TOperation::FaultSequence& TOperation::
    getFault ()
    {
      return this->fault_;
    }

    void TOperation::
    setFault (const FaultSequence& s)
    {
      this->fault_ = s;
    }

    const TOperation::NameType& TOperation::
    getName () const
    {
      return this->name_.get ();
    }

    TOperation::NameType& TOperation::
    getName ()
    {
      return this->name_.get ();
    }

    void TOperation::
    setName (const NameType& x)
    {
      this->name_.set (x);
    }

    void TOperation::
    setName (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const TOperation::ParameterOrderOptional& TOperation::
    getParameterOrder () const
    {
      return this->parameterOrder_;
    }

    TOperation::ParameterOrderOptional& TOperation::
    getParameterOrder ()
    {
      return this->parameterOrder_;
    }

    void TOperation::
    setParameterOrder (const ParameterOrderType& x)
    {
      this->parameterOrder_.set (x);
    }

    void TOperation::
    setParameterOrder (const ParameterOrderOptional& x)
    {
      this->parameterOrder_ = x;
    }

    void TOperation::
    setParameterOrder (::std::unique_ptr< ParameterOrderType > x)
    {
      this->parameterOrder_.set (std::move (x));
    }


    // TParam
    // 

    const TParam::NameOptional& TParam::
    getName () const
    {
      return this->name_;
    }

    TParam::NameOptional& TParam::
    getName ()
    {
      return this->name_;
    }

    void TParam::
    setName (const NameType& x)
    {
      this->name_.set (x);
    }

    void TParam::
    setName (const NameOptional& x)
    {
      this->name_ = x;
    }

    void TParam::
    setName (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const TParam::MessageType& TParam::
    getMessage () const
    {
      return this->message_.get ();
    }

    TParam::MessageType& TParam::
    getMessage ()
    {
      return this->message_.get ();
    }

    void TParam::
    setMessage (const MessageType& x)
    {
      this->message_.set (x);
    }

    void TParam::
    setMessage (::std::unique_ptr< MessageType > x)
    {
      this->message_.set (std::move (x));
    }

    const TParam::ActionOptional& TParam::
    getAction () const
    {
      return this->Action_;
    }

    TParam::ActionOptional& TParam::
    getAction ()
    {
      return this->Action_;
    }

    void TParam::
    setAction (const ActionType& x)
    {
      this->Action_.set (x);
    }

    void TParam::
    setAction (const ActionOptional& x)
    {
      this->Action_ = x;
    }

    void TParam::
    setAction (::std::unique_ptr< ActionType > x)
    {
      this->Action_.set (std::move (x));
    }


    // TFault
    // 

    const TFault::NameType& TFault::
    getName () const
    {
      return this->name_.get ();
    }

    TFault::NameType& TFault::
    getName ()
    {
      return this->name_.get ();
    }

    void TFault::
    setName (const NameType& x)
    {
      this->name_.set (x);
    }

    void TFault::
    setName (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const TFault::MessageType& TFault::
    getMessage () const
    {
      return this->message_.get ();
    }

    TFault::MessageType& TFault::
    getMessage ()
    {
      return this->message_.get ();
    }

    void TFault::
    setMessage (const MessageType& x)
    {
      this->message_.set (x);
    }

    void TFault::
    setMessage (::std::unique_ptr< MessageType > x)
    {
      this->message_.set (std::move (x));
    }


    // TBinding
    // 

    const TBinding::BindingType& TBinding::
    getBinding () const
    {
      return this->binding_.get ();
    }

    TBinding::BindingType& TBinding::
    getBinding ()
    {
      return this->binding_.get ();
    }

    void TBinding::
    setBinding (const BindingType& x)
    {
      this->binding_.set (x);
    }

    void TBinding::
    setBinding (::std::unique_ptr< BindingType > x)
    {
      this->binding_.set (std::move (x));
    }

    const TBinding::OperationSequence& TBinding::
    getOperation () const
    {
      return this->operation_;
    }

    TBinding::OperationSequence& TBinding::
    getOperation ()
    {
      return this->operation_;
    }

    void TBinding::
    setOperation (const OperationSequence& s)
    {
      this->operation_ = s;
    }

    const TBinding::NameType& TBinding::
    getName () const
    {
      return this->name_.get ();
    }

    TBinding::NameType& TBinding::
    getName ()
    {
      return this->name_.get ();
    }

    void TBinding::
    setName (const NameType& x)
    {
      this->name_.set (x);
    }

    void TBinding::
    setName (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const TBinding::TypeType& TBinding::
    getType () const
    {
      return this->type_.get ();
    }

    TBinding::TypeType& TBinding::
    getType ()
    {
      return this->type_.get ();
    }

    void TBinding::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void TBinding::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }


    // TBindingOperationMessage
    // 

    const TBindingOperationMessage::BodyType& TBindingOperationMessage::
    getBody () const
    {
      return this->body_.get ();
    }

    TBindingOperationMessage::BodyType& TBindingOperationMessage::
    getBody ()
    {
      return this->body_.get ();
    }

    void TBindingOperationMessage::
    setBody (const BodyType& x)
    {
      this->body_.set (x);
    }

    void TBindingOperationMessage::
    setBody (::std::unique_ptr< BodyType > x)
    {
      this->body_.set (std::move (x));
    }

    const TBindingOperationMessage::NameOptional& TBindingOperationMessage::
    getName () const
    {
      return this->name_;
    }

    TBindingOperationMessage::NameOptional& TBindingOperationMessage::
    getName ()
    {
      return this->name_;
    }

    void TBindingOperationMessage::
    setName (const NameType& x)
    {
      this->name_.set (x);
    }

    void TBindingOperationMessage::
    setName (const NameOptional& x)
    {
      this->name_ = x;
    }

    void TBindingOperationMessage::
    setName (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }


    // TBindingOperationFault
    // 

    const TBindingOperationFault::NameType& TBindingOperationFault::
    getName () const
    {
      return this->name_.get ();
    }

    TBindingOperationFault::NameType& TBindingOperationFault::
    getName ()
    {
      return this->name_.get ();
    }

    void TBindingOperationFault::
    setName (const NameType& x)
    {
      this->name_.set (x);
    }

    void TBindingOperationFault::
    setName (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }


    // TBindingOperation
    // 

    const TBindingOperation::OperationType& TBindingOperation::
    getOperation () const
    {
      return this->operation_.get ();
    }

    TBindingOperation::OperationType& TBindingOperation::
    getOperation ()
    {
      return this->operation_.get ();
    }

    void TBindingOperation::
    setOperation (const OperationType& x)
    {
      this->operation_.set (x);
    }

    void TBindingOperation::
    setOperation (::std::unique_ptr< OperationType > x)
    {
      this->operation_.set (std::move (x));
    }

    const TBindingOperation::InputOptional& TBindingOperation::
    getInput () const
    {
      return this->input_;
    }

    TBindingOperation::InputOptional& TBindingOperation::
    getInput ()
    {
      return this->input_;
    }

    void TBindingOperation::
    setInput (const InputType& x)
    {
      this->input_.set (x);
    }

    void TBindingOperation::
    setInput (const InputOptional& x)
    {
      this->input_ = x;
    }

    void TBindingOperation::
    setInput (::std::unique_ptr< InputType > x)
    {
      this->input_.set (std::move (x));
    }

    const TBindingOperation::OutputOptional& TBindingOperation::
    getOutput () const
    {
      return this->output_;
    }

    TBindingOperation::OutputOptional& TBindingOperation::
    getOutput ()
    {
      return this->output_;
    }

    void TBindingOperation::
    setOutput (const OutputType& x)
    {
      this->output_.set (x);
    }

    void TBindingOperation::
    setOutput (const OutputOptional& x)
    {
      this->output_ = x;
    }

    void TBindingOperation::
    setOutput (::std::unique_ptr< OutputType > x)
    {
      this->output_.set (std::move (x));
    }

    const TBindingOperation::FaultSequence& TBindingOperation::
    getFault () const
    {
      return this->fault_;
    }

    TBindingOperation::FaultSequence& TBindingOperation::
    getFault ()
    {
      return this->fault_;
    }

    void TBindingOperation::
    setFault (const FaultSequence& s)
    {
      this->fault_ = s;
    }

    const TBindingOperation::NameType& TBindingOperation::
    getName () const
    {
      return this->name_.get ();
    }

    TBindingOperation::NameType& TBindingOperation::
    getName ()
    {
      return this->name_.get ();
    }

    void TBindingOperation::
    setName (const NameType& x)
    {
      this->name_.set (x);
    }

    void TBindingOperation::
    setName (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }


    // TService
    // 

    const TService::PortSequence& TService::
    getPort () const
    {
      return this->port_;
    }

    TService::PortSequence& TService::
    getPort ()
    {
      return this->port_;
    }

    void TService::
    setPort (const PortSequence& s)
    {
      this->port_ = s;
    }

    const TService::NameType& TService::
    getName () const
    {
      return this->name_.get ();
    }

    TService::NameType& TService::
    getName ()
    {
      return this->name_.get ();
    }

    void TService::
    setName (const NameType& x)
    {
      this->name_.set (x);
    }

    void TService::
    setName (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }


    // TPort
    // 

    const TPort::NameType& TPort::
    getName () const
    {
      return this->name_.get ();
    }

    TPort::NameType& TPort::
    getName ()
    {
      return this->name_.get ();
    }

    void TPort::
    setName (const NameType& x)
    {
      this->name_.set (x);
    }

    void TPort::
    setName (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const TPort::BindingType& TPort::
    getBinding () const
    {
      return this->binding_.get ();
    }

    TPort::BindingType& TPort::
    getBinding ()
    {
      return this->binding_.get ();
    }

    void TPort::
    setBinding (const BindingType& x)
    {
      this->binding_.set (x);
    }

    void TPort::
    setBinding (::std::unique_ptr< BindingType > x)
    {
      this->binding_.set (std::move (x));
    }


    // TExtensibilityElement
    // 

    const TExtensibilityElement::RequiredOptional& TExtensibilityElement::
    getRequired () const
    {
      return this->required_;
    }

    TExtensibilityElement::RequiredOptional& TExtensibilityElement::
    getRequired ()
    {
      return this->required_;
    }

    void TExtensibilityElement::
    setRequired (const RequiredType& x)
    {
      this->required_.set (x);
    }

    void TExtensibilityElement::
    setRequired (const RequiredOptional& x)
    {
      this->required_ = x;
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace WS
{
  namespace WSDL
  {
    // TDocumentation
    //

    TDocumentation::
    TDocumentation ()
    : ::xml_schema::Type ()
    {
    }

    TDocumentation::
    TDocumentation (const TDocumentation& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c)
    {
    }

    TDocumentation::
    TDocumentation (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TDocumentation::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        break;
      }
    }

    TDocumentation* TDocumentation::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TDocumentation (*this, f, c);
    }

    TDocumentation::
    ~TDocumentation ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TDocumentation >
    _xsd_TDocumentation_type_factory_init (
      "tDocumentation",
      "http://schemas.xmlsoap.org/wsdl/");

    // TDocumented
    //

    TDocumented::
    TDocumented ()
    : ::xml_schema::Type (),
      documentation_ (this)
    {
    }

    TDocumented::
    TDocumented (const TDocumented& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      documentation_ (x.documentation_, f, this)
    {
    }

    TDocumented::
    TDocumented (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      documentation_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TDocumented::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // documentation
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "documentation",
              "http://schemas.xmlsoap.org/wsdl/",
              &::xsd::cxx::tree::factory_impl< DocumentationType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->documentation_)
            {
              ::std::unique_ptr< DocumentationType > r (
                dynamic_cast< DocumentationType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->documentation_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    TDocumented* TDocumented::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TDocumented (*this, f, c);
    }

    TDocumented& TDocumented::
    operator= (const TDocumented& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->documentation_ = x.documentation_;
      }

      return *this;
    }

    TDocumented::
    ~TDocumented ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TDocumented >
    _xsd_TDocumented_type_factory_init (
      "tDocumented",
      "http://schemas.xmlsoap.org/wsdl/");

    // TExtensibleAttributesDocumented
    //

    TExtensibleAttributesDocumented::
    TExtensibleAttributesDocumented ()
    : ::WS::WSDL::TDocumented ()
    {
    }

    TExtensibleAttributesDocumented::
    TExtensibleAttributesDocumented (const TExtensibleAttributesDocumented& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::WS::WSDL::TDocumented (x, f, c)
    {
    }

    TExtensibleAttributesDocumented::
    TExtensibleAttributesDocumented (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::WS::WSDL::TDocumented (e, f, c)
    {
    }

    TExtensibleAttributesDocumented* TExtensibleAttributesDocumented::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TExtensibleAttributesDocumented (*this, f, c);
    }

    TExtensibleAttributesDocumented::
    ~TExtensibleAttributesDocumented ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TExtensibleAttributesDocumented >
    _xsd_TExtensibleAttributesDocumented_type_factory_init (
      "tExtensibleAttributesDocumented",
      "http://schemas.xmlsoap.org/wsdl/");

    // TExtensibleDocumented
    //

    TExtensibleDocumented::
    TExtensibleDocumented ()
    : ::WS::WSDL::TDocumented ()
    {
    }

    TExtensibleDocumented::
    TExtensibleDocumented (const TExtensibleDocumented& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::WS::WSDL::TDocumented (x, f, c)
    {
    }

    TExtensibleDocumented::
    TExtensibleDocumented (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::WS::WSDL::TDocumented (e, f | ::xml_schema::Flags::base, c)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TExtensibleDocumented::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::WS::WSDL::TDocumented::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        break;
      }
    }

    TExtensibleDocumented* TExtensibleDocumented::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TExtensibleDocumented (*this, f, c);
    }

    TExtensibleDocumented::
    ~TExtensibleDocumented ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TExtensibleDocumented >
    _xsd_TExtensibleDocumented_type_factory_init (
      "tExtensibleDocumented",
      "http://schemas.xmlsoap.org/wsdl/");

    // TDefinitions
    //

    TDefinitions::
    TDefinitions ()
    : ::WS::WSDL::TExtensibleDocumented (),
      import_ (this),
      types_ (this),
      message_ (this),
      portType_ (this),
      binding_ (this),
      service_ (this),
      targetNamespace_ (this),
      name_ (this)
    {
    }

    TDefinitions::
    TDefinitions (const TDefinitions& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleDocumented (x, f, c),
      import_ (x.import_, f, this),
      types_ (x.types_, f, this),
      message_ (x.message_, f, this),
      portType_ (x.portType_, f, this),
      binding_ (x.binding_, f, this),
      service_ (x.service_, f, this),
      targetNamespace_ (x.targetNamespace_, f, this),
      name_ (x.name_, f, this)
    {
    }

    TDefinitions::
    TDefinitions (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleDocumented (e, f | ::xml_schema::Flags::base, c),
      import_ (this),
      types_ (this),
      message_ (this),
      portType_ (this),
      binding_ (this),
      service_ (this),
      targetNamespace_ (this),
      name_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TDefinitions::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::WS::WSDL::TExtensibleDocumented::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // import
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "import",
              "http://schemas.xmlsoap.org/wsdl/",
              &::xsd::cxx::tree::factory_impl< ImportType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ImportType > r (
              dynamic_cast< ImportType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->import_.push_back (::std::move (r));
            continue;
          }
        }

        // types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "types",
              "http://schemas.xmlsoap.org/wsdl/",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< TypesType > r (
              dynamic_cast< TypesType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->types_.push_back (::std::move (r));
            continue;
          }
        }

        // message
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "message",
              "http://schemas.xmlsoap.org/wsdl/",
              &::xsd::cxx::tree::factory_impl< MessageType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< MessageType > r (
              dynamic_cast< MessageType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->message_.push_back (::std::move (r));
            continue;
          }
        }

        // portType
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "portType",
              "http://schemas.xmlsoap.org/wsdl/",
              &::xsd::cxx::tree::factory_impl< PortTypeType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< PortTypeType > r (
              dynamic_cast< PortTypeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->portType_.push_back (::std::move (r));
            continue;
          }
        }

        // binding
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "binding",
              "http://schemas.xmlsoap.org/wsdl/",
              &::xsd::cxx::tree::factory_impl< BindingType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< BindingType > r (
              dynamic_cast< BindingType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->binding_.push_back (::std::move (r));
            continue;
          }
        }

        // service
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "service",
              "http://schemas.xmlsoap.org/wsdl/",
              &::xsd::cxx::tree::factory_impl< ServiceType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ServiceType > r (
              dynamic_cast< ServiceType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->service_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "targetNamespace" && n.namespace_ ().empty ())
        {
          this->targetNamespace_.set (TargetNamespaceTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }
      }
    }

    TDefinitions* TDefinitions::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TDefinitions (*this, f, c);
    }

    TDefinitions& TDefinitions::
    operator= (const TDefinitions& x)
    {
      if (this != &x)
      {
        static_cast< ::WS::WSDL::TExtensibleDocumented& > (*this) = x;
        this->import_ = x.import_;
        this->types_ = x.types_;
        this->message_ = x.message_;
        this->portType_ = x.portType_;
        this->binding_ = x.binding_;
        this->service_ = x.service_;
        this->targetNamespace_ = x.targetNamespace_;
        this->name_ = x.name_;
      }

      return *this;
    }

    TDefinitions::
    ~TDefinitions ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TDefinitions >
    _xsd_TDefinitions_type_factory_init (
      "tDefinitions",
      "http://schemas.xmlsoap.org/wsdl/");

    // TImport
    //

    TImport::
    TImport (const NamespaceType& namespace_,
             const LocationType& location)
    : ::WS::WSDL::TExtensibleAttributesDocumented (),
      namespace__ (namespace_, this),
      location_ (location, this)
    {
    }

    TImport::
    TImport (const TImport& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleAttributesDocumented (x, f, c),
      namespace__ (x.namespace__, f, this),
      location_ (x.location_, f, this)
    {
    }

    TImport::
    TImport (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleAttributesDocumented (e, f | ::xml_schema::Flags::base, c),
      namespace__ (this),
      location_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TImport::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::WS::WSDL::TExtensibleAttributesDocumented::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "namespace" && n.namespace_ ().empty ())
        {
          this->namespace__.set (NamespaceTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "location" && n.namespace_ ().empty ())
        {
          this->location_.set (LocationTraits::create (i, f, this));
          continue;
        }
      }

      if (!namespace__.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "namespace",
          "");
      }

      if (!location_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "location",
          "");
      }
    }

    TImport* TImport::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TImport (*this, f, c);
    }

    TImport& TImport::
    operator= (const TImport& x)
    {
      if (this != &x)
      {
        static_cast< ::WS::WSDL::TExtensibleAttributesDocumented& > (*this) = x;
        this->namespace__ = x.namespace__;
        this->location_ = x.location_;
      }

      return *this;
    }

    TImport::
    ~TImport ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TImport >
    _xsd_TImport_type_factory_init (
      "tImport",
      "http://schemas.xmlsoap.org/wsdl/");

    // TTypes
    //

    TTypes::
    TTypes ()
    : ::WS::WSDL::TExtensibleDocumented ()
    {
    }

    TTypes::
    TTypes (const TTypes& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleDocumented (x, f, c)
    {
    }

    TTypes::
    TTypes (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleDocumented (e, f, c)
    {
    }

    TTypes* TTypes::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TTypes (*this, f, c);
    }

    TTypes::
    ~TTypes ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TTypes >
    _xsd_TTypes_type_factory_init (
      "tTypes",
      "http://schemas.xmlsoap.org/wsdl/");

    // TMessage
    //

    TMessage::
    TMessage (const NameType& name)
    : ::WS::WSDL::TExtensibleDocumented (),
      part_ (this),
      name_ (name, this)
    {
    }

    TMessage::
    TMessage (const TMessage& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleDocumented (x, f, c),
      part_ (x.part_, f, this),
      name_ (x.name_, f, this)
    {
    }

    TMessage::
    TMessage (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleDocumented (e, f | ::xml_schema::Flags::base, c),
      part_ (this),
      name_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TMessage::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::WS::WSDL::TExtensibleDocumented::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // part
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "part",
              "http://schemas.xmlsoap.org/wsdl/",
              &::xsd::cxx::tree::factory_impl< PartType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< PartType > r (
              dynamic_cast< PartType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->part_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    TMessage* TMessage::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TMessage (*this, f, c);
    }

    TMessage& TMessage::
    operator= (const TMessage& x)
    {
      if (this != &x)
      {
        static_cast< ::WS::WSDL::TExtensibleDocumented& > (*this) = x;
        this->part_ = x.part_;
        this->name_ = x.name_;
      }

      return *this;
    }

    TMessage::
    ~TMessage ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TMessage >
    _xsd_TMessage_type_factory_init (
      "tMessage",
      "http://schemas.xmlsoap.org/wsdl/");

    // TPart
    //

    TPart::
    TPart (const NameType& name)
    : ::WS::WSDL::TExtensibleAttributesDocumented (),
      name_ (name, this),
      element_ (this),
      type_ (this)
    {
    }

    TPart::
    TPart (const TPart& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleAttributesDocumented (x, f, c),
      name_ (x.name_, f, this),
      element_ (x.element_, f, this),
      type_ (x.type_, f, this)
    {
    }

    TPart::
    TPart (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleAttributesDocumented (e, f | ::xml_schema::Flags::base, c),
      name_ (this),
      element_ (this),
      type_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TPart::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::WS::WSDL::TExtensibleAttributesDocumented::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "element" && n.namespace_ ().empty ())
        {
          this->element_.set (ElementTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    TPart* TPart::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TPart (*this, f, c);
    }

    TPart& TPart::
    operator= (const TPart& x)
    {
      if (this != &x)
      {
        static_cast< ::WS::WSDL::TExtensibleAttributesDocumented& > (*this) = x;
        this->name_ = x.name_;
        this->element_ = x.element_;
        this->type_ = x.type_;
      }

      return *this;
    }

    TPart::
    ~TPart ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TPart >
    _xsd_TPart_type_factory_init (
      "tPart",
      "http://schemas.xmlsoap.org/wsdl/");

    // TPortType
    //

    TPortType::
    TPortType (const NameType& name)
    : ::WS::WSDL::TExtensibleAttributesDocumented (),
      operation_ (this),
      Policy_ (this),
      name_ (name, this),
      EventSource_ (this)
    {
    }

    TPortType::
    TPortType (const TPortType& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleAttributesDocumented (x, f, c),
      operation_ (x.operation_, f, this),
      Policy_ (x.Policy_, f, this),
      name_ (x.name_, f, this),
      EventSource_ (x.EventSource_, f, this)
    {
    }

    TPortType::
    TPortType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleAttributesDocumented (e, f | ::xml_schema::Flags::base, c),
      operation_ (this),
      Policy_ (this),
      name_ (this),
      EventSource_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TPortType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::WS::WSDL::TExtensibleAttributesDocumented::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // operation
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "operation",
              "http://schemas.xmlsoap.org/wsdl/",
              &::xsd::cxx::tree::factory_impl< OperationType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< OperationType > r (
              dynamic_cast< OperationType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->operation_.push_back (::std::move (r));
            continue;
          }
        }

        // Policy
        //
        if (n.name () == "Policy" && n.namespace_ () == "http://www.w3.org/ns/ws-policy")
        {
          ::std::unique_ptr< PolicyType > r (
            PolicyTraits::create (i, f, this));

          if (!this->Policy_)
          {
            this->Policy_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "EventSource" && n.namespace_ () == "http://schemas.xmlsoap.org/ws/2004/08/eventing")
        {
          this->EventSource_.set (EventSourceTraits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    TPortType* TPortType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TPortType (*this, f, c);
    }

    TPortType& TPortType::
    operator= (const TPortType& x)
    {
      if (this != &x)
      {
        static_cast< ::WS::WSDL::TExtensibleAttributesDocumented& > (*this) = x;
        this->operation_ = x.operation_;
        this->Policy_ = x.Policy_;
        this->name_ = x.name_;
        this->EventSource_ = x.EventSource_;
      }

      return *this;
    }

    TPortType::
    ~TPortType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TPortType >
    _xsd_TPortType_type_factory_init (
      "tPortType",
      "http://schemas.xmlsoap.org/wsdl/");

    // TOperation
    //

    TOperation::
    TOperation (const NameType& name)
    : ::WS::WSDL::TExtensibleDocumented (),
      input_ (this),
      output_ (this),
      fault_ (this),
      name_ (name, this),
      parameterOrder_ (this)
    {
    }

    TOperation::
    TOperation (const TOperation& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleDocumented (x, f, c),
      input_ (x.input_, f, this),
      output_ (x.output_, f, this),
      fault_ (x.fault_, f, this),
      name_ (x.name_, f, this),
      parameterOrder_ (x.parameterOrder_, f, this)
    {
    }

    TOperation::
    TOperation (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleDocumented (e, f | ::xml_schema::Flags::base, c),
      input_ (this),
      output_ (this),
      fault_ (this),
      name_ (this),
      parameterOrder_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TOperation::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::WS::WSDL::TExtensibleDocumented::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // input
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "input",
              "http://schemas.xmlsoap.org/wsdl/",
              &::xsd::cxx::tree::factory_impl< InputType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->input_)
            {
              ::std::unique_ptr< InputType > r (
                dynamic_cast< InputType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->input_.set (::std::move (r));
              continue;
            }
          }
        }

        // output
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "output",
              "http://schemas.xmlsoap.org/wsdl/",
              &::xsd::cxx::tree::factory_impl< OutputType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->output_)
            {
              ::std::unique_ptr< OutputType > r (
                dynamic_cast< OutputType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->output_.set (::std::move (r));
              continue;
            }
          }
        }

        // fault
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "fault",
              "http://schemas.xmlsoap.org/wsdl/",
              &::xsd::cxx::tree::factory_impl< FaultType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< FaultType > r (
              dynamic_cast< FaultType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->fault_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "parameterOrder" && n.namespace_ ().empty ())
        {
          this->parameterOrder_.set (ParameterOrderTraits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    TOperation* TOperation::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TOperation (*this, f, c);
    }

    TOperation& TOperation::
    operator= (const TOperation& x)
    {
      if (this != &x)
      {
        static_cast< ::WS::WSDL::TExtensibleDocumented& > (*this) = x;
        this->input_ = x.input_;
        this->output_ = x.output_;
        this->fault_ = x.fault_;
        this->name_ = x.name_;
        this->parameterOrder_ = x.parameterOrder_;
      }

      return *this;
    }

    TOperation::
    ~TOperation ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TOperation >
    _xsd_TOperation_type_factory_init (
      "tOperation",
      "http://schemas.xmlsoap.org/wsdl/");

    // TParam
    //

    TParam::
    TParam (const MessageType& message)
    : ::WS::WSDL::TExtensibleAttributesDocumented (),
      name_ (this),
      message_ (message, this),
      Action_ (this)
    {
    }

    TParam::
    TParam (const TParam& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleAttributesDocumented (x, f, c),
      name_ (x.name_, f, this),
      message_ (x.message_, f, this),
      Action_ (x.Action_, f, this)
    {
    }

    TParam::
    TParam (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleAttributesDocumented (e, f | ::xml_schema::Flags::base, c),
      name_ (this),
      message_ (this),
      Action_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TParam::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::WS::WSDL::TExtensibleAttributesDocumented::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "message" && n.namespace_ ().empty ())
        {
          this->message_.set (MessageTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "Action" && n.namespace_ () == "http://www.w3.org/2005/08/addressing")
        {
          this->Action_.set (ActionTraits::create (i, f, this));
          continue;
        }
      }

      if (!message_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "message",
          "");
      }
    }

    TParam* TParam::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TParam (*this, f, c);
    }

    TParam& TParam::
    operator= (const TParam& x)
    {
      if (this != &x)
      {
        static_cast< ::WS::WSDL::TExtensibleAttributesDocumented& > (*this) = x;
        this->name_ = x.name_;
        this->message_ = x.message_;
        this->Action_ = x.Action_;
      }

      return *this;
    }

    TParam::
    ~TParam ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TParam >
    _xsd_TParam_type_factory_init (
      "tParam",
      "http://schemas.xmlsoap.org/wsdl/");

    // TFault
    //

    TFault::
    TFault (const NameType& name,
            const MessageType& message)
    : ::WS::WSDL::TExtensibleAttributesDocumented (),
      name_ (name, this),
      message_ (message, this)
    {
    }

    TFault::
    TFault (const TFault& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleAttributesDocumented (x, f, c),
      name_ (x.name_, f, this),
      message_ (x.message_, f, this)
    {
    }

    TFault::
    TFault (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleAttributesDocumented (e, f | ::xml_schema::Flags::base, c),
      name_ (this),
      message_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TFault::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::WS::WSDL::TExtensibleAttributesDocumented::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "message" && n.namespace_ ().empty ())
        {
          this->message_.set (MessageTraits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!message_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "message",
          "");
      }
    }

    TFault* TFault::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TFault (*this, f, c);
    }

    TFault& TFault::
    operator= (const TFault& x)
    {
      if (this != &x)
      {
        static_cast< ::WS::WSDL::TExtensibleAttributesDocumented& > (*this) = x;
        this->name_ = x.name_;
        this->message_ = x.message_;
      }

      return *this;
    }

    TFault::
    ~TFault ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TFault >
    _xsd_TFault_type_factory_init (
      "tFault",
      "http://schemas.xmlsoap.org/wsdl/");

    // TBinding
    //

    TBinding::
    TBinding (const BindingType& binding,
              const NameType& name,
              const TypeType& type)
    : ::WS::WSDL::TDocumented (),
      binding_ (binding, this),
      operation_ (this),
      name_ (name, this),
      type_ (type, this)
    {
    }

    TBinding::
    TBinding (::std::unique_ptr< BindingType > binding,
              const NameType& name,
              const TypeType& type)
    : ::WS::WSDL::TDocumented (),
      binding_ (std::move (binding), this),
      operation_ (this),
      name_ (name, this),
      type_ (type, this)
    {
    }

    TBinding::
    TBinding (const TBinding& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::WS::WSDL::TDocumented (x, f, c),
      binding_ (x.binding_, f, this),
      operation_ (x.operation_, f, this),
      name_ (x.name_, f, this),
      type_ (x.type_, f, this)
    {
    }

    TBinding::
    TBinding (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::WS::WSDL::TDocumented (e, f | ::xml_schema::Flags::base, c),
      binding_ (this),
      operation_ (this),
      name_ (this),
      type_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TBinding::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::WS::WSDL::TDocumented::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // binding
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "binding",
              "http://schemas.xmlsoap.org/wsdl/soap12/",
              &::xsd::cxx::tree::factory_impl< BindingType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!binding_.present ())
            {
              ::std::unique_ptr< BindingType > r (
                dynamic_cast< BindingType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->binding_.set (::std::move (r));
              continue;
            }
          }
        }

        // operation
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "operation",
              "http://schemas.xmlsoap.org/wsdl/",
              &::xsd::cxx::tree::factory_impl< OperationType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< OperationType > r (
              dynamic_cast< OperationType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->operation_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!binding_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "binding",
          "http://schemas.xmlsoap.org/wsdl/soap12/");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }
    }

    TBinding* TBinding::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TBinding (*this, f, c);
    }

    TBinding& TBinding::
    operator= (const TBinding& x)
    {
      if (this != &x)
      {
        static_cast< ::WS::WSDL::TDocumented& > (*this) = x;
        this->binding_ = x.binding_;
        this->operation_ = x.operation_;
        this->name_ = x.name_;
        this->type_ = x.type_;
      }

      return *this;
    }

    TBinding::
    ~TBinding ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TBinding >
    _xsd_TBinding_type_factory_init (
      "tBinding",
      "http://schemas.xmlsoap.org/wsdl/");

    // TBindingOperationMessage
    //

    TBindingOperationMessage::
    TBindingOperationMessage (const BodyType& body)
    : ::WS::WSDL::TDocumented (),
      body_ (body, this),
      name_ (this)
    {
    }

    TBindingOperationMessage::
    TBindingOperationMessage (::std::unique_ptr< BodyType > body)
    : ::WS::WSDL::TDocumented (),
      body_ (std::move (body), this),
      name_ (this)
    {
    }

    TBindingOperationMessage::
    TBindingOperationMessage (const TBindingOperationMessage& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::WS::WSDL::TDocumented (x, f, c),
      body_ (x.body_, f, this),
      name_ (x.name_, f, this)
    {
    }

    TBindingOperationMessage::
    TBindingOperationMessage (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::WS::WSDL::TDocumented (e, f | ::xml_schema::Flags::base, c),
      body_ (this),
      name_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TBindingOperationMessage::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::WS::WSDL::TDocumented::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // body
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "body",
              "http://schemas.xmlsoap.org/wsdl/soap12/",
              &::xsd::cxx::tree::factory_impl< BodyType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!body_.present ())
            {
              ::std::unique_ptr< BodyType > r (
                dynamic_cast< BodyType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->body_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!body_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "body",
          "http://schemas.xmlsoap.org/wsdl/soap12/");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }
      }
    }

    TBindingOperationMessage* TBindingOperationMessage::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TBindingOperationMessage (*this, f, c);
    }

    TBindingOperationMessage& TBindingOperationMessage::
    operator= (const TBindingOperationMessage& x)
    {
      if (this != &x)
      {
        static_cast< ::WS::WSDL::TDocumented& > (*this) = x;
        this->body_ = x.body_;
        this->name_ = x.name_;
      }

      return *this;
    }

    TBindingOperationMessage::
    ~TBindingOperationMessage ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TBindingOperationMessage >
    _xsd_TBindingOperationMessage_type_factory_init (
      "tBindingOperationMessage",
      "http://schemas.xmlsoap.org/wsdl/");

    // TBindingOperationFault
    //

    TBindingOperationFault::
    TBindingOperationFault (const NameType& name)
    : ::WS::WSDL::TExtensibleDocumented (),
      name_ (name, this)
    {
    }

    TBindingOperationFault::
    TBindingOperationFault (const TBindingOperationFault& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleDocumented (x, f, c),
      name_ (x.name_, f, this)
    {
    }

    TBindingOperationFault::
    TBindingOperationFault (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleDocumented (e, f | ::xml_schema::Flags::base, c),
      name_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TBindingOperationFault::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::WS::WSDL::TExtensibleDocumented::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    TBindingOperationFault* TBindingOperationFault::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TBindingOperationFault (*this, f, c);
    }

    TBindingOperationFault& TBindingOperationFault::
    operator= (const TBindingOperationFault& x)
    {
      if (this != &x)
      {
        static_cast< ::WS::WSDL::TExtensibleDocumented& > (*this) = x;
        this->name_ = x.name_;
      }

      return *this;
    }

    TBindingOperationFault::
    ~TBindingOperationFault ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TBindingOperationFault >
    _xsd_TBindingOperationFault_type_factory_init (
      "tBindingOperationFault",
      "http://schemas.xmlsoap.org/wsdl/");

    // TBindingOperation
    //

    TBindingOperation::
    TBindingOperation (const OperationType& operation,
                       const NameType& name)
    : ::WS::WSDL::TDocumented (),
      operation_ (operation, this),
      input_ (this),
      output_ (this),
      fault_ (this),
      name_ (name, this)
    {
    }

    TBindingOperation::
    TBindingOperation (::std::unique_ptr< OperationType > operation,
                       const NameType& name)
    : ::WS::WSDL::TDocumented (),
      operation_ (std::move (operation), this),
      input_ (this),
      output_ (this),
      fault_ (this),
      name_ (name, this)
    {
    }

    TBindingOperation::
    TBindingOperation (const TBindingOperation& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::WS::WSDL::TDocumented (x, f, c),
      operation_ (x.operation_, f, this),
      input_ (x.input_, f, this),
      output_ (x.output_, f, this),
      fault_ (x.fault_, f, this),
      name_ (x.name_, f, this)
    {
    }

    TBindingOperation::
    TBindingOperation (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::WS::WSDL::TDocumented (e, f | ::xml_schema::Flags::base, c),
      operation_ (this),
      input_ (this),
      output_ (this),
      fault_ (this),
      name_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TBindingOperation::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::WS::WSDL::TDocumented::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // operation
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "operation",
              "http://schemas.xmlsoap.org/wsdl/soap12/",
              &::xsd::cxx::tree::factory_impl< OperationType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!operation_.present ())
            {
              ::std::unique_ptr< OperationType > r (
                dynamic_cast< OperationType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->operation_.set (::std::move (r));
              continue;
            }
          }
        }

        // input
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "input",
              "http://schemas.xmlsoap.org/wsdl/",
              &::xsd::cxx::tree::factory_impl< InputType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->input_)
            {
              ::std::unique_ptr< InputType > r (
                dynamic_cast< InputType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->input_.set (::std::move (r));
              continue;
            }
          }
        }

        // output
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "output",
              "http://schemas.xmlsoap.org/wsdl/",
              &::xsd::cxx::tree::factory_impl< OutputType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->output_)
            {
              ::std::unique_ptr< OutputType > r (
                dynamic_cast< OutputType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->output_.set (::std::move (r));
              continue;
            }
          }
        }

        // fault
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "fault",
              "http://schemas.xmlsoap.org/wsdl/",
              &::xsd::cxx::tree::factory_impl< FaultType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< FaultType > r (
              dynamic_cast< FaultType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->fault_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!operation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "operation",
          "http://schemas.xmlsoap.org/wsdl/soap12/");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    TBindingOperation* TBindingOperation::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TBindingOperation (*this, f, c);
    }

    TBindingOperation& TBindingOperation::
    operator= (const TBindingOperation& x)
    {
      if (this != &x)
      {
        static_cast< ::WS::WSDL::TDocumented& > (*this) = x;
        this->operation_ = x.operation_;
        this->input_ = x.input_;
        this->output_ = x.output_;
        this->fault_ = x.fault_;
        this->name_ = x.name_;
      }

      return *this;
    }

    TBindingOperation::
    ~TBindingOperation ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TBindingOperation >
    _xsd_TBindingOperation_type_factory_init (
      "tBindingOperation",
      "http://schemas.xmlsoap.org/wsdl/");

    // TService
    //

    TService::
    TService (const NameType& name)
    : ::WS::WSDL::TExtensibleDocumented (),
      port_ (this),
      name_ (name, this)
    {
    }

    TService::
    TService (const TService& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleDocumented (x, f, c),
      port_ (x.port_, f, this),
      name_ (x.name_, f, this)
    {
    }

    TService::
    TService (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleDocumented (e, f | ::xml_schema::Flags::base, c),
      port_ (this),
      name_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TService::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::WS::WSDL::TExtensibleDocumented::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // port
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "port",
              "http://schemas.xmlsoap.org/wsdl/",
              &::xsd::cxx::tree::factory_impl< PortType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< PortType > r (
              dynamic_cast< PortType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->port_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    TService* TService::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TService (*this, f, c);
    }

    TService& TService::
    operator= (const TService& x)
    {
      if (this != &x)
      {
        static_cast< ::WS::WSDL::TExtensibleDocumented& > (*this) = x;
        this->port_ = x.port_;
        this->name_ = x.name_;
      }

      return *this;
    }

    TService::
    ~TService ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TService >
    _xsd_TService_type_factory_init (
      "tService",
      "http://schemas.xmlsoap.org/wsdl/");

    // TPort
    //

    TPort::
    TPort (const NameType& name,
           const BindingType& binding)
    : ::WS::WSDL::TExtensibleDocumented (),
      name_ (name, this),
      binding_ (binding, this)
    {
    }

    TPort::
    TPort (const TPort& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleDocumented (x, f, c),
      name_ (x.name_, f, this),
      binding_ (x.binding_, f, this)
    {
    }

    TPort::
    TPort (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::WS::WSDL::TExtensibleDocumented (e, f | ::xml_schema::Flags::base, c),
      name_ (this),
      binding_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TPort::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::WS::WSDL::TExtensibleDocumented::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "binding" && n.namespace_ ().empty ())
        {
          this->binding_.set (BindingTraits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!binding_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "binding",
          "");
      }
    }

    TPort* TPort::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TPort (*this, f, c);
    }

    TPort& TPort::
    operator= (const TPort& x)
    {
      if (this != &x)
      {
        static_cast< ::WS::WSDL::TExtensibleDocumented& > (*this) = x;
        this->name_ = x.name_;
        this->binding_ = x.binding_;
      }

      return *this;
    }

    TPort::
    ~TPort ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TPort >
    _xsd_TPort_type_factory_init (
      "tPort",
      "http://schemas.xmlsoap.org/wsdl/");

    // TExtensibilityElement
    //

    TExtensibilityElement::
    TExtensibilityElement ()
    : ::xml_schema::Type (),
      required_ (this)
    {
    }

    TExtensibilityElement::
    TExtensibilityElement (const TExtensibilityElement& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      required_ (x.required_, f, this)
    {
    }

    TExtensibilityElement::
    TExtensibilityElement (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      required_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void TExtensibilityElement::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "required" && n.namespace_ () == "http://schemas.xmlsoap.org/wsdl/")
        {
          this->required_.set (RequiredTraits::create (i, f, this));
          continue;
        }
      }
    }

    TExtensibilityElement* TExtensibilityElement::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TExtensibilityElement (*this, f, c);
    }

    TExtensibilityElement& TExtensibilityElement::
    operator= (const TExtensibilityElement& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->required_ = x.required_;
      }

      return *this;
    }

    TExtensibilityElement::
    ~TExtensibilityElement ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TExtensibilityElement >
    _xsd_TExtensibilityElement_type_factory_init (
      "tExtensibilityElement",
      "http://schemas.xmlsoap.org/wsdl/");
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace WS
{
  namespace WSDL
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace WS
{
  namespace WSDL
  {
    void
    operator<< (::xercesc::DOMElement& e, const TDocumentation& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TDocumentation >
    _xsd_TDocumentation_type_serializer_init (
      "tDocumentation",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TDocumented& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // documentation
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getDocumentation ())
        {
          const TDocumented::DocumentationType& x (*i.getDocumentation ());
          if (typeid (TDocumented::DocumentationType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "documentation",
                "http://schemas.xmlsoap.org/wsdl/",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "documentation",
              "http://schemas.xmlsoap.org/wsdl/",
              false, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TDocumented >
    _xsd_TDocumented_type_serializer_init (
      "tDocumented",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TExtensibleAttributesDocumented& i)
    {
      e << static_cast< const ::WS::WSDL::TDocumented& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TExtensibleAttributesDocumented >
    _xsd_TExtensibleAttributesDocumented_type_serializer_init (
      "tExtensibleAttributesDocumented",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TExtensibleDocumented& i)
    {
      e << static_cast< const ::WS::WSDL::TDocumented& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TExtensibleDocumented >
    _xsd_TExtensibleDocumented_type_serializer_init (
      "tExtensibleDocumented",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TDefinitions& i)
    {
      e << static_cast< const ::WS::WSDL::TExtensibleDocumented& > (i);

      // import
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (TDefinitions::ImportConstIterator
             b (i.getImport ().begin ()), n (i.getImport ().end ());
             b != n; ++b)
        {
          if (typeid (TDefinitions::ImportType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "import",
                "http://schemas.xmlsoap.org/wsdl/",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "import",
              "http://schemas.xmlsoap.org/wsdl/",
              false, true, e, *b);
        }
      }

      // types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (TDefinitions::TypesConstIterator
             b (i.getTypes ().begin ()), n (i.getTypes ().end ());
             b != n; ++b)
        {
          if (typeid (TDefinitions::TypesType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "types",
                "http://schemas.xmlsoap.org/wsdl/",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "types",
              "http://schemas.xmlsoap.org/wsdl/",
              false, true, e, *b);
        }
      }

      // message
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (TDefinitions::MessageConstIterator
             b (i.getMessage ().begin ()), n (i.getMessage ().end ());
             b != n; ++b)
        {
          if (typeid (TDefinitions::MessageType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "message",
                "http://schemas.xmlsoap.org/wsdl/",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "message",
              "http://schemas.xmlsoap.org/wsdl/",
              false, true, e, *b);
        }
      }

      // portType
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (TDefinitions::PortTypeConstIterator
             b (i.getPortType ().begin ()), n (i.getPortType ().end ());
             b != n; ++b)
        {
          if (typeid (TDefinitions::PortTypeType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "portType",
                "http://schemas.xmlsoap.org/wsdl/",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "portType",
              "http://schemas.xmlsoap.org/wsdl/",
              false, true, e, *b);
        }
      }

      // binding
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (TDefinitions::BindingConstIterator
             b (i.getBinding ().begin ()), n (i.getBinding ().end ());
             b != n; ++b)
        {
          if (typeid (TDefinitions::BindingType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "binding",
                "http://schemas.xmlsoap.org/wsdl/",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "binding",
              "http://schemas.xmlsoap.org/wsdl/",
              false, true, e, *b);
        }
      }

      // service
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (TDefinitions::ServiceConstIterator
             b (i.getService ().begin ()), n (i.getService ().end ());
             b != n; ++b)
        {
          if (typeid (TDefinitions::ServiceType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "service",
                "http://schemas.xmlsoap.org/wsdl/",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "service",
              "http://schemas.xmlsoap.org/wsdl/",
              false, true, e, *b);
        }
      }

      // targetNamespace
      //
      if (i.getTargetNamespace ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "targetNamespace",
            e));

        a << *i.getTargetNamespace ();
      }

      // name
      //
      if (i.getName ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << *i.getName ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TDefinitions >
    _xsd_TDefinitions_type_serializer_init (
      "tDefinitions",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TImport& i)
    {
      e << static_cast< const ::WS::WSDL::TExtensibleAttributesDocumented& > (i);

      // namespace
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "namespace",
            e));

        a << i.getNamespace ();
      }

      // location
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "location",
            e));

        a << i.getLocation ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TImport >
    _xsd_TImport_type_serializer_init (
      "tImport",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TTypes& i)
    {
      e << static_cast< const ::WS::WSDL::TExtensibleDocumented& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TTypes >
    _xsd_TTypes_type_serializer_init (
      "tTypes",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TMessage& i)
    {
      e << static_cast< const ::WS::WSDL::TExtensibleDocumented& > (i);

      // part
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (TMessage::PartConstIterator
             b (i.getPart ().begin ()), n (i.getPart ().end ());
             b != n; ++b)
        {
          if (typeid (TMessage::PartType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "part",
                "http://schemas.xmlsoap.org/wsdl/",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "part",
              "http://schemas.xmlsoap.org/wsdl/",
              false, true, e, *b);
        }
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.getName ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TMessage >
    _xsd_TMessage_type_serializer_init (
      "tMessage",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TPart& i)
    {
      e << static_cast< const ::WS::WSDL::TExtensibleAttributesDocumented& > (i);

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.getName ();
      }

      // element
      //
      if (i.getElement ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "element",
            e));

        a << *i.getElement ();
      }

      // type
      //
      if (i.getType ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << *i.getType ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TPart >
    _xsd_TPart_type_serializer_init (
      "tPart",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TPortType& i)
    {
      e << static_cast< const ::WS::WSDL::TExtensibleAttributesDocumented& > (i);

      // operation
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (TPortType::OperationConstIterator
             b (i.getOperation ().begin ()), n (i.getOperation ().end ());
             b != n; ++b)
        {
          if (typeid (TPortType::OperationType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "operation",
                "http://schemas.xmlsoap.org/wsdl/",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "operation",
              "http://schemas.xmlsoap.org/wsdl/",
              false, true, e, *b);
        }
      }

      // Policy
      //
      if (i.getPolicy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Policy",
            "http://www.w3.org/ns/ws-policy",
            e));

        s << *i.getPolicy ();
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.getName ();
      }

      // EventSource
      //
      if (i.getEventSource ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "EventSource",
            "http://schemas.xmlsoap.org/ws/2004/08/eventing",
            e));

        a << *i.getEventSource ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TPortType >
    _xsd_TPortType_type_serializer_init (
      "tPortType",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TOperation& i)
    {
      e << static_cast< const ::WS::WSDL::TExtensibleDocumented& > (i);

      // input
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getInput ())
        {
          const TOperation::InputType& x (*i.getInput ());
          if (typeid (TOperation::InputType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "input",
                "http://schemas.xmlsoap.org/wsdl/",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "input",
              "http://schemas.xmlsoap.org/wsdl/",
              false, true, e, x);
        }
      }

      // output
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getOutput ())
        {
          const TOperation::OutputType& x (*i.getOutput ());
          if (typeid (TOperation::OutputType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "output",
                "http://schemas.xmlsoap.org/wsdl/",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "output",
              "http://schemas.xmlsoap.org/wsdl/",
              false, true, e, x);
        }
      }

      // fault
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (TOperation::FaultConstIterator
             b (i.getFault ().begin ()), n (i.getFault ().end ());
             b != n; ++b)
        {
          if (typeid (TOperation::FaultType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "fault",
                "http://schemas.xmlsoap.org/wsdl/",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "fault",
              "http://schemas.xmlsoap.org/wsdl/",
              false, true, e, *b);
        }
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.getName ();
      }

      // parameterOrder
      //
      if (i.getParameterOrder ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "parameterOrder",
            e));

        a << *i.getParameterOrder ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TOperation >
    _xsd_TOperation_type_serializer_init (
      "tOperation",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TParam& i)
    {
      e << static_cast< const ::WS::WSDL::TExtensibleAttributesDocumented& > (i);

      // name
      //
      if (i.getName ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << *i.getName ();
      }

      // message
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "message",
            e));

        a << i.getMessage ();
      }

      // Action
      //
      if (i.getAction ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Action",
            "http://www.w3.org/2005/08/addressing",
            e));

        a << *i.getAction ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TParam >
    _xsd_TParam_type_serializer_init (
      "tParam",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TFault& i)
    {
      e << static_cast< const ::WS::WSDL::TExtensibleAttributesDocumented& > (i);

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.getName ();
      }

      // message
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "message",
            e));

        a << i.getMessage ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TFault >
    _xsd_TFault_type_serializer_init (
      "tFault",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TBinding& i)
    {
      e << static_cast< const ::WS::WSDL::TDocumented& > (i);

      // binding
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const TBinding::BindingType& x (i.getBinding ());
        if (typeid (TBinding::BindingType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "binding",
              "http://schemas.xmlsoap.org/wsdl/soap12/",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "binding",
            "http://schemas.xmlsoap.org/wsdl/soap12/",
            true, true, e, x);
      }

      // operation
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (TBinding::OperationConstIterator
             b (i.getOperation ().begin ()), n (i.getOperation ().end ());
             b != n; ++b)
        {
          if (typeid (TBinding::OperationType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "operation",
                "http://schemas.xmlsoap.org/wsdl/",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "operation",
              "http://schemas.xmlsoap.org/wsdl/",
              false, true, e, *b);
        }
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.getName ();
      }

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.getType ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TBinding >
    _xsd_TBinding_type_serializer_init (
      "tBinding",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TBindingOperationMessage& i)
    {
      e << static_cast< const ::WS::WSDL::TDocumented& > (i);

      // body
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const TBindingOperationMessage::BodyType& x (i.getBody ());
        if (typeid (TBindingOperationMessage::BodyType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "body",
              "http://schemas.xmlsoap.org/wsdl/soap12/",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "body",
            "http://schemas.xmlsoap.org/wsdl/soap12/",
            true, true, e, x);
      }

      // name
      //
      if (i.getName ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << *i.getName ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TBindingOperationMessage >
    _xsd_TBindingOperationMessage_type_serializer_init (
      "tBindingOperationMessage",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TBindingOperationFault& i)
    {
      e << static_cast< const ::WS::WSDL::TExtensibleDocumented& > (i);

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.getName ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TBindingOperationFault >
    _xsd_TBindingOperationFault_type_serializer_init (
      "tBindingOperationFault",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TBindingOperation& i)
    {
      e << static_cast< const ::WS::WSDL::TDocumented& > (i);

      // operation
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const TBindingOperation::OperationType& x (i.getOperation ());
        if (typeid (TBindingOperation::OperationType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "operation",
              "http://schemas.xmlsoap.org/wsdl/soap12/",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "operation",
            "http://schemas.xmlsoap.org/wsdl/soap12/",
            true, true, e, x);
      }

      // input
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getInput ())
        {
          const TBindingOperation::InputType& x (*i.getInput ());
          if (typeid (TBindingOperation::InputType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "input",
                "http://schemas.xmlsoap.org/wsdl/",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "input",
              "http://schemas.xmlsoap.org/wsdl/",
              false, true, e, x);
        }
      }

      // output
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getOutput ())
        {
          const TBindingOperation::OutputType& x (*i.getOutput ());
          if (typeid (TBindingOperation::OutputType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "output",
                "http://schemas.xmlsoap.org/wsdl/",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "output",
              "http://schemas.xmlsoap.org/wsdl/",
              false, true, e, x);
        }
      }

      // fault
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (TBindingOperation::FaultConstIterator
             b (i.getFault ().begin ()), n (i.getFault ().end ());
             b != n; ++b)
        {
          if (typeid (TBindingOperation::FaultType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "fault",
                "http://schemas.xmlsoap.org/wsdl/",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "fault",
              "http://schemas.xmlsoap.org/wsdl/",
              false, true, e, *b);
        }
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.getName ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TBindingOperation >
    _xsd_TBindingOperation_type_serializer_init (
      "tBindingOperation",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TService& i)
    {
      e << static_cast< const ::WS::WSDL::TExtensibleDocumented& > (i);

      // port
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (TService::PortConstIterator
             b (i.getPort ().begin ()), n (i.getPort ().end ());
             b != n; ++b)
        {
          if (typeid (TService::PortType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "port",
                "http://schemas.xmlsoap.org/wsdl/",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "port",
              "http://schemas.xmlsoap.org/wsdl/",
              false, true, e, *b);
        }
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.getName ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TService >
    _xsd_TService_type_serializer_init (
      "tService",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TPort& i)
    {
      e << static_cast< const ::WS::WSDL::TExtensibleDocumented& > (i);

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.getName ();
      }

      // binding
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "binding",
            e));

        a << i.getBinding ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TPort >
    _xsd_TPort_type_serializer_init (
      "tPort",
      "http://schemas.xmlsoap.org/wsdl/");


    void
    operator<< (::xercesc::DOMElement& e, const TExtensibilityElement& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // required
      //
      if (i.getRequired ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "required",
            "http://schemas.xmlsoap.org/wsdl/",
            e));

        a << *i.getRequired ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TExtensibilityElement >
    _xsd_TExtensibilityElement_type_serializer_init (
      "tExtensibilityElement",
      "http://schemas.xmlsoap.org/wsdl/");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

