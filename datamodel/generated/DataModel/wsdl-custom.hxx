// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef WSDL_CUSTOM_HXX
#define WSDL_CUSTOM_HXX

#include "wsdl-custom-fwd.hxx"

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "ws-addressing.hxx"

#include "wsdl-soap-binding.hxx"

#include "eventing.hxx"

#include "ws-policy.hxx"

namespace WS
{
  namespace WSDL
  {
    class TDocumentation: public ::xml_schema::Type
    {
      public:
      // Constructors.
      //
      TDocumentation ();

      TDocumentation (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      TDocumentation (const TDocumentation& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      virtual TDocumentation*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~TDocumentation ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
    };

    class TDocumented: public ::xml_schema::Type
    {
      public:
      // documentation
      //
      typedef ::WS::WSDL::TDocumentation DocumentationType;
      typedef ::xsd::cxx::tree::optional< DocumentationType > DocumentationOptional;
      typedef ::xsd::cxx::tree::traits< DocumentationType, char > DocumentationTraits;

      const DocumentationOptional&
      documentation () const;

      DocumentationOptional&
      documentation ();

      void
      documentation (const DocumentationType& x);

      void
      documentation (const DocumentationOptional& x);

      void
      documentation (::std::unique_ptr< DocumentationType > p);

      // Constructors.
      //
      TDocumented ();

      TDocumented (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      TDocumented (const TDocumented& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      virtual TDocumented*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      TDocumented&
      operator= (const TDocumented& x);

      virtual 
      ~TDocumented ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      DocumentationOptional documentation_;
    };

    class TExtensibleAttributesDocumented: public ::WS::WSDL::TDocumented
    {
      public:
      // Constructors.
      //
      TExtensibleAttributesDocumented ();

      TExtensibleAttributesDocumented (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

      TExtensibleAttributesDocumented (const TExtensibleAttributesDocumented& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

      virtual TExtensibleAttributesDocumented*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~TExtensibleAttributesDocumented ();
    };

    class TExtensibleDocumented: public ::WS::WSDL::TDocumented
    {
      public:
      // Constructors.
      //
      TExtensibleDocumented ();

      TExtensibleDocumented (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

      TExtensibleDocumented (const TExtensibleDocumented& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

      virtual TExtensibleDocumented*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~TExtensibleDocumented ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
    };

    class TDefinitions: public ::WS::WSDL::TExtensibleDocumented
    {
      public:
      // import
      //
      typedef ::WS::WSDL::TImport ImportType;
      typedef ::xsd::cxx::tree::sequence< ImportType > ImportSequence;
      typedef ImportSequence::iterator ImportIterator;
      typedef ImportSequence::const_iterator ImportConstIterator;
      typedef ::xsd::cxx::tree::traits< ImportType, char > ImportTraits;

      const ImportSequence&
      import () const;

      ImportSequence&
      import ();

      void
      import (const ImportSequence& s);

      // types
      //
      typedef ::WS::WSDL::TTypes TypesType;
      typedef ::xsd::cxx::tree::sequence< TypesType > TypesSequence;
      typedef TypesSequence::iterator TypesIterator;
      typedef TypesSequence::const_iterator TypesConstIterator;
      typedef ::xsd::cxx::tree::traits< TypesType, char > TypesTraits;

      const TypesSequence&
      types () const;

      TypesSequence&
      types ();

      void
      types (const TypesSequence& s);

      // message
      //
      typedef ::WS::WSDL::TMessage MessageType;
      typedef ::xsd::cxx::tree::sequence< MessageType > MessageSequence;
      typedef MessageSequence::iterator MessageIterator;
      typedef MessageSequence::const_iterator MessageConstIterator;
      typedef ::xsd::cxx::tree::traits< MessageType, char > MessageTraits;

      const MessageSequence&
      message () const;

      MessageSequence&
      message ();

      void
      message (const MessageSequence& s);

      // portType
      //
      typedef ::WS::WSDL::TPortType PortTypeType;
      typedef ::xsd::cxx::tree::sequence< PortTypeType > PortTypeSequence;
      typedef PortTypeSequence::iterator PortTypeIterator;
      typedef PortTypeSequence::const_iterator PortTypeConstIterator;
      typedef ::xsd::cxx::tree::traits< PortTypeType, char > PortTypeTraits;

      const PortTypeSequence&
      portType () const;

      PortTypeSequence&
      portType ();

      void
      portType (const PortTypeSequence& s);

      // binding
      //
      typedef ::WS::WSDL::TBinding BindingType;
      typedef ::xsd::cxx::tree::sequence< BindingType > BindingSequence;
      typedef BindingSequence::iterator BindingIterator;
      typedef BindingSequence::const_iterator BindingConstIterator;
      typedef ::xsd::cxx::tree::traits< BindingType, char > BindingTraits;

      const BindingSequence&
      binding () const;

      BindingSequence&
      binding ();

      void
      binding (const BindingSequence& s);

      // service
      //
      typedef ::WS::WSDL::TService ServiceType;
      typedef ::xsd::cxx::tree::sequence< ServiceType > ServiceSequence;
      typedef ServiceSequence::iterator ServiceIterator;
      typedef ServiceSequence::const_iterator ServiceConstIterator;
      typedef ::xsd::cxx::tree::traits< ServiceType, char > ServiceTraits;

      const ServiceSequence&
      service () const;

      ServiceSequence&
      service ();

      void
      service (const ServiceSequence& s);

      // targetNamespace
      //
      typedef ::xml_schema::Uri TargetNamespaceType;
      typedef ::xsd::cxx::tree::optional< TargetNamespaceType > TargetNamespaceOptional;
      typedef ::xsd::cxx::tree::traits< TargetNamespaceType, char > TargetNamespaceTraits;

      const TargetNamespaceOptional&
      targetNamespace () const;

      TargetNamespaceOptional&
      targetNamespace ();

      void
      targetNamespace (const TargetNamespaceType& x);

      void
      targetNamespace (const TargetNamespaceOptional& x);

      void
      targetNamespace (::std::unique_ptr< TargetNamespaceType > p);

      // name
      //
      typedef ::xml_schema::Ncname NameType;
      typedef ::xsd::cxx::tree::optional< NameType > NameOptional;
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      const NameOptional&
      name () const;

      NameOptional&
      name ();

      void
      name (const NameType& x);

      void
      name (const NameOptional& x);

      void
      name (::std::unique_ptr< NameType > p);

      // Constructors.
      //
      TDefinitions ();

      TDefinitions (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      TDefinitions (const TDefinitions& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      virtual TDefinitions*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      TDefinitions&
      operator= (const TDefinitions& x);

      virtual 
      ~TDefinitions ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ImportSequence import_;
      TypesSequence types_;
      MessageSequence message_;
      PortTypeSequence portType_;
      BindingSequence binding_;
      ServiceSequence service_;
      TargetNamespaceOptional targetNamespace_;
      NameOptional name_;
    };

    class TImport: public ::WS::WSDL::TExtensibleAttributesDocumented
    {
      public:
      // namespace
      //
      typedef ::xml_schema::Uri NamespaceType;
      typedef ::xsd::cxx::tree::traits< NamespaceType, char > NamespaceTraits;

      const NamespaceType&
      namespace_ () const;

      NamespaceType&
      namespace_ ();

      void
      namespace_ (const NamespaceType& x);

      void
      namespace_ (::std::unique_ptr< NamespaceType > p);

      // location
      //
      typedef ::xml_schema::Uri LocationType;
      typedef ::xsd::cxx::tree::traits< LocationType, char > LocationTraits;

      const LocationType&
      location () const;

      LocationType&
      location ();

      void
      location (const LocationType& x);

      void
      location (::std::unique_ptr< LocationType > p);

      // Constructors.
      //
      TImport (const NamespaceType&,
               const LocationType&);

      TImport (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      TImport (const TImport& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      virtual TImport*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      TImport&
      operator= (const TImport& x);

      virtual 
      ~TImport ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< NamespaceType > namespace__;
      ::xsd::cxx::tree::one< LocationType > location_;
    };

    class TTypes: public ::WS::WSDL::TExtensibleDocumented
    {
      public:
      // Constructors.
      //
      TTypes ();

      TTypes (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      TTypes (const TTypes& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      virtual TTypes*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~TTypes ();
    };

    class TMessage: public ::WS::WSDL::TExtensibleDocumented
    {
      public:
      // part
      //
      typedef ::WS::WSDL::TPart PartType;
      typedef ::xsd::cxx::tree::sequence< PartType > PartSequence;
      typedef PartSequence::iterator PartIterator;
      typedef PartSequence::const_iterator PartConstIterator;
      typedef ::xsd::cxx::tree::traits< PartType, char > PartTraits;

      const PartSequence&
      part () const;

      PartSequence&
      part ();

      void
      part (const PartSequence& s);

      // name
      //
      typedef ::xml_schema::Ncname NameType;
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      const NameType&
      name () const;

      NameType&
      name ();

      void
      name (const NameType& x);

      void
      name (::std::unique_ptr< NameType > p);

      // Constructors.
      //
      TMessage (const NameType&);

      TMessage (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      TMessage (const TMessage& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      virtual TMessage*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      TMessage&
      operator= (const TMessage& x);

      virtual 
      ~TMessage ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      PartSequence part_;
      ::xsd::cxx::tree::one< NameType > name_;
    };

    class TPart: public ::WS::WSDL::TExtensibleAttributesDocumented
    {
      public:
      // name
      //
      typedef ::xml_schema::Ncname NameType;
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      const NameType&
      name () const;

      NameType&
      name ();

      void
      name (const NameType& x);

      void
      name (::std::unique_ptr< NameType > p);

      // element
      //
      typedef ::xml_schema::Qname ElementType;
      typedef ::xsd::cxx::tree::optional< ElementType > ElementOptional;
      typedef ::xsd::cxx::tree::traits< ElementType, char > ElementTraits;

      const ElementOptional&
      element () const;

      ElementOptional&
      element ();

      void
      element (const ElementType& x);

      void
      element (const ElementOptional& x);

      void
      element (::std::unique_ptr< ElementType > p);

      // type
      //
      typedef ::xml_schema::Qname TypeType;
      typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeOptional&
      type () const;

      TypeOptional&
      type ();

      void
      type (const TypeType& x);

      void
      type (const TypeOptional& x);

      void
      type (::std::unique_ptr< TypeType > p);

      // Constructors.
      //
      TPart (const NameType&);

      TPart (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      TPart (const TPart& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      virtual TPart*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      TPart&
      operator= (const TPart& x);

      virtual 
      ~TPart ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< NameType > name_;
      ElementOptional element_;
      TypeOptional type_;
    };

    class TPortType: public ::WS::WSDL::TExtensibleAttributesDocumented
    {
      public:
      // operation
      //
      typedef ::WS::WSDL::TOperation OperationType;
      typedef ::xsd::cxx::tree::sequence< OperationType > OperationSequence;
      typedef OperationSequence::iterator OperationIterator;
      typedef OperationSequence::const_iterator OperationConstIterator;
      typedef ::xsd::cxx::tree::traits< OperationType, char > OperationTraits;

      const OperationSequence&
      operation () const;

      OperationSequence&
      operation ();

      void
      operation (const OperationSequence& s);

      // Policy
      //
      typedef ::WS::POLICY::Policy PolicyType;
      typedef ::xsd::cxx::tree::optional< PolicyType > PolicyOptional;
      typedef ::xsd::cxx::tree::traits< PolicyType, char > PolicyTraits;

      const PolicyOptional&
      Policy () const;

      PolicyOptional&
      Policy ();

      void
      Policy (const PolicyType& x);

      void
      Policy (const PolicyOptional& x);

      void
      Policy (::std::unique_ptr< PolicyType > p);

      // name
      //
      typedef ::xml_schema::Ncname NameType;
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      const NameType&
      name () const;

      NameType&
      name ();

      void
      name (const NameType& x);

      void
      name (::std::unique_ptr< NameType > p);

      // EventSource
      //
      typedef ::xml_schema::Boolean EventSourceType;
      typedef ::xsd::cxx::tree::optional< EventSourceType > EventSourceOptional;
      typedef ::xsd::cxx::tree::traits< EventSourceType, char > EventSourceTraits;

      const EventSourceOptional&
      EventSource () const;

      EventSourceOptional&
      EventSource ();

      void
      EventSource (const EventSourceType& x);

      void
      EventSource (const EventSourceOptional& x);

      // Constructors.
      //
      TPortType (const NameType&);

      TPortType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      TPortType (const TPortType& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      virtual TPortType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      TPortType&
      operator= (const TPortType& x);

      virtual 
      ~TPortType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      OperationSequence operation_;
      PolicyOptional Policy_;
      ::xsd::cxx::tree::one< NameType > name_;
      EventSourceOptional EventSource_;
    };

    class TOperation: public ::WS::WSDL::TExtensibleDocumented
    {
      public:
      // input
      //
      typedef ::WS::WSDL::TParam InputType;
      typedef ::xsd::cxx::tree::optional< InputType > InputOptional;
      typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

      const InputOptional&
      input () const;

      InputOptional&
      input ();

      void
      input (const InputType& x);

      void
      input (const InputOptional& x);

      void
      input (::std::unique_ptr< InputType > p);

      // output
      //
      typedef ::WS::WSDL::TParam OutputType;
      typedef ::xsd::cxx::tree::optional< OutputType > OutputOptional;
      typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

      const OutputOptional&
      output () const;

      OutputOptional&
      output ();

      void
      output (const OutputType& x);

      void
      output (const OutputOptional& x);

      void
      output (::std::unique_ptr< OutputType > p);

      // fault
      //
      typedef ::WS::WSDL::TFault FaultType;
      typedef ::xsd::cxx::tree::sequence< FaultType > FaultSequence;
      typedef FaultSequence::iterator FaultIterator;
      typedef FaultSequence::const_iterator FaultConstIterator;
      typedef ::xsd::cxx::tree::traits< FaultType, char > FaultTraits;

      const FaultSequence&
      fault () const;

      FaultSequence&
      fault ();

      void
      fault (const FaultSequence& s);

      // name
      //
      typedef ::xml_schema::Ncname NameType;
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      const NameType&
      name () const;

      NameType&
      name ();

      void
      name (const NameType& x);

      void
      name (::std::unique_ptr< NameType > p);

      // parameterOrder
      //
      typedef ::xml_schema::Nmtokens ParameterOrderType;
      typedef ::xsd::cxx::tree::optional< ParameterOrderType > ParameterOrderOptional;
      typedef ::xsd::cxx::tree::traits< ParameterOrderType, char > ParameterOrderTraits;

      const ParameterOrderOptional&
      parameterOrder () const;

      ParameterOrderOptional&
      parameterOrder ();

      void
      parameterOrder (const ParameterOrderType& x);

      void
      parameterOrder (const ParameterOrderOptional& x);

      void
      parameterOrder (::std::unique_ptr< ParameterOrderType > p);

      // Constructors.
      //
      TOperation (const NameType&);

      TOperation (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      TOperation (const TOperation& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      virtual TOperation*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      TOperation&
      operator= (const TOperation& x);

      virtual 
      ~TOperation ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      InputOptional input_;
      OutputOptional output_;
      FaultSequence fault_;
      ::xsd::cxx::tree::one< NameType > name_;
      ParameterOrderOptional parameterOrder_;
    };

    class TParam: public ::WS::WSDL::TExtensibleAttributesDocumented
    {
      public:
      // name
      //
      typedef ::xml_schema::Ncname NameType;
      typedef ::xsd::cxx::tree::optional< NameType > NameOptional;
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      const NameOptional&
      name () const;

      NameOptional&
      name ();

      void
      name (const NameType& x);

      void
      name (const NameOptional& x);

      void
      name (::std::unique_ptr< NameType > p);

      // message
      //
      typedef ::xml_schema::Qname MessageType;
      typedef ::xsd::cxx::tree::traits< MessageType, char > MessageTraits;

      const MessageType&
      message () const;

      MessageType&
      message ();

      void
      message (const MessageType& x);

      void
      message (::std::unique_ptr< MessageType > p);

      // Action
      //
      typedef ::xml_schema::Uri ActionType;
      typedef ::xsd::cxx::tree::optional< ActionType > ActionOptional;
      typedef ::xsd::cxx::tree::traits< ActionType, char > ActionTraits;

      const ActionOptional&
      Action () const;

      ActionOptional&
      Action ();

      void
      Action (const ActionType& x);

      void
      Action (const ActionOptional& x);

      void
      Action (::std::unique_ptr< ActionType > p);

      // Constructors.
      //
      TParam (const MessageType&);

      TParam (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      TParam (const TParam& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      virtual TParam*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      TParam&
      operator= (const TParam& x);

      virtual 
      ~TParam ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      NameOptional name_;
      ::xsd::cxx::tree::one< MessageType > message_;
      ActionOptional Action_;
    };

    class TFault: public ::WS::WSDL::TExtensibleAttributesDocumented
    {
      public:
      // name
      //
      typedef ::xml_schema::Ncname NameType;
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      const NameType&
      name () const;

      NameType&
      name ();

      void
      name (const NameType& x);

      void
      name (::std::unique_ptr< NameType > p);

      // message
      //
      typedef ::xml_schema::Qname MessageType;
      typedef ::xsd::cxx::tree::traits< MessageType, char > MessageTraits;

      const MessageType&
      message () const;

      MessageType&
      message ();

      void
      message (const MessageType& x);

      void
      message (::std::unique_ptr< MessageType > p);

      // Constructors.
      //
      TFault (const NameType&,
              const MessageType&);

      TFault (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      TFault (const TFault& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      virtual TFault*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      TFault&
      operator= (const TFault& x);

      virtual 
      ~TFault ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< NameType > name_;
      ::xsd::cxx::tree::one< MessageType > message_;
    };

    class TBinding: public ::WS::WSDL::TDocumented
    {
      public:
      // binding
      //
      typedef ::WS::WSDL::SOAP_BINDING::BindingType BindingType;
      typedef ::xsd::cxx::tree::traits< BindingType, char > BindingTraits;

      const BindingType&
      binding () const;

      BindingType&
      binding ();

      void
      binding (const BindingType& x);

      void
      binding (::std::unique_ptr< BindingType > p);

      // operation
      //
      typedef ::WS::WSDL::TBindingOperation OperationType;
      typedef ::xsd::cxx::tree::sequence< OperationType > OperationSequence;
      typedef OperationSequence::iterator OperationIterator;
      typedef OperationSequence::const_iterator OperationConstIterator;
      typedef ::xsd::cxx::tree::traits< OperationType, char > OperationTraits;

      const OperationSequence&
      operation () const;

      OperationSequence&
      operation ();

      void
      operation (const OperationSequence& s);

      // name
      //
      typedef ::xml_schema::Ncname NameType;
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      const NameType&
      name () const;

      NameType&
      name ();

      void
      name (const NameType& x);

      void
      name (::std::unique_ptr< NameType > p);

      // type
      //
      typedef ::xml_schema::Qname TypeType;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeType&
      type () const;

      TypeType&
      type ();

      void
      type (const TypeType& x);

      void
      type (::std::unique_ptr< TypeType > p);

      // Constructors.
      //
      TBinding (const BindingType&,
                const NameType&,
                const TypeType&);

      TBinding (::std::unique_ptr< BindingType >,
                const NameType&,
                const TypeType&);

      TBinding (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      TBinding (const TBinding& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      virtual TBinding*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      TBinding&
      operator= (const TBinding& x);

      virtual 
      ~TBinding ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< BindingType > binding_;
      OperationSequence operation_;
      ::xsd::cxx::tree::one< NameType > name_;
      ::xsd::cxx::tree::one< TypeType > type_;
    };

    class TBindingOperationMessage: public ::WS::WSDL::TDocumented
    {
      public:
      // body
      //
      typedef ::WS::WSDL::SOAP_BINDING::BodyType BodyType;
      typedef ::xsd::cxx::tree::traits< BodyType, char > BodyTraits;

      const BodyType&
      body () const;

      BodyType&
      body ();

      void
      body (const BodyType& x);

      void
      body (::std::unique_ptr< BodyType > p);

      // name
      //
      typedef ::xml_schema::Ncname NameType;
      typedef ::xsd::cxx::tree::optional< NameType > NameOptional;
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      const NameOptional&
      name () const;

      NameOptional&
      name ();

      void
      name (const NameType& x);

      void
      name (const NameOptional& x);

      void
      name (::std::unique_ptr< NameType > p);

      // Constructors.
      //
      TBindingOperationMessage (const BodyType&);

      TBindingOperationMessage (::std::unique_ptr< BodyType >);

      TBindingOperationMessage (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      TBindingOperationMessage (const TBindingOperationMessage& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      virtual TBindingOperationMessage*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      TBindingOperationMessage&
      operator= (const TBindingOperationMessage& x);

      virtual 
      ~TBindingOperationMessage ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< BodyType > body_;
      NameOptional name_;
    };

    class TBindingOperationFault: public ::WS::WSDL::TExtensibleDocumented
    {
      public:
      // name
      //
      typedef ::xml_schema::Ncname NameType;
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      const NameType&
      name () const;

      NameType&
      name ();

      void
      name (const NameType& x);

      void
      name (::std::unique_ptr< NameType > p);

      // Constructors.
      //
      TBindingOperationFault (const NameType&);

      TBindingOperationFault (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

      TBindingOperationFault (const TBindingOperationFault& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

      virtual TBindingOperationFault*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      TBindingOperationFault&
      operator= (const TBindingOperationFault& x);

      virtual 
      ~TBindingOperationFault ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< NameType > name_;
    };

    class TBindingOperation: public ::WS::WSDL::TDocumented
    {
      public:
      // operation
      //
      typedef ::WS::WSDL::SOAP_BINDING::OperationType OperationType;
      typedef ::xsd::cxx::tree::traits< OperationType, char > OperationTraits;

      const OperationType&
      operation () const;

      OperationType&
      operation ();

      void
      operation (const OperationType& x);

      void
      operation (::std::unique_ptr< OperationType > p);

      // input
      //
      typedef ::WS::WSDL::TBindingOperationMessage InputType;
      typedef ::xsd::cxx::tree::optional< InputType > InputOptional;
      typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

      const InputOptional&
      input () const;

      InputOptional&
      input ();

      void
      input (const InputType& x);

      void
      input (const InputOptional& x);

      void
      input (::std::unique_ptr< InputType > p);

      // output
      //
      typedef ::WS::WSDL::TBindingOperationMessage OutputType;
      typedef ::xsd::cxx::tree::optional< OutputType > OutputOptional;
      typedef ::xsd::cxx::tree::traits< OutputType, char > OutputTraits;

      const OutputOptional&
      output () const;

      OutputOptional&
      output ();

      void
      output (const OutputType& x);

      void
      output (const OutputOptional& x);

      void
      output (::std::unique_ptr< OutputType > p);

      // fault
      //
      typedef ::WS::WSDL::TBindingOperationFault FaultType;
      typedef ::xsd::cxx::tree::sequence< FaultType > FaultSequence;
      typedef FaultSequence::iterator FaultIterator;
      typedef FaultSequence::const_iterator FaultConstIterator;
      typedef ::xsd::cxx::tree::traits< FaultType, char > FaultTraits;

      const FaultSequence&
      fault () const;

      FaultSequence&
      fault ();

      void
      fault (const FaultSequence& s);

      // name
      //
      typedef ::xml_schema::Ncname NameType;
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      const NameType&
      name () const;

      NameType&
      name ();

      void
      name (const NameType& x);

      void
      name (::std::unique_ptr< NameType > p);

      // Constructors.
      //
      TBindingOperation (const OperationType&,
                         const NameType&);

      TBindingOperation (::std::unique_ptr< OperationType >,
                         const NameType&);

      TBindingOperation (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      TBindingOperation (const TBindingOperation& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      virtual TBindingOperation*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      TBindingOperation&
      operator= (const TBindingOperation& x);

      virtual 
      ~TBindingOperation ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< OperationType > operation_;
      InputOptional input_;
      OutputOptional output_;
      FaultSequence fault_;
      ::xsd::cxx::tree::one< NameType > name_;
    };

    class TService: public ::WS::WSDL::TExtensibleDocumented
    {
      public:
      // port
      //
      typedef ::WS::WSDL::TPort PortType;
      typedef ::xsd::cxx::tree::sequence< PortType > PortSequence;
      typedef PortSequence::iterator PortIterator;
      typedef PortSequence::const_iterator PortConstIterator;
      typedef ::xsd::cxx::tree::traits< PortType, char > PortTraits;

      const PortSequence&
      port () const;

      PortSequence&
      port ();

      void
      port (const PortSequence& s);

      // name
      //
      typedef ::xml_schema::Ncname NameType;
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      const NameType&
      name () const;

      NameType&
      name ();

      void
      name (const NameType& x);

      void
      name (::std::unique_ptr< NameType > p);

      // Constructors.
      //
      TService (const NameType&);

      TService (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      TService (const TService& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      virtual TService*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      TService&
      operator= (const TService& x);

      virtual 
      ~TService ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      PortSequence port_;
      ::xsd::cxx::tree::one< NameType > name_;
    };

    class TPort: public ::WS::WSDL::TExtensibleDocumented
    {
      public:
      // name
      //
      typedef ::xml_schema::Ncname NameType;
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      const NameType&
      name () const;

      NameType&
      name ();

      void
      name (const NameType& x);

      void
      name (::std::unique_ptr< NameType > p);

      // binding
      //
      typedef ::xml_schema::Qname BindingType;
      typedef ::xsd::cxx::tree::traits< BindingType, char > BindingTraits;

      const BindingType&
      binding () const;

      BindingType&
      binding ();

      void
      binding (const BindingType& x);

      void
      binding (::std::unique_ptr< BindingType > p);

      // Constructors.
      //
      TPort (const NameType&,
             const BindingType&);

      TPort (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      TPort (const TPort& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      virtual TPort*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      TPort&
      operator= (const TPort& x);

      virtual 
      ~TPort ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< NameType > name_;
      ::xsd::cxx::tree::one< BindingType > binding_;
    };

    class TExtensibilityElement: public ::xml_schema::Type
    {
      public:
      // required
      //
      typedef ::xml_schema::Boolean RequiredType;
      typedef ::xsd::cxx::tree::optional< RequiredType > RequiredOptional;
      typedef ::xsd::cxx::tree::traits< RequiredType, char > RequiredTraits;

      const RequiredOptional&
      required () const;

      RequiredOptional&
      required ();

      void
      required (const RequiredType& x);

      void
      required (const RequiredOptional& x);

      // Constructors.
      //
      TExtensibilityElement ();

      TExtensibilityElement (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

      TExtensibilityElement (const TExtensibilityElement& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

      virtual TExtensibilityElement*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      TExtensibilityElement&
      operator= (const TExtensibilityElement& x);

      virtual 
      ~TExtensibilityElement ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      RequiredOptional required_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace WS
{
  namespace WSDL
  {
    // Parse a URI or a local file.
    //

    ::std::unique_ptr< ::WS::WSDL::TDefinitions >
    definitions (const ::std::string& uri,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::WS::WSDL::TDefinitions >
    definitions (const ::std::string& uri,
                 ::xml_schema::ErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::WS::WSDL::TDefinitions >
    definitions (const ::std::string& uri,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    // Parse std::istream.
    //

    ::std::unique_ptr< ::WS::WSDL::TDefinitions >
    definitions (::std::istream& is,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::WS::WSDL::TDefinitions >
    definitions (::std::istream& is,
                 ::xml_schema::ErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::WS::WSDL::TDefinitions >
    definitions (::std::istream& is,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::WS::WSDL::TDefinitions >
    definitions (::std::istream& is,
                 const ::std::string& id,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::WS::WSDL::TDefinitions >
    definitions (::std::istream& is,
                 const ::std::string& id,
                 ::xml_schema::ErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::WS::WSDL::TDefinitions >
    definitions (::std::istream& is,
                 const ::std::string& id,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    // Parse xercesc::InputSource.
    //

    ::std::unique_ptr< ::WS::WSDL::TDefinitions >
    definitions (::xercesc::InputSource& is,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::WS::WSDL::TDefinitions >
    definitions (::xercesc::InputSource& is,
                 ::xml_schema::ErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::WS::WSDL::TDefinitions >
    definitions (::xercesc::InputSource& is,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    // Parse xercesc::DOMDocument.
    //

    ::std::unique_ptr< ::WS::WSDL::TDefinitions >
    definitions (const ::xercesc::DOMDocument& d,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::WS::WSDL::TDefinitions >
    definitions (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace WS
{
  namespace WSDL
  {
    void
    operator<< (::xercesc::DOMElement&, const TDocumentation&);

    void
    operator<< (::xercesc::DOMElement&, const TDocumented&);

    void
    operator<< (::xercesc::DOMElement&, const TExtensibleAttributesDocumented&);

    void
    operator<< (::xercesc::DOMElement&, const TExtensibleDocumented&);

    // Serialize to std::ostream.
    //

    void
    definitions (::std::ostream& os,
                 const ::WS::WSDL::TDefinitions& x, 
                 const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::Flags f = 0);

    void
    definitions (::std::ostream& os,
                 const ::WS::WSDL::TDefinitions& x, 
                 ::xml_schema::ErrorHandler& eh,
                 const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::Flags f = 0);

    void
    definitions (::std::ostream& os,
                 const ::WS::WSDL::TDefinitions& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::Flags f = 0);

    // Serialize to xercesc::XMLFormatTarget.
    //

    void
    definitions (::xercesc::XMLFormatTarget& ft,
                 const ::WS::WSDL::TDefinitions& x, 
                 const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::Flags f = 0);

    void
    definitions (::xercesc::XMLFormatTarget& ft,
                 const ::WS::WSDL::TDefinitions& x, 
                 ::xml_schema::ErrorHandler& eh,
                 const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::Flags f = 0);

    void
    definitions (::xercesc::XMLFormatTarget& ft,
                 const ::WS::WSDL::TDefinitions& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::Flags f = 0);

    // Serialize to an existing xercesc::DOMDocument.
    //

    void
    definitions (::xercesc::DOMDocument& d,
                 const ::WS::WSDL::TDefinitions& x,
                 ::xml_schema::Flags f = 0);

    // Serialize to a new xercesc::DOMDocument.
    //

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    definitions (const ::WS::WSDL::TDefinitions& x, 
                 const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                 ::xml_schema::Flags f = 0);

    void
    operator<< (::xercesc::DOMElement&, const TDefinitions&);

    void
    operator<< (::xercesc::DOMElement&, const TImport&);

    void
    operator<< (::xercesc::DOMElement&, const TTypes&);

    void
    operator<< (::xercesc::DOMElement&, const TMessage&);

    void
    operator<< (::xercesc::DOMElement&, const TPart&);

    void
    operator<< (::xercesc::DOMElement&, const TPortType&);

    void
    operator<< (::xercesc::DOMElement&, const TOperation&);

    void
    operator<< (::xercesc::DOMElement&, const TParam&);

    void
    operator<< (::xercesc::DOMElement&, const TFault&);

    void
    operator<< (::xercesc::DOMElement&, const TBinding&);

    void
    operator<< (::xercesc::DOMElement&, const TBindingOperationMessage&);

    void
    operator<< (::xercesc::DOMElement&, const TBindingOperationFault&);

    void
    operator<< (::xercesc::DOMElement&, const TBindingOperation&);

    void
    operator<< (::xercesc::DOMElement&, const TService&);

    void
    operator<< (::xercesc::DOMElement&, const TPort&);

    void
    operator<< (::xercesc::DOMElement&, const TExtensibilityElement&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // WSDL_CUSTOM_HXX
