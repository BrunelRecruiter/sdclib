// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "DataModel/wsdd-dpws-1.1-schema-os.hxx"

namespace WS
{
  namespace DPWS
  {
    // ThisModelType
    // 

    const ThisModelType::ManufacturerSequence& ThisModelType::
    getManufacturer () const
    {
      return this->Manufacturer_;
    }

    ThisModelType::ManufacturerSequence& ThisModelType::
    getManufacturer ()
    {
      return this->Manufacturer_;
    }

    void ThisModelType::
    setManufacturer (const ManufacturerSequence& s)
    {
      this->Manufacturer_ = s;
    }

    const ThisModelType::ManufacturerUrlOptional& ThisModelType::
    getManufacturerUrl () const
    {
      return this->ManufacturerUrl_;
    }

    ThisModelType::ManufacturerUrlOptional& ThisModelType::
    getManufacturerUrl ()
    {
      return this->ManufacturerUrl_;
    }

    void ThisModelType::
    setManufacturerUrl (const ManufacturerUrlType& x)
    {
      this->ManufacturerUrl_.set (x);
    }

    void ThisModelType::
    setManufacturerUrl (const ManufacturerUrlOptional& x)
    {
      this->ManufacturerUrl_ = x;
    }

    void ThisModelType::
    setManufacturerUrl (::std::unique_ptr< ManufacturerUrlType > x)
    {
      this->ManufacturerUrl_.set (std::move (x));
    }

    const ThisModelType::ModelNameSequence& ThisModelType::
    getModelName () const
    {
      return this->ModelName_;
    }

    ThisModelType::ModelNameSequence& ThisModelType::
    getModelName ()
    {
      return this->ModelName_;
    }

    void ThisModelType::
    setModelName (const ModelNameSequence& s)
    {
      this->ModelName_ = s;
    }

    const ThisModelType::ModelNumberOptional& ThisModelType::
    getModelNumber () const
    {
      return this->ModelNumber_;
    }

    ThisModelType::ModelNumberOptional& ThisModelType::
    getModelNumber ()
    {
      return this->ModelNumber_;
    }

    void ThisModelType::
    setModelNumber (const ModelNumberType& x)
    {
      this->ModelNumber_.set (x);
    }

    void ThisModelType::
    setModelNumber (const ModelNumberOptional& x)
    {
      this->ModelNumber_ = x;
    }

    void ThisModelType::
    setModelNumber (::std::unique_ptr< ModelNumberType > x)
    {
      this->ModelNumber_.set (std::move (x));
    }

    const ThisModelType::ModelUrlOptional& ThisModelType::
    getModelUrl () const
    {
      return this->ModelUrl_;
    }

    ThisModelType::ModelUrlOptional& ThisModelType::
    getModelUrl ()
    {
      return this->ModelUrl_;
    }

    void ThisModelType::
    setModelUrl (const ModelUrlType& x)
    {
      this->ModelUrl_.set (x);
    }

    void ThisModelType::
    setModelUrl (const ModelUrlOptional& x)
    {
      this->ModelUrl_ = x;
    }

    void ThisModelType::
    setModelUrl (::std::unique_ptr< ModelUrlType > x)
    {
      this->ModelUrl_.set (std::move (x));
    }

    const ThisModelType::PresentationUrlOptional& ThisModelType::
    getPresentationUrl () const
    {
      return this->PresentationUrl_;
    }

    ThisModelType::PresentationUrlOptional& ThisModelType::
    getPresentationUrl ()
    {
      return this->PresentationUrl_;
    }

    void ThisModelType::
    setPresentationUrl (const PresentationUrlType& x)
    {
      this->PresentationUrl_.set (x);
    }

    void ThisModelType::
    setPresentationUrl (const PresentationUrlOptional& x)
    {
      this->PresentationUrl_ = x;
    }

    void ThisModelType::
    setPresentationUrl (::std::unique_ptr< PresentationUrlType > x)
    {
      this->PresentationUrl_.set (std::move (x));
    }


    // ThisDeviceType
    // 

    const ThisDeviceType::FriendlyNameSequence& ThisDeviceType::
    getFriendlyName () const
    {
      return this->FriendlyName_;
    }

    ThisDeviceType::FriendlyNameSequence& ThisDeviceType::
    getFriendlyName ()
    {
      return this->FriendlyName_;
    }

    void ThisDeviceType::
    setFriendlyName (const FriendlyNameSequence& s)
    {
      this->FriendlyName_ = s;
    }

    const ThisDeviceType::FirmwareVersionOptional& ThisDeviceType::
    getFirmwareVersion () const
    {
      return this->FirmwareVersion_;
    }

    ThisDeviceType::FirmwareVersionOptional& ThisDeviceType::
    getFirmwareVersion ()
    {
      return this->FirmwareVersion_;
    }

    void ThisDeviceType::
    setFirmwareVersion (const FirmwareVersionType& x)
    {
      this->FirmwareVersion_.set (x);
    }

    void ThisDeviceType::
    setFirmwareVersion (const FirmwareVersionOptional& x)
    {
      this->FirmwareVersion_ = x;
    }

    void ThisDeviceType::
    setFirmwareVersion (::std::unique_ptr< FirmwareVersionType > x)
    {
      this->FirmwareVersion_.set (std::move (x));
    }

    const ThisDeviceType::SerialNumberOptional& ThisDeviceType::
    getSerialNumber () const
    {
      return this->SerialNumber_;
    }

    ThisDeviceType::SerialNumberOptional& ThisDeviceType::
    getSerialNumber ()
    {
      return this->SerialNumber_;
    }

    void ThisDeviceType::
    setSerialNumber (const SerialNumberType& x)
    {
      this->SerialNumber_.set (x);
    }

    void ThisDeviceType::
    setSerialNumber (const SerialNumberOptional& x)
    {
      this->SerialNumber_ = x;
    }

    void ThisDeviceType::
    setSerialNumber (::std::unique_ptr< SerialNumberType > x)
    {
      this->SerialNumber_.set (std::move (x));
    }


    // LocalizedStringType
    // 


    // DeviceRelationshipTypes
    //

    DeviceRelationshipTypes::
    DeviceRelationshipTypes (const char* s)
    : ::xml_schema::String (s)
    {
    }

    DeviceRelationshipTypes::
    DeviceRelationshipTypes (const ::std::string& s)
    : ::xml_schema::String (s)
    {
    }

    DeviceRelationshipTypes::
    DeviceRelationshipTypes (const DeviceRelationshipTypes& o,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (o, f, c)
    {
    }

    // DeviceRelationshipTypeURIs
    // 

    DeviceRelationshipTypeURIs::
    DeviceRelationshipTypeURIs (const ::xml_schema::Uri& v)
    : ::xml_schema::Uri (v)
    {
    }

    DeviceRelationshipTypeURIs::
    DeviceRelationshipTypeURIs (const DeviceRelationshipTypeURIs& v,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::Uri (v, f, c)
    {
    }


    // DeviceMetadataDialectURIs
    // 

    DeviceMetadataDialectURIs::
    DeviceMetadataDialectURIs (const ::xml_schema::Uri& v)
    : ::xml_schema::Uri (v)
    {
    }

    DeviceMetadataDialectURIs::
    DeviceMetadataDialectURIs (const DeviceMetadataDialectURIs& v,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::Uri (v, f, c)
    {
    }


    // DeviceEventingFilterDialects
    //

    DeviceEventingFilterDialects::
    DeviceEventingFilterDialects (const char* s)
    : ::xml_schema::String (s)
    {
    }

    DeviceEventingFilterDialects::
    DeviceEventingFilterDialects (const ::std::string& s)
    : ::xml_schema::String (s)
    {
    }

    DeviceEventingFilterDialects::
    DeviceEventingFilterDialects (const DeviceEventingFilterDialects& o,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::String (o, f, c)
    {
    }

    // DeviceEventingFilterDialectURIs
    // 

    DeviceEventingFilterDialectURIs::
    DeviceEventingFilterDialectURIs (const ::xml_schema::Uri& v)
    : ::xml_schema::Uri (v)
    {
    }

    DeviceEventingFilterDialectURIs::
    DeviceEventingFilterDialectURIs (const DeviceEventingFilterDialectURIs& v,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::Uri (v, f, c)
    {
    }


    // DeviceActionURIs
    // 

    DeviceActionURIs::
    DeviceActionURIs (const ::xml_schema::Uri& v)
    : ::xml_schema::Uri (v)
    {
    }

    DeviceActionURIs::
    DeviceActionURIs (const DeviceActionURIs& v,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Uri (v, f, c)
    {
    }


    // DeviceSoapFaultSubcodes
    //

    DeviceSoapFaultSubcodes::
    DeviceSoapFaultSubcodes (const char* s)
    : ::xml_schema::String (s)
    {
    }

    DeviceSoapFaultSubcodes::
    DeviceSoapFaultSubcodes (const ::std::string& s)
    : ::xml_schema::String (s)
    {
    }

    DeviceSoapFaultSubcodes::
    DeviceSoapFaultSubcodes (const DeviceSoapFaultSubcodes& o,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (o, f, c)
    {
    }

    // DeviceSoapFaultSubcodeQNames
    // 

    DeviceSoapFaultSubcodeQNames::
    DeviceSoapFaultSubcodeQNames (const ::xml_schema::Qname& v)
    : ::xml_schema::Qname (v)
    {
    }

    DeviceSoapFaultSubcodeQNames::
    DeviceSoapFaultSubcodeQNames (const DeviceSoapFaultSubcodeQNames& v,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::Qname (v, f, c)
    {
    }


    // HostServiceType
    // 

    const HostServiceType::EndpointReferenceType& HostServiceType::
    getEndpointReference () const
    {
      return this->EndpointReference_.get ();
    }

    HostServiceType::EndpointReferenceType& HostServiceType::
    getEndpointReference ()
    {
      return this->EndpointReference_.get ();
    }

    void HostServiceType::
    setEndpointReference (const EndpointReferenceType& x)
    {
      this->EndpointReference_.set (x);
    }

    void HostServiceType::
    setEndpointReference (::std::unique_ptr< EndpointReferenceType > x)
    {
      this->EndpointReference_.set (std::move (x));
    }

    const HostServiceType::TypesOptional& HostServiceType::
    getTypes () const
    {
      return this->Types_;
    }

    HostServiceType::TypesOptional& HostServiceType::
    getTypes ()
    {
      return this->Types_;
    }

    void HostServiceType::
    setTypes (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void HostServiceType::
    setTypes (const TypesOptional& x)
    {
      this->Types_ = x;
    }

    void HostServiceType::
    setTypes (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }


    // HostedServiceType
    // 

    const HostedServiceType::EndpointReferenceSequence& HostedServiceType::
    getEndpointReference () const
    {
      return this->EndpointReference_;
    }

    HostedServiceType::EndpointReferenceSequence& HostedServiceType::
    getEndpointReference ()
    {
      return this->EndpointReference_;
    }

    void HostedServiceType::
    setEndpointReference (const EndpointReferenceSequence& s)
    {
      this->EndpointReference_ = s;
    }

    const HostedServiceType::TypesType& HostedServiceType::
    getTypes () const
    {
      return this->Types_.get ();
    }

    HostedServiceType::TypesType& HostedServiceType::
    getTypes ()
    {
      return this->Types_.get ();
    }

    void HostedServiceType::
    setTypes (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void HostedServiceType::
    setTypes (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }

    const HostedServiceType::ServiceIdType& HostedServiceType::
    getServiceId () const
    {
      return this->ServiceId_.get ();
    }

    HostedServiceType::ServiceIdType& HostedServiceType::
    getServiceId ()
    {
      return this->ServiceId_.get ();
    }

    void HostedServiceType::
    setServiceId (const ServiceIdType& x)
    {
      this->ServiceId_.set (x);
    }

    void HostedServiceType::
    setServiceId (::std::unique_ptr< ServiceIdType > x)
    {
      this->ServiceId_.set (std::move (x));
    }


    // QNameListType
    //

    QNameListType::
    QNameListType ()
    : ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (this)
    {
    }

    QNameListType::
    QNameListType (size_type n, const ::xml_schema::Qname& x)
    : ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (n, x, this)
    {
    }

    QNameListType::
    QNameListType (const QNameListType& o,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (o, f, this)
    {
    }

    // DiscoveryTypeValues
    // 

    DiscoveryTypeValues::
    DiscoveryTypeValues (const ::xml_schema::Qname& v)
    : ::xml_schema::Qname (v)
    {
    }

    DiscoveryTypeValues::
    DiscoveryTypeValues (const DiscoveryTypeValues& v,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Qname (v, f, c)
    {
    }


    // AssertionType
    // 


    // Relationship
    // 

    const Relationship::HostType& Relationship::
    getHost () const
    {
      return this->Host_.get ();
    }

    Relationship::HostType& Relationship::
    getHost ()
    {
      return this->Host_.get ();
    }

    void Relationship::
    setHost (const HostType& x)
    {
      this->Host_.set (x);
    }

    void Relationship::
    setHost (::std::unique_ptr< HostType > x)
    {
      this->Host_.set (std::move (x));
    }

    const Relationship::HostedSequence& Relationship::
    getHosted () const
    {
      return this->Hosted_;
    }

    Relationship::HostedSequence& Relationship::
    getHosted ()
    {
      return this->Hosted_;
    }

    void Relationship::
    setHosted (const HostedSequence& s)
    {
      this->Hosted_ = s;
    }

    const Relationship::TypeType& Relationship::
    getType () const
    {
      return this->Type_.get ();
    }

    Relationship::TypeType& Relationship::
    getType ()
    {
      return this->Type_.get ();
    }

    void Relationship::
    setType (const TypeType& x)
    {
      this->Type_.set (x);
    }

    void Relationship::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->Type_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace WS
{
  namespace DPWS
  {
    // ThisModelType
    //

    ThisModelType::
    ThisModelType ()
    : ::xml_schema::Type (),
      Manufacturer_ (this),
      ManufacturerUrl_ (this),
      ModelName_ (this),
      ModelNumber_ (this),
      ModelUrl_ (this),
      PresentationUrl_ (this)
    {
    }

    ThisModelType::
    ThisModelType (const ThisModelType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Manufacturer_ (x.Manufacturer_, f, this),
      ManufacturerUrl_ (x.ManufacturerUrl_, f, this),
      ModelName_ (x.ModelName_, f, this),
      ModelNumber_ (x.ModelNumber_, f, this),
      ModelUrl_ (x.ModelUrl_, f, this),
      PresentationUrl_ (x.PresentationUrl_, f, this)
    {
    }

    ThisModelType::
    ThisModelType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Manufacturer_ (this),
      ManufacturerUrl_ (this),
      ModelName_ (this),
      ModelNumber_ (this),
      ModelUrl_ (this),
      PresentationUrl_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThisModelType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Manufacturer
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Manufacturer",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< ManufacturerType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ManufacturerType > r (
              dynamic_cast< ManufacturerType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Manufacturer_.push_back (::std::move (r));
            continue;
          }
        }

        // ManufacturerUrl
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ManufacturerUrl",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< ManufacturerUrlType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->ManufacturerUrl_)
            {
              ::std::unique_ptr< ManufacturerUrlType > r (
                dynamic_cast< ManufacturerUrlType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->ManufacturerUrl_.set (::std::move (r));
              continue;
            }
          }
        }

        // ModelName
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ModelName",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< ModelNameType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ModelNameType > r (
              dynamic_cast< ModelNameType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ModelName_.push_back (::std::move (r));
            continue;
          }
        }

        // ModelNumber
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ModelNumber",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< ModelNumberType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->ModelNumber_)
            {
              ::std::unique_ptr< ModelNumberType > r (
                dynamic_cast< ModelNumberType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->ModelNumber_.set (::std::move (r));
              continue;
            }
          }
        }

        // ModelUrl
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ModelUrl",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< ModelUrlType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->ModelUrl_)
            {
              ::std::unique_ptr< ModelUrlType > r (
                dynamic_cast< ModelUrlType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->ModelUrl_.set (::std::move (r));
              continue;
            }
          }
        }

        // PresentationUrl
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "PresentationUrl",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< PresentationUrlType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->PresentationUrl_)
            {
              ::std::unique_ptr< PresentationUrlType > r (
                dynamic_cast< PresentationUrlType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->PresentationUrl_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    ThisModelType* ThisModelType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ThisModelType (*this, f, c);
    }

    ThisModelType& ThisModelType::
    operator= (const ThisModelType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->Manufacturer_ = x.Manufacturer_;
        this->ManufacturerUrl_ = x.ManufacturerUrl_;
        this->ModelName_ = x.ModelName_;
        this->ModelNumber_ = x.ModelNumber_;
        this->ModelUrl_ = x.ModelUrl_;
        this->PresentationUrl_ = x.PresentationUrl_;
      }

      return *this;
    }

    ThisModelType::
    ~ThisModelType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ThisModelType >
    _xsd_ThisModelType_type_factory_init (
      "ThisModelType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // ThisDeviceType
    //

    ThisDeviceType::
    ThisDeviceType ()
    : ::xml_schema::Type (),
      FriendlyName_ (this),
      FirmwareVersion_ (this),
      SerialNumber_ (this)
    {
    }

    ThisDeviceType::
    ThisDeviceType (const ThisDeviceType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      FriendlyName_ (x.FriendlyName_, f, this),
      FirmwareVersion_ (x.FirmwareVersion_, f, this),
      SerialNumber_ (x.SerialNumber_, f, this)
    {
    }

    ThisDeviceType::
    ThisDeviceType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      FriendlyName_ (this),
      FirmwareVersion_ (this),
      SerialNumber_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThisDeviceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FriendlyName
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "FriendlyName",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< FriendlyNameType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< FriendlyNameType > r (
              dynamic_cast< FriendlyNameType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FriendlyName_.push_back (::std::move (r));
            continue;
          }
        }

        // FirmwareVersion
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "FirmwareVersion",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< FirmwareVersionType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->FirmwareVersion_)
            {
              ::std::unique_ptr< FirmwareVersionType > r (
                dynamic_cast< FirmwareVersionType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->FirmwareVersion_.set (::std::move (r));
              continue;
            }
          }
        }

        // SerialNumber
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "SerialNumber",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< SerialNumberType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->SerialNumber_)
            {
              ::std::unique_ptr< SerialNumberType > r (
                dynamic_cast< SerialNumberType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->SerialNumber_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    ThisDeviceType* ThisDeviceType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ThisDeviceType (*this, f, c);
    }

    ThisDeviceType& ThisDeviceType::
    operator= (const ThisDeviceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->FriendlyName_ = x.FriendlyName_;
        this->FirmwareVersion_ = x.FirmwareVersion_;
        this->SerialNumber_ = x.SerialNumber_;
      }

      return *this;
    }

    ThisDeviceType::
    ~ThisDeviceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ThisDeviceType >
    _xsd_ThisDeviceType_type_factory_init (
      "ThisDeviceType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // LocalizedStringType
    //

    LocalizedStringType::
    LocalizedStringType ()
    : ::xml_schema::String ()
    {
    }

    LocalizedStringType::
    LocalizedStringType (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    LocalizedStringType::
    LocalizedStringType (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    LocalizedStringType::
    LocalizedStringType (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    LocalizedStringType::
    LocalizedStringType (const LocalizedStringType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    LocalizedStringType::
    LocalizedStringType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    LocalizedStringType* LocalizedStringType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class LocalizedStringType (*this, f, c);
    }

    LocalizedStringType::
    ~LocalizedStringType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, LocalizedStringType >
    _xsd_LocalizedStringType_type_factory_init (
      "LocalizedStringType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DeviceRelationshipTypes
    //

    DeviceRelationshipTypes::
    DeviceRelationshipTypes (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    DeviceRelationshipTypes::
    DeviceRelationshipTypes (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    DeviceRelationshipTypes::
    DeviceRelationshipTypes (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    DeviceRelationshipTypes* DeviceRelationshipTypes::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DeviceRelationshipTypes (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DeviceRelationshipTypes >
    _xsd_DeviceRelationshipTypes_type_factory_init (
      "DeviceRelationshipTypes",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DeviceRelationshipTypeURIs
    //

    DeviceRelationshipTypeURIs::
    DeviceRelationshipTypeURIs (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::Uri (e, f, c)
    {
    }

    DeviceRelationshipTypeURIs::
    DeviceRelationshipTypeURIs (const ::xercesc::DOMAttr& a,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::Uri (a, f, c)
    {
    }

    DeviceRelationshipTypeURIs::
    DeviceRelationshipTypeURIs (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::Uri (s, e, f, c)
    {
    }

    DeviceRelationshipTypeURIs* DeviceRelationshipTypeURIs::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DeviceRelationshipTypeURIs (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DeviceRelationshipTypeURIs >
    _xsd_DeviceRelationshipTypeURIs_type_factory_init (
      "DeviceRelationshipTypeURIs",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DeviceMetadataDialectURIs
    //

    DeviceMetadataDialectURIs::
    DeviceMetadataDialectURIs (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::Uri (e, f, c)
    {
    }

    DeviceMetadataDialectURIs::
    DeviceMetadataDialectURIs (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::Uri (a, f, c)
    {
    }

    DeviceMetadataDialectURIs::
    DeviceMetadataDialectURIs (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::Uri (s, e, f, c)
    {
    }

    DeviceMetadataDialectURIs* DeviceMetadataDialectURIs::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DeviceMetadataDialectURIs (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DeviceMetadataDialectURIs >
    _xsd_DeviceMetadataDialectURIs_type_factory_init (
      "DeviceMetadataDialectURIs",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DeviceEventingFilterDialects
    //

    DeviceEventingFilterDialects::
    DeviceEventingFilterDialects (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    DeviceEventingFilterDialects::
    DeviceEventingFilterDialects (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    DeviceEventingFilterDialects::
    DeviceEventingFilterDialects (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    DeviceEventingFilterDialects* DeviceEventingFilterDialects::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DeviceEventingFilterDialects (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DeviceEventingFilterDialects >
    _xsd_DeviceEventingFilterDialects_type_factory_init (
      "DeviceEventingFilterDialects",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DeviceEventingFilterDialectURIs
    //

    DeviceEventingFilterDialectURIs::
    DeviceEventingFilterDialectURIs (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::Uri (e, f, c)
    {
    }

    DeviceEventingFilterDialectURIs::
    DeviceEventingFilterDialectURIs (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::Uri (a, f, c)
    {
    }

    DeviceEventingFilterDialectURIs::
    DeviceEventingFilterDialectURIs (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::Uri (s, e, f, c)
    {
    }

    DeviceEventingFilterDialectURIs* DeviceEventingFilterDialectURIs::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DeviceEventingFilterDialectURIs (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DeviceEventingFilterDialectURIs >
    _xsd_DeviceEventingFilterDialectURIs_type_factory_init (
      "DeviceEventingFilterDialectURIs",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DeviceActionURIs
    //

    DeviceActionURIs::
    DeviceActionURIs (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Uri (e, f, c)
    {
    }

    DeviceActionURIs::
    DeviceActionURIs (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Uri (a, f, c)
    {
    }

    DeviceActionURIs::
    DeviceActionURIs (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Uri (s, e, f, c)
    {
    }

    DeviceActionURIs* DeviceActionURIs::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DeviceActionURIs (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DeviceActionURIs >
    _xsd_DeviceActionURIs_type_factory_init (
      "DeviceActionURIs",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DeviceSoapFaultSubcodes
    //

    DeviceSoapFaultSubcodes::
    DeviceSoapFaultSubcodes (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    DeviceSoapFaultSubcodes::
    DeviceSoapFaultSubcodes (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    DeviceSoapFaultSubcodes::
    DeviceSoapFaultSubcodes (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    DeviceSoapFaultSubcodes* DeviceSoapFaultSubcodes::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DeviceSoapFaultSubcodes (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DeviceSoapFaultSubcodes >
    _xsd_DeviceSoapFaultSubcodes_type_factory_init (
      "DeviceSoapFaultSubcodes",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DeviceSoapFaultSubcodeQNames
    //

    DeviceSoapFaultSubcodeQNames::
    DeviceSoapFaultSubcodeQNames (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::Qname (e, f, c)
    {
    }

    DeviceSoapFaultSubcodeQNames::
    DeviceSoapFaultSubcodeQNames (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::Qname (a, f, c)
    {
    }

    DeviceSoapFaultSubcodeQNames::
    DeviceSoapFaultSubcodeQNames (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::Qname (s, e, f, c)
    {
    }

    DeviceSoapFaultSubcodeQNames* DeviceSoapFaultSubcodeQNames::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DeviceSoapFaultSubcodeQNames (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DeviceSoapFaultSubcodeQNames >
    _xsd_DeviceSoapFaultSubcodeQNames_type_factory_init (
      "DeviceSoapFaultSubcodeQNames",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // HostServiceType
    //

    HostServiceType::
    HostServiceType (const EndpointReferenceType& EndpointReference)
    : ::xml_schema::Type (),
      EndpointReference_ (EndpointReference, this),
      Types_ (this)
    {
    }

    HostServiceType::
    HostServiceType (::std::unique_ptr< EndpointReferenceType > EndpointReference)
    : ::xml_schema::Type (),
      EndpointReference_ (std::move (EndpointReference), this),
      Types_ (this)
    {
    }

    HostServiceType::
    HostServiceType (const HostServiceType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this),
      Types_ (x.Types_, f, this)
    {
    }

    HostServiceType::
    HostServiceType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this),
      Types_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void HostServiceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EndpointReference_.present ())
            {
              ::std::unique_ptr< EndpointReferenceType > r (
                dynamic_cast< EndpointReferenceType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->EndpointReference_.set (::std::move (r));
              continue;
            }
          }
        }

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Types_)
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!EndpointReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndpointReference",
          "http://www.w3.org/2005/08/addressing");
      }
    }

    HostServiceType* HostServiceType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class HostServiceType (*this, f, c);
    }

    HostServiceType& HostServiceType::
    operator= (const HostServiceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
        this->Types_ = x.Types_;
      }

      return *this;
    }

    HostServiceType::
    ~HostServiceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, HostServiceType >
    _xsd_HostServiceType_type_factory_init (
      "HostServiceType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // HostedServiceType
    //

    HostedServiceType::
    HostedServiceType (const TypesType& Types,
                       const ServiceIdType& ServiceId)
    : ::xml_schema::Type (),
      EndpointReference_ (this),
      Types_ (Types, this),
      ServiceId_ (ServiceId, this)
    {
    }

    HostedServiceType::
    HostedServiceType (::std::unique_ptr< TypesType > Types,
                       ::std::unique_ptr< ServiceIdType > ServiceId)
    : ::xml_schema::Type (),
      EndpointReference_ (this),
      Types_ (std::move (Types), this),
      ServiceId_ (std::move (ServiceId), this)
    {
    }

    HostedServiceType::
    HostedServiceType (const HostedServiceType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this),
      Types_ (x.Types_, f, this),
      ServiceId_ (x.ServiceId_, f, this)
    {
    }

    HostedServiceType::
    HostedServiceType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this),
      Types_ (this),
      ServiceId_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void HostedServiceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< EndpointReferenceType > r (
              dynamic_cast< EndpointReferenceType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->EndpointReference_.push_back (::std::move (r));
            continue;
          }
        }

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Types_.present ())
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        // ServiceId
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ServiceId",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< ServiceIdType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!ServiceId_.present ())
            {
              ::std::unique_ptr< ServiceIdType > r (
                dynamic_cast< ServiceIdType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->ServiceId_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!Types_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Types",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
      }

      if (!ServiceId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ServiceId",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
      }
    }

    HostedServiceType* HostedServiceType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class HostedServiceType (*this, f, c);
    }

    HostedServiceType& HostedServiceType::
    operator= (const HostedServiceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
        this->Types_ = x.Types_;
        this->ServiceId_ = x.ServiceId_;
      }

      return *this;
    }

    HostedServiceType::
    ~HostedServiceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, HostedServiceType >
    _xsd_HostedServiceType_type_factory_init (
      "HostedServiceType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // QNameListType
    //

    QNameListType::
    QNameListType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (e, f, this)
    {
    }

    QNameListType::
    QNameListType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (a, f, this)
    {
    }

    QNameListType::
    QNameListType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (s, e, f, this)
    {
    }

    QNameListType* QNameListType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class QNameListType (*this, f, c);
    }

    QNameListType::
    ~QNameListType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, QNameListType >
    _xsd_QNameListType_type_factory_init (
      "QNameListType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // DiscoveryTypeValues
    //

    DiscoveryTypeValues::
    DiscoveryTypeValues (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Qname (e, f, c)
    {
    }

    DiscoveryTypeValues::
    DiscoveryTypeValues (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Qname (a, f, c)
    {
    }

    DiscoveryTypeValues::
    DiscoveryTypeValues (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Qname (s, e, f, c)
    {
    }

    DiscoveryTypeValues* DiscoveryTypeValues::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DiscoveryTypeValues (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DiscoveryTypeValues >
    _xsd_DiscoveryTypeValues_type_factory_init (
      "DiscoveryTypeValues",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // AssertionType
    //

    AssertionType::
    AssertionType ()
    : ::xml_schema::Type ()
    {
    }

    AssertionType::
    AssertionType (const ::xml_schema::Type& _xsd_Type_base)
    : ::xml_schema::Type (_xsd_Type_base)
    {
    }

    AssertionType::
    AssertionType (const AssertionType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c)
    {
    }

    AssertionType::
    AssertionType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f, c)
    {
    }

    AssertionType* AssertionType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class AssertionType (*this, f, c);
    }

    AssertionType::
    ~AssertionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, AssertionType >
    _xsd_AssertionType_type_factory_init (
      "AssertionType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");

    // Relationship
    //

    Relationship::
    Relationship (const HostType& Host,
                  const TypeType& Type)
    : ::xml_schema::Type (),
      Host_ (Host, this),
      Hosted_ (this),
      Type_ (Type, this)
    {
    }

    Relationship::
    Relationship (::std::unique_ptr< HostType > Host,
                  const TypeType& Type)
    : ::xml_schema::Type (),
      Host_ (std::move (Host), this),
      Hosted_ (this),
      Type_ (Type, this)
    {
    }

    Relationship::
    Relationship (const Relationship& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Host_ (x.Host_, f, this),
      Hosted_ (x.Hosted_, f, this),
      Type_ (x.Type_, f, this)
    {
    }

    Relationship::
    Relationship (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Host_ (this),
      Hosted_ (this),
      Type_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Relationship::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Host
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Host",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< HostType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Host_.present ())
            {
              ::std::unique_ptr< HostType > r (
                dynamic_cast< HostType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Host_.set (::std::move (r));
              continue;
            }
          }
        }

        // Hosted
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Hosted",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              &::xsd::cxx::tree::factory_impl< HostedType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< HostedType > r (
              dynamic_cast< HostedType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Hosted_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!Host_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Host",
          "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Type" && n.namespace_ ().empty ())
        {
          this->Type_.set (TypeTraits::create (i, f, this));
          continue;
        }
      }

      if (!Type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "Type",
          "");
      }
    }

    Relationship* Relationship::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Relationship (*this, f, c);
    }

    Relationship& Relationship::
    operator= (const Relationship& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->Host_ = x.Host_;
        this->Hosted_ = x.Hosted_;
        this->Type_ = x.Type_;
      }

      return *this;
    }

    Relationship::
    ~Relationship ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace WS
{
  namespace DPWS
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace WS
{
  namespace DPWS
  {
    void
    operator<< (::xercesc::DOMElement& e, const ThisModelType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Manufacturer
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (ThisModelType::ManufacturerConstIterator
             b (i.getManufacturer ().begin ()), n (i.getManufacturer ().end ());
             b != n; ++b)
        {
          if (typeid (ThisModelType::ManufacturerType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Manufacturer",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "Manufacturer",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, *b);
        }
      }

      // ManufacturerUrl
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getManufacturerUrl ())
        {
          const ThisModelType::ManufacturerUrlType& x (*i.getManufacturerUrl ());
          if (typeid (ThisModelType::ManufacturerUrlType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ManufacturerUrl",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "ManufacturerUrl",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, x);
        }
      }

      // ModelName
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (ThisModelType::ModelNameConstIterator
             b (i.getModelName ().begin ()), n (i.getModelName ().end ());
             b != n; ++b)
        {
          if (typeid (ThisModelType::ModelNameType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ModelName",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "ModelName",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, *b);
        }
      }

      // ModelNumber
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getModelNumber ())
        {
          const ThisModelType::ModelNumberType& x (*i.getModelNumber ());
          if (typeid (ThisModelType::ModelNumberType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ModelNumber",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "ModelNumber",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, x);
        }
      }

      // ModelUrl
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getModelUrl ())
        {
          const ThisModelType::ModelUrlType& x (*i.getModelUrl ());
          if (typeid (ThisModelType::ModelUrlType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ModelUrl",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "ModelUrl",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, x);
        }
      }

      // PresentationUrl
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getPresentationUrl ())
        {
          const ThisModelType::PresentationUrlType& x (*i.getPresentationUrl ());
          if (typeid (ThisModelType::PresentationUrlType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "PresentationUrl",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "PresentationUrl",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ThisModelType >
    _xsd_ThisModelType_type_serializer_init (
      "ThisModelType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const ThisDeviceType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // FriendlyName
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (ThisDeviceType::FriendlyNameConstIterator
             b (i.getFriendlyName ().begin ()), n (i.getFriendlyName ().end ());
             b != n; ++b)
        {
          if (typeid (ThisDeviceType::FriendlyNameType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "FriendlyName",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "FriendlyName",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, *b);
        }
      }

      // FirmwareVersion
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getFirmwareVersion ())
        {
          const ThisDeviceType::FirmwareVersionType& x (*i.getFirmwareVersion ());
          if (typeid (ThisDeviceType::FirmwareVersionType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "FirmwareVersion",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "FirmwareVersion",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, x);
        }
      }

      // SerialNumber
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getSerialNumber ())
        {
          const ThisDeviceType::SerialNumberType& x (*i.getSerialNumber ());
          if (typeid (ThisDeviceType::SerialNumberType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "SerialNumber",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "SerialNumber",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              false, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ThisDeviceType >
    _xsd_ThisDeviceType_type_serializer_init (
      "ThisDeviceType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const LocalizedStringType& i)
    {
      e << static_cast< const ::xml_schema::String& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LocalizedStringType >
    _xsd_LocalizedStringType_type_serializer_init (
      "LocalizedStringType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const DeviceRelationshipTypes& i)
    {
      e << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DeviceRelationshipTypes& i)
    {
      a << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DeviceRelationshipTypes& i)
    {
      l << static_cast< const ::xml_schema::String& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DeviceRelationshipTypes >
    _xsd_DeviceRelationshipTypes_type_serializer_init (
      "DeviceRelationshipTypes",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const DeviceRelationshipTypeURIs& i)
    {
      e << static_cast< const ::xml_schema::Uri& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DeviceRelationshipTypeURIs& i)
    {
      a << static_cast< const ::xml_schema::Uri& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DeviceRelationshipTypeURIs& i)
    {
      l << static_cast< const ::xml_schema::Uri& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DeviceRelationshipTypeURIs >
    _xsd_DeviceRelationshipTypeURIs_type_serializer_init (
      "DeviceRelationshipTypeURIs",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const DeviceMetadataDialectURIs& i)
    {
      e << static_cast< const ::xml_schema::Uri& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DeviceMetadataDialectURIs& i)
    {
      a << static_cast< const ::xml_schema::Uri& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DeviceMetadataDialectURIs& i)
    {
      l << static_cast< const ::xml_schema::Uri& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DeviceMetadataDialectURIs >
    _xsd_DeviceMetadataDialectURIs_type_serializer_init (
      "DeviceMetadataDialectURIs",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const DeviceEventingFilterDialects& i)
    {
      e << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DeviceEventingFilterDialects& i)
    {
      a << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DeviceEventingFilterDialects& i)
    {
      l << static_cast< const ::xml_schema::String& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DeviceEventingFilterDialects >
    _xsd_DeviceEventingFilterDialects_type_serializer_init (
      "DeviceEventingFilterDialects",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const DeviceEventingFilterDialectURIs& i)
    {
      e << static_cast< const ::xml_schema::Uri& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DeviceEventingFilterDialectURIs& i)
    {
      a << static_cast< const ::xml_schema::Uri& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DeviceEventingFilterDialectURIs& i)
    {
      l << static_cast< const ::xml_schema::Uri& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DeviceEventingFilterDialectURIs >
    _xsd_DeviceEventingFilterDialectURIs_type_serializer_init (
      "DeviceEventingFilterDialectURIs",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const DeviceActionURIs& i)
    {
      e << static_cast< const ::xml_schema::Uri& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DeviceActionURIs& i)
    {
      a << static_cast< const ::xml_schema::Uri& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DeviceActionURIs& i)
    {
      l << static_cast< const ::xml_schema::Uri& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DeviceActionURIs >
    _xsd_DeviceActionURIs_type_serializer_init (
      "DeviceActionURIs",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const DeviceSoapFaultSubcodes& i)
    {
      e << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DeviceSoapFaultSubcodes& i)
    {
      a << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DeviceSoapFaultSubcodes& i)
    {
      l << static_cast< const ::xml_schema::String& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DeviceSoapFaultSubcodes >
    _xsd_DeviceSoapFaultSubcodes_type_serializer_init (
      "DeviceSoapFaultSubcodes",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const DeviceSoapFaultSubcodeQNames& i)
    {
      e << static_cast< const ::xml_schema::Qname& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DeviceSoapFaultSubcodeQNames& i)
    {
      a << static_cast< const ::xml_schema::Qname& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DeviceSoapFaultSubcodeQNames& i)
    {
      l << static_cast< const ::xml_schema::Qname& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DeviceSoapFaultSubcodeQNames >
    _xsd_DeviceSoapFaultSubcodeQNames_type_serializer_init (
      "DeviceSoapFaultSubcodeQNames",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const HostServiceType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const HostServiceType::EndpointReferenceType& x (i.getEndpointReference ());
        if (typeid (HostServiceType::EndpointReferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EndpointReference",
            "http://www.w3.org/2005/08/addressing",
            true, true, e, x);
      }

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.getTypes ())
        {
          const HostServiceType::TypesType& x (*i.getTypes ());
          if (typeid (HostServiceType::TypesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Types",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              true, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, HostServiceType >
    _xsd_HostServiceType_type_serializer_init (
      "HostServiceType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const HostedServiceType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (HostedServiceType::EndpointReferenceConstIterator
             b (i.getEndpointReference ().begin ()), n (i.getEndpointReference ().end ());
             b != n; ++b)
        {
          if (typeid (HostedServiceType::EndpointReferenceType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "EndpointReference",
                "http://www.w3.org/2005/08/addressing",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              true, true, e, *b);
        }
      }

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const HostedServiceType::TypesType& x (i.getTypes ());
        if (typeid (HostedServiceType::TypesType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Types",
            "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
            true, true, e, x);
      }

      // ServiceId
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const HostedServiceType::ServiceIdType& x (i.getServiceId ());
        if (typeid (HostedServiceType::ServiceIdType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ServiceId",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ServiceId",
            "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, HostedServiceType >
    _xsd_HostedServiceType_type_serializer_init (
      "HostedServiceType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const QNameListType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Qname, char >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const QNameListType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Qname, char >& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const QNameListType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Qname, char >& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, QNameListType >
    _xsd_QNameListType_type_serializer_init (
      "QNameListType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const DiscoveryTypeValues& i)
    {
      e << static_cast< const ::xml_schema::Qname& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DiscoveryTypeValues& i)
    {
      a << static_cast< const ::xml_schema::Qname& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const DiscoveryTypeValues& i)
    {
      l << static_cast< const ::xml_schema::Qname& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DiscoveryTypeValues >
    _xsd_DiscoveryTypeValues_type_serializer_init (
      "DiscoveryTypeValues",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const AssertionType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AssertionType >
    _xsd_AssertionType_type_serializer_init (
      "AssertionType",
      "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const Relationship& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Host
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const Relationship::HostType& x (i.getHost ());
        if (typeid (Relationship::HostType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Host",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Host",
            "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
            true, true, e, x);
      }

      // Hosted
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (Relationship::HostedConstIterator
             b (i.getHosted ().begin ()), n (i.getHosted ().end ());
             b != n; ++b)
        {
          if (typeid (Relationship::HostedType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Hosted",
                "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "Hosted",
              "http://docs.oasis-open.org/ws-dd/ns/dpws/2009/01",
              true, true, e, *b);
        }
      }

      // Type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Type",
            e));

        a << i.getType ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

