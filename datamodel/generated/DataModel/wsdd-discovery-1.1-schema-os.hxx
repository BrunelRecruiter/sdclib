// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from wsdd-discovery-1.1-schema-os.xsd.
 */

#ifndef WSDD_DISCOVERY_1_1_SCHEMA_OS_HXX
#define WSDD_DISCOVERY_1_1_SCHEMA_OS_HXX

#include "DataModel/wsdd-discovery-1.1-schema-os-fwd.hxx"

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "DataModel/ws-addressing.hxx"

namespace WS
{
  /**
   * @brief C++ namespace for the %http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01
   * schema namespace.
   */
  namespace DISCOVERY
  {
    /**
     * @brief Class corresponding to the %HelloType schema type.
     *
     * @nosubgrouping
     */
    class HelloType: public ::xml_schema::Type
    {
      public:
      /**
       * @name EndpointReference
       *
       * @brief Accessor and modifier functions for the %EndpointReference
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::ADDRESSING::EndpointReferenceType EndpointReferenceType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< EndpointReferenceType, char > EndpointReferenceTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const EndpointReferenceType&
      getEndpointReference () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      EndpointReferenceType&
      getEndpointReference ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setEndpointReference (const EndpointReferenceType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      setEndpointReference (::std::unique_ptr< EndpointReferenceType > p);

      //@}

      /**
       * @name Types
       *
       * @brief Accessor and modifier functions for the %Types
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DISCOVERY::QNameListType TypesType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< TypesType > TypesOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TypesType, char > TypesTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const TypesOptional&
      getTypes () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      TypesOptional&
      getTypes ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setTypes (const TypesType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setTypes (const TypesOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setTypes (::std::unique_ptr< TypesType > p);

      //@}

      /**
       * @name Scopes
       *
       * @brief Accessor and modifier functions for the %Scopes
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DISCOVERY::ScopesType ScopesType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ScopesType > ScopesOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ScopesType, char > ScopesTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ScopesOptional&
      getScopes () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      ScopesOptional&
      getScopes ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setScopes (const ScopesType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setScopes (const ScopesOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setScopes (::std::unique_ptr< ScopesType > p);

      //@}

      /**
       * @name XAddrs
       *
       * @brief Accessor and modifier functions for the %XAddrs
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DISCOVERY::UriListType XAddrsType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< XAddrsType > XAddrsOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< XAddrsType, char > XAddrsTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const XAddrsOptional&
      getXAddrs () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      XAddrsOptional&
      getXAddrs ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setXAddrs (const XAddrsType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setXAddrs (const XAddrsOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setXAddrs (::std::unique_ptr< XAddrsType > p);

      //@}

      /**
       * @name MetadataVersion
       *
       * @brief Accessor and modifier functions for the %MetadataVersion
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::UnsignedInt MetadataVersionType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< MetadataVersionType, char > MetadataVersionTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const MetadataVersionType&
      getMetadataVersion () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      MetadataVersionType&
      getMetadataVersion ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setMetadataVersion (const MetadataVersionType& x);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      HelloType (const EndpointReferenceType&,
                 const MetadataVersionType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      HelloType (::std::unique_ptr< EndpointReferenceType >,
                 const MetadataVersionType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      HelloType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      HelloType (const HelloType& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual HelloType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      HelloType&
      operator= (const HelloType& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~HelloType ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< EndpointReferenceType > EndpointReference_;
      TypesOptional Types_;
      ScopesOptional Scopes_;
      XAddrsOptional XAddrs_;
      ::xsd::cxx::tree::one< MetadataVersionType > MetadataVersion_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %ByeType schema type.
     *
     * @nosubgrouping
     */
    class ByeType: public ::xml_schema::Type
    {
      public:
      /**
       * @name EndpointReference
       *
       * @brief Accessor and modifier functions for the %EndpointReference
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::ADDRESSING::EndpointReferenceType EndpointReferenceType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< EndpointReferenceType, char > EndpointReferenceTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const EndpointReferenceType&
      getEndpointReference () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      EndpointReferenceType&
      getEndpointReference ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setEndpointReference (const EndpointReferenceType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      setEndpointReference (::std::unique_ptr< EndpointReferenceType > p);

      //@}

      /**
       * @name Types
       *
       * @brief Accessor and modifier functions for the %Types
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DISCOVERY::QNameListType TypesType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< TypesType > TypesOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TypesType, char > TypesTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const TypesOptional&
      getTypes () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      TypesOptional&
      getTypes ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setTypes (const TypesType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setTypes (const TypesOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setTypes (::std::unique_ptr< TypesType > p);

      //@}

      /**
       * @name Scopes
       *
       * @brief Accessor and modifier functions for the %Scopes
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DISCOVERY::ScopesType ScopesType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ScopesType > ScopesOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ScopesType, char > ScopesTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ScopesOptional&
      getScopes () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      ScopesOptional&
      getScopes ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setScopes (const ScopesType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setScopes (const ScopesOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setScopes (::std::unique_ptr< ScopesType > p);

      //@}

      /**
       * @name XAddrs
       *
       * @brief Accessor and modifier functions for the %XAddrs
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DISCOVERY::UriListType XAddrsType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< XAddrsType > XAddrsOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< XAddrsType, char > XAddrsTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const XAddrsOptional&
      getXAddrs () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      XAddrsOptional&
      getXAddrs ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setXAddrs (const XAddrsType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setXAddrs (const XAddrsOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setXAddrs (::std::unique_ptr< XAddrsType > p);

      //@}

      /**
       * @name MetadataVersion
       *
       * @brief Accessor and modifier functions for the %MetadataVersion
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::UnsignedInt MetadataVersionType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< MetadataVersionType > MetadataVersionOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< MetadataVersionType, char > MetadataVersionTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const MetadataVersionOptional&
      getMetadataVersion () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      MetadataVersionOptional&
      getMetadataVersion ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setMetadataVersion (const MetadataVersionType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setMetadataVersion (const MetadataVersionOptional& x);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ByeType (const EndpointReferenceType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      ByeType (::std::unique_ptr< EndpointReferenceType >);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ByeType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ByeType (const ByeType& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ByeType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ByeType&
      operator= (const ByeType& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ByeType ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< EndpointReferenceType > EndpointReference_;
      TypesOptional Types_;
      ScopesOptional Scopes_;
      XAddrsOptional XAddrs_;
      MetadataVersionOptional MetadataVersion_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %ProbeType schema type.
     *
     * @nosubgrouping
     */
    class ProbeType: public ::xml_schema::Type
    {
      public:
      /**
       * @name Types
       *
       * @brief Accessor and modifier functions for the %Types
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DISCOVERY::QNameListType TypesType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< TypesType > TypesOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TypesType, char > TypesTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const TypesOptional&
      getTypes () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      TypesOptional&
      getTypes ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setTypes (const TypesType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setTypes (const TypesOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setTypes (::std::unique_ptr< TypesType > p);

      //@}

      /**
       * @name Scopes
       *
       * @brief Accessor and modifier functions for the %Scopes
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DISCOVERY::ScopesType ScopesType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ScopesType > ScopesOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ScopesType, char > ScopesTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ScopesOptional&
      getScopes () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      ScopesOptional&
      getScopes ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setScopes (const ScopesType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setScopes (const ScopesOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setScopes (::std::unique_ptr< ScopesType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ProbeType ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ProbeType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ProbeType (const ProbeType& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ProbeType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ProbeType&
      operator= (const ProbeType& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ProbeType ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      TypesOptional Types_;
      ScopesOptional Scopes_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %ProbeMatchesType schema type.
     *
     * @nosubgrouping
     */
    class ProbeMatchesType: public ::xml_schema::Type
    {
      public:
      /**
       * @name ProbeMatch
       *
       * @brief Accessor and modifier functions for the %ProbeMatch
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DISCOVERY::ProbeMatchType ProbeMatchType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< ProbeMatchType > ProbeMatchSequence;

      /**
       * @brief Element iterator type.
       */
      typedef ProbeMatchSequence::iterator ProbeMatchIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef ProbeMatchSequence::const_iterator ProbeMatchConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ProbeMatchType, char > ProbeMatchTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const ProbeMatchSequence&
      getProbeMatch () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      ProbeMatchSequence&
      getProbeMatch ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      setProbeMatch (const ProbeMatchSequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ProbeMatchesType ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ProbeMatchesType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ProbeMatchesType (const ProbeMatchesType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ProbeMatchesType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ProbeMatchesType&
      operator= (const ProbeMatchesType& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ProbeMatchesType ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ProbeMatchSequence ProbeMatch_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %ProbeMatchType schema type.
     *
     * @nosubgrouping
     */
    class ProbeMatchType: public ::xml_schema::Type
    {
      public:
      /**
       * @name EndpointReference
       *
       * @brief Accessor and modifier functions for the %EndpointReference
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::ADDRESSING::EndpointReferenceType EndpointReferenceType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< EndpointReferenceType, char > EndpointReferenceTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const EndpointReferenceType&
      getEndpointReference () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      EndpointReferenceType&
      getEndpointReference ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setEndpointReference (const EndpointReferenceType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      setEndpointReference (::std::unique_ptr< EndpointReferenceType > p);

      //@}

      /**
       * @name Types
       *
       * @brief Accessor and modifier functions for the %Types
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DISCOVERY::QNameListType TypesType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< TypesType > TypesOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TypesType, char > TypesTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const TypesOptional&
      getTypes () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      TypesOptional&
      getTypes ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setTypes (const TypesType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setTypes (const TypesOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setTypes (::std::unique_ptr< TypesType > p);

      //@}

      /**
       * @name Scopes
       *
       * @brief Accessor and modifier functions for the %Scopes
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DISCOVERY::ScopesType ScopesType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ScopesType > ScopesOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ScopesType, char > ScopesTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ScopesOptional&
      getScopes () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      ScopesOptional&
      getScopes ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setScopes (const ScopesType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setScopes (const ScopesOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setScopes (::std::unique_ptr< ScopesType > p);

      //@}

      /**
       * @name XAddrs
       *
       * @brief Accessor and modifier functions for the %XAddrs
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DISCOVERY::UriListType XAddrsType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< XAddrsType > XAddrsOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< XAddrsType, char > XAddrsTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const XAddrsOptional&
      getXAddrs () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      XAddrsOptional&
      getXAddrs ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setXAddrs (const XAddrsType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setXAddrs (const XAddrsOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setXAddrs (::std::unique_ptr< XAddrsType > p);

      //@}

      /**
       * @name MetadataVersion
       *
       * @brief Accessor and modifier functions for the %MetadataVersion
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::UnsignedInt MetadataVersionType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< MetadataVersionType, char > MetadataVersionTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const MetadataVersionType&
      getMetadataVersion () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      MetadataVersionType&
      getMetadataVersion ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setMetadataVersion (const MetadataVersionType& x);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ProbeMatchType (const EndpointReferenceType&,
                      const MetadataVersionType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      ProbeMatchType (::std::unique_ptr< EndpointReferenceType >,
                      const MetadataVersionType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ProbeMatchType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ProbeMatchType (const ProbeMatchType& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ProbeMatchType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ProbeMatchType&
      operator= (const ProbeMatchType& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ProbeMatchType ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< EndpointReferenceType > EndpointReference_;
      TypesOptional Types_;
      ScopesOptional Scopes_;
      XAddrsOptional XAddrs_;
      ::xsd::cxx::tree::one< MetadataVersionType > MetadataVersion_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %ResolveType schema type.
     *
     * @nosubgrouping
     */
    class ResolveType: public ::xml_schema::Type
    {
      public:
      /**
       * @name EndpointReference
       *
       * @brief Accessor and modifier functions for the %EndpointReference
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::ADDRESSING::EndpointReferenceType EndpointReferenceType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< EndpointReferenceType, char > EndpointReferenceTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const EndpointReferenceType&
      getEndpointReference () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      EndpointReferenceType&
      getEndpointReference ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setEndpointReference (const EndpointReferenceType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      setEndpointReference (::std::unique_ptr< EndpointReferenceType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ResolveType (const EndpointReferenceType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      ResolveType (::std::unique_ptr< EndpointReferenceType >);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ResolveType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ResolveType (const ResolveType& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ResolveType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ResolveType&
      operator= (const ResolveType& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ResolveType ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< EndpointReferenceType > EndpointReference_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %ResolveMatchesType schema type.
     *
     * @nosubgrouping
     */
    class ResolveMatchesType: public ::xml_schema::Type
    {
      public:
      /**
       * @name ResolveMatch
       *
       * @brief Accessor and modifier functions for the %ResolveMatch
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DISCOVERY::ResolveMatchType ResolveMatchType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ResolveMatchType > ResolveMatchOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ResolveMatchType, char > ResolveMatchTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ResolveMatchOptional&
      getResolveMatch () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      ResolveMatchOptional&
      getResolveMatch ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setResolveMatch (const ResolveMatchType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setResolveMatch (const ResolveMatchOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setResolveMatch (::std::unique_ptr< ResolveMatchType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ResolveMatchesType ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ResolveMatchesType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ResolveMatchesType (const ResolveMatchesType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ResolveMatchesType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ResolveMatchesType&
      operator= (const ResolveMatchesType& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ResolveMatchesType ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ResolveMatchOptional ResolveMatch_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %ResolveMatchType schema type.
     *
     * @nosubgrouping
     */
    class ResolveMatchType: public ::xml_schema::Type
    {
      public:
      /**
       * @name EndpointReference
       *
       * @brief Accessor and modifier functions for the %EndpointReference
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::ADDRESSING::EndpointReferenceType EndpointReferenceType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< EndpointReferenceType, char > EndpointReferenceTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const EndpointReferenceType&
      getEndpointReference () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      EndpointReferenceType&
      getEndpointReference ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setEndpointReference (const EndpointReferenceType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      setEndpointReference (::std::unique_ptr< EndpointReferenceType > p);

      //@}

      /**
       * @name Types
       *
       * @brief Accessor and modifier functions for the %Types
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DISCOVERY::QNameListType TypesType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< TypesType > TypesOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TypesType, char > TypesTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const TypesOptional&
      getTypes () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      TypesOptional&
      getTypes ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setTypes (const TypesType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setTypes (const TypesOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setTypes (::std::unique_ptr< TypesType > p);

      //@}

      /**
       * @name Scopes
       *
       * @brief Accessor and modifier functions for the %Scopes
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DISCOVERY::ScopesType ScopesType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ScopesType > ScopesOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ScopesType, char > ScopesTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ScopesOptional&
      getScopes () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      ScopesOptional&
      getScopes ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setScopes (const ScopesType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setScopes (const ScopesOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setScopes (::std::unique_ptr< ScopesType > p);

      //@}

      /**
       * @name XAddrs
       *
       * @brief Accessor and modifier functions for the %XAddrs
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DISCOVERY::UriListType XAddrsType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< XAddrsType > XAddrsOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< XAddrsType, char > XAddrsTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const XAddrsOptional&
      getXAddrs () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      XAddrsOptional&
      getXAddrs ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setXAddrs (const XAddrsType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setXAddrs (const XAddrsOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setXAddrs (::std::unique_ptr< XAddrsType > p);

      //@}

      /**
       * @name MetadataVersion
       *
       * @brief Accessor and modifier functions for the %MetadataVersion
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::UnsignedInt MetadataVersionType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< MetadataVersionType, char > MetadataVersionTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const MetadataVersionType&
      getMetadataVersion () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      MetadataVersionType&
      getMetadataVersion ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setMetadataVersion (const MetadataVersionType& x);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ResolveMatchType (const EndpointReferenceType&,
                        const MetadataVersionType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      ResolveMatchType (::std::unique_ptr< EndpointReferenceType >,
                        const MetadataVersionType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ResolveMatchType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ResolveMatchType (const ResolveMatchType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ResolveMatchType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ResolveMatchType&
      operator= (const ResolveMatchType& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ResolveMatchType ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< EndpointReferenceType > EndpointReference_;
      TypesOptional Types_;
      ScopesOptional Scopes_;
      XAddrsOptional XAddrs_;
      ::xsd::cxx::tree::one< MetadataVersionType > MetadataVersion_;

      //@endcond
    };

    /**
     * @brief List class corresponding to the %QNameListType
     * schema type.
     *
     * This class has an interface of a standard C++ sequence (e.g.,
     * std::vector).
     */
    class QNameListType: public ::xml_schema::SimpleType,
      public ::xsd::cxx::tree::list< ::xml_schema::Qname, char >
    {
      public:
      /**
       * @brief Default constructor.
       *
       * Creates an empty list.
       */
      QNameListType ();

      /**
       * @brief Create a list with copies of the specified element.
       *
       * @param n A number of elements to copy.
       * @param x An element to copy.
       *
       * This constructor creates a list with @a n copies of @a x.
       */
      QNameListType (size_type n, const ::xml_schema::Qname& x);

      /**
       * @brief Create a list from an iterator range.
       *
       * @param begin An iterator pointing to the first element.
       * @param end An iterator pointing to the one past the last element.
       *
       * This constructor creates a list consisting of copies of the
       * elements in the range [begin,end).
       */
      template < typename I >
      QNameListType (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (begin, end, this)
      {
      }

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      QNameListType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      QNameListType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      QNameListType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      QNameListType (const QNameListType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual QNameListType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Destructor.
       */
      virtual 
      ~QNameListType ();
    };

    /**
     * @brief List class corresponding to the %UriListType
     * schema type.
     *
     * This class has an interface of a standard C++ sequence (e.g.,
     * std::vector).
     */
    class UriListType: public ::xml_schema::SimpleType,
      public ::xsd::cxx::tree::list< ::xml_schema::Uri, char >
    {
      public:
      /**
       * @brief Default constructor.
       *
       * Creates an empty list.
       */
      UriListType ();

      /**
       * @brief Create a list with copies of the specified element.
       *
       * @param n A number of elements to copy.
       * @param x An element to copy.
       *
       * This constructor creates a list with @a n copies of @a x.
       */
      UriListType (size_type n, const ::xml_schema::Uri& x);

      /**
       * @brief Create a list from an iterator range.
       *
       * @param begin An iterator pointing to the first element.
       * @param end An iterator pointing to the one past the last element.
       *
       * This constructor creates a list consisting of copies of the
       * elements in the range [begin,end).
       */
      template < typename I >
      UriListType (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (begin, end, this)
      {
      }

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      UriListType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      UriListType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      UriListType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      UriListType (const UriListType& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual UriListType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Destructor.
       */
      virtual 
      ~UriListType ();
    };

    /**
     * @brief Class corresponding to the %ScopesType schema type.
     *
     * @nosubgrouping
     */
    class ScopesType: public ::WS::DISCOVERY::UriListType
    {
      public:
      /**
       * @name MatchBy
       *
       * @brief Accessor and modifier functions for the %MatchBy
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Uri MatchByType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< MatchByType > MatchByOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< MatchByType, char > MatchByTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const MatchByOptional&
      getMatchBy () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      MatchByOptional&
      getMatchBy ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      setMatchBy (const MatchByType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      setMatchBy (const MatchByOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setMatchBy (::std::unique_ptr< MatchByType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from initializers for required 
       * elements and attributes.
       */
      ScopesType ();

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ScopesType (const ::WS::DISCOVERY::UriListType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ScopesType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ScopesType (const ScopesType& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ScopesType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ScopesType&
      operator= (const ScopesType& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ScopesType ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      MatchByOptional MatchBy_;

      //@endcond
    };

    /**
     * @brief Enumeration class corresponding to the %FaultCodeType
     * schema type.
     */
    class FaultCodeType: public ::xml_schema::Qname
    {
      public:
      /**
       * @brief Create an instance from the base value.
       *
       * @param v A base value.
       */
      FaultCodeType (const ::xml_schema::Qname& v);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      FaultCodeType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      FaultCodeType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      FaultCodeType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      FaultCodeType (const FaultCodeType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual FaultCodeType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;
    };

    /**
     * @brief Union class corresponding to the %FaultCodeOpenType
     * schema type.
     *
     * The mapping represents unions as strings.
     */
    class FaultCodeOpenType: public ::xml_schema::String
    {
      public:

      /**
       * @brief Create an instance from a C string.
       *
       * @param v A string value.
       */
      FaultCodeOpenType (const char* v);

      /**
       * @brief Create an instance from a string.
       *
       * @param v A string value.
       */
      FaultCodeOpenType (const ::std::string& v);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      FaultCodeOpenType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      FaultCodeOpenType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      FaultCodeOpenType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      FaultCodeOpenType (const FaultCodeOpenType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual FaultCodeOpenType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;
    };

    /**
     * @brief Class corresponding to the %SecurityType schema type.
     *
     * @nosubgrouping
     */
    class SecurityType: public ::xml_schema::Type
    {
      public:
      /**
       * @name Sig
       *
       * @brief Accessor and modifier functions for the %Sig
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::WS::DISCOVERY::SigType SigType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< SigType > SigOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< SigType, char > SigTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const SigOptional&
      getSig () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      SigOptional&
      getSig ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      setSig (const SigType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      setSig (const SigOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setSig (::std::unique_ptr< SigType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      SecurityType ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      SecurityType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SecurityType (const SecurityType& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual SecurityType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SecurityType&
      operator= (const SecurityType& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~SecurityType ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      SigOptional Sig_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %SigType schema type.
     *
     * @nosubgrouping
     */
    class SigType: public ::xml_schema::Type
    {
      public:
      /**
       * @name Scheme
       *
       * @brief Accessor and modifier functions for the %Scheme
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Uri SchemeType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< SchemeType, char > SchemeTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const SchemeType&
      getScheme () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      SchemeType&
      getScheme ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      setScheme (const SchemeType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      setScheme (::std::unique_ptr< SchemeType > p);

      //@}

      /**
       * @name KeyId
       *
       * @brief Accessor and modifier functions for the %KeyId
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Base64Binary KeyIdType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< KeyIdType > KeyIdOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< KeyIdType, char > KeyIdTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const KeyIdOptional&
      getKeyId () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      KeyIdOptional&
      getKeyId ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      setKeyId (const KeyIdType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      setKeyId (const KeyIdOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setKeyId (::std::unique_ptr< KeyIdType > p);

      //@}

      /**
       * @name Refs
       *
       * @brief Accessor and modifier functions for the %Refs
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Idrefs RefsType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< RefsType, char > RefsTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const RefsType&
      getRefs () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      RefsType&
      getRefs ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      setRefs (const RefsType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      setRefs (::std::unique_ptr< RefsType > p);

      //@}

      /**
       * @name Sig
       *
       * @brief Accessor and modifier functions for the %Sig
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Base64Binary SigType1;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< SigType1, char > SigTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const SigType1&
      getSig () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      SigType1&
      getSig ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      setSig (const SigType1& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      setSig (::std::unique_ptr< SigType1 > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      SigType (const SchemeType&,
               const RefsType&,
               const SigType1&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      SigType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SigType (const SigType& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual SigType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SigType&
      operator= (const SigType& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~SigType ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< SchemeType > Scheme_;
      KeyIdOptional KeyId_;
      ::xsd::cxx::tree::one< RefsType > Refs_;
      ::xsd::cxx::tree::one< SigType1 > Sig_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %AppSequenceType schema type.
     *
     * @nosubgrouping
     */
    class AppSequenceType: public ::xml_schema::Type
    {
      public:
      /**
       * @name InstanceId
       *
       * @brief Accessor and modifier functions for the %InstanceId
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt InstanceIdType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< InstanceIdType, char > InstanceIdTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const InstanceIdType&
      getInstanceId () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      InstanceIdType&
      getInstanceId ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      setInstanceId (const InstanceIdType& x);

      //@}

      /**
       * @name SequenceId
       *
       * @brief Accessor and modifier functions for the %SequenceId
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Uri SequenceIdType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< SequenceIdType > SequenceIdOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< SequenceIdType, char > SequenceIdTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const SequenceIdOptional&
      getSequenceId () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      SequenceIdOptional&
      getSequenceId ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      setSequenceId (const SequenceIdType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      setSequenceId (const SequenceIdOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      setSequenceId (::std::unique_ptr< SequenceIdType > p);

      //@}

      /**
       * @name MessageNumber
       *
       * @brief Accessor and modifier functions for the %MessageNumber
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt MessageNumberType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< MessageNumberType, char > MessageNumberTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const MessageNumberType&
      getMessageNumber () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      MessageNumberType&
      getMessageNumber ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      setMessageNumber (const MessageNumberType& x);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from initializers for required 
       * elements and attributes.
       */
      AppSequenceType (const InstanceIdType&,
                       const MessageNumberType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      AppSequenceType (const ::xml_schema::Type&,
                       const InstanceIdType&,
                       const MessageNumberType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      AppSequenceType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      AppSequenceType (const AppSequenceType& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual AppSequenceType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      AppSequenceType&
      operator= (const AppSequenceType& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~AppSequenceType ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< InstanceIdType > InstanceId_;
      SequenceIdOptional SequenceId_;
      ::xsd::cxx::tree::one< MessageNumberType > MessageNumber_;

      //@endcond
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace WS
{
  namespace DISCOVERY
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace WS
{
  namespace DISCOVERY
  {
    void
    operator<< (::xercesc::DOMElement&, const HelloType&);

    void
    operator<< (::xercesc::DOMElement&, const ByeType&);

    void
    operator<< (::xercesc::DOMElement&, const ProbeType&);

    void
    operator<< (::xercesc::DOMElement&, const ProbeMatchesType&);

    void
    operator<< (::xercesc::DOMElement&, const ProbeMatchType&);

    void
    operator<< (::xercesc::DOMElement&, const ResolveType&);

    void
    operator<< (::xercesc::DOMElement&, const ResolveMatchesType&);

    void
    operator<< (::xercesc::DOMElement&, const ResolveMatchType&);

    void
    operator<< (::xercesc::DOMElement&, const QNameListType&);

    void
    operator<< (::xercesc::DOMAttr&, const QNameListType&);

    void
    operator<< (::xml_schema::ListStream&,
                const QNameListType&);

    void
    operator<< (::xercesc::DOMElement&, const UriListType&);

    void
    operator<< (::xercesc::DOMAttr&, const UriListType&);

    void
    operator<< (::xml_schema::ListStream&,
                const UriListType&);

    void
    operator<< (::xercesc::DOMElement&, const ScopesType&);

    void
    operator<< (::xercesc::DOMElement&, const FaultCodeType&);

    void
    operator<< (::xercesc::DOMAttr&, const FaultCodeType&);

    void
    operator<< (::xml_schema::ListStream&,
                const FaultCodeType&);

    void
    operator<< (::xercesc::DOMElement&, const FaultCodeOpenType&);

    void
    operator<< (::xercesc::DOMAttr&, const FaultCodeOpenType&);

    void
    operator<< (::xml_schema::ListStream&,
                const FaultCodeOpenType&);

    void
    operator<< (::xercesc::DOMElement&, const SecurityType&);

    void
    operator<< (::xercesc::DOMElement&, const SigType&);

    void
    operator<< (::xercesc::DOMElement&, const AppSequenceType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // WSDD_DISCOVERY_1_1_SCHEMA_OS_HXX
