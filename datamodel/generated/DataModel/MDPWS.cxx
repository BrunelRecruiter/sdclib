// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "DataModel/MDPWS.hxx"

namespace MDPWS
{
  // StreamSourceType
  // 


  // StreamTransmissionType
  // 

  const StreamTransmissionType::StreamAddressOptional& StreamTransmissionType::
  getStreamAddress () const
  {
    return this->StreamAddress_;
  }

  StreamTransmissionType::StreamAddressOptional& StreamTransmissionType::
  getStreamAddress ()
  {
    return this->StreamAddress_;
  }

  void StreamTransmissionType::
  setStreamAddress (const StreamAddressType& x)
  {
    this->StreamAddress_.set (x);
  }

  void StreamTransmissionType::
  setStreamAddress (const StreamAddressOptional& x)
  {
    this->StreamAddress_ = x;
  }

  void StreamTransmissionType::
  setStreamAddress (::std::unique_ptr< StreamAddressType > x)
  {
    this->StreamAddress_.set (std::move (x));
  }

  const StreamTransmissionType::StreamPeriodOptional& StreamTransmissionType::
  getStreamPeriod () const
  {
    return this->StreamPeriod_;
  }

  StreamTransmissionType::StreamPeriodOptional& StreamTransmissionType::
  getStreamPeriod ()
  {
    return this->StreamPeriod_;
  }

  void StreamTransmissionType::
  setStreamPeriod (const StreamPeriodType& x)
  {
    this->StreamPeriod_.set (x);
  }

  void StreamTransmissionType::
  setStreamPeriod (const StreamPeriodOptional& x)
  {
    this->StreamPeriod_ = x;
  }

  void StreamTransmissionType::
  setStreamPeriod (::std::unique_ptr< StreamPeriodType > x)
  {
    this->StreamPeriod_.set (std::move (x));
  }

  const StreamTransmissionType::TypeOptional& StreamTransmissionType::
  getType () const
  {
    return this->Type_;
  }

  StreamTransmissionType::TypeOptional& StreamTransmissionType::
  getType ()
  {
    return this->Type_;
  }

  void StreamTransmissionType::
  setType (const TypeType& x)
  {
    this->Type_.set (x);
  }

  void StreamTransmissionType::
  setType (const TypeOptional& x)
  {
    this->Type_ = x;
  }

  void StreamTransmissionType::
  setType (::std::unique_ptr< TypeType > x)
  {
    this->Type_.set (std::move (x));
  }


  // StreamTypeType
  // 

  const StreamTypeType::StreamTransmissionType& StreamTypeType::
  getStreamTransmission () const
  {
    return this->StreamTransmission_.get ();
  }

  StreamTypeType::StreamTransmissionType& StreamTypeType::
  getStreamTransmission ()
  {
    return this->StreamTransmission_.get ();
  }

  void StreamTypeType::
  setStreamTransmission (const StreamTransmissionType& x)
  {
    this->StreamTransmission_.set (x);
  }

  void StreamTypeType::
  setStreamTransmission (::std::unique_ptr< StreamTransmissionType > x)
  {
    this->StreamTransmission_.set (std::move (x));
  }

  const StreamTypeType::IdType& StreamTypeType::
  getId () const
  {
    return this->Id_.get ();
  }

  StreamTypeType::IdType& StreamTypeType::
  getId ()
  {
    return this->Id_.get ();
  }

  void StreamTypeType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void StreamTypeType::
  setId (::std::unique_ptr< IdType > x)
  {
    this->Id_.set (std::move (x));
  }

  const StreamTypeType::StreamTypeType1& StreamTypeType::
  getStreamType () const
  {
    return this->StreamType_.get ();
  }

  StreamTypeType::StreamTypeType1& StreamTypeType::
  getStreamType ()
  {
    return this->StreamType_.get ();
  }

  void StreamTypeType::
  setStreamType (const StreamTypeType1& x)
  {
    this->StreamType_.set (x);
  }

  void StreamTypeType::
  setStreamType (::std::unique_ptr< StreamTypeType1 > x)
  {
    this->StreamType_.set (std::move (x));
  }

  const StreamTypeType::ElementOptional& StreamTypeType::
  getElement () const
  {
    return this->Element_;
  }

  StreamTypeType::ElementOptional& StreamTypeType::
  getElement ()
  {
    return this->Element_;
  }

  void StreamTypeType::
  setElement (const ElementType& x)
  {
    this->Element_.set (x);
  }

  void StreamTypeType::
  setElement (const ElementOptional& x)
  {
    this->Element_ = x;
  }

  void StreamTypeType::
  setElement (::std::unique_ptr< ElementType > x)
  {
    this->Element_.set (std::move (x));
  }

  const StreamTypeType::ActionUriOptional& StreamTypeType::
  getActionUri () const
  {
    return this->ActionUri_;
  }

  StreamTypeType::ActionUriOptional& StreamTypeType::
  getActionUri ()
  {
    return this->ActionUri_;
  }

  void StreamTypeType::
  setActionUri (const ActionUriType& x)
  {
    this->ActionUri_.set (x);
  }

  void StreamTypeType::
  setActionUri (const ActionUriOptional& x)
  {
    this->ActionUri_ = x;
  }

  void StreamTypeType::
  setActionUri (::std::unique_ptr< ActionUriType > x)
  {
    this->ActionUri_.set (std::move (x));
  }


  // StreamDescriptionsType
  // 

  const StreamDescriptionsType::TypesOptional& StreamDescriptionsType::
  getTypes () const
  {
    return this->Types_;
  }

  StreamDescriptionsType::TypesOptional& StreamDescriptionsType::
  getTypes ()
  {
    return this->Types_;
  }

  void StreamDescriptionsType::
  setTypes (const TypesType& x)
  {
    this->Types_.set (x);
  }

  void StreamDescriptionsType::
  setTypes (const TypesOptional& x)
  {
    this->Types_ = x;
  }

  void StreamDescriptionsType::
  setTypes (::std::unique_ptr< TypesType > x)
  {
    this->Types_.set (std::move (x));
  }

  const StreamDescriptionsType::StreamTypeSequence& StreamDescriptionsType::
  getStreamType () const
  {
    return this->StreamType_;
  }

  StreamDescriptionsType::StreamTypeSequence& StreamDescriptionsType::
  getStreamType ()
  {
    return this->StreamType_;
  }

  void StreamDescriptionsType::
  setStreamType (const StreamTypeSequence& s)
  {
    this->StreamType_ = s;
  }

  const StreamDescriptionsType::TargetNamespaceType& StreamDescriptionsType::
  getTargetNamespace () const
  {
    return this->TargetNamespace_.get ();
  }

  StreamDescriptionsType::TargetNamespaceType& StreamDescriptionsType::
  getTargetNamespace ()
  {
    return this->TargetNamespace_.get ();
  }

  void StreamDescriptionsType::
  setTargetNamespace (const TargetNamespaceType& x)
  {
    this->TargetNamespace_.set (x);
  }

  void StreamDescriptionsType::
  setTargetNamespace (::std::unique_ptr< TargetNamespaceType > x)
  {
    this->TargetNamespace_.set (std::move (x));
  }


  // SafetyReqAssertionType
  // 

  const SafetyReqAssertionType::TransmitDualChannelType& SafetyReqAssertionType::
  getTransmitDualChannel () const
  {
    return this->TransmitDualChannel_.get ();
  }

  SafetyReqAssertionType::TransmitDualChannelType& SafetyReqAssertionType::
  getTransmitDualChannel ()
  {
    return this->TransmitDualChannel_.get ();
  }

  void SafetyReqAssertionType::
  setTransmitDualChannel (const TransmitDualChannelType& x)
  {
    this->TransmitDualChannel_.set (x);
  }

  SafetyReqAssertionType::TransmitDualChannelType SafetyReqAssertionType::
  getTransmitDualChannelDefaultValue ()
  {
    return TransmitDualChannelType (true);
  }

  const SafetyReqAssertionType::TransmitSafetyContextType& SafetyReqAssertionType::
  getTransmitSafetyContext () const
  {
    return this->TransmitSafetyContext_.get ();
  }

  SafetyReqAssertionType::TransmitSafetyContextType& SafetyReqAssertionType::
  getTransmitSafetyContext ()
  {
    return this->TransmitSafetyContext_.get ();
  }

  void SafetyReqAssertionType::
  setTransmitSafetyContext (const TransmitSafetyContextType& x)
  {
    this->TransmitSafetyContext_.set (x);
  }

  SafetyReqAssertionType::TransmitSafetyContextType SafetyReqAssertionType::
  getTransmitSafetyContextDefaultValue ()
  {
    return TransmitSafetyContextType (true);
  }


  // SelectorType
  // 

  const SelectorType::IdType& SelectorType::
  getId () const
  {
    return this->Id_.get ();
  }

  SelectorType::IdType& SelectorType::
  getId ()
  {
    return this->Id_.get ();
  }

  void SelectorType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void SelectorType::
  setId (::std::unique_ptr< IdType > x)
  {
    this->Id_.set (std::move (x));
  }


  // SafetyReqType
  // 

  const SafetyReqType::DualChannelDefOptional& SafetyReqType::
  getDualChannelDef () const
  {
    return this->DualChannelDef_;
  }

  SafetyReqType::DualChannelDefOptional& SafetyReqType::
  getDualChannelDef ()
  {
    return this->DualChannelDef_;
  }

  void SafetyReqType::
  setDualChannelDef (const DualChannelDefType& x)
  {
    this->DualChannelDef_.set (x);
  }

  void SafetyReqType::
  setDualChannelDef (const DualChannelDefOptional& x)
  {
    this->DualChannelDef_ = x;
  }

  void SafetyReqType::
  setDualChannelDef (::std::unique_ptr< DualChannelDefType > x)
  {
    this->DualChannelDef_.set (std::move (x));
  }

  const SafetyReqType::SafetyContextDefOptional& SafetyReqType::
  getSafetyContextDef () const
  {
    return this->SafetyContextDef_;
  }

  SafetyReqType::SafetyContextDefOptional& SafetyReqType::
  getSafetyContextDef ()
  {
    return this->SafetyContextDef_;
  }

  void SafetyReqType::
  setSafetyContextDef (const SafetyContextDefType& x)
  {
    this->SafetyContextDef_.set (x);
  }

  void SafetyReqType::
  setSafetyContextDef (const SafetyContextDefOptional& x)
  {
    this->SafetyContextDef_ = x;
  }

  void SafetyReqType::
  setSafetyContextDef (::std::unique_ptr< SafetyContextDefType > x)
  {
    this->SafetyContextDef_.set (std::move (x));
  }


  // DualChannelDefType
  // 

  const DualChannelDefType::SelectorSequence& DualChannelDefType::
  getSelector () const
  {
    return this->Selector_;
  }

  DualChannelDefType::SelectorSequence& DualChannelDefType::
  getSelector ()
  {
    return this->Selector_;
  }

  void DualChannelDefType::
  setSelector (const SelectorSequence& s)
  {
    this->Selector_ = s;
  }

  const DualChannelDefType::AlgorithmOptional& DualChannelDefType::
  getAlgorithm () const
  {
    return this->Algorithm_;
  }

  DualChannelDefType::AlgorithmOptional& DualChannelDefType::
  getAlgorithm ()
  {
    return this->Algorithm_;
  }

  void DualChannelDefType::
  setAlgorithm (const AlgorithmType& x)
  {
    this->Algorithm_.set (x);
  }

  void DualChannelDefType::
  setAlgorithm (const AlgorithmOptional& x)
  {
    this->Algorithm_ = x;
  }

  void DualChannelDefType::
  setAlgorithm (::std::unique_ptr< AlgorithmType > x)
  {
    this->Algorithm_.set (std::move (x));
  }

  const DualChannelDefType::TransformOptional& DualChannelDefType::
  getTransform () const
  {
    return this->Transform_;
  }

  DualChannelDefType::TransformOptional& DualChannelDefType::
  getTransform ()
  {
    return this->Transform_;
  }

  void DualChannelDefType::
  setTransform (const TransformType& x)
  {
    this->Transform_.set (x);
  }

  void DualChannelDefType::
  setTransform (const TransformOptional& x)
  {
    this->Transform_ = x;
  }

  void DualChannelDefType::
  setTransform (::std::unique_ptr< TransformType > x)
  {
    this->Transform_.set (std::move (x));
  }


  // SafetyContextDefType
  // 

  const SafetyContextDefType::SelectorSequence& SafetyContextDefType::
  getSelector () const
  {
    return this->Selector_;
  }

  SafetyContextDefType::SelectorSequence& SafetyContextDefType::
  getSelector ()
  {
    return this->Selector_;
  }

  void SafetyContextDefType::
  setSelector (const SelectorSequence& s)
  {
    this->Selector_ = s;
  }


  // SafetyInfoType
  // 

  const SafetyInfoType::DualChannelOptional& SafetyInfoType::
  getDualChannel () const
  {
    return this->DualChannel_;
  }

  SafetyInfoType::DualChannelOptional& SafetyInfoType::
  getDualChannel ()
  {
    return this->DualChannel_;
  }

  void SafetyInfoType::
  setDualChannel (const DualChannelType& x)
  {
    this->DualChannel_.set (x);
  }

  void SafetyInfoType::
  setDualChannel (const DualChannelOptional& x)
  {
    this->DualChannel_ = x;
  }

  void SafetyInfoType::
  setDualChannel (::std::unique_ptr< DualChannelType > x)
  {
    this->DualChannel_.set (std::move (x));
  }

  const SafetyInfoType::SafetyContextOptional& SafetyInfoType::
  getSafetyContext () const
  {
    return this->SafetyContext_;
  }

  SafetyInfoType::SafetyContextOptional& SafetyInfoType::
  getSafetyContext ()
  {
    return this->SafetyContext_;
  }

  void SafetyInfoType::
  setSafetyContext (const SafetyContextType& x)
  {
    this->SafetyContext_.set (x);
  }

  void SafetyInfoType::
  setSafetyContext (const SafetyContextOptional& x)
  {
    this->SafetyContext_ = x;
  }

  void SafetyInfoType::
  setSafetyContext (::std::unique_ptr< SafetyContextType > x)
  {
    this->SafetyContext_.set (std::move (x));
  }


  // DualChannelType
  // 

  const DualChannelType::DcValueSequence& DualChannelType::
  getDcValue () const
  {
    return this->DcValue_;
  }

  DualChannelType::DcValueSequence& DualChannelType::
  getDcValue ()
  {
    return this->DcValue_;
  }

  void DualChannelType::
  setDcValue (const DcValueSequence& s)
  {
    this->DcValue_ = s;
  }


  // SafetyContextType
  // 

  const SafetyContextType::CtxtValueSequence& SafetyContextType::
  getCtxtValue () const
  {
    return this->CtxtValue_;
  }

  SafetyContextType::CtxtValueSequence& SafetyContextType::
  getCtxtValue ()
  {
    return this->CtxtValue_;
  }

  void SafetyContextType::
  setCtxtValue (const CtxtValueSequence& s)
  {
    this->CtxtValue_ = s;
  }


  // DcValueType
  // 

  const DcValueType::ReferencedSelectorType& DcValueType::
  getReferencedSelector () const
  {
    return this->ReferencedSelector_.get ();
  }

  DcValueType::ReferencedSelectorType& DcValueType::
  getReferencedSelector ()
  {
    return this->ReferencedSelector_.get ();
  }

  void DcValueType::
  setReferencedSelector (const ReferencedSelectorType& x)
  {
    this->ReferencedSelector_.set (x);
  }

  void DcValueType::
  setReferencedSelector (::std::unique_ptr< ReferencedSelectorType > x)
  {
    this->ReferencedSelector_.set (std::move (x));
  }


  // CtxtValueType
  // 

  const CtxtValueType::ReferencedSelectorType& CtxtValueType::
  getReferencedSelector () const
  {
    return this->ReferencedSelector_.get ();
  }

  CtxtValueType::ReferencedSelectorType& CtxtValueType::
  getReferencedSelector ()
  {
    return this->ReferencedSelector_.get ();
  }

  void CtxtValueType::
  setReferencedSelector (const ReferencedSelectorType& x)
  {
    this->ReferencedSelector_.set (x);
  }

  void CtxtValueType::
  setReferencedSelector (::std::unique_ptr< ReferencedSelectorType > x)
  {
    this->ReferencedSelector_.set (std::move (x));
  }


  // Types
  // 
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace MDPWS
{
  // StreamSourceType
  //

  StreamSourceType::
  StreamSourceType ()
  : ::xml_schema::Type ()
  {
  }

  StreamSourceType::
  StreamSourceType (const StreamSourceType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c)
  {
  }

  StreamSourceType::
  StreamSourceType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void StreamSourceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }
  }

  StreamSourceType* StreamSourceType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class StreamSourceType (*this, f, c);
  }

  StreamSourceType::
  ~StreamSourceType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, StreamSourceType >
  _xsd_StreamSourceType_type_factory_init (
    "StreamSourceType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");

  // StreamTransmissionType
  //

  StreamTransmissionType::
  StreamTransmissionType ()
  : ::xml_schema::Type (),
    StreamAddress_ (this),
    StreamPeriod_ (this),
    Type_ (this)
  {
  }

  StreamTransmissionType::
  StreamTransmissionType (const StreamTransmissionType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    StreamAddress_ (x.StreamAddress_, f, this),
    StreamPeriod_ (x.StreamPeriod_, f, this),
    Type_ (x.Type_, f, this)
  {
  }

  StreamTransmissionType::
  StreamTransmissionType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    StreamAddress_ (this),
    StreamPeriod_ (this),
    Type_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void StreamTransmissionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // StreamAddress
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "StreamAddress",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            &::xsd::cxx::tree::factory_impl< StreamAddressType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->StreamAddress_)
          {
            ::std::unique_ptr< StreamAddressType > r (
              dynamic_cast< StreamAddressType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->StreamAddress_.set (::std::move (r));
            continue;
          }
        }
      }

      // StreamPeriod
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "StreamPeriod",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            &::xsd::cxx::tree::factory_impl< StreamPeriodType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->StreamPeriod_)
          {
            ::std::unique_ptr< StreamPeriodType > r (
              dynamic_cast< StreamPeriodType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->StreamPeriod_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Type" && n.namespace_ ().empty ())
      {
        this->Type_.set (TypeTraits::create (i, f, this));
        continue;
      }
    }
  }

  StreamTransmissionType* StreamTransmissionType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class StreamTransmissionType (*this, f, c);
  }

  StreamTransmissionType& StreamTransmissionType::
  operator= (const StreamTransmissionType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->StreamAddress_ = x.StreamAddress_;
      this->StreamPeriod_ = x.StreamPeriod_;
      this->Type_ = x.Type_;
    }

    return *this;
  }

  StreamTransmissionType::
  ~StreamTransmissionType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, StreamTransmissionType >
  _xsd_StreamTransmissionType_type_factory_init (
    "StreamTransmissionType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");

  // StreamTypeType
  //

  StreamTypeType::
  StreamTypeType (const StreamTransmissionType& StreamTransmission,
                  const IdType& Id,
                  const StreamTypeType1& StreamType)
  : ::xml_schema::Type (),
    StreamTransmission_ (StreamTransmission, this),
    Id_ (Id, this),
    StreamType_ (StreamType, this),
    Element_ (this),
    ActionUri_ (this)
  {
  }

  StreamTypeType::
  StreamTypeType (::std::unique_ptr< StreamTransmissionType > StreamTransmission,
                  const IdType& Id,
                  const StreamTypeType1& StreamType)
  : ::xml_schema::Type (),
    StreamTransmission_ (std::move (StreamTransmission), this),
    Id_ (Id, this),
    StreamType_ (StreamType, this),
    Element_ (this),
    ActionUri_ (this)
  {
  }

  StreamTypeType::
  StreamTypeType (const StreamTypeType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    StreamTransmission_ (x.StreamTransmission_, f, this),
    Id_ (x.Id_, f, this),
    StreamType_ (x.StreamType_, f, this),
    Element_ (x.Element_, f, this),
    ActionUri_ (x.ActionUri_, f, this)
  {
  }

  StreamTypeType::
  StreamTypeType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    StreamTransmission_ (this),
    Id_ (this),
    StreamType_ (this),
    Element_ (this),
    ActionUri_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void StreamTypeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // StreamTransmission
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "StreamTransmission",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            &::xsd::cxx::tree::factory_impl< StreamTransmissionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!StreamTransmission_.present ())
          {
            ::std::unique_ptr< StreamTransmissionType > r (
              dynamic_cast< StreamTransmissionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->StreamTransmission_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!StreamTransmission_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "StreamTransmission",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Id" && n.namespace_ ().empty ())
      {
        this->Id_.set (IdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "StreamType" && n.namespace_ ().empty ())
      {
        this->StreamType_.set (StreamTypeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Element" && n.namespace_ ().empty ())
      {
        this->Element_.set (ElementTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ActionUri" && n.namespace_ ().empty ())
      {
        this->ActionUri_.set (ActionUriTraits::create (i, f, this));
        continue;
      }
    }

    if (!Id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Id",
        "");
    }

    if (!StreamType_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "StreamType",
        "");
    }
  }

  StreamTypeType* StreamTypeType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class StreamTypeType (*this, f, c);
  }

  StreamTypeType& StreamTypeType::
  operator= (const StreamTypeType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->StreamTransmission_ = x.StreamTransmission_;
      this->Id_ = x.Id_;
      this->StreamType_ = x.StreamType_;
      this->Element_ = x.Element_;
      this->ActionUri_ = x.ActionUri_;
    }

    return *this;
  }

  StreamTypeType::
  ~StreamTypeType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, StreamTypeType >
  _xsd_StreamTypeType_type_factory_init (
    "StreamTypeType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");

  // StreamDescriptionsType
  //

  StreamDescriptionsType::
  StreamDescriptionsType (const TargetNamespaceType& TargetNamespace)
  : ::xml_schema::Type (),
    Types_ (this),
    StreamType_ (this),
    TargetNamespace_ (TargetNamespace, this)
  {
  }

  StreamDescriptionsType::
  StreamDescriptionsType (const StreamDescriptionsType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Types_ (x.Types_, f, this),
    StreamType_ (x.StreamType_, f, this),
    TargetNamespace_ (x.TargetNamespace_, f, this)
  {
  }

  StreamDescriptionsType::
  StreamDescriptionsType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Types_ (this),
    StreamType_ (this),
    TargetNamespace_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void StreamDescriptionsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Types
      //
      if (n.name () == "Types" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-20702-2016")
      {
        ::std::unique_ptr< TypesType > r (
          TypesTraits::create (i, f, this));

        if (!this->Types_)
        {
          this->Types_.set (::std::move (r));
          continue;
        }
      }

      // StreamType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "StreamType",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            &::xsd::cxx::tree::factory_impl< StreamTypeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< StreamTypeType > r (
            dynamic_cast< StreamTypeType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->StreamType_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "TargetNamespace" && n.namespace_ ().empty ())
      {
        this->TargetNamespace_.set (TargetNamespaceTraits::create (i, f, this));
        continue;
      }
    }

    if (!TargetNamespace_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "TargetNamespace",
        "");
    }
  }

  StreamDescriptionsType* StreamDescriptionsType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class StreamDescriptionsType (*this, f, c);
  }

  StreamDescriptionsType& StreamDescriptionsType::
  operator= (const StreamDescriptionsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Types_ = x.Types_;
      this->StreamType_ = x.StreamType_;
      this->TargetNamespace_ = x.TargetNamespace_;
    }

    return *this;
  }

  StreamDescriptionsType::
  ~StreamDescriptionsType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, StreamDescriptionsType >
  _xsd_StreamDescriptionsType_type_factory_init (
    "StreamDescriptionsType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");

  // SafetyReqAssertionType
  //

  SafetyReqAssertionType::
  SafetyReqAssertionType ()
  : ::xml_schema::Type (),
    TransmitDualChannel_ (getTransmitDualChannelDefaultValue (), this),
    TransmitSafetyContext_ (getTransmitSafetyContextDefaultValue (), this)
  {
  }

  SafetyReqAssertionType::
  SafetyReqAssertionType (const SafetyReqAssertionType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    TransmitDualChannel_ (x.TransmitDualChannel_, f, this),
    TransmitSafetyContext_ (x.TransmitSafetyContext_, f, this)
  {
  }

  SafetyReqAssertionType::
  SafetyReqAssertionType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    TransmitDualChannel_ (this),
    TransmitSafetyContext_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SafetyReqAssertionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "TransmitDualChannel" && n.namespace_ ().empty ())
      {
        this->TransmitDualChannel_.set (TransmitDualChannelTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "TransmitSafetyContext" && n.namespace_ ().empty ())
      {
        this->TransmitSafetyContext_.set (TransmitSafetyContextTraits::create (i, f, this));
        continue;
      }
    }

    if (!TransmitDualChannel_.present ())
    {
      this->TransmitDualChannel_.set (getTransmitDualChannelDefaultValue ());
    }

    if (!TransmitSafetyContext_.present ())
    {
      this->TransmitSafetyContext_.set (getTransmitSafetyContextDefaultValue ());
    }
  }

  SafetyReqAssertionType* SafetyReqAssertionType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SafetyReqAssertionType (*this, f, c);
  }

  SafetyReqAssertionType& SafetyReqAssertionType::
  operator= (const SafetyReqAssertionType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->TransmitDualChannel_ = x.TransmitDualChannel_;
      this->TransmitSafetyContext_ = x.TransmitSafetyContext_;
    }

    return *this;
  }

  SafetyReqAssertionType::
  ~SafetyReqAssertionType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SafetyReqAssertionType >
  _xsd_SafetyReqAssertionType_type_factory_init (
    "SafetyReqAssertionType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");

  // SelectorType
  //

  SelectorType::
  SelectorType (const IdType& Id)
  : ::xml_schema::String (),
    Id_ (Id, this)
  {
  }

  SelectorType::
  SelectorType (const char* _xsd_String_base,
                const IdType& Id)
  : ::xml_schema::String (_xsd_String_base),
    Id_ (Id, this)
  {
  }

  SelectorType::
  SelectorType (const ::std::string& _xsd_String_base,
                const IdType& Id)
  : ::xml_schema::String (_xsd_String_base),
    Id_ (Id, this)
  {
  }

  SelectorType::
  SelectorType (const ::xml_schema::String& _xsd_String_base,
                const IdType& Id)
  : ::xml_schema::String (_xsd_String_base),
    Id_ (Id, this)
  {
  }

  SelectorType::
  SelectorType (const SelectorType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c),
    Id_ (x.Id_, f, this)
  {
  }

  SelectorType::
  SelectorType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::String (e, f | ::xml_schema::Flags::base, c),
    Id_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SelectorType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Id" && n.namespace_ ().empty ())
      {
        this->Id_.set (IdTraits::create (i, f, this));
        continue;
      }
    }

    if (!Id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Id",
        "");
    }
  }

  SelectorType* SelectorType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SelectorType (*this, f, c);
  }

  SelectorType& SelectorType::
  operator= (const SelectorType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::String& > (*this) = x;
      this->Id_ = x.Id_;
    }

    return *this;
  }

  SelectorType::
  ~SelectorType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SelectorType >
  _xsd_SelectorType_type_factory_init (
    "SelectorType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");

  // SafetyReqType
  //

  SafetyReqType::
  SafetyReqType ()
  : ::xml_schema::Type (),
    DualChannelDef_ (this),
    SafetyContextDef_ (this)
  {
  }

  SafetyReqType::
  SafetyReqType (const SafetyReqType& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    DualChannelDef_ (x.DualChannelDef_, f, this),
    SafetyContextDef_ (x.SafetyContextDef_, f, this)
  {
  }

  SafetyReqType::
  SafetyReqType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    DualChannelDef_ (this),
    SafetyContextDef_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SafetyReqType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DualChannelDef
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DualChannelDef",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            &::xsd::cxx::tree::factory_impl< DualChannelDefType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DualChannelDef_)
          {
            ::std::unique_ptr< DualChannelDefType > r (
              dynamic_cast< DualChannelDefType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DualChannelDef_.set (::std::move (r));
            continue;
          }
        }
      }

      // SafetyContextDef
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SafetyContextDef",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            &::xsd::cxx::tree::factory_impl< SafetyContextDefType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->SafetyContextDef_)
          {
            ::std::unique_ptr< SafetyContextDefType > r (
              dynamic_cast< SafetyContextDefType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SafetyContextDef_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  SafetyReqType* SafetyReqType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SafetyReqType (*this, f, c);
  }

  SafetyReqType& SafetyReqType::
  operator= (const SafetyReqType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->DualChannelDef_ = x.DualChannelDef_;
      this->SafetyContextDef_ = x.SafetyContextDef_;
    }

    return *this;
  }

  SafetyReqType::
  ~SafetyReqType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SafetyReqType >
  _xsd_SafetyReqType_type_factory_init (
    "SafetyReqType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");

  // DualChannelDefType
  //

  DualChannelDefType::
  DualChannelDefType ()
  : ::xml_schema::Type (),
    Selector_ (this),
    Algorithm_ (this),
    Transform_ (this)
  {
  }

  DualChannelDefType::
  DualChannelDefType (const DualChannelDefType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Selector_ (x.Selector_, f, this),
    Algorithm_ (x.Algorithm_, f, this),
    Transform_ (x.Transform_, f, this)
  {
  }

  DualChannelDefType::
  DualChannelDefType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Selector_ (this),
    Algorithm_ (this),
    Transform_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DualChannelDefType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Selector
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Selector",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            &::xsd::cxx::tree::factory_impl< SelectorType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< SelectorType > r (
            dynamic_cast< SelectorType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Selector_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Algorithm" && n.namespace_ ().empty ())
      {
        this->Algorithm_.set (AlgorithmTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Transform" && n.namespace_ ().empty ())
      {
        this->Transform_.set (TransformTraits::create (i, f, this));
        continue;
      }
    }
  }

  DualChannelDefType* DualChannelDefType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DualChannelDefType (*this, f, c);
  }

  DualChannelDefType& DualChannelDefType::
  operator= (const DualChannelDefType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Selector_ = x.Selector_;
      this->Algorithm_ = x.Algorithm_;
      this->Transform_ = x.Transform_;
    }

    return *this;
  }

  DualChannelDefType::
  ~DualChannelDefType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, DualChannelDefType >
  _xsd_DualChannelDefType_type_factory_init (
    "DualChannelDefType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");

  // SafetyContextDefType
  //

  SafetyContextDefType::
  SafetyContextDefType ()
  : ::xml_schema::Type (),
    Selector_ (this)
  {
  }

  SafetyContextDefType::
  SafetyContextDefType (const SafetyContextDefType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Selector_ (x.Selector_, f, this)
  {
  }

  SafetyContextDefType::
  SafetyContextDefType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Selector_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SafetyContextDefType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Selector
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Selector",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            &::xsd::cxx::tree::factory_impl< SelectorType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< SelectorType > r (
            dynamic_cast< SelectorType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Selector_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SafetyContextDefType* SafetyContextDefType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SafetyContextDefType (*this, f, c);
  }

  SafetyContextDefType& SafetyContextDefType::
  operator= (const SafetyContextDefType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Selector_ = x.Selector_;
    }

    return *this;
  }

  SafetyContextDefType::
  ~SafetyContextDefType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SafetyContextDefType >
  _xsd_SafetyContextDefType_type_factory_init (
    "SafetyContextDefType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");

  // SafetyInfoType
  //

  SafetyInfoType::
  SafetyInfoType ()
  : ::xml_schema::Type (),
    DualChannel_ (this),
    SafetyContext_ (this)
  {
  }

  SafetyInfoType::
  SafetyInfoType (const SafetyInfoType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    DualChannel_ (x.DualChannel_, f, this),
    SafetyContext_ (x.SafetyContext_, f, this)
  {
  }

  SafetyInfoType::
  SafetyInfoType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    DualChannel_ (this),
    SafetyContext_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SafetyInfoType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DualChannel
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DualChannel",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            &::xsd::cxx::tree::factory_impl< DualChannelType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DualChannel_)
          {
            ::std::unique_ptr< DualChannelType > r (
              dynamic_cast< DualChannelType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DualChannel_.set (::std::move (r));
            continue;
          }
        }
      }

      // SafetyContext
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SafetyContext",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            &::xsd::cxx::tree::factory_impl< SafetyContextType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->SafetyContext_)
          {
            ::std::unique_ptr< SafetyContextType > r (
              dynamic_cast< SafetyContextType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SafetyContext_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  SafetyInfoType* SafetyInfoType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SafetyInfoType (*this, f, c);
  }

  SafetyInfoType& SafetyInfoType::
  operator= (const SafetyInfoType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->DualChannel_ = x.DualChannel_;
      this->SafetyContext_ = x.SafetyContext_;
    }

    return *this;
  }

  SafetyInfoType::
  ~SafetyInfoType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SafetyInfoType >
  _xsd_SafetyInfoType_type_factory_init (
    "SafetyInfoType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");

  // DualChannelType
  //

  DualChannelType::
  DualChannelType ()
  : ::xml_schema::Type (),
    DcValue_ (this)
  {
  }

  DualChannelType::
  DualChannelType (const DualChannelType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    DcValue_ (x.DcValue_, f, this)
  {
  }

  DualChannelType::
  DualChannelType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    DcValue_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DualChannelType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DcValue
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DcValue",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            &::xsd::cxx::tree::factory_impl< DcValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< DcValueType > r (
            dynamic_cast< DcValueType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->DcValue_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  DualChannelType* DualChannelType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DualChannelType (*this, f, c);
  }

  DualChannelType& DualChannelType::
  operator= (const DualChannelType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->DcValue_ = x.DcValue_;
    }

    return *this;
  }

  DualChannelType::
  ~DualChannelType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, DualChannelType >
  _xsd_DualChannelType_type_factory_init (
    "DualChannelType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");

  // SafetyContextType
  //

  SafetyContextType::
  SafetyContextType ()
  : ::xml_schema::Type (),
    CtxtValue_ (this)
  {
  }

  SafetyContextType::
  SafetyContextType (const SafetyContextType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    CtxtValue_ (x.CtxtValue_, f, this)
  {
  }

  SafetyContextType::
  SafetyContextType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    CtxtValue_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SafetyContextType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CtxtValue
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CtxtValue",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            &::xsd::cxx::tree::factory_impl< CtxtValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< CtxtValueType > r (
            dynamic_cast< CtxtValueType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->CtxtValue_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SafetyContextType* SafetyContextType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SafetyContextType (*this, f, c);
  }

  SafetyContextType& SafetyContextType::
  operator= (const SafetyContextType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->CtxtValue_ = x.CtxtValue_;
    }

    return *this;
  }

  SafetyContextType::
  ~SafetyContextType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SafetyContextType >
  _xsd_SafetyContextType_type_factory_init (
    "SafetyContextType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");

  // DcValueType
  //

  DcValueType::
  DcValueType (const ReferencedSelectorType& ReferencedSelector)
  : ::xml_schema::SimpleType (),
    ReferencedSelector_ (ReferencedSelector, this)
  {
  }

  DcValueType::
  DcValueType (const ::xml_schema::SimpleType& _xsd_SimpleType_base,
               const ReferencedSelectorType& ReferencedSelector)
  : ::xml_schema::SimpleType (_xsd_SimpleType_base),
    ReferencedSelector_ (ReferencedSelector, this)
  {
  }

  DcValueType::
  DcValueType (const DcValueType& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (x, f, c),
    ReferencedSelector_ (x.ReferencedSelector_, f, this)
  {
  }

  DcValueType::
  DcValueType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (e, f | ::xml_schema::Flags::base, c),
    ReferencedSelector_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DcValueType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ReferencedSelector" && n.namespace_ ().empty ())
      {
        this->ReferencedSelector_.set (ReferencedSelectorTraits::create (i, f, this));
        continue;
      }
    }

    if (!ReferencedSelector_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ReferencedSelector",
        "");
    }
  }

  DcValueType* DcValueType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DcValueType (*this, f, c);
  }

  DcValueType& DcValueType::
  operator= (const DcValueType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::SimpleType& > (*this) = x;
      this->ReferencedSelector_ = x.ReferencedSelector_;
    }

    return *this;
  }

  DcValueType::
  ~DcValueType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, DcValueType >
  _xsd_DcValueType_type_factory_init (
    "DcValueType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");

  // CtxtValueType
  //

  CtxtValueType::
  CtxtValueType (const ReferencedSelectorType& ReferencedSelector)
  : ::xml_schema::SimpleType (),
    ReferencedSelector_ (ReferencedSelector, this)
  {
  }

  CtxtValueType::
  CtxtValueType (const ::xml_schema::SimpleType& _xsd_SimpleType_base,
                 const ReferencedSelectorType& ReferencedSelector)
  : ::xml_schema::SimpleType (_xsd_SimpleType_base),
    ReferencedSelector_ (ReferencedSelector, this)
  {
  }

  CtxtValueType::
  CtxtValueType (const CtxtValueType& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (x, f, c),
    ReferencedSelector_ (x.ReferencedSelector_, f, this)
  {
  }

  CtxtValueType::
  CtxtValueType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (e, f | ::xml_schema::Flags::base, c),
    ReferencedSelector_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CtxtValueType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ReferencedSelector" && n.namespace_ ().empty ())
      {
        this->ReferencedSelector_.set (ReferencedSelectorTraits::create (i, f, this));
        continue;
      }
    }

    if (!ReferencedSelector_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ReferencedSelector",
        "");
    }
  }

  CtxtValueType* CtxtValueType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CtxtValueType (*this, f, c);
  }

  CtxtValueType& CtxtValueType::
  operator= (const CtxtValueType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::SimpleType& > (*this) = x;
      this->ReferencedSelector_ = x.ReferencedSelector_;
    }

    return *this;
  }

  CtxtValueType::
  ~CtxtValueType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CtxtValueType >
  _xsd_CtxtValueType_type_factory_init (
    "CtxtValueType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");

  // Types
  //

  Types::
  Types ()
  : ::xml_schema::Type ()
  {
  }

  Types::
  Types (const Types& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c)
  {
  }

  Types::
  Types (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Types::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      break;
    }
  }

  Types* Types::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Types (*this, f, c);
  }

  Types::
  ~Types ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace MDPWS
{
  ::std::unique_ptr< ::MDPWS::StreamSourceType >
  parseStreamSource (const ::std::string& u,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDPWS::StreamSourceType > (
      ::MDPWS::parseStreamSource (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::StreamSourceType >
  parseStreamSource (const ::std::string& u,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::StreamSourceType > (
      ::MDPWS::parseStreamSource (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::StreamSourceType >
  parseStreamSource (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::StreamSourceType > (
      ::MDPWS::parseStreamSource (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::StreamSourceType >
  parseStreamSource (::std::istream& is,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDPWS::parseStreamSource (isrc, f, p);
  }

  ::std::unique_ptr< ::MDPWS::StreamSourceType >
  parseStreamSource (::std::istream& is,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDPWS::parseStreamSource (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::StreamSourceType >
  parseStreamSource (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDPWS::parseStreamSource (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::StreamSourceType >
  parseStreamSource (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDPWS::parseStreamSource (isrc, f, p);
  }

  ::std::unique_ptr< ::MDPWS::StreamSourceType >
  parseStreamSource (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDPWS::parseStreamSource (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::StreamSourceType >
  parseStreamSource (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDPWS::parseStreamSource (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::StreamSourceType >
  parseStreamSource (::xercesc::InputSource& i,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDPWS::StreamSourceType > (
      ::MDPWS::parseStreamSource (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::StreamSourceType >
  parseStreamSource (::xercesc::InputSource& i,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::StreamSourceType > (
      ::MDPWS::parseStreamSource (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::StreamSourceType >
  parseStreamSource (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::StreamSourceType > (
      ::MDPWS::parseStreamSource (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::StreamSourceType >
  parseStreamSource (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDPWS::StreamSourceType > (
        ::MDPWS::parseStreamSource (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "StreamSource",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        &::xsd::cxx::tree::factory_impl< ::MDPWS::StreamSourceType >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {
      ::std::unique_ptr< ::MDPWS::StreamSourceType > r (
        dynamic_cast< ::MDPWS::StreamSourceType* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "StreamSource",
      "http://standards.ieee.org/downloads/11073/11073-20702-2016");
  }

  ::std::unique_ptr< ::MDPWS::StreamSourceType >
  parseStreamSource (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "StreamSource",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        &::xsd::cxx::tree::factory_impl< ::MDPWS::StreamSourceType >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {

      ::std::unique_ptr< ::MDPWS::StreamSourceType > r (
        dynamic_cast< ::MDPWS::StreamSourceType* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "StreamSource",
      "http://standards.ieee.org/downloads/11073/11073-20702-2016");
  }

  ::std::unique_ptr< ::MDPWS::StreamDescriptionsType >
  parseStreamDescriptions (const ::std::string& u,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDPWS::StreamDescriptionsType > (
      ::MDPWS::parseStreamDescriptions (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::StreamDescriptionsType >
  parseStreamDescriptions (const ::std::string& u,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::StreamDescriptionsType > (
      ::MDPWS::parseStreamDescriptions (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::StreamDescriptionsType >
  parseStreamDescriptions (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::StreamDescriptionsType > (
      ::MDPWS::parseStreamDescriptions (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::StreamDescriptionsType >
  parseStreamDescriptions (::std::istream& is,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDPWS::parseStreamDescriptions (isrc, f, p);
  }

  ::std::unique_ptr< ::MDPWS::StreamDescriptionsType >
  parseStreamDescriptions (::std::istream& is,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDPWS::parseStreamDescriptions (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::StreamDescriptionsType >
  parseStreamDescriptions (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDPWS::parseStreamDescriptions (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::StreamDescriptionsType >
  parseStreamDescriptions (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDPWS::parseStreamDescriptions (isrc, f, p);
  }

  ::std::unique_ptr< ::MDPWS::StreamDescriptionsType >
  parseStreamDescriptions (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDPWS::parseStreamDescriptions (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::StreamDescriptionsType >
  parseStreamDescriptions (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDPWS::parseStreamDescriptions (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::StreamDescriptionsType >
  parseStreamDescriptions (::xercesc::InputSource& i,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDPWS::StreamDescriptionsType > (
      ::MDPWS::parseStreamDescriptions (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::StreamDescriptionsType >
  parseStreamDescriptions (::xercesc::InputSource& i,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::StreamDescriptionsType > (
      ::MDPWS::parseStreamDescriptions (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::StreamDescriptionsType >
  parseStreamDescriptions (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::StreamDescriptionsType > (
      ::MDPWS::parseStreamDescriptions (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::StreamDescriptionsType >
  parseStreamDescriptions (const ::xercesc::DOMDocument& doc,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDPWS::StreamDescriptionsType > (
        ::MDPWS::parseStreamDescriptions (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "StreamDescriptions",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        &::xsd::cxx::tree::factory_impl< ::MDPWS::StreamDescriptionsType >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {
      ::std::unique_ptr< ::MDPWS::StreamDescriptionsType > r (
        dynamic_cast< ::MDPWS::StreamDescriptionsType* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "StreamDescriptions",
      "http://standards.ieee.org/downloads/11073/11073-20702-2016");
  }

  ::std::unique_ptr< ::MDPWS::StreamDescriptionsType >
  parseStreamDescriptions (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "StreamDescriptions",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        &::xsd::cxx::tree::factory_impl< ::MDPWS::StreamDescriptionsType >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {

      ::std::unique_ptr< ::MDPWS::StreamDescriptionsType > r (
        dynamic_cast< ::MDPWS::StreamDescriptionsType* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "StreamDescriptions",
      "http://standards.ieee.org/downloads/11073/11073-20702-2016");
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType >
  parseSafetyReqAssertion (const ::std::string& u,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType > (
      ::MDPWS::parseSafetyReqAssertion (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType >
  parseSafetyReqAssertion (const ::std::string& u,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType > (
      ::MDPWS::parseSafetyReqAssertion (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType >
  parseSafetyReqAssertion (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType > (
      ::MDPWS::parseSafetyReqAssertion (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType >
  parseSafetyReqAssertion (::std::istream& is,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDPWS::parseSafetyReqAssertion (isrc, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType >
  parseSafetyReqAssertion (::std::istream& is,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDPWS::parseSafetyReqAssertion (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType >
  parseSafetyReqAssertion (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDPWS::parseSafetyReqAssertion (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType >
  parseSafetyReqAssertion (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDPWS::parseSafetyReqAssertion (isrc, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType >
  parseSafetyReqAssertion (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDPWS::parseSafetyReqAssertion (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType >
  parseSafetyReqAssertion (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDPWS::parseSafetyReqAssertion (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType >
  parseSafetyReqAssertion (::xercesc::InputSource& i,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType > (
      ::MDPWS::parseSafetyReqAssertion (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType >
  parseSafetyReqAssertion (::xercesc::InputSource& i,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType > (
      ::MDPWS::parseSafetyReqAssertion (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType >
  parseSafetyReqAssertion (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType > (
      ::MDPWS::parseSafetyReqAssertion (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType >
  parseSafetyReqAssertion (const ::xercesc::DOMDocument& doc,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType > (
        ::MDPWS::parseSafetyReqAssertion (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "SafetyReqAssertion",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        &::xsd::cxx::tree::factory_impl< ::MDPWS::SafetyReqAssertionType >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {
      ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType > r (
        dynamic_cast< ::MDPWS::SafetyReqAssertionType* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SafetyReqAssertion",
      "http://standards.ieee.org/downloads/11073/11073-20702-2016");
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType >
  parseSafetyReqAssertion (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "SafetyReqAssertion",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        &::xsd::cxx::tree::factory_impl< ::MDPWS::SafetyReqAssertionType >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {

      ::std::unique_ptr< ::MDPWS::SafetyReqAssertionType > r (
        dynamic_cast< ::MDPWS::SafetyReqAssertionType* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SafetyReqAssertion",
      "http://standards.ieee.org/downloads/11073/11073-20702-2016");
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqType >
  parseSafetyReq (const ::std::string& u,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDPWS::SafetyReqType > (
      ::MDPWS::parseSafetyReq (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqType >
  parseSafetyReq (const ::std::string& u,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::SafetyReqType > (
      ::MDPWS::parseSafetyReq (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqType >
  parseSafetyReq (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::SafetyReqType > (
      ::MDPWS::parseSafetyReq (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqType >
  parseSafetyReq (::std::istream& is,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDPWS::parseSafetyReq (isrc, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqType >
  parseSafetyReq (::std::istream& is,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDPWS::parseSafetyReq (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqType >
  parseSafetyReq (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDPWS::parseSafetyReq (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqType >
  parseSafetyReq (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDPWS::parseSafetyReq (isrc, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqType >
  parseSafetyReq (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDPWS::parseSafetyReq (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqType >
  parseSafetyReq (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDPWS::parseSafetyReq (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqType >
  parseSafetyReq (::xercesc::InputSource& i,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDPWS::SafetyReqType > (
      ::MDPWS::parseSafetyReq (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqType >
  parseSafetyReq (::xercesc::InputSource& i,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::SafetyReqType > (
      ::MDPWS::parseSafetyReq (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqType >
  parseSafetyReq (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::SafetyReqType > (
      ::MDPWS::parseSafetyReq (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqType >
  parseSafetyReq (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDPWS::SafetyReqType > (
        ::MDPWS::parseSafetyReq (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "SafetyReq",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        &::xsd::cxx::tree::factory_impl< ::MDPWS::SafetyReqType >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {
      ::std::unique_ptr< ::MDPWS::SafetyReqType > r (
        dynamic_cast< ::MDPWS::SafetyReqType* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SafetyReq",
      "http://standards.ieee.org/downloads/11073/11073-20702-2016");
  }

  ::std::unique_ptr< ::MDPWS::SafetyReqType >
  parseSafetyReq (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "SafetyReq",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        &::xsd::cxx::tree::factory_impl< ::MDPWS::SafetyReqType >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {

      ::std::unique_ptr< ::MDPWS::SafetyReqType > r (
        dynamic_cast< ::MDPWS::SafetyReqType* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SafetyReq",
      "http://standards.ieee.org/downloads/11073/11073-20702-2016");
  }

  ::std::unique_ptr< ::MDPWS::SafetyInfoType >
  parseSafetyInfo (const ::std::string& u,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDPWS::SafetyInfoType > (
      ::MDPWS::parseSafetyInfo (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyInfoType >
  parseSafetyInfo (const ::std::string& u,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::SafetyInfoType > (
      ::MDPWS::parseSafetyInfo (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyInfoType >
  parseSafetyInfo (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::SafetyInfoType > (
      ::MDPWS::parseSafetyInfo (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyInfoType >
  parseSafetyInfo (::std::istream& is,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDPWS::parseSafetyInfo (isrc, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyInfoType >
  parseSafetyInfo (::std::istream& is,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDPWS::parseSafetyInfo (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyInfoType >
  parseSafetyInfo (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDPWS::parseSafetyInfo (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyInfoType >
  parseSafetyInfo (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDPWS::parseSafetyInfo (isrc, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyInfoType >
  parseSafetyInfo (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDPWS::parseSafetyInfo (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyInfoType >
  parseSafetyInfo (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDPWS::parseSafetyInfo (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDPWS::SafetyInfoType >
  parseSafetyInfo (::xercesc::InputSource& i,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDPWS::SafetyInfoType > (
      ::MDPWS::parseSafetyInfo (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyInfoType >
  parseSafetyInfo (::xercesc::InputSource& i,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::SafetyInfoType > (
      ::MDPWS::parseSafetyInfo (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyInfoType >
  parseSafetyInfo (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDPWS::SafetyInfoType > (
      ::MDPWS::parseSafetyInfo (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDPWS::SafetyInfoType >
  parseSafetyInfo (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDPWS::SafetyInfoType > (
        ::MDPWS::parseSafetyInfo (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "SafetyInfo",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        &::xsd::cxx::tree::factory_impl< ::MDPWS::SafetyInfoType >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {
      ::std::unique_ptr< ::MDPWS::SafetyInfoType > r (
        dynamic_cast< ::MDPWS::SafetyInfoType* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SafetyInfo",
      "http://standards.ieee.org/downloads/11073/11073-20702-2016");
  }

  ::std::unique_ptr< ::MDPWS::SafetyInfoType >
  parseSafetyInfo (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "SafetyInfo",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        &::xsd::cxx::tree::factory_impl< ::MDPWS::SafetyInfoType >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {

      ::std::unique_ptr< ::MDPWS::SafetyInfoType > r (
        dynamic_cast< ::MDPWS::SafetyInfoType* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SafetyInfo",
      "http://standards.ieee.org/downloads/11073/11073-20702-2016");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace MDPWS
{
  void
  operator<< (::xercesc::DOMElement& e, const StreamSourceType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StreamSourceType >
  _xsd_StreamSourceType_type_serializer_init (
    "StreamSourceType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");


  void
  serializeStreamSource (::std::ostream& o,
                         const ::MDPWS::StreamSourceType& s,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeStreamSource (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeStreamSource (::std::ostream& o,
                         const ::MDPWS::StreamSourceType& s,
                         ::xml_schema::ErrorHandler& h,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeStreamSource (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeStreamSource (::std::ostream& o,
                         const ::MDPWS::StreamSourceType& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeStreamSource (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeStreamSource (::xercesc::XMLFormatTarget& t,
                         const ::MDPWS::StreamSourceType& s,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeStreamSource (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeStreamSource (::xercesc::XMLFormatTarget& t,
                         const ::MDPWS::StreamSourceType& s,
                         ::xml_schema::ErrorHandler& h,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeStreamSource (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeStreamSource (::xercesc::XMLFormatTarget& t,
                         const ::MDPWS::StreamSourceType& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeStreamSource (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeStreamSource (::xercesc::DOMDocument& d,
                         const ::MDPWS::StreamSourceType& s,
                         ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (typeid (::MDPWS::StreamSourceType) == typeid (s))
    {
      if (n.name () == "StreamSource" &&
          n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-20702-2016")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "StreamSource",
          "http://standards.ieee.org/downloads/11073/11073-20702-2016");
      }
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "StreamSource",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        e, n, s);
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeStreamSource (const ::MDPWS::StreamSourceType& s,
                         const ::xml_schema::NamespaceInfomap& m,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

    if (typeid (::MDPWS::StreamSourceType) == typeid (s))
    {
      d = ::xsd::cxx::xml::dom::serialize< char > (
        "StreamSource",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        m, f);
    }
    else
    {
      d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "StreamSource",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        m, s, f);
    }

    ::MDPWS::serializeStreamSource (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const StreamTransmissionType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // StreamAddress
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getStreamAddress ())
      {
        const StreamTransmissionType::StreamAddressType& x (*i.getStreamAddress ());
        if (typeid (StreamTransmissionType::StreamAddressType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "StreamAddress",
              "http://standards.ieee.org/downloads/11073/11073-20702-2016",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "StreamAddress",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            false, true, e, x);
      }
    }

    // StreamPeriod
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getStreamPeriod ())
      {
        const StreamTransmissionType::StreamPeriodType& x (*i.getStreamPeriod ());
        if (typeid (StreamTransmissionType::StreamPeriodType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "StreamPeriod",
              "http://standards.ieee.org/downloads/11073/11073-20702-2016",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "StreamPeriod",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            false, true, e, x);
      }
    }

    // Type
    //
    if (i.getType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Type",
          e));

      a << *i.getType ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StreamTransmissionType >
  _xsd_StreamTransmissionType_type_serializer_init (
    "StreamTransmissionType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");


  void
  operator<< (::xercesc::DOMElement& e, const StreamTypeType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // StreamTransmission
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const StreamTypeType::StreamTransmissionType& x (i.getStreamTransmission ());
      if (typeid (StreamTypeType::StreamTransmissionType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "StreamTransmission",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "StreamTransmission",
          "http://standards.ieee.org/downloads/11073/11073-20702-2016",
          false, true, e, x);
    }

    // Id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Id",
          e));

      a << i.getId ();
    }

    // StreamType
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "StreamType",
          e));

      a << i.getStreamType ();
    }

    // Element
    //
    if (i.getElement ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Element",
          e));

      a << *i.getElement ();
    }

    // ActionUri
    //
    if (i.getActionUri ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ActionUri",
          e));

      a << *i.getActionUri ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StreamTypeType >
  _xsd_StreamTypeType_type_serializer_init (
    "StreamTypeType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");


  void
  operator<< (::xercesc::DOMElement& e, const StreamDescriptionsType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Types
    //
    if (i.getTypes ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Types",
          "http://standards.ieee.org/downloads/11073/11073-20702-2016",
          e));

      s << *i.getTypes ();
    }

    // StreamType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (StreamDescriptionsType::StreamTypeConstIterator
           b (i.getStreamType ().begin ()), n (i.getStreamType ().end ());
           b != n; ++b)
      {
        if (typeid (StreamDescriptionsType::StreamTypeType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "StreamType",
              "http://standards.ieee.org/downloads/11073/11073-20702-2016",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "StreamType",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            false, true, e, *b);
      }
    }

    // TargetNamespace
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "TargetNamespace",
          e));

      a << i.getTargetNamespace ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StreamDescriptionsType >
  _xsd_StreamDescriptionsType_type_serializer_init (
    "StreamDescriptionsType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");


  void
  serializeStreamDescriptions (::std::ostream& o,
                               const ::MDPWS::StreamDescriptionsType& s,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeStreamDescriptions (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeStreamDescriptions (::std::ostream& o,
                               const ::MDPWS::StreamDescriptionsType& s,
                               ::xml_schema::ErrorHandler& h,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeStreamDescriptions (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeStreamDescriptions (::std::ostream& o,
                               const ::MDPWS::StreamDescriptionsType& s,
                               ::xercesc::DOMErrorHandler& h,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeStreamDescriptions (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeStreamDescriptions (::xercesc::XMLFormatTarget& t,
                               const ::MDPWS::StreamDescriptionsType& s,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeStreamDescriptions (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeStreamDescriptions (::xercesc::XMLFormatTarget& t,
                               const ::MDPWS::StreamDescriptionsType& s,
                               ::xml_schema::ErrorHandler& h,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeStreamDescriptions (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeStreamDescriptions (::xercesc::XMLFormatTarget& t,
                               const ::MDPWS::StreamDescriptionsType& s,
                               ::xercesc::DOMErrorHandler& h,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeStreamDescriptions (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeStreamDescriptions (::xercesc::DOMDocument& d,
                               const ::MDPWS::StreamDescriptionsType& s,
                               ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (typeid (::MDPWS::StreamDescriptionsType) == typeid (s))
    {
      if (n.name () == "StreamDescriptions" &&
          n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-20702-2016")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "StreamDescriptions",
          "http://standards.ieee.org/downloads/11073/11073-20702-2016");
      }
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "StreamDescriptions",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        e, n, s);
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeStreamDescriptions (const ::MDPWS::StreamDescriptionsType& s,
                               const ::xml_schema::NamespaceInfomap& m,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

    if (typeid (::MDPWS::StreamDescriptionsType) == typeid (s))
    {
      d = ::xsd::cxx::xml::dom::serialize< char > (
        "StreamDescriptions",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        m, f);
    }
    else
    {
      d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "StreamDescriptions",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        m, s, f);
    }

    ::MDPWS::serializeStreamDescriptions (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const SafetyReqAssertionType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // TransmitDualChannel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "TransmitDualChannel",
          e));

      a << i.getTransmitDualChannel ();
    }

    // TransmitSafetyContext
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "TransmitSafetyContext",
          e));

      a << i.getTransmitSafetyContext ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SafetyReqAssertionType >
  _xsd_SafetyReqAssertionType_type_serializer_init (
    "SafetyReqAssertionType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");


  void
  serializeSafetyReqAssertion (::std::ostream& o,
                               const ::MDPWS::SafetyReqAssertionType& s,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyReqAssertion (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeSafetyReqAssertion (::std::ostream& o,
                               const ::MDPWS::SafetyReqAssertionType& s,
                               ::xml_schema::ErrorHandler& h,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyReqAssertion (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeSafetyReqAssertion (::std::ostream& o,
                               const ::MDPWS::SafetyReqAssertionType& s,
                               ::xercesc::DOMErrorHandler& h,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyReqAssertion (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeSafetyReqAssertion (::xercesc::XMLFormatTarget& t,
                               const ::MDPWS::SafetyReqAssertionType& s,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyReqAssertion (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeSafetyReqAssertion (::xercesc::XMLFormatTarget& t,
                               const ::MDPWS::SafetyReqAssertionType& s,
                               ::xml_schema::ErrorHandler& h,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyReqAssertion (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeSafetyReqAssertion (::xercesc::XMLFormatTarget& t,
                               const ::MDPWS::SafetyReqAssertionType& s,
                               ::xercesc::DOMErrorHandler& h,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyReqAssertion (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeSafetyReqAssertion (::xercesc::DOMDocument& d,
                               const ::MDPWS::SafetyReqAssertionType& s,
                               ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (typeid (::MDPWS::SafetyReqAssertionType) == typeid (s))
    {
      if (n.name () == "SafetyReqAssertion" &&
          n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-20702-2016")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "SafetyReqAssertion",
          "http://standards.ieee.org/downloads/11073/11073-20702-2016");
      }
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "SafetyReqAssertion",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        e, n, s);
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeSafetyReqAssertion (const ::MDPWS::SafetyReqAssertionType& s,
                               const ::xml_schema::NamespaceInfomap& m,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

    if (typeid (::MDPWS::SafetyReqAssertionType) == typeid (s))
    {
      d = ::xsd::cxx::xml::dom::serialize< char > (
        "SafetyReqAssertion",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        m, f);
    }
    else
    {
      d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "SafetyReqAssertion",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        m, s, f);
    }

    ::MDPWS::serializeSafetyReqAssertion (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const SelectorType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);

    // Id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Id",
          e));

      a << i.getId ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SelectorType >
  _xsd_SelectorType_type_serializer_init (
    "SelectorType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");


  void
  operator<< (::xercesc::DOMElement& e, const SafetyReqType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // DualChannelDef
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getDualChannelDef ())
      {
        const SafetyReqType::DualChannelDefType& x (*i.getDualChannelDef ());
        if (typeid (SafetyReqType::DualChannelDefType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DualChannelDef",
              "http://standards.ieee.org/downloads/11073/11073-20702-2016",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DualChannelDef",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            false, true, e, x);
      }
    }

    // SafetyContextDef
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getSafetyContextDef ())
      {
        const SafetyReqType::SafetyContextDefType& x (*i.getSafetyContextDef ());
        if (typeid (SafetyReqType::SafetyContextDefType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SafetyContextDef",
              "http://standards.ieee.org/downloads/11073/11073-20702-2016",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "SafetyContextDef",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SafetyReqType >
  _xsd_SafetyReqType_type_serializer_init (
    "SafetyReqType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");


  void
  serializeSafetyReq (::std::ostream& o,
                      const ::MDPWS::SafetyReqType& s,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyReq (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeSafetyReq (::std::ostream& o,
                      const ::MDPWS::SafetyReqType& s,
                      ::xml_schema::ErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyReq (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeSafetyReq (::std::ostream& o,
                      const ::MDPWS::SafetyReqType& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyReq (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeSafetyReq (::xercesc::XMLFormatTarget& t,
                      const ::MDPWS::SafetyReqType& s,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyReq (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeSafetyReq (::xercesc::XMLFormatTarget& t,
                      const ::MDPWS::SafetyReqType& s,
                      ::xml_schema::ErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyReq (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeSafetyReq (::xercesc::XMLFormatTarget& t,
                      const ::MDPWS::SafetyReqType& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyReq (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeSafetyReq (::xercesc::DOMDocument& d,
                      const ::MDPWS::SafetyReqType& s,
                      ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (typeid (::MDPWS::SafetyReqType) == typeid (s))
    {
      if (n.name () == "SafetyReq" &&
          n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-20702-2016")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "SafetyReq",
          "http://standards.ieee.org/downloads/11073/11073-20702-2016");
      }
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "SafetyReq",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        e, n, s);
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeSafetyReq (const ::MDPWS::SafetyReqType& s,
                      const ::xml_schema::NamespaceInfomap& m,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

    if (typeid (::MDPWS::SafetyReqType) == typeid (s))
    {
      d = ::xsd::cxx::xml::dom::serialize< char > (
        "SafetyReq",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        m, f);
    }
    else
    {
      d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "SafetyReq",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        m, s, f);
    }

    ::MDPWS::serializeSafetyReq (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const DualChannelDefType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Selector
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (DualChannelDefType::SelectorConstIterator
           b (i.getSelector ().begin ()), n (i.getSelector ().end ());
           b != n; ++b)
      {
        if (typeid (DualChannelDefType::SelectorType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Selector",
              "http://standards.ieee.org/downloads/11073/11073-20702-2016",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Selector",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            false, true, e, *b);
      }
    }

    // Algorithm
    //
    if (i.getAlgorithm ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Algorithm",
          e));

      a << *i.getAlgorithm ();
    }

    // Transform
    //
    if (i.getTransform ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Transform",
          e));

      a << *i.getTransform ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DualChannelDefType >
  _xsd_DualChannelDefType_type_serializer_init (
    "DualChannelDefType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");


  void
  operator<< (::xercesc::DOMElement& e, const SafetyContextDefType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Selector
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SafetyContextDefType::SelectorConstIterator
           b (i.getSelector ().begin ()), n (i.getSelector ().end ());
           b != n; ++b)
      {
        if (typeid (SafetyContextDefType::SelectorType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Selector",
              "http://standards.ieee.org/downloads/11073/11073-20702-2016",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Selector",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SafetyContextDefType >
  _xsd_SafetyContextDefType_type_serializer_init (
    "SafetyContextDefType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");


  void
  operator<< (::xercesc::DOMElement& e, const SafetyInfoType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // DualChannel
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getDualChannel ())
      {
        const SafetyInfoType::DualChannelType& x (*i.getDualChannel ());
        if (typeid (SafetyInfoType::DualChannelType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DualChannel",
              "http://standards.ieee.org/downloads/11073/11073-20702-2016",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DualChannel",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            false, true, e, x);
      }
    }

    // SafetyContext
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.getSafetyContext ())
      {
        const SafetyInfoType::SafetyContextType& x (*i.getSafetyContext ());
        if (typeid (SafetyInfoType::SafetyContextType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SafetyContext",
              "http://standards.ieee.org/downloads/11073/11073-20702-2016",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "SafetyContext",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SafetyInfoType >
  _xsd_SafetyInfoType_type_serializer_init (
    "SafetyInfoType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");


  void
  serializeSafetyInfo (::std::ostream& o,
                       const ::MDPWS::SafetyInfoType& s,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyInfo (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeSafetyInfo (::std::ostream& o,
                       const ::MDPWS::SafetyInfoType& s,
                       ::xml_schema::ErrorHandler& h,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyInfo (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeSafetyInfo (::std::ostream& o,
                       const ::MDPWS::SafetyInfoType& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyInfo (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeSafetyInfo (::xercesc::XMLFormatTarget& t,
                       const ::MDPWS::SafetyInfoType& s,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyInfo (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeSafetyInfo (::xercesc::XMLFormatTarget& t,
                       const ::MDPWS::SafetyInfoType& s,
                       ::xml_schema::ErrorHandler& h,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyInfo (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeSafetyInfo (::xercesc::XMLFormatTarget& t,
                       const ::MDPWS::SafetyInfoType& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDPWS::serializeSafetyInfo (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeSafetyInfo (::xercesc::DOMDocument& d,
                       const ::MDPWS::SafetyInfoType& s,
                       ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (typeid (::MDPWS::SafetyInfoType) == typeid (s))
    {
      if (n.name () == "SafetyInfo" &&
          n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-20702-2016")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "SafetyInfo",
          "http://standards.ieee.org/downloads/11073/11073-20702-2016");
      }
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "SafetyInfo",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        e, n, s);
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeSafetyInfo (const ::MDPWS::SafetyInfoType& s,
                       const ::xml_schema::NamespaceInfomap& m,
                       ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

    if (typeid (::MDPWS::SafetyInfoType) == typeid (s))
    {
      d = ::xsd::cxx::xml::dom::serialize< char > (
        "SafetyInfo",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        m, f);
    }
    else
    {
      d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "SafetyInfo",
        "http://standards.ieee.org/downloads/11073/11073-20702-2016",
        m, s, f);
    }

    ::MDPWS::serializeSafetyInfo (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const DualChannelType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // DcValue
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (DualChannelType::DcValueConstIterator
           b (i.getDcValue ().begin ()), n (i.getDcValue ().end ());
           b != n; ++b)
      {
        if (typeid (DualChannelType::DcValueType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DcValue",
              "http://standards.ieee.org/downloads/11073/11073-20702-2016",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "DcValue",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DualChannelType >
  _xsd_DualChannelType_type_serializer_init (
    "DualChannelType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");


  void
  operator<< (::xercesc::DOMElement& e, const SafetyContextType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // CtxtValue
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SafetyContextType::CtxtValueConstIterator
           b (i.getCtxtValue ().begin ()), n (i.getCtxtValue ().end ());
           b != n; ++b)
      {
        if (typeid (SafetyContextType::CtxtValueType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CtxtValue",
              "http://standards.ieee.org/downloads/11073/11073-20702-2016",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "CtxtValue",
            "http://standards.ieee.org/downloads/11073/11073-20702-2016",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SafetyContextType >
  _xsd_SafetyContextType_type_serializer_init (
    "SafetyContextType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");


  void
  operator<< (::xercesc::DOMElement& e, const DcValueType& i)
  {
    e << static_cast< const ::xml_schema::SimpleType& > (i);

    // ReferencedSelector
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ReferencedSelector",
          e));

      a << i.getReferencedSelector ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DcValueType >
  _xsd_DcValueType_type_serializer_init (
    "DcValueType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");


  void
  operator<< (::xercesc::DOMElement& e, const CtxtValueType& i)
  {
    e << static_cast< const ::xml_schema::SimpleType& > (i);

    // ReferencedSelector
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ReferencedSelector",
          e));

      a << i.getReferencedSelector ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CtxtValueType >
  _xsd_CtxtValueType_type_serializer_init (
    "CtxtValueType",
    "http://standards.ieee.org/downloads/11073/11073-20702-2016");


  void
  operator<< (::xercesc::DOMElement& e, const Types& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

