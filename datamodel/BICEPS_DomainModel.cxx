// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "BICEPS_DomainModel.hxx"

namespace CDM
{
  // Handle
  // 


  // HandleRef
  // 


  // Timestamp
  // 


  // VersionCounter
  // 


  // ReferencedVersion
  // 


  // Activation
  // 

  Activation::
  Activation (Value v)
  : ::xml_schema::String (_xsd_Activation_literals_[v])
  {
  }

  Activation::
  Activation (const char* v)
  : ::xml_schema::String (v)
  {
  }

  Activation::
  Activation (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  Activation::
  Activation (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Activation::
  Activation (const Activation& v,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Activation& Activation::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Activation_literals_[v]);

    return *this;
  }


  // CodeIdentifier
  // 


  // LocalizedTextRef
  // 


  // LocalizedText
  // 

  const LocalizedText::LangOptional& LocalizedText::
  Lang () const
  {
    return this->Lang_;
  }

  LocalizedText::LangOptional& LocalizedText::
  Lang ()
  {
    return this->Lang_;
  }

  void LocalizedText::
  Lang (const LangType& x)
  {
    this->Lang_.set (x);
  }

  void LocalizedText::
  Lang (const LangOptional& x)
  {
    this->Lang_ = x;
  }

  void LocalizedText::
  Lang (::std::unique_ptr< LangType > x)
  {
    this->Lang_.set (std::move (x));
  }

  const LocalizedText::RefOptional& LocalizedText::
  Ref () const
  {
    return this->Ref_;
  }

  LocalizedText::RefOptional& LocalizedText::
  Ref ()
  {
    return this->Ref_;
  }

  void LocalizedText::
  Ref (const RefType& x)
  {
    this->Ref_.set (x);
  }

  void LocalizedText::
  Ref (const RefOptional& x)
  {
    this->Ref_ = x;
  }

  void LocalizedText::
  Ref (::std::unique_ptr< RefType > x)
  {
    this->Ref_.set (std::move (x));
  }

  const LocalizedText::VersionOptional& LocalizedText::
  Version () const
  {
    return this->Version_;
  }

  LocalizedText::VersionOptional& LocalizedText::
  Version ()
  {
    return this->Version_;
  }

  void LocalizedText::
  Version (const VersionType& x)
  {
    this->Version_.set (x);
  }

  void LocalizedText::
  Version (const VersionOptional& x)
  {
    this->Version_ = x;
  }

  void LocalizedText::
  Version (::std::unique_ptr< VersionType > x)
  {
    this->Version_.set (std::move (x));
  }


  // InstanceIdentifier
  // 

  const InstanceIdentifier::ExtensionOptional& InstanceIdentifier::
  Extension () const
  {
    return this->Extension_;
  }

  InstanceIdentifier::ExtensionOptional& InstanceIdentifier::
  Extension ()
  {
    return this->Extension_;
  }

  void InstanceIdentifier::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void InstanceIdentifier::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void InstanceIdentifier::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const InstanceIdentifier::IdentifierNameSequence& InstanceIdentifier::
  IdentifierName () const
  {
    return this->IdentifierName_;
  }

  InstanceIdentifier::IdentifierNameSequence& InstanceIdentifier::
  IdentifierName ()
  {
    return this->IdentifierName_;
  }

  void InstanceIdentifier::
  IdentifierName (const IdentifierNameSequence& s)
  {
    this->IdentifierName_ = s;
  }

  const InstanceIdentifier::RootType& InstanceIdentifier::
  root () const
  {
    return this->root_.get ();
  }

  InstanceIdentifier::RootType& InstanceIdentifier::
  root ()
  {
    return this->root_.get ();
  }

  void InstanceIdentifier::
  root (const RootType& x)
  {
    this->root_.set (x);
  }

  void InstanceIdentifier::
  root (::std::unique_ptr< RootType > x)
  {
    this->root_.set (std::move (x));
  }

  const InstanceIdentifier::ExtensionOptional1& InstanceIdentifier::
  extension () const
  {
    return this->extension_;
  }

  InstanceIdentifier::ExtensionOptional1& InstanceIdentifier::
  extension ()
  {
    return this->extension_;
  }

  void InstanceIdentifier::
  extension (const ExtensionType1& x)
  {
    this->extension_.set (x);
  }

  void InstanceIdentifier::
  extension (const ExtensionOptional1& x)
  {
    this->extension_ = x;
  }

  void InstanceIdentifier::
  extension (::std::unique_ptr< ExtensionType1 > x)
  {
    this->extension_.set (std::move (x));
  }


  // CodedValue
  // 

  const CodedValue::ExtensionOptional& CodedValue::
  Extension () const
  {
    return this->Extension_;
  }

  CodedValue::ExtensionOptional& CodedValue::
  Extension ()
  {
    return this->Extension_;
  }

  void CodedValue::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void CodedValue::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void CodedValue::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const CodedValue::CodingSystemIdOptional& CodedValue::
  CodingSystemId () const
  {
    return this->CodingSystemId_;
  }

  CodedValue::CodingSystemIdOptional& CodedValue::
  CodingSystemId ()
  {
    return this->CodingSystemId_;
  }

  void CodedValue::
  CodingSystemId (const CodingSystemIdType& x)
  {
    this->CodingSystemId_.set (x);
  }

  void CodedValue::
  CodingSystemId (const CodingSystemIdOptional& x)
  {
    this->CodingSystemId_ = x;
  }

  void CodedValue::
  CodingSystemId (::std::unique_ptr< CodingSystemIdType > x)
  {
    this->CodingSystemId_.set (std::move (x));
  }

  const CodedValue::CodingSystemNameSequence& CodedValue::
  CodingSystemName () const
  {
    return this->CodingSystemName_;
  }

  CodedValue::CodingSystemNameSequence& CodedValue::
  CodingSystemName ()
  {
    return this->CodingSystemName_;
  }

  void CodedValue::
  CodingSystemName (const CodingSystemNameSequence& s)
  {
    this->CodingSystemName_ = s;
  }

  const CodedValue::VersionIdOptional& CodedValue::
  VersionId () const
  {
    return this->VersionId_;
  }

  CodedValue::VersionIdOptional& CodedValue::
  VersionId ()
  {
    return this->VersionId_;
  }

  void CodedValue::
  VersionId (const VersionIdType& x)
  {
    this->VersionId_.set (x);
  }

  void CodedValue::
  VersionId (const VersionIdOptional& x)
  {
    this->VersionId_ = x;
  }

  void CodedValue::
  VersionId (::std::unique_ptr< VersionIdType > x)
  {
    this->VersionId_.set (std::move (x));
  }

  const CodedValue::CodeIdType& CodedValue::
  CodeId () const
  {
    return this->CodeId_.get ();
  }

  CodedValue::CodeIdType& CodedValue::
  CodeId ()
  {
    return this->CodeId_.get ();
  }

  void CodedValue::
  CodeId (const CodeIdType& x)
  {
    this->CodeId_.set (x);
  }

  void CodedValue::
  CodeId (::std::unique_ptr< CodeIdType > x)
  {
    this->CodeId_.set (std::move (x));
  }

  const CodedValue::ConceptDescriptionSequence& CodedValue::
  ConceptDescription () const
  {
    return this->ConceptDescription_;
  }

  CodedValue::ConceptDescriptionSequence& CodedValue::
  ConceptDescription ()
  {
    return this->ConceptDescription_;
  }

  void CodedValue::
  ConceptDescription (const ConceptDescriptionSequence& s)
  {
    this->ConceptDescription_ = s;
  }


  // CodedWithTranslations
  // 

  const CodedWithTranslations::TranslationSequence& CodedWithTranslations::
  Translation () const
  {
    return this->Translation_;
  }

  CodedWithTranslations::TranslationSequence& CodedWithTranslations::
  Translation ()
  {
    return this->Translation_;
  }

  void CodedWithTranslations::
  Translation (const TranslationSequence& s)
  {
    this->Translation_ = s;
  }


  // CauseInfo
  // 

  const CauseInfo::ExtensionOptional& CauseInfo::
  Extension () const
  {
    return this->Extension_;
  }

  CauseInfo::ExtensionOptional& CauseInfo::
  Extension ()
  {
    return this->Extension_;
  }

  void CauseInfo::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void CauseInfo::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void CauseInfo::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const CauseInfo::RemedyOptional& CauseInfo::
  Remedy () const
  {
    return this->Remedy_;
  }

  CauseInfo::RemedyOptional& CauseInfo::
  Remedy ()
  {
    return this->Remedy_;
  }

  void CauseInfo::
  Remedy (const RemedyType& x)
  {
    this->Remedy_.set (x);
  }

  void CauseInfo::
  Remedy (const RemedyOptional& x)
  {
    this->Remedy_ = x;
  }

  void CauseInfo::
  Remedy (::std::unique_ptr< RemedyType > x)
  {
    this->Remedy_.set (std::move (x));
  }

  const CauseInfo::DescriptionSequence& CauseInfo::
  Description () const
  {
    return this->Description_;
  }

  CauseInfo::DescriptionSequence& CauseInfo::
  Description ()
  {
    return this->Description_;
  }

  void CauseInfo::
  Description (const DescriptionSequence& s)
  {
    this->Description_ = s;
  }


  // RemedyInfo
  // 

  const RemedyInfo::ExtensionOptional& RemedyInfo::
  Extension () const
  {
    return this->Extension_;
  }

  RemedyInfo::ExtensionOptional& RemedyInfo::
  Extension ()
  {
    return this->Extension_;
  }

  void RemedyInfo::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void RemedyInfo::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void RemedyInfo::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const RemedyInfo::DescriptionSequence& RemedyInfo::
  Description () const
  {
    return this->Description_;
  }

  RemedyInfo::DescriptionSequence& RemedyInfo::
  Description ()
  {
    return this->Description_;
  }

  void RemedyInfo::
  Description (const DescriptionSequence& s)
  {
    this->Description_ = s;
  }


  // Range
  // 

  const Range::ExtensionOptional& Range::
  Extension () const
  {
    return this->Extension_;
  }

  Range::ExtensionOptional& Range::
  Extension ()
  {
    return this->Extension_;
  }

  void Range::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void Range::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void Range::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const Range::LowerOptional& Range::
  Lower () const
  {
    return this->Lower_;
  }

  Range::LowerOptional& Range::
  Lower ()
  {
    return this->Lower_;
  }

  void Range::
  Lower (const LowerType& x)
  {
    this->Lower_.set (x);
  }

  void Range::
  Lower (const LowerOptional& x)
  {
    this->Lower_ = x;
  }

  const Range::UpperOptional& Range::
  Upper () const
  {
    return this->Upper_;
  }

  Range::UpperOptional& Range::
  Upper ()
  {
    return this->Upper_;
  }

  void Range::
  Upper (const UpperType& x)
  {
    this->Upper_.set (x);
  }

  void Range::
  Upper (const UpperOptional& x)
  {
    this->Upper_ = x;
  }

  const Range::StepWidthOptional& Range::
  StepWidth () const
  {
    return this->StepWidth_;
  }

  Range::StepWidthOptional& Range::
  StepWidth ()
  {
    return this->StepWidth_;
  }

  void Range::
  StepWidth (const StepWidthType& x)
  {
    this->StepWidth_.set (x);
  }

  void Range::
  StepWidth (const StepWidthOptional& x)
  {
    this->StepWidth_ = x;
  }


  // Measure
  // 

  const Measure::ExtensionOptional& Measure::
  Extension () const
  {
    return this->Extension_;
  }

  Measure::ExtensionOptional& Measure::
  Extension ()
  {
    return this->Extension_;
  }

  void Measure::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void Measure::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void Measure::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const Measure::MeasurementUnitType& Measure::
  MeasurementUnit () const
  {
    return this->MeasurementUnit_.get ();
  }

  Measure::MeasurementUnitType& Measure::
  MeasurementUnit ()
  {
    return this->MeasurementUnit_.get ();
  }

  void Measure::
  MeasurementUnit (const MeasurementUnitType& x)
  {
    this->MeasurementUnit_.set (x);
  }

  void Measure::
  MeasurementUnit (::std::unique_ptr< MeasurementUnitType > x)
  {
    this->MeasurementUnit_.set (std::move (x));
  }

  const Measure::MeasuredValueOptional& Measure::
  MeasuredValue () const
  {
    return this->MeasuredValue_;
  }

  Measure::MeasuredValueOptional& Measure::
  MeasuredValue ()
  {
    return this->MeasuredValue_;
  }

  void Measure::
  MeasuredValue (const MeasuredValueType& x)
  {
    this->MeasuredValue_.set (x);
  }

  void Measure::
  MeasuredValue (const MeasuredValueOptional& x)
  {
    this->MeasuredValue_ = x;
  }


  // IntendedUse
  // 

  IntendedUse::
  IntendedUse (Value v)
  : ::xml_schema::String (_xsd_IntendedUse_literals_[v])
  {
  }

  IntendedUse::
  IntendedUse (const char* v)
  : ::xml_schema::String (v)
  {
  }

  IntendedUse::
  IntendedUse (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  IntendedUse::
  IntendedUse (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  IntendedUse::
  IntendedUse (const IntendedUse& v,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  IntendedUse& IntendedUse::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_IntendedUse_literals_[v]);

    return *this;
  }


  // AbstractDescriptor
  // 

  const AbstractDescriptor::ExtensionOptional& AbstractDescriptor::
  Extension () const
  {
    return this->Extension_;
  }

  AbstractDescriptor::ExtensionOptional& AbstractDescriptor::
  Extension ()
  {
    return this->Extension_;
  }

  void AbstractDescriptor::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractDescriptor::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractDescriptor::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const AbstractDescriptor::TypeOptional& AbstractDescriptor::
  Type () const
  {
    return this->Type_;
  }

  AbstractDescriptor::TypeOptional& AbstractDescriptor::
  Type ()
  {
    return this->Type_;
  }

  void AbstractDescriptor::
  Type (const TypeType& x)
  {
    this->Type_.set (x);
  }

  void AbstractDescriptor::
  Type (const TypeOptional& x)
  {
    this->Type_ = x;
  }

  void AbstractDescriptor::
  Type (::std::unique_ptr< TypeType > x)
  {
    this->Type_.set (std::move (x));
  }

  const AbstractDescriptor::HandleType& AbstractDescriptor::
  Handle () const
  {
    return this->Handle_.get ();
  }

  AbstractDescriptor::HandleType& AbstractDescriptor::
  Handle ()
  {
    return this->Handle_.get ();
  }

  void AbstractDescriptor::
  Handle (const HandleType& x)
  {
    this->Handle_.set (x);
  }

  void AbstractDescriptor::
  Handle (::std::unique_ptr< HandleType > x)
  {
    this->Handle_.set (std::move (x));
  }

  const AbstractDescriptor::DescriptorVersionOptional& AbstractDescriptor::
  DescriptorVersion () const
  {
    return this->DescriptorVersion_;
  }

  AbstractDescriptor::DescriptorVersionOptional& AbstractDescriptor::
  DescriptorVersion ()
  {
    return this->DescriptorVersion_;
  }

  void AbstractDescriptor::
  DescriptorVersion (const DescriptorVersionType& x)
  {
    this->DescriptorVersion_.set (x);
  }

  void AbstractDescriptor::
  DescriptorVersion (const DescriptorVersionOptional& x)
  {
    this->DescriptorVersion_ = x;
  }

  void AbstractDescriptor::
  DescriptorVersion (::std::unique_ptr< DescriptorVersionType > x)
  {
    this->DescriptorVersion_.set (std::move (x));
  }

  const AbstractDescriptor::IntendedUseOptional& AbstractDescriptor::
  IntendedUse () const
  {
    return this->IntendedUse_;
  }

  AbstractDescriptor::IntendedUseOptional& AbstractDescriptor::
  IntendedUse ()
  {
    return this->IntendedUse_;
  }

  void AbstractDescriptor::
  IntendedUse (const IntendedUseType& x)
  {
    this->IntendedUse_.set (x);
  }

  void AbstractDescriptor::
  IntendedUse (const IntendedUseOptional& x)
  {
    this->IntendedUse_ = x;
  }

  void AbstractDescriptor::
  IntendedUse (::std::unique_ptr< IntendedUseType > x)
  {
    this->IntendedUse_.set (std::move (x));
  }


  // AbstractState
  // 

  const AbstractState::ExtensionOptional& AbstractState::
  Extension () const
  {
    return this->Extension_;
  }

  AbstractState::ExtensionOptional& AbstractState::
  Extension ()
  {
    return this->Extension_;
  }

  void AbstractState::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractState::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractState::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const AbstractState::HandleOptional& AbstractState::
  Handle () const
  {
    return this->Handle_;
  }

  AbstractState::HandleOptional& AbstractState::
  Handle ()
  {
    return this->Handle_;
  }

  void AbstractState::
  Handle (const HandleType& x)
  {
    this->Handle_.set (x);
  }

  void AbstractState::
  Handle (const HandleOptional& x)
  {
    this->Handle_ = x;
  }

  void AbstractState::
  Handle (::std::unique_ptr< HandleType > x)
  {
    this->Handle_.set (std::move (x));
  }

  const AbstractState::StateVersionOptional& AbstractState::
  StateVersion () const
  {
    return this->StateVersion_;
  }

  AbstractState::StateVersionOptional& AbstractState::
  StateVersion ()
  {
    return this->StateVersion_;
  }

  void AbstractState::
  StateVersion (const StateVersionType& x)
  {
    this->StateVersion_.set (x);
  }

  void AbstractState::
  StateVersion (const StateVersionOptional& x)
  {
    this->StateVersion_ = x;
  }

  void AbstractState::
  StateVersion (::std::unique_ptr< StateVersionType > x)
  {
    this->StateVersion_.set (std::move (x));
  }

  const AbstractState::DescriptorHandleType& AbstractState::
  DescriptorHandle () const
  {
    return this->DescriptorHandle_.get ();
  }

  AbstractState::DescriptorHandleType& AbstractState::
  DescriptorHandle ()
  {
    return this->DescriptorHandle_.get ();
  }

  void AbstractState::
  DescriptorHandle (const DescriptorHandleType& x)
  {
    this->DescriptorHandle_.set (x);
  }

  void AbstractState::
  DescriptorHandle (::std::unique_ptr< DescriptorHandleType > x)
  {
    this->DescriptorHandle_.set (std::move (x));
  }

  const AbstractState::DescriptorVersionOptional& AbstractState::
  DescriptorVersion () const
  {
    return this->DescriptorVersion_;
  }

  AbstractState::DescriptorVersionOptional& AbstractState::
  DescriptorVersion ()
  {
    return this->DescriptorVersion_;
  }

  void AbstractState::
  DescriptorVersion (const DescriptorVersionType& x)
  {
    this->DescriptorVersion_.set (x);
  }

  void AbstractState::
  DescriptorVersion (const DescriptorVersionOptional& x)
  {
    this->DescriptorVersion_ = x;
  }

  void AbstractState::
  DescriptorVersion (::std::unique_ptr< DescriptorVersionType > x)
  {
    this->DescriptorVersion_.set (std::move (x));
  }


  // MDDescription
  // 

  const MDDescription::ExtensionOptional& MDDescription::
  Extension () const
  {
    return this->Extension_;
  }

  MDDescription::ExtensionOptional& MDDescription::
  Extension ()
  {
    return this->Extension_;
  }

  void MDDescription::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void MDDescription::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void MDDescription::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const MDDescription::MDSSequence& MDDescription::
  MDS () const
  {
    return this->MDS_;
  }

  MDDescription::MDSSequence& MDDescription::
  MDS ()
  {
    return this->MDS_;
  }

  void MDDescription::
  MDS (const MDSSequence& s)
  {
    this->MDS_ = s;
  }

  const MDDescription::DescriptionVersionOptional& MDDescription::
  DescriptionVersion () const
  {
    return this->DescriptionVersion_;
  }

  MDDescription::DescriptionVersionOptional& MDDescription::
  DescriptionVersion ()
  {
    return this->DescriptionVersion_;
  }

  void MDDescription::
  DescriptionVersion (const DescriptionVersionType& x)
  {
    this->DescriptionVersion_.set (x);
  }

  void MDDescription::
  DescriptionVersion (const DescriptionVersionOptional& x)
  {
    this->DescriptionVersion_ = x;
  }

  void MDDescription::
  DescriptionVersion (::std::unique_ptr< DescriptionVersionType > x)
  {
    this->DescriptionVersion_.set (std::move (x));
  }


  // MDState
  // 

  const MDState::ExtensionOptional& MDState::
  Extension () const
  {
    return this->Extension_;
  }

  MDState::ExtensionOptional& MDState::
  Extension ()
  {
    return this->Extension_;
  }

  void MDState::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void MDState::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void MDState::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const MDState::StateSequence& MDState::
  State () const
  {
    return this->State_;
  }

  MDState::StateSequence& MDState::
  State ()
  {
    return this->State_;
  }

  void MDState::
  State (const StateSequence& s)
  {
    this->State_ = s;
  }

  const MDState::StateVersionOptional& MDState::
  StateVersion () const
  {
    return this->StateVersion_;
  }

  MDState::StateVersionOptional& MDState::
  StateVersion ()
  {
    return this->StateVersion_;
  }

  void MDState::
  StateVersion (const StateVersionType& x)
  {
    this->StateVersion_.set (x);
  }

  void MDState::
  StateVersion (const StateVersionOptional& x)
  {
    this->StateVersion_ = x;
  }

  void MDState::
  StateVersion (::std::unique_ptr< StateVersionType > x)
  {
    this->StateVersion_.set (std::move (x));
  }


  // MDIB
  // 

  const MDIB::ExtensionOptional& MDIB::
  Extension () const
  {
    return this->Extension_;
  }

  MDIB::ExtensionOptional& MDIB::
  Extension ()
  {
    return this->Extension_;
  }

  void MDIB::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void MDIB::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void MDIB::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const MDIB::MDDescriptionType& MDIB::
  MDDescription () const
  {
    return this->MDDescription_.get ();
  }

  MDIB::MDDescriptionType& MDIB::
  MDDescription ()
  {
    return this->MDDescription_.get ();
  }

  void MDIB::
  MDDescription (const MDDescriptionType& x)
  {
    this->MDDescription_.set (x);
  }

  void MDIB::
  MDDescription (::std::unique_ptr< MDDescriptionType > x)
  {
    this->MDDescription_.set (std::move (x));
  }

  const MDIB::MDStateType& MDIB::
  MDState () const
  {
    return this->MDState_.get ();
  }

  MDIB::MDStateType& MDIB::
  MDState ()
  {
    return this->MDState_.get ();
  }

  void MDIB::
  MDState (const MDStateType& x)
  {
    this->MDState_.set (x);
  }

  void MDIB::
  MDState (::std::unique_ptr< MDStateType > x)
  {
    this->MDState_.set (std::move (x));
  }

  const MDIB::MDIBVersionType& MDIB::
  MDIBVersion () const
  {
    return this->MDIBVersion_.get ();
  }

  MDIB::MDIBVersionType& MDIB::
  MDIBVersion ()
  {
    return this->MDIBVersion_.get ();
  }

  void MDIB::
  MDIBVersion (const MDIBVersionType& x)
  {
    this->MDIBVersion_.set (x);
  }

  void MDIB::
  MDIBVersion (::std::unique_ptr< MDIBVersionType > x)
  {
    this->MDIBVersion_.set (std::move (x));
  }


  // ProductionSpecification
  // 

  const ProductionSpecification::SpecTypeType& ProductionSpecification::
  specType () const
  {
    return this->specType_.get ();
  }

  ProductionSpecification::SpecTypeType& ProductionSpecification::
  specType ()
  {
    return this->specType_.get ();
  }

  void ProductionSpecification::
  specType (const SpecTypeType& x)
  {
    this->specType_.set (x);
  }

  void ProductionSpecification::
  specType (::std::unique_ptr< SpecTypeType > x)
  {
    this->specType_.set (std::move (x));
  }

  const ProductionSpecification::ProductionSpecType& ProductionSpecification::
  productionSpec () const
  {
    return this->productionSpec_.get ();
  }

  ProductionSpecification::ProductionSpecType& ProductionSpecification::
  productionSpec ()
  {
    return this->productionSpec_.get ();
  }

  void ProductionSpecification::
  productionSpec (const ProductionSpecType& x)
  {
    this->productionSpec_.set (x);
  }

  void ProductionSpecification::
  productionSpec (::std::unique_ptr< ProductionSpecType > x)
  {
    this->productionSpec_.set (std::move (x));
  }

  const ProductionSpecification::ComponentIdOptional& ProductionSpecification::
  componentId () const
  {
    return this->componentId_;
  }

  ProductionSpecification::ComponentIdOptional& ProductionSpecification::
  componentId ()
  {
    return this->componentId_;
  }

  void ProductionSpecification::
  componentId (const ComponentIdType& x)
  {
    this->componentId_.set (x);
  }

  void ProductionSpecification::
  componentId (const ComponentIdOptional& x)
  {
    this->componentId_ = x;
  }

  void ProductionSpecification::
  componentId (::std::unique_ptr< ComponentIdType > x)
  {
    this->componentId_.set (std::move (x));
  }


  // SystemMetaData
  // 

  const SystemMetaData::ExtensionOptional& SystemMetaData::
  Extension () const
  {
    return this->Extension_;
  }

  SystemMetaData::ExtensionOptional& SystemMetaData::
  Extension ()
  {
    return this->Extension_;
  }

  void SystemMetaData::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void SystemMetaData::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void SystemMetaData::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const SystemMetaData::UDIOptional& SystemMetaData::
  UDI () const
  {
    return this->UDI_;
  }

  SystemMetaData::UDIOptional& SystemMetaData::
  UDI ()
  {
    return this->UDI_;
  }

  void SystemMetaData::
  UDI (const UDIType& x)
  {
    this->UDI_.set (x);
  }

  void SystemMetaData::
  UDI (const UDIOptional& x)
  {
    this->UDI_ = x;
  }

  void SystemMetaData::
  UDI (::std::unique_ptr< UDIType > x)
  {
    this->UDI_.set (std::move (x));
  }

  const SystemMetaData::ManufacturerSequence& SystemMetaData::
  Manufacturer () const
  {
    return this->Manufacturer_;
  }

  SystemMetaData::ManufacturerSequence& SystemMetaData::
  Manufacturer ()
  {
    return this->Manufacturer_;
  }

  void SystemMetaData::
  Manufacturer (const ManufacturerSequence& s)
  {
    this->Manufacturer_ = s;
  }

  const SystemMetaData::ModelNameSequence& SystemMetaData::
  ModelName () const
  {
    return this->ModelName_;
  }

  SystemMetaData::ModelNameSequence& SystemMetaData::
  ModelName ()
  {
    return this->ModelName_;
  }

  void SystemMetaData::
  ModelName (const ModelNameSequence& s)
  {
    this->ModelName_ = s;
  }

  const SystemMetaData::ModelNumberSequence& SystemMetaData::
  ModelNumber () const
  {
    return this->ModelNumber_;
  }

  SystemMetaData::ModelNumberSequence& SystemMetaData::
  ModelNumber ()
  {
    return this->ModelNumber_;
  }

  void SystemMetaData::
  ModelNumber (const ModelNumberSequence& s)
  {
    this->ModelNumber_ = s;
  }

  const SystemMetaData::SerialNumberSequence& SystemMetaData::
  SerialNumber () const
  {
    return this->SerialNumber_;
  }

  SystemMetaData::SerialNumberSequence& SystemMetaData::
  SerialNumber ()
  {
    return this->SerialNumber_;
  }

  void SystemMetaData::
  SerialNumber (const SerialNumberSequence& s)
  {
    this->SerialNumber_ = s;
  }


  // SystemContext
  // 

  const SystemContext::PatientContextOptional& SystemContext::
  PatientContext () const
  {
    return this->PatientContext_;
  }

  SystemContext::PatientContextOptional& SystemContext::
  PatientContext ()
  {
    return this->PatientContext_;
  }

  void SystemContext::
  PatientContext (const PatientContextType& x)
  {
    this->PatientContext_.set (x);
  }

  void SystemContext::
  PatientContext (const PatientContextOptional& x)
  {
    this->PatientContext_ = x;
  }

  void SystemContext::
  PatientContext (::std::unique_ptr< PatientContextType > x)
  {
    this->PatientContext_.set (std::move (x));
  }

  const SystemContext::LocationContextOptional& SystemContext::
  LocationContext () const
  {
    return this->LocationContext_;
  }

  SystemContext::LocationContextOptional& SystemContext::
  LocationContext ()
  {
    return this->LocationContext_;
  }

  void SystemContext::
  LocationContext (const LocationContextType& x)
  {
    this->LocationContext_.set (x);
  }

  void SystemContext::
  LocationContext (const LocationContextOptional& x)
  {
    this->LocationContext_ = x;
  }

  void SystemContext::
  LocationContext (::std::unique_ptr< LocationContextType > x)
  {
    this->LocationContext_.set (std::move (x));
  }

  const SystemContext::EnsembleContextOptional& SystemContext::
  EnsembleContext () const
  {
    return this->EnsembleContext_;
  }

  SystemContext::EnsembleContextOptional& SystemContext::
  EnsembleContext ()
  {
    return this->EnsembleContext_;
  }

  void SystemContext::
  EnsembleContext (const EnsembleContextType& x)
  {
    this->EnsembleContext_.set (x);
  }

  void SystemContext::
  EnsembleContext (const EnsembleContextOptional& x)
  {
    this->EnsembleContext_ = x;
  }

  void SystemContext::
  EnsembleContext (::std::unique_ptr< EnsembleContextType > x)
  {
    this->EnsembleContext_.set (std::move (x));
  }

  const SystemContext::OperatorContextOptional& SystemContext::
  OperatorContext () const
  {
    return this->OperatorContext_;
  }

  SystemContext::OperatorContextOptional& SystemContext::
  OperatorContext ()
  {
    return this->OperatorContext_;
  }

  void SystemContext::
  OperatorContext (const OperatorContextType& x)
  {
    this->OperatorContext_.set (x);
  }

  void SystemContext::
  OperatorContext (const OperatorContextOptional& x)
  {
    this->OperatorContext_ = x;
  }

  void SystemContext::
  OperatorContext (::std::unique_ptr< OperatorContextType > x)
  {
    this->OperatorContext_.set (std::move (x));
  }

  const SystemContext::WorkflowContextOptional& SystemContext::
  WorkflowContext () const
  {
    return this->WorkflowContext_;
  }

  SystemContext::WorkflowContextOptional& SystemContext::
  WorkflowContext ()
  {
    return this->WorkflowContext_;
  }

  void SystemContext::
  WorkflowContext (const WorkflowContextType& x)
  {
    this->WorkflowContext_.set (x);
  }

  void SystemContext::
  WorkflowContext (const WorkflowContextOptional& x)
  {
    this->WorkflowContext_ = x;
  }

  void SystemContext::
  WorkflowContext (::std::unique_ptr< WorkflowContextType > x)
  {
    this->WorkflowContext_.set (std::move (x));
  }


  // AbstractDeviceComponent
  // 

  const AbstractDeviceComponent::ProductionSpecificationSequence& AbstractDeviceComponent::
  ProductionSpecification () const
  {
    return this->ProductionSpecification_;
  }

  AbstractDeviceComponent::ProductionSpecificationSequence& AbstractDeviceComponent::
  ProductionSpecification ()
  {
    return this->ProductionSpecification_;
  }

  void AbstractDeviceComponent::
  ProductionSpecification (const ProductionSpecificationSequence& s)
  {
    this->ProductionSpecification_ = s;
  }


  // AbstractMDSDescriptor
  // 

  const AbstractMDSDescriptor::MetaDataOptional& AbstractMDSDescriptor::
  MetaData () const
  {
    return this->MetaData_;
  }

  AbstractMDSDescriptor::MetaDataOptional& AbstractMDSDescriptor::
  MetaData ()
  {
    return this->MetaData_;
  }

  void AbstractMDSDescriptor::
  MetaData (const MetaDataType& x)
  {
    this->MetaData_.set (x);
  }

  void AbstractMDSDescriptor::
  MetaData (const MetaDataOptional& x)
  {
    this->MetaData_ = x;
  }

  void AbstractMDSDescriptor::
  MetaData (::std::unique_ptr< MetaDataType > x)
  {
    this->MetaData_.set (std::move (x));
  }

  const AbstractMDSDescriptor::ContextType& AbstractMDSDescriptor::
  Context () const
  {
    return this->Context_.get ();
  }

  AbstractMDSDescriptor::ContextType& AbstractMDSDescriptor::
  Context ()
  {
    return this->Context_.get ();
  }

  void AbstractMDSDescriptor::
  Context (const ContextType& x)
  {
    this->Context_.set (x);
  }

  void AbstractMDSDescriptor::
  Context (::std::unique_ptr< ContextType > x)
  {
    this->Context_.set (std::move (x));
  }

  const AbstractMDSDescriptor::ClockOptional& AbstractMDSDescriptor::
  Clock () const
  {
    return this->Clock_;
  }

  AbstractMDSDescriptor::ClockOptional& AbstractMDSDescriptor::
  Clock ()
  {
    return this->Clock_;
  }

  void AbstractMDSDescriptor::
  Clock (const ClockType& x)
  {
    this->Clock_.set (x);
  }

  void AbstractMDSDescriptor::
  Clock (const ClockOptional& x)
  {
    this->Clock_ = x;
  }

  void AbstractMDSDescriptor::
  Clock (::std::unique_ptr< ClockType > x)
  {
    this->Clock_.set (std::move (x));
  }


  // HydraMDSDescriptor
  // 

  const HydraMDSDescriptor::SCOOptional& HydraMDSDescriptor::
  SCO () const
  {
    return this->SCO_;
  }

  HydraMDSDescriptor::SCOOptional& HydraMDSDescriptor::
  SCO ()
  {
    return this->SCO_;
  }

  void HydraMDSDescriptor::
  SCO (const SCOType& x)
  {
    this->SCO_.set (x);
  }

  void HydraMDSDescriptor::
  SCO (const SCOOptional& x)
  {
    this->SCO_ = x;
  }

  void HydraMDSDescriptor::
  SCO (::std::unique_ptr< SCOType > x)
  {
    this->SCO_.set (std::move (x));
  }

  const HydraMDSDescriptor::AlertSystemOptional& HydraMDSDescriptor::
  AlertSystem () const
  {
    return this->AlertSystem_;
  }

  HydraMDSDescriptor::AlertSystemOptional& HydraMDSDescriptor::
  AlertSystem ()
  {
    return this->AlertSystem_;
  }

  void HydraMDSDescriptor::
  AlertSystem (const AlertSystemType& x)
  {
    this->AlertSystem_.set (x);
  }

  void HydraMDSDescriptor::
  AlertSystem (const AlertSystemOptional& x)
  {
    this->AlertSystem_ = x;
  }

  void HydraMDSDescriptor::
  AlertSystem (::std::unique_ptr< AlertSystemType > x)
  {
    this->AlertSystem_.set (std::move (x));
  }

  const HydraMDSDescriptor::VMDSequence& HydraMDSDescriptor::
  VMD () const
  {
    return this->VMD_;
  }

  HydraMDSDescriptor::VMDSequence& HydraMDSDescriptor::
  VMD ()
  {
    return this->VMD_;
  }

  void HydraMDSDescriptor::
  VMD (const VMDSequence& s)
  {
    this->VMD_ = s;
  }


  // ComponentState
  // 

  const ComponentState::CalibrationInfoOptional& ComponentState::
  CalibrationInfo () const
  {
    return this->CalibrationInfo_;
  }

  ComponentState::CalibrationInfoOptional& ComponentState::
  CalibrationInfo ()
  {
    return this->CalibrationInfo_;
  }

  void ComponentState::
  CalibrationInfo (const CalibrationInfoType& x)
  {
    this->CalibrationInfo_.set (x);
  }

  void ComponentState::
  CalibrationInfo (const CalibrationInfoOptional& x)
  {
    this->CalibrationInfo_ = x;
  }

  void ComponentState::
  CalibrationInfo (::std::unique_ptr< CalibrationInfoType > x)
  {
    this->CalibrationInfo_.set (std::move (x));
  }

  const ComponentState::ComponentActivationStateOptional& ComponentState::
  ComponentActivationState () const
  {
    return this->ComponentActivationState_;
  }

  ComponentState::ComponentActivationStateOptional& ComponentState::
  ComponentActivationState ()
  {
    return this->ComponentActivationState_;
  }

  void ComponentState::
  ComponentActivationState (const ComponentActivationStateType& x)
  {
    this->ComponentActivationState_.set (x);
  }

  void ComponentState::
  ComponentActivationState (const ComponentActivationStateOptional& x)
  {
    this->ComponentActivationState_ = x;
  }

  void ComponentState::
  ComponentActivationState (::std::unique_ptr< ComponentActivationStateType > x)
  {
    this->ComponentActivationState_.set (std::move (x));
  }

  const ComponentState::OperatingHoursOptional& ComponentState::
  OperatingHours () const
  {
    return this->OperatingHours_;
  }

  ComponentState::OperatingHoursOptional& ComponentState::
  OperatingHours ()
  {
    return this->OperatingHours_;
  }

  void ComponentState::
  OperatingHours (const OperatingHoursType& x)
  {
    this->OperatingHours_.set (x);
  }

  void ComponentState::
  OperatingHours (const OperatingHoursOptional& x)
  {
    this->OperatingHours_ = x;
  }

  const ComponentState::OperatingCyclesOptional& ComponentState::
  OperatingCycles () const
  {
    return this->OperatingCycles_;
  }

  ComponentState::OperatingCyclesOptional& ComponentState::
  OperatingCycles ()
  {
    return this->OperatingCycles_;
  }

  void ComponentState::
  OperatingCycles (const OperatingCyclesType& x)
  {
    this->OperatingCycles_.set (x);
  }

  void ComponentState::
  OperatingCycles (const OperatingCyclesOptional& x)
  {
    this->OperatingCycles_ = x;
  }


  // AbstractMDSState
  // 

  const AbstractMDSState::LangOptional& AbstractMDSState::
  Lang () const
  {
    return this->Lang_;
  }

  AbstractMDSState::LangOptional& AbstractMDSState::
  Lang ()
  {
    return this->Lang_;
  }

  void AbstractMDSState::
  Lang (const LangType& x)
  {
    this->Lang_.set (x);
  }

  void AbstractMDSState::
  Lang (const LangOptional& x)
  {
    this->Lang_ = x;
  }

  void AbstractMDSState::
  Lang (::std::unique_ptr< LangType > x)
  {
    this->Lang_.set (std::move (x));
  }


  // HydraMDSState
  // 


  // AlertConditionKind
  // 

  AlertConditionKind::
  AlertConditionKind (Value v)
  : ::xml_schema::String (_xsd_AlertConditionKind_literals_[v])
  {
  }

  AlertConditionKind::
  AlertConditionKind (const char* v)
  : ::xml_schema::String (v)
  {
  }

  AlertConditionKind::
  AlertConditionKind (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  AlertConditionKind::
  AlertConditionKind (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  AlertConditionKind::
  AlertConditionKind (const AlertConditionKind& v,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  AlertConditionKind& AlertConditionKind::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_AlertConditionKind_literals_[v]);

    return *this;
  }


  // AlertConditionPriority
  // 

  AlertConditionPriority::
  AlertConditionPriority (Value v)
  : ::xml_schema::String (_xsd_AlertConditionPriority_literals_[v])
  {
  }

  AlertConditionPriority::
  AlertConditionPriority (const char* v)
  : ::xml_schema::String (v)
  {
  }

  AlertConditionPriority::
  AlertConditionPriority (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  AlertConditionPriority::
  AlertConditionPriority (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  AlertConditionPriority::
  AlertConditionPriority (const AlertConditionPriority& v,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  AlertConditionPriority& AlertConditionPriority::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_AlertConditionPriority_literals_[v]);

    return *this;
  }


  // AlertSignalManifestation
  // 

  AlertSignalManifestation::
  AlertSignalManifestation (Value v)
  : ::xml_schema::String (_xsd_AlertSignalManifestation_literals_[v])
  {
  }

  AlertSignalManifestation::
  AlertSignalManifestation (const char* v)
  : ::xml_schema::String (v)
  {
  }

  AlertSignalManifestation::
  AlertSignalManifestation (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  AlertSignalManifestation::
  AlertSignalManifestation (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  AlertSignalManifestation::
  AlertSignalManifestation (const AlertSignalManifestation& v,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  AlertSignalManifestation& AlertSignalManifestation::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_AlertSignalManifestation_literals_[v]);

    return *this;
  }


  // AbstractAlertDescriptor
  // 


  // AlertSystemDescriptor
  // 

  const AlertSystemDescriptor::AlertConditionSequence& AlertSystemDescriptor::
  AlertCondition () const
  {
    return this->AlertCondition_;
  }

  AlertSystemDescriptor::AlertConditionSequence& AlertSystemDescriptor::
  AlertCondition ()
  {
    return this->AlertCondition_;
  }

  void AlertSystemDescriptor::
  AlertCondition (const AlertConditionSequence& s)
  {
    this->AlertCondition_ = s;
  }

  const AlertSystemDescriptor::AlertSignalSequence& AlertSystemDescriptor::
  AlertSignal () const
  {
    return this->AlertSignal_;
  }

  AlertSystemDescriptor::AlertSignalSequence& AlertSystemDescriptor::
  AlertSignal ()
  {
    return this->AlertSignal_;
  }

  void AlertSystemDescriptor::
  AlertSignal (const AlertSignalSequence& s)
  {
    this->AlertSignal_ = s;
  }

  const AlertSystemDescriptor::MaxPhysiologicalAlarmListEntriesOptional& AlertSystemDescriptor::
  MaxPhysiologicalAlarmListEntries () const
  {
    return this->MaxPhysiologicalAlarmListEntries_;
  }

  AlertSystemDescriptor::MaxPhysiologicalAlarmListEntriesOptional& AlertSystemDescriptor::
  MaxPhysiologicalAlarmListEntries ()
  {
    return this->MaxPhysiologicalAlarmListEntries_;
  }

  void AlertSystemDescriptor::
  MaxPhysiologicalAlarmListEntries (const MaxPhysiologicalAlarmListEntriesType& x)
  {
    this->MaxPhysiologicalAlarmListEntries_.set (x);
  }

  void AlertSystemDescriptor::
  MaxPhysiologicalAlarmListEntries (const MaxPhysiologicalAlarmListEntriesOptional& x)
  {
    this->MaxPhysiologicalAlarmListEntries_ = x;
  }

  const AlertSystemDescriptor::MaxTechnicalAlarmListEntriesOptional& AlertSystemDescriptor::
  MaxTechnicalAlarmListEntries () const
  {
    return this->MaxTechnicalAlarmListEntries_;
  }

  AlertSystemDescriptor::MaxTechnicalAlarmListEntriesOptional& AlertSystemDescriptor::
  MaxTechnicalAlarmListEntries ()
  {
    return this->MaxTechnicalAlarmListEntries_;
  }

  void AlertSystemDescriptor::
  MaxTechnicalAlarmListEntries (const MaxTechnicalAlarmListEntriesType& x)
  {
    this->MaxTechnicalAlarmListEntries_.set (x);
  }

  void AlertSystemDescriptor::
  MaxTechnicalAlarmListEntries (const MaxTechnicalAlarmListEntriesOptional& x)
  {
    this->MaxTechnicalAlarmListEntries_ = x;
  }

  const AlertSystemDescriptor::SelfCheckPeriodOptional& AlertSystemDescriptor::
  SelfCheckPeriod () const
  {
    return this->SelfCheckPeriod_;
  }

  AlertSystemDescriptor::SelfCheckPeriodOptional& AlertSystemDescriptor::
  SelfCheckPeriod ()
  {
    return this->SelfCheckPeriod_;
  }

  void AlertSystemDescriptor::
  SelfCheckPeriod (const SelfCheckPeriodType& x)
  {
    this->SelfCheckPeriod_.set (x);
  }

  void AlertSystemDescriptor::
  SelfCheckPeriod (const SelfCheckPeriodOptional& x)
  {
    this->SelfCheckPeriod_ = x;
  }

  void AlertSystemDescriptor::
  SelfCheckPeriod (::std::unique_ptr< SelfCheckPeriodType > x)
  {
    this->SelfCheckPeriod_.set (std::move (x));
  }


  // AlertConditionDescriptor
  // 

  const AlertConditionDescriptor::KindType& AlertConditionDescriptor::
  Kind () const
  {
    return this->Kind_.get ();
  }

  AlertConditionDescriptor::KindType& AlertConditionDescriptor::
  Kind ()
  {
    return this->Kind_.get ();
  }

  void AlertConditionDescriptor::
  Kind (const KindType& x)
  {
    this->Kind_.set (x);
  }

  void AlertConditionDescriptor::
  Kind (::std::unique_ptr< KindType > x)
  {
    this->Kind_.set (std::move (x));
  }

  const AlertConditionDescriptor::SourceSequence& AlertConditionDescriptor::
  Source () const
  {
    return this->Source_;
  }

  AlertConditionDescriptor::SourceSequence& AlertConditionDescriptor::
  Source ()
  {
    return this->Source_;
  }

  void AlertConditionDescriptor::
  Source (const SourceSequence& s)
  {
    this->Source_ = s;
  }

  const AlertConditionDescriptor::PriorityType& AlertConditionDescriptor::
  Priority () const
  {
    return this->Priority_.get ();
  }

  AlertConditionDescriptor::PriorityType& AlertConditionDescriptor::
  Priority ()
  {
    return this->Priority_.get ();
  }

  void AlertConditionDescriptor::
  Priority (const PriorityType& x)
  {
    this->Priority_.set (x);
  }

  void AlertConditionDescriptor::
  Priority (::std::unique_ptr< PriorityType > x)
  {
    this->Priority_.set (std::move (x));
  }

  const AlertConditionDescriptor::CauseInfoSequence& AlertConditionDescriptor::
  CauseInfo () const
  {
    return this->CauseInfo_;
  }

  AlertConditionDescriptor::CauseInfoSequence& AlertConditionDescriptor::
  CauseInfo ()
  {
    return this->CauseInfo_;
  }

  void AlertConditionDescriptor::
  CauseInfo (const CauseInfoSequence& s)
  {
    this->CauseInfo_ = s;
  }


  // AlertSignalDescriptor
  // 

  const AlertSignalDescriptor::ConditionSignaledType& AlertSignalDescriptor::
  ConditionSignaled () const
  {
    return this->ConditionSignaled_.get ();
  }

  AlertSignalDescriptor::ConditionSignaledType& AlertSignalDescriptor::
  ConditionSignaled ()
  {
    return this->ConditionSignaled_.get ();
  }

  void AlertSignalDescriptor::
  ConditionSignaled (const ConditionSignaledType& x)
  {
    this->ConditionSignaled_.set (x);
  }

  void AlertSignalDescriptor::
  ConditionSignaled (::std::unique_ptr< ConditionSignaledType > x)
  {
    this->ConditionSignaled_.set (std::move (x));
  }

  const AlertSignalDescriptor::ManifestationType& AlertSignalDescriptor::
  Manifestation () const
  {
    return this->Manifestation_.get ();
  }

  AlertSignalDescriptor::ManifestationType& AlertSignalDescriptor::
  Manifestation ()
  {
    return this->Manifestation_.get ();
  }

  void AlertSignalDescriptor::
  Manifestation (const ManifestationType& x)
  {
    this->Manifestation_.set (x);
  }

  void AlertSignalDescriptor::
  Manifestation (::std::unique_ptr< ManifestationType > x)
  {
    this->Manifestation_.set (std::move (x));
  }

  const AlertSignalDescriptor::LatchingType& AlertSignalDescriptor::
  Latching () const
  {
    return this->Latching_.get ();
  }

  AlertSignalDescriptor::LatchingType& AlertSignalDescriptor::
  Latching ()
  {
    return this->Latching_.get ();
  }

  void AlertSignalDescriptor::
  Latching (const LatchingType& x)
  {
    this->Latching_.set (x);
  }

  const AlertSignalDescriptor::DefaultSignalGenerationDelayOptional& AlertSignalDescriptor::
  DefaultSignalGenerationDelay () const
  {
    return this->DefaultSignalGenerationDelay_;
  }

  AlertSignalDescriptor::DefaultSignalGenerationDelayOptional& AlertSignalDescriptor::
  DefaultSignalGenerationDelay ()
  {
    return this->DefaultSignalGenerationDelay_;
  }

  void AlertSignalDescriptor::
  DefaultSignalGenerationDelay (const DefaultSignalGenerationDelayType& x)
  {
    this->DefaultSignalGenerationDelay_.set (x);
  }

  void AlertSignalDescriptor::
  DefaultSignalGenerationDelay (const DefaultSignalGenerationDelayOptional& x)
  {
    this->DefaultSignalGenerationDelay_ = x;
  }

  void AlertSignalDescriptor::
  DefaultSignalGenerationDelay (::std::unique_ptr< DefaultSignalGenerationDelayType > x)
  {
    this->DefaultSignalGenerationDelay_.set (std::move (x));
  }

  const AlertSignalDescriptor::SignalDelegationSupportedOptional& AlertSignalDescriptor::
  SignalDelegationSupported () const
  {
    return this->SignalDelegationSupported_;
  }

  AlertSignalDescriptor::SignalDelegationSupportedOptional& AlertSignalDescriptor::
  SignalDelegationSupported ()
  {
    return this->SignalDelegationSupported_;
  }

  void AlertSignalDescriptor::
  SignalDelegationSupported (const SignalDelegationSupportedType& x)
  {
    this->SignalDelegationSupported_.set (x);
  }

  void AlertSignalDescriptor::
  SignalDelegationSupported (const SignalDelegationSupportedOptional& x)
  {
    this->SignalDelegationSupported_ = x;
  }

  AlertSignalDescriptor::SignalDelegationSupportedType AlertSignalDescriptor::
  SignalDelegationSupported_default_value ()
  {
    return SignalDelegationSupportedType (false);
  }

  const AlertSignalDescriptor::AcknowledgementSupportedOptional& AlertSignalDescriptor::
  AcknowledgementSupported () const
  {
    return this->AcknowledgementSupported_;
  }

  AlertSignalDescriptor::AcknowledgementSupportedOptional& AlertSignalDescriptor::
  AcknowledgementSupported ()
  {
    return this->AcknowledgementSupported_;
  }

  void AlertSignalDescriptor::
  AcknowledgementSupported (const AcknowledgementSupportedType& x)
  {
    this->AcknowledgementSupported_.set (x);
  }

  void AlertSignalDescriptor::
  AcknowledgementSupported (const AcknowledgementSupportedOptional& x)
  {
    this->AcknowledgementSupported_ = x;
  }

  const AlertSignalDescriptor::AcknowledgeTimeoutOptional& AlertSignalDescriptor::
  AcknowledgeTimeout () const
  {
    return this->AcknowledgeTimeout_;
  }

  AlertSignalDescriptor::AcknowledgeTimeoutOptional& AlertSignalDescriptor::
  AcknowledgeTimeout ()
  {
    return this->AcknowledgeTimeout_;
  }

  void AlertSignalDescriptor::
  AcknowledgeTimeout (const AcknowledgeTimeoutType& x)
  {
    this->AcknowledgeTimeout_.set (x);
  }

  void AlertSignalDescriptor::
  AcknowledgeTimeout (const AcknowledgeTimeoutOptional& x)
  {
    this->AcknowledgeTimeout_ = x;
  }

  void AlertSignalDescriptor::
  AcknowledgeTimeout (::std::unique_ptr< AcknowledgeTimeoutType > x)
  {
    this->AcknowledgeTimeout_.set (std::move (x));
  }


  // LimitAlertConditionDescriptor
  // 

  const LimitAlertConditionDescriptor::MaxLimitsType& LimitAlertConditionDescriptor::
  MaxLimits () const
  {
    return this->MaxLimits_.get ();
  }

  LimitAlertConditionDescriptor::MaxLimitsType& LimitAlertConditionDescriptor::
  MaxLimits ()
  {
    return this->MaxLimits_.get ();
  }

  void LimitAlertConditionDescriptor::
  MaxLimits (const MaxLimitsType& x)
  {
    this->MaxLimits_.set (x);
  }

  void LimitAlertConditionDescriptor::
  MaxLimits (::std::unique_ptr< MaxLimitsType > x)
  {
    this->MaxLimits_.set (std::move (x));
  }

  const LimitAlertConditionDescriptor::AutoLimitSupportedOptional& LimitAlertConditionDescriptor::
  AutoLimitSupported () const
  {
    return this->AutoLimitSupported_;
  }

  LimitAlertConditionDescriptor::AutoLimitSupportedOptional& LimitAlertConditionDescriptor::
  AutoLimitSupported ()
  {
    return this->AutoLimitSupported_;
  }

  void LimitAlertConditionDescriptor::
  AutoLimitSupported (const AutoLimitSupportedType& x)
  {
    this->AutoLimitSupported_.set (x);
  }

  void LimitAlertConditionDescriptor::
  AutoLimitSupported (const AutoLimitSupportedOptional& x)
  {
    this->AutoLimitSupported_ = x;
  }


  // PausableActivation
  // 

  PausableActivation::
  PausableActivation (Value v)
  : ::xml_schema::String (_xsd_PausableActivation_literals_[v])
  {
  }

  PausableActivation::
  PausableActivation (const char* v)
  : ::xml_schema::String (v)
  {
  }

  PausableActivation::
  PausableActivation (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  PausableActivation::
  PausableActivation (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  PausableActivation::
  PausableActivation (const PausableActivation& v,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  PausableActivation& PausableActivation::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_PausableActivation_literals_[v]);

    return *this;
  }


  // SignalPresence
  // 

  SignalPresence::
  SignalPresence (Value v)
  : ::xml_schema::String (_xsd_SignalPresence_literals_[v])
  {
  }

  SignalPresence::
  SignalPresence (const char* v)
  : ::xml_schema::String (v)
  {
  }

  SignalPresence::
  SignalPresence (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  SignalPresence::
  SignalPresence (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  SignalPresence::
  SignalPresence (const SignalPresence& v,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  SignalPresence& SignalPresence::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_SignalPresence_literals_[v]);

    return *this;
  }


  // PrimaryAlertSignalLocation
  // 

  PrimaryAlertSignalLocation::
  PrimaryAlertSignalLocation (Value v)
  : ::xml_schema::String (_xsd_PrimaryAlertSignalLocation_literals_[v])
  {
  }

  PrimaryAlertSignalLocation::
  PrimaryAlertSignalLocation (const char* v)
  : ::xml_schema::String (v)
  {
  }

  PrimaryAlertSignalLocation::
  PrimaryAlertSignalLocation (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  PrimaryAlertSignalLocation::
  PrimaryAlertSignalLocation (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  PrimaryAlertSignalLocation::
  PrimaryAlertSignalLocation (const PrimaryAlertSignalLocation& v,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  PrimaryAlertSignalLocation& PrimaryAlertSignalLocation::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_PrimaryAlertSignalLocation_literals_[v]);

    return *this;
  }


  // MonitoredAlertLimits
  // 

  MonitoredAlertLimits::
  MonitoredAlertLimits (Value v)
  : ::xml_schema::String (_xsd_MonitoredAlertLimits_literals_[v])
  {
  }

  MonitoredAlertLimits::
  MonitoredAlertLimits (const char* v)
  : ::xml_schema::String (v)
  {
  }

  MonitoredAlertLimits::
  MonitoredAlertLimits (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  MonitoredAlertLimits::
  MonitoredAlertLimits (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  MonitoredAlertLimits::
  MonitoredAlertLimits (const MonitoredAlertLimits& v,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  MonitoredAlertLimits& MonitoredAlertLimits::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_MonitoredAlertLimits_literals_[v]);

    return *this;
  }


  // AbstractAlertState
  // 


  // AlertConditionState
  // 

  const AlertConditionState::ActivationStateType& AlertConditionState::
  ActivationState () const
  {
    return this->ActivationState_.get ();
  }

  AlertConditionState::ActivationStateType& AlertConditionState::
  ActivationState ()
  {
    return this->ActivationState_.get ();
  }

  void AlertConditionState::
  ActivationState (const ActivationStateType& x)
  {
    this->ActivationState_.set (x);
  }

  void AlertConditionState::
  ActivationState (::std::unique_ptr< ActivationStateType > x)
  {
    this->ActivationState_.set (std::move (x));
  }

  const AlertConditionState::ActualPriorityOptional& AlertConditionState::
  ActualPriority () const
  {
    return this->ActualPriority_;
  }

  AlertConditionState::ActualPriorityOptional& AlertConditionState::
  ActualPriority ()
  {
    return this->ActualPriority_;
  }

  void AlertConditionState::
  ActualPriority (const ActualPriorityType& x)
  {
    this->ActualPriority_.set (x);
  }

  void AlertConditionState::
  ActualPriority (const ActualPriorityOptional& x)
  {
    this->ActualPriority_ = x;
  }

  void AlertConditionState::
  ActualPriority (::std::unique_ptr< ActualPriorityType > x)
  {
    this->ActualPriority_.set (std::move (x));
  }

  const AlertConditionState::RankOptional& AlertConditionState::
  Rank () const
  {
    return this->Rank_;
  }

  AlertConditionState::RankOptional& AlertConditionState::
  Rank ()
  {
    return this->Rank_;
  }

  void AlertConditionState::
  Rank (const RankType& x)
  {
    this->Rank_.set (x);
  }

  void AlertConditionState::
  Rank (const RankOptional& x)
  {
    this->Rank_ = x;
  }

  const AlertConditionState::PresenceType& AlertConditionState::
  Presence () const
  {
    return this->Presence_.get ();
  }

  AlertConditionState::PresenceType& AlertConditionState::
  Presence ()
  {
    return this->Presence_.get ();
  }

  void AlertConditionState::
  Presence (const PresenceType& x)
  {
    this->Presence_.set (x);
  }

  const AlertConditionState::ObservationTimeOptional& AlertConditionState::
  ObservationTime () const
  {
    return this->ObservationTime_;
  }

  AlertConditionState::ObservationTimeOptional& AlertConditionState::
  ObservationTime ()
  {
    return this->ObservationTime_;
  }

  void AlertConditionState::
  ObservationTime (const ObservationTimeType& x)
  {
    this->ObservationTime_.set (x);
  }

  void AlertConditionState::
  ObservationTime (const ObservationTimeOptional& x)
  {
    this->ObservationTime_ = x;
  }

  void AlertConditionState::
  ObservationTime (::std::unique_ptr< ObservationTimeType > x)
  {
    this->ObservationTime_.set (std::move (x));
  }


  // AlertSignalState
  // 

  const AlertSignalState::ActivationStateType& AlertSignalState::
  ActivationState () const
  {
    return this->ActivationState_.get ();
  }

  AlertSignalState::ActivationStateType& AlertSignalState::
  ActivationState ()
  {
    return this->ActivationState_.get ();
  }

  void AlertSignalState::
  ActivationState (const ActivationStateType& x)
  {
    this->ActivationState_.set (x);
  }

  void AlertSignalState::
  ActivationState (::std::unique_ptr< ActivationStateType > x)
  {
    this->ActivationState_.set (std::move (x));
  }

  const AlertSignalState::PresenceOptional& AlertSignalState::
  Presence () const
  {
    return this->Presence_;
  }

  AlertSignalState::PresenceOptional& AlertSignalState::
  Presence ()
  {
    return this->Presence_;
  }

  void AlertSignalState::
  Presence (const PresenceType& x)
  {
    this->Presence_.set (x);
  }

  void AlertSignalState::
  Presence (const PresenceOptional& x)
  {
    this->Presence_ = x;
  }

  void AlertSignalState::
  Presence (::std::unique_ptr< PresenceType > x)
  {
    this->Presence_.set (std::move (x));
  }

  const AlertSignalState::LocationOptional& AlertSignalState::
  Location () const
  {
    return this->Location_;
  }

  AlertSignalState::LocationOptional& AlertSignalState::
  Location ()
  {
    return this->Location_;
  }

  void AlertSignalState::
  Location (const LocationType& x)
  {
    this->Location_.set (x);
  }

  void AlertSignalState::
  Location (const LocationOptional& x)
  {
    this->Location_ = x;
  }

  void AlertSignalState::
  Location (::std::unique_ptr< LocationType > x)
  {
    this->Location_.set (std::move (x));
  }

  const AlertSignalState::SlotOptional& AlertSignalState::
  Slot () const
  {
    return this->Slot_;
  }

  AlertSignalState::SlotOptional& AlertSignalState::
  Slot ()
  {
    return this->Slot_;
  }

  void AlertSignalState::
  Slot (const SlotType& x)
  {
    this->Slot_.set (x);
  }

  void AlertSignalState::
  Slot (const SlotOptional& x)
  {
    this->Slot_ = x;
  }


  // AlertSystemState
  // 

  const AlertSystemState::ActivationStateType& AlertSystemState::
  ActivationState () const
  {
    return this->ActivationState_.get ();
  }

  AlertSystemState::ActivationStateType& AlertSystemState::
  ActivationState ()
  {
    return this->ActivationState_.get ();
  }

  void AlertSystemState::
  ActivationState (const ActivationStateType& x)
  {
    this->ActivationState_.set (x);
  }

  void AlertSystemState::
  ActivationState (::std::unique_ptr< ActivationStateType > x)
  {
    this->ActivationState_.set (std::move (x));
  }

  const AlertSystemState::LastSelfCheckOptional& AlertSystemState::
  LastSelfCheck () const
  {
    return this->LastSelfCheck_;
  }

  AlertSystemState::LastSelfCheckOptional& AlertSystemState::
  LastSelfCheck ()
  {
    return this->LastSelfCheck_;
  }

  void AlertSystemState::
  LastSelfCheck (const LastSelfCheckType& x)
  {
    this->LastSelfCheck_.set (x);
  }

  void AlertSystemState::
  LastSelfCheck (const LastSelfCheckOptional& x)
  {
    this->LastSelfCheck_ = x;
  }

  void AlertSystemState::
  LastSelfCheck (::std::unique_ptr< LastSelfCheckType > x)
  {
    this->LastSelfCheck_.set (std::move (x));
  }

  const AlertSystemState::SelfCheckCountOptional& AlertSystemState::
  SelfCheckCount () const
  {
    return this->SelfCheckCount_;
  }

  AlertSystemState::SelfCheckCountOptional& AlertSystemState::
  SelfCheckCount ()
  {
    return this->SelfCheckCount_;
  }

  void AlertSystemState::
  SelfCheckCount (const SelfCheckCountType& x)
  {
    this->SelfCheckCount_.set (x);
  }

  void AlertSystemState::
  SelfCheckCount (const SelfCheckCountOptional& x)
  {
    this->SelfCheckCount_ = x;
  }

  const AlertSystemState::PresentPhysiologicalAlarmConditionsOptional& AlertSystemState::
  PresentPhysiologicalAlarmConditions () const
  {
    return this->PresentPhysiologicalAlarmConditions_;
  }

  AlertSystemState::PresentPhysiologicalAlarmConditionsOptional& AlertSystemState::
  PresentPhysiologicalAlarmConditions ()
  {
    return this->PresentPhysiologicalAlarmConditions_;
  }

  void AlertSystemState::
  PresentPhysiologicalAlarmConditions (const PresentPhysiologicalAlarmConditionsType& x)
  {
    this->PresentPhysiologicalAlarmConditions_.set (x);
  }

  void AlertSystemState::
  PresentPhysiologicalAlarmConditions (const PresentPhysiologicalAlarmConditionsOptional& x)
  {
    this->PresentPhysiologicalAlarmConditions_ = x;
  }

  void AlertSystemState::
  PresentPhysiologicalAlarmConditions (::std::unique_ptr< PresentPhysiologicalAlarmConditionsType > x)
  {
    this->PresentPhysiologicalAlarmConditions_.set (std::move (x));
  }

  const AlertSystemState::PresentTechnicalAlarmConditionsOptional& AlertSystemState::
  PresentTechnicalAlarmConditions () const
  {
    return this->PresentTechnicalAlarmConditions_;
  }

  AlertSystemState::PresentTechnicalAlarmConditionsOptional& AlertSystemState::
  PresentTechnicalAlarmConditions ()
  {
    return this->PresentTechnicalAlarmConditions_;
  }

  void AlertSystemState::
  PresentTechnicalAlarmConditions (const PresentTechnicalAlarmConditionsType& x)
  {
    this->PresentTechnicalAlarmConditions_.set (x);
  }

  void AlertSystemState::
  PresentTechnicalAlarmConditions (const PresentTechnicalAlarmConditionsOptional& x)
  {
    this->PresentTechnicalAlarmConditions_ = x;
  }

  void AlertSystemState::
  PresentTechnicalAlarmConditions (::std::unique_ptr< PresentTechnicalAlarmConditionsType > x)
  {
    this->PresentTechnicalAlarmConditions_.set (std::move (x));
  }


  // AlertConditionReference
  //

  AlertConditionReference::
  AlertConditionReference ()
  : ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (this)
  {
  }

  AlertConditionReference::
  AlertConditionReference (size_type n, const ::CDM::HandleRef& x)
  : ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (n, x, this)
  {
  }

  AlertConditionReference::
  AlertConditionReference (const AlertConditionReference& o,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (o, f, c),
    ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (o, f, this)
  {
  }

  // LimitAlertConditionState
  // 

  const LimitAlertConditionState::LimitsOptional& LimitAlertConditionState::
  Limits () const
  {
    return this->Limits_;
  }

  LimitAlertConditionState::LimitsOptional& LimitAlertConditionState::
  Limits ()
  {
    return this->Limits_;
  }

  void LimitAlertConditionState::
  Limits (const LimitsType& x)
  {
    this->Limits_.set (x);
  }

  void LimitAlertConditionState::
  Limits (const LimitsOptional& x)
  {
    this->Limits_ = x;
  }

  void LimitAlertConditionState::
  Limits (::std::unique_ptr< LimitsType > x)
  {
    this->Limits_.set (std::move (x));
  }

  const LimitAlertConditionState::MonitoredAlertLimitsType& LimitAlertConditionState::
  MonitoredAlertLimits () const
  {
    return this->MonitoredAlertLimits_.get ();
  }

  LimitAlertConditionState::MonitoredAlertLimitsType& LimitAlertConditionState::
  MonitoredAlertLimits ()
  {
    return this->MonitoredAlertLimits_.get ();
  }

  void LimitAlertConditionState::
  MonitoredAlertLimits (const MonitoredAlertLimitsType& x)
  {
    this->MonitoredAlertLimits_.set (x);
  }

  void LimitAlertConditionState::
  MonitoredAlertLimits (::std::unique_ptr< MonitoredAlertLimitsType > x)
  {
    this->MonitoredAlertLimits_.set (std::move (x));
  }

  const LimitAlertConditionState::AutoLimitActivationStateOptional& LimitAlertConditionState::
  AutoLimitActivationState () const
  {
    return this->AutoLimitActivationState_;
  }

  LimitAlertConditionState::AutoLimitActivationStateOptional& LimitAlertConditionState::
  AutoLimitActivationState ()
  {
    return this->AutoLimitActivationState_;
  }

  void LimitAlertConditionState::
  AutoLimitActivationState (const AutoLimitActivationStateType& x)
  {
    this->AutoLimitActivationState_.set (x);
  }

  void LimitAlertConditionState::
  AutoLimitActivationState (const AutoLimitActivationStateOptional& x)
  {
    this->AutoLimitActivationState_ = x;
  }

  void LimitAlertConditionState::
  AutoLimitActivationState (::std::unique_ptr< AutoLimitActivationStateType > x)
  {
    this->AutoLimitActivationState_.set (std::move (x));
  }


  // MetricCategory
  // 

  MetricCategory::
  MetricCategory (Value v)
  : ::xml_schema::String (_xsd_MetricCategory_literals_[v])
  {
  }

  MetricCategory::
  MetricCategory (const char* v)
  : ::xml_schema::String (v)
  {
  }

  MetricCategory::
  MetricCategory (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  MetricCategory::
  MetricCategory (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  MetricCategory::
  MetricCategory (const MetricCategory& v,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  MetricCategory& MetricCategory::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_MetricCategory_literals_[v]);

    return *this;
  }


  // MetricAvailability
  // 

  MetricAvailability::
  MetricAvailability (Value v)
  : ::xml_schema::String (_xsd_MetricAvailability_literals_[v])
  {
  }

  MetricAvailability::
  MetricAvailability (const char* v)
  : ::xml_schema::String (v)
  {
  }

  MetricAvailability::
  MetricAvailability (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  MetricAvailability::
  MetricAvailability (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  MetricAvailability::
  MetricAvailability (const MetricAvailability& v,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  MetricAvailability& MetricAvailability::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_MetricAvailability_literals_[v]);

    return *this;
  }


  // VMDDescriptor
  // 

  const VMDDescriptor::ChannelSequence& VMDDescriptor::
  Channel () const
  {
    return this->Channel_;
  }

  VMDDescriptor::ChannelSequence& VMDDescriptor::
  Channel ()
  {
    return this->Channel_;
  }

  void VMDDescriptor::
  Channel (const ChannelSequence& s)
  {
    this->Channel_ = s;
  }

  const VMDDescriptor::AlertSystemOptional& VMDDescriptor::
  AlertSystem () const
  {
    return this->AlertSystem_;
  }

  VMDDescriptor::AlertSystemOptional& VMDDescriptor::
  AlertSystem ()
  {
    return this->AlertSystem_;
  }

  void VMDDescriptor::
  AlertSystem (const AlertSystemType& x)
  {
    this->AlertSystem_.set (x);
  }

  void VMDDescriptor::
  AlertSystem (const AlertSystemOptional& x)
  {
    this->AlertSystem_ = x;
  }

  void VMDDescriptor::
  AlertSystem (::std::unique_ptr< AlertSystemType > x)
  {
    this->AlertSystem_.set (std::move (x));
  }


  // ChannelDescriptor
  // 

  const ChannelDescriptor::MetricSequence& ChannelDescriptor::
  Metric () const
  {
    return this->Metric_;
  }

  ChannelDescriptor::MetricSequence& ChannelDescriptor::
  Metric ()
  {
    return this->Metric_;
  }

  void ChannelDescriptor::
  Metric (const MetricSequence& s)
  {
    this->Metric_ = s;
  }

  const ChannelDescriptor::AlertSystemOptional& ChannelDescriptor::
  AlertSystem () const
  {
    return this->AlertSystem_;
  }

  ChannelDescriptor::AlertSystemOptional& ChannelDescriptor::
  AlertSystem ()
  {
    return this->AlertSystem_;
  }

  void ChannelDescriptor::
  AlertSystem (const AlertSystemType& x)
  {
    this->AlertSystem_.set (x);
  }

  void ChannelDescriptor::
  AlertSystem (const AlertSystemOptional& x)
  {
    this->AlertSystem_ = x;
  }

  void ChannelDescriptor::
  AlertSystem (::std::unique_ptr< AlertSystemType > x)
  {
    this->AlertSystem_.set (std::move (x));
  }


  // AbstractMetricDescriptor
  // 

  const AbstractMetricDescriptor::UnitType& AbstractMetricDescriptor::
  Unit () const
  {
    return this->Unit_.get ();
  }

  AbstractMetricDescriptor::UnitType& AbstractMetricDescriptor::
  Unit ()
  {
    return this->Unit_.get ();
  }

  void AbstractMetricDescriptor::
  Unit (const UnitType& x)
  {
    this->Unit_.set (x);
  }

  void AbstractMetricDescriptor::
  Unit (::std::unique_ptr< UnitType > x)
  {
    this->Unit_.set (std::move (x));
  }

  const AbstractMetricDescriptor::BodySiteSequence& AbstractMetricDescriptor::
  BodySite () const
  {
    return this->BodySite_;
  }

  AbstractMetricDescriptor::BodySiteSequence& AbstractMetricDescriptor::
  BodySite ()
  {
    return this->BodySite_;
  }

  void AbstractMetricDescriptor::
  BodySite (const BodySiteSequence& s)
  {
    this->BodySite_ = s;
  }

  const AbstractMetricDescriptor::MetricCategoryType& AbstractMetricDescriptor::
  MetricCategory () const
  {
    return this->MetricCategory_.get ();
  }

  AbstractMetricDescriptor::MetricCategoryType& AbstractMetricDescriptor::
  MetricCategory ()
  {
    return this->MetricCategory_.get ();
  }

  void AbstractMetricDescriptor::
  MetricCategory (const MetricCategoryType& x)
  {
    this->MetricCategory_.set (x);
  }

  void AbstractMetricDescriptor::
  MetricCategory (::std::unique_ptr< MetricCategoryType > x)
  {
    this->MetricCategory_.set (std::move (x));
  }

  const AbstractMetricDescriptor::AvailabilityType& AbstractMetricDescriptor::
  Availability () const
  {
    return this->Availability_.get ();
  }

  AbstractMetricDescriptor::AvailabilityType& AbstractMetricDescriptor::
  Availability ()
  {
    return this->Availability_.get ();
  }

  void AbstractMetricDescriptor::
  Availability (const AvailabilityType& x)
  {
    this->Availability_.set (x);
  }

  void AbstractMetricDescriptor::
  Availability (::std::unique_ptr< AvailabilityType > x)
  {
    this->Availability_.set (std::move (x));
  }

  const AbstractMetricDescriptor::MaxDelayTimeOptional& AbstractMetricDescriptor::
  MaxDelayTime () const
  {
    return this->MaxDelayTime_;
  }

  AbstractMetricDescriptor::MaxDelayTimeOptional& AbstractMetricDescriptor::
  MaxDelayTime ()
  {
    return this->MaxDelayTime_;
  }

  void AbstractMetricDescriptor::
  MaxDelayTime (const MaxDelayTimeType& x)
  {
    this->MaxDelayTime_.set (x);
  }

  void AbstractMetricDescriptor::
  MaxDelayTime (const MaxDelayTimeOptional& x)
  {
    this->MaxDelayTime_ = x;
  }

  void AbstractMetricDescriptor::
  MaxDelayTime (::std::unique_ptr< MaxDelayTimeType > x)
  {
    this->MaxDelayTime_.set (std::move (x));
  }


  // NumericMetricDescriptor
  // 

  const NumericMetricDescriptor::ResolutionType& NumericMetricDescriptor::
  Resolution () const
  {
    return this->Resolution_.get ();
  }

  NumericMetricDescriptor::ResolutionType& NumericMetricDescriptor::
  Resolution ()
  {
    return this->Resolution_.get ();
  }

  void NumericMetricDescriptor::
  Resolution (const ResolutionType& x)
  {
    this->Resolution_.set (x);
  }

  const NumericMetricDescriptor::MeasurePeriodOptional& NumericMetricDescriptor::
  MeasurePeriod () const
  {
    return this->MeasurePeriod_;
  }

  NumericMetricDescriptor::MeasurePeriodOptional& NumericMetricDescriptor::
  MeasurePeriod ()
  {
    return this->MeasurePeriod_;
  }

  void NumericMetricDescriptor::
  MeasurePeriod (const MeasurePeriodType& x)
  {
    this->MeasurePeriod_.set (x);
  }

  void NumericMetricDescriptor::
  MeasurePeriod (const MeasurePeriodOptional& x)
  {
    this->MeasurePeriod_ = x;
  }

  void NumericMetricDescriptor::
  MeasurePeriod (::std::unique_ptr< MeasurePeriodType > x)
  {
    this->MeasurePeriod_.set (std::move (x));
  }

  const NumericMetricDescriptor::AveragingPeriodOptional& NumericMetricDescriptor::
  AveragingPeriod () const
  {
    return this->AveragingPeriod_;
  }

  NumericMetricDescriptor::AveragingPeriodOptional& NumericMetricDescriptor::
  AveragingPeriod ()
  {
    return this->AveragingPeriod_;
  }

  void NumericMetricDescriptor::
  AveragingPeriod (const AveragingPeriodType& x)
  {
    this->AveragingPeriod_.set (x);
  }

  void NumericMetricDescriptor::
  AveragingPeriod (const AveragingPeriodOptional& x)
  {
    this->AveragingPeriod_ = x;
  }

  void NumericMetricDescriptor::
  AveragingPeriod (::std::unique_ptr< AveragingPeriodType > x)
  {
    this->AveragingPeriod_.set (std::move (x));
  }

  const NumericMetricDescriptor::TechnicalRangeSequence& NumericMetricDescriptor::
  TechnicalRange () const
  {
    return this->TechnicalRange_;
  }

  NumericMetricDescriptor::TechnicalRangeSequence& NumericMetricDescriptor::
  TechnicalRange ()
  {
    return this->TechnicalRange_;
  }

  void NumericMetricDescriptor::
  TechnicalRange (const TechnicalRangeSequence& s)
  {
    this->TechnicalRange_ = s;
  }


  // StringMetricDescriptor
  // 


  // EnumNomenRef
  // 

  const EnumNomenRef::ExtensionOptional& EnumNomenRef::
  Extension () const
  {
    return this->Extension_;
  }

  EnumNomenRef::ExtensionOptional& EnumNomenRef::
  Extension ()
  {
    return this->Extension_;
  }

  void EnumNomenRef::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void EnumNomenRef::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void EnumNomenRef::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const EnumNomenRef::CodeType& EnumNomenRef::
  Code () const
  {
    return this->Code_.get ();
  }

  EnumNomenRef::CodeType& EnumNomenRef::
  Code ()
  {
    return this->Code_.get ();
  }

  void EnumNomenRef::
  Code (const CodeType& x)
  {
    this->Code_.set (x);
  }

  void EnumNomenRef::
  Code (::std::unique_ptr< CodeType > x)
  {
    this->Code_.set (std::move (x));
  }

  const EnumNomenRef::EnumIndexOptional& EnumNomenRef::
  EnumIndex () const
  {
    return this->EnumIndex_;
  }

  EnumNomenRef::EnumIndexOptional& EnumNomenRef::
  EnumIndex ()
  {
    return this->EnumIndex_;
  }

  void EnumNomenRef::
  EnumIndex (const EnumIndexType& x)
  {
    this->EnumIndex_.set (x);
  }

  void EnumNomenRef::
  EnumIndex (const EnumIndexOptional& x)
  {
    this->EnumIndex_ = x;
  }

  void EnumNomenRef::
  EnumIndex (::std::unique_ptr< EnumIndexType > x)
  {
    this->EnumIndex_.set (std::move (x));
  }


  // EnumStringMetricDescriptor
  // 

  const EnumStringMetricDescriptor::AllowedValueSequence& EnumStringMetricDescriptor::
  AllowedValue () const
  {
    return this->AllowedValue_;
  }

  EnumStringMetricDescriptor::AllowedValueSequence& EnumStringMetricDescriptor::
  AllowedValue ()
  {
    return this->AllowedValue_;
  }

  void EnumStringMetricDescriptor::
  AllowedValue (const AllowedValueSequence& s)
  {
    this->AllowedValue_ = s;
  }

  const EnumStringMetricDescriptor::EnumCodesSequence& EnumStringMetricDescriptor::
  EnumCodes () const
  {
    return this->EnumCodes_;
  }

  EnumStringMetricDescriptor::EnumCodesSequence& EnumStringMetricDescriptor::
  EnumCodes ()
  {
    return this->EnumCodes_;
  }

  void EnumStringMetricDescriptor::
  EnumCodes (const EnumCodesSequence& s)
  {
    this->EnumCodes_ = s;
  }


  // RealTimeSampleArrayMetricDescriptor
  // 

  const RealTimeSampleArrayMetricDescriptor::SamplePeriodType& RealTimeSampleArrayMetricDescriptor::
  SamplePeriod () const
  {
    return this->SamplePeriod_.get ();
  }

  RealTimeSampleArrayMetricDescriptor::SamplePeriodType& RealTimeSampleArrayMetricDescriptor::
  SamplePeriod ()
  {
    return this->SamplePeriod_.get ();
  }

  void RealTimeSampleArrayMetricDescriptor::
  SamplePeriod (const SamplePeriodType& x)
  {
    this->SamplePeriod_.set (x);
  }

  void RealTimeSampleArrayMetricDescriptor::
  SamplePeriod (::std::unique_ptr< SamplePeriodType > x)
  {
    this->SamplePeriod_.set (std::move (x));
  }

  const RealTimeSampleArrayMetricDescriptor::ResolutionType& RealTimeSampleArrayMetricDescriptor::
  Resolution () const
  {
    return this->Resolution_.get ();
  }

  RealTimeSampleArrayMetricDescriptor::ResolutionType& RealTimeSampleArrayMetricDescriptor::
  Resolution ()
  {
    return this->Resolution_.get ();
  }

  void RealTimeSampleArrayMetricDescriptor::
  Resolution (const ResolutionType& x)
  {
    this->Resolution_.set (x);
  }

  const RealTimeSampleArrayMetricDescriptor::TechnicalRangeSequence& RealTimeSampleArrayMetricDescriptor::
  TechnicalRange () const
  {
    return this->TechnicalRange_;
  }

  RealTimeSampleArrayMetricDescriptor::TechnicalRangeSequence& RealTimeSampleArrayMetricDescriptor::
  TechnicalRange ()
  {
    return this->TechnicalRange_;
  }

  void RealTimeSampleArrayMetricDescriptor::
  TechnicalRange (const TechnicalRangeSequence& s)
  {
    this->TechnicalRange_ = s;
  }


  // CalibrationState
  // 

  CalibrationState::
  CalibrationState (Value v)
  : ::xml_schema::String (_xsd_CalibrationState_literals_[v])
  {
  }

  CalibrationState::
  CalibrationState (const char* v)
  : ::xml_schema::String (v)
  {
  }

  CalibrationState::
  CalibrationState (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  CalibrationState::
  CalibrationState (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  CalibrationState::
  CalibrationState (const CalibrationState& v,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  CalibrationState& CalibrationState::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_CalibrationState_literals_[v]);

    return *this;
  }


  // ComponentActivation
  // 

  ComponentActivation::
  ComponentActivation (Value v)
  : ::xml_schema::String (_xsd_ComponentActivation_literals_[v])
  {
  }

  ComponentActivation::
  ComponentActivation (const char* v)
  : ::xml_schema::String (v)
  {
  }

  ComponentActivation::
  ComponentActivation (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  ComponentActivation::
  ComponentActivation (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  ComponentActivation::
  ComponentActivation (const ComponentActivation& v,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  ComponentActivation& ComponentActivation::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_ComponentActivation_literals_[v]);

    return *this;
  }


  // MetricMeasurementValidity
  // 

  MetricMeasurementValidity::
  MetricMeasurementValidity (Value v)
  : ::xml_schema::String (_xsd_MetricMeasurementValidity_literals_[v])
  {
  }

  MetricMeasurementValidity::
  MetricMeasurementValidity (const char* v)
  : ::xml_schema::String (v)
  {
  }

  MetricMeasurementValidity::
  MetricMeasurementValidity (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  MetricMeasurementValidity::
  MetricMeasurementValidity (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  MetricMeasurementValidity::
  MetricMeasurementValidity (const MetricMeasurementValidity& v,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  MetricMeasurementValidity& MetricMeasurementValidity::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_MetricMeasurementValidity_literals_[v]);

    return *this;
  }


  // GenerationMode
  // 

  GenerationMode::
  GenerationMode (Value v)
  : ::xml_schema::String (_xsd_GenerationMode_literals_[v])
  {
  }

  GenerationMode::
  GenerationMode (const char* v)
  : ::xml_schema::String (v)
  {
  }

  GenerationMode::
  GenerationMode (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  GenerationMode::
  GenerationMode (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  GenerationMode::
  GenerationMode (const GenerationMode& v,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  GenerationMode& GenerationMode::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_GenerationMode_literals_[v]);

    return *this;
  }


  // CalibrationInfo
  // 

  const CalibrationInfo::ExtensionOptional& CalibrationInfo::
  Extension () const
  {
    return this->Extension_;
  }

  CalibrationInfo::ExtensionOptional& CalibrationInfo::
  Extension ()
  {
    return this->Extension_;
  }

  void CalibrationInfo::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void CalibrationInfo::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void CalibrationInfo::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const CalibrationInfo::ComponentCalibrationStateOptional& CalibrationInfo::
  ComponentCalibrationState () const
  {
    return this->ComponentCalibrationState_;
  }

  CalibrationInfo::ComponentCalibrationStateOptional& CalibrationInfo::
  ComponentCalibrationState ()
  {
    return this->ComponentCalibrationState_;
  }

  void CalibrationInfo::
  ComponentCalibrationState (const ComponentCalibrationStateType& x)
  {
    this->ComponentCalibrationState_.set (x);
  }

  void CalibrationInfo::
  ComponentCalibrationState (const ComponentCalibrationStateOptional& x)
  {
    this->ComponentCalibrationState_ = x;
  }

  void CalibrationInfo::
  ComponentCalibrationState (::std::unique_ptr< ComponentCalibrationStateType > x)
  {
    this->ComponentCalibrationState_.set (std::move (x));
  }


  // AbstractMetricState
  // 

  const AbstractMetricState::MeasurementPeriodOptional& AbstractMetricState::
  MeasurementPeriod () const
  {
    return this->MeasurementPeriod_;
  }

  AbstractMetricState::MeasurementPeriodOptional& AbstractMetricState::
  MeasurementPeriod ()
  {
    return this->MeasurementPeriod_;
  }

  void AbstractMetricState::
  MeasurementPeriod (const MeasurementPeriodType& x)
  {
    this->MeasurementPeriod_.set (x);
  }

  void AbstractMetricState::
  MeasurementPeriod (const MeasurementPeriodOptional& x)
  {
    this->MeasurementPeriod_ = x;
  }

  void AbstractMetricState::
  MeasurementPeriod (::std::unique_ptr< MeasurementPeriodType > x)
  {
    this->MeasurementPeriod_.set (std::move (x));
  }

  const AbstractMetricState::AveragingPeriodOptional& AbstractMetricState::
  AveragingPeriod () const
  {
    return this->AveragingPeriod_;
  }

  AbstractMetricState::AveragingPeriodOptional& AbstractMetricState::
  AveragingPeriod ()
  {
    return this->AveragingPeriod_;
  }

  void AbstractMetricState::
  AveragingPeriod (const AveragingPeriodType& x)
  {
    this->AveragingPeriod_.set (x);
  }

  void AbstractMetricState::
  AveragingPeriod (const AveragingPeriodOptional& x)
  {
    this->AveragingPeriod_ = x;
  }

  void AbstractMetricState::
  AveragingPeriod (::std::unique_ptr< AveragingPeriodType > x)
  {
    this->AveragingPeriod_.set (std::move (x));
  }

  const AbstractMetricState::BodySiteSequence& AbstractMetricState::
  BodySite () const
  {
    return this->BodySite_;
  }

  AbstractMetricState::BodySiteSequence& AbstractMetricState::
  BodySite ()
  {
    return this->BodySite_;
  }

  void AbstractMetricState::
  BodySite (const BodySiteSequence& s)
  {
    this->BodySite_ = s;
  }


  // NumericMetricState
  // 

  const NumericMetricState::ObservedValueOptional& NumericMetricState::
  ObservedValue () const
  {
    return this->ObservedValue_;
  }

  NumericMetricState::ObservedValueOptional& NumericMetricState::
  ObservedValue ()
  {
    return this->ObservedValue_;
  }

  void NumericMetricState::
  ObservedValue (const ObservedValueType& x)
  {
    this->ObservedValue_.set (x);
  }

  void NumericMetricState::
  ObservedValue (const ObservedValueOptional& x)
  {
    this->ObservedValue_ = x;
  }

  void NumericMetricState::
  ObservedValue (::std::unique_ptr< ObservedValueType > x)
  {
    this->ObservedValue_.set (std::move (x));
  }

  const NumericMetricState::PhysiologicalRangeSequence& NumericMetricState::
  PhysiologicalRange () const
  {
    return this->PhysiologicalRange_;
  }

  NumericMetricState::PhysiologicalRangeSequence& NumericMetricState::
  PhysiologicalRange ()
  {
    return this->PhysiologicalRange_;
  }

  void NumericMetricState::
  PhysiologicalRange (const PhysiologicalRangeSequence& s)
  {
    this->PhysiologicalRange_ = s;
  }


  // RealTimeSampleArrayMetricState
  // 

  const RealTimeSampleArrayMetricState::ObservedValueOptional& RealTimeSampleArrayMetricState::
  ObservedValue () const
  {
    return this->ObservedValue_;
  }

  RealTimeSampleArrayMetricState::ObservedValueOptional& RealTimeSampleArrayMetricState::
  ObservedValue ()
  {
    return this->ObservedValue_;
  }

  void RealTimeSampleArrayMetricState::
  ObservedValue (const ObservedValueType& x)
  {
    this->ObservedValue_.set (x);
  }

  void RealTimeSampleArrayMetricState::
  ObservedValue (const ObservedValueOptional& x)
  {
    this->ObservedValue_ = x;
  }

  void RealTimeSampleArrayMetricState::
  ObservedValue (::std::unique_ptr< ObservedValueType > x)
  {
    this->ObservedValue_.set (std::move (x));
  }


  // StringMetricState
  // 

  const StringMetricState::ObservedValueOptional& StringMetricState::
  ObservedValue () const
  {
    return this->ObservedValue_;
  }

  StringMetricState::ObservedValueOptional& StringMetricState::
  ObservedValue ()
  {
    return this->ObservedValue_;
  }

  void StringMetricState::
  ObservedValue (const ObservedValueType& x)
  {
    this->ObservedValue_.set (x);
  }

  void StringMetricState::
  ObservedValue (const ObservedValueOptional& x)
  {
    this->ObservedValue_ = x;
  }

  void StringMetricState::
  ObservedValue (::std::unique_ptr< ObservedValueType > x)
  {
    this->ObservedValue_.set (std::move (x));
  }


  // EnumStringMetricState
  // 


  // QualityIndicator
  // 


  // MeasurementState
  // 

  const MeasurementState::ExtensionOptional& MeasurementState::
  Extension () const
  {
    return this->Extension_;
  }

  MeasurementState::ExtensionOptional& MeasurementState::
  Extension ()
  {
    return this->Extension_;
  }

  void MeasurementState::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void MeasurementState::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void MeasurementState::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const MeasurementState::ValidityType& MeasurementState::
  Validity () const
  {
    return this->Validity_.get ();
  }

  MeasurementState::ValidityType& MeasurementState::
  Validity ()
  {
    return this->Validity_.get ();
  }

  void MeasurementState::
  Validity (const ValidityType& x)
  {
    this->Validity_.set (x);
  }

  void MeasurementState::
  Validity (::std::unique_ptr< ValidityType > x)
  {
    this->Validity_.set (std::move (x));
  }

  const MeasurementState::ModeOptional& MeasurementState::
  Mode () const
  {
    return this->Mode_;
  }

  MeasurementState::ModeOptional& MeasurementState::
  Mode ()
  {
    return this->Mode_;
  }

  void MeasurementState::
  Mode (const ModeType& x)
  {
    this->Mode_.set (x);
  }

  void MeasurementState::
  Mode (const ModeOptional& x)
  {
    this->Mode_ = x;
  }

  void MeasurementState::
  Mode (::std::unique_ptr< ModeType > x)
  {
    this->Mode_.set (std::move (x));
  }

  const MeasurementState::QIOptional& MeasurementState::
  QI () const
  {
    return this->QI_;
  }

  MeasurementState::QIOptional& MeasurementState::
  QI ()
  {
    return this->QI_;
  }

  void MeasurementState::
  QI (const QIType& x)
  {
    this->QI_.set (x);
  }

  void MeasurementState::
  QI (const QIOptional& x)
  {
    this->QI_ = x;
  }

  void MeasurementState::
  QI (::std::unique_ptr< QIType > x)
  {
    this->QI_.set (std::move (x));
  }


  // SampleIndex
  // 


  // Annotation
  // 

  const Annotation::ExtensionOptional& Annotation::
  Extension () const
  {
    return this->Extension_;
  }

  Annotation::ExtensionOptional& Annotation::
  Extension ()
  {
    return this->Extension_;
  }

  void Annotation::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void Annotation::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void Annotation::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const Annotation::CodeType& Annotation::
  Code () const
  {
    return this->Code_.get ();
  }

  Annotation::CodeType& Annotation::
  Code ()
  {
    return this->Code_.get ();
  }

  void Annotation::
  Code (const CodeType& x)
  {
    this->Code_.set (x);
  }

  void Annotation::
  Code (::std::unique_ptr< CodeType > x)
  {
    this->Code_.set (std::move (x));
  }

  const Annotation::SampleIndexOptional& Annotation::
  SampleIndex () const
  {
    return this->SampleIndex_;
  }

  Annotation::SampleIndexOptional& Annotation::
  SampleIndex ()
  {
    return this->SampleIndex_;
  }

  void Annotation::
  SampleIndex (const SampleIndexType& x)
  {
    this->SampleIndex_.set (x);
  }

  void Annotation::
  SampleIndex (const SampleIndexOptional& x)
  {
    this->SampleIndex_ = x;
  }

  void Annotation::
  SampleIndex (::std::unique_ptr< SampleIndexType > x)
  {
    this->SampleIndex_.set (std::move (x));
  }


  // AbstractMetricValue
  // 

  const AbstractMetricValue::ExtensionOptional& AbstractMetricValue::
  Extension () const
  {
    return this->Extension_;
  }

  AbstractMetricValue::ExtensionOptional& AbstractMetricValue::
  Extension ()
  {
    return this->Extension_;
  }

  void AbstractMetricValue::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractMetricValue::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractMetricValue::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const AbstractMetricValue::MeasurementStateType& AbstractMetricValue::
  MeasurementState () const
  {
    return this->MeasurementState_.get ();
  }

  AbstractMetricValue::MeasurementStateType& AbstractMetricValue::
  MeasurementState ()
  {
    return this->MeasurementState_.get ();
  }

  void AbstractMetricValue::
  MeasurementState (const MeasurementStateType& x)
  {
    this->MeasurementState_.set (x);
  }

  void AbstractMetricValue::
  MeasurementState (::std::unique_ptr< MeasurementStateType > x)
  {
    this->MeasurementState_.set (std::move (x));
  }

  const AbstractMetricValue::Start_TimeOptional& AbstractMetricValue::
  Start_Time () const
  {
    return this->Start_Time_;
  }

  AbstractMetricValue::Start_TimeOptional& AbstractMetricValue::
  Start_Time ()
  {
    return this->Start_Time_;
  }

  void AbstractMetricValue::
  Start_Time (const Start_TimeType& x)
  {
    this->Start_Time_.set (x);
  }

  void AbstractMetricValue::
  Start_Time (const Start_TimeOptional& x)
  {
    this->Start_Time_ = x;
  }

  void AbstractMetricValue::
  Start_Time (::std::unique_ptr< Start_TimeType > x)
  {
    this->Start_Time_.set (std::move (x));
  }

  const AbstractMetricValue::Stop_TimeOptional& AbstractMetricValue::
  Stop_Time () const
  {
    return this->Stop_Time_;
  }

  AbstractMetricValue::Stop_TimeOptional& AbstractMetricValue::
  Stop_Time ()
  {
    return this->Stop_Time_;
  }

  void AbstractMetricValue::
  Stop_Time (const Stop_TimeType& x)
  {
    this->Stop_Time_.set (x);
  }

  void AbstractMetricValue::
  Stop_Time (const Stop_TimeOptional& x)
  {
    this->Stop_Time_ = x;
  }

  void AbstractMetricValue::
  Stop_Time (::std::unique_ptr< Stop_TimeType > x)
  {
    this->Stop_Time_.set (std::move (x));
  }

  const AbstractMetricValue::ObservationTimeOptional& AbstractMetricValue::
  ObservationTime () const
  {
    return this->ObservationTime_;
  }

  AbstractMetricValue::ObservationTimeOptional& AbstractMetricValue::
  ObservationTime ()
  {
    return this->ObservationTime_;
  }

  void AbstractMetricValue::
  ObservationTime (const ObservationTimeType& x)
  {
    this->ObservationTime_.set (x);
  }

  void AbstractMetricValue::
  ObservationTime (const ObservationTimeOptional& x)
  {
    this->ObservationTime_ = x;
  }

  void AbstractMetricValue::
  ObservationTime (::std::unique_ptr< ObservationTimeType > x)
  {
    this->ObservationTime_.set (std::move (x));
  }


  // NumericMetricValue
  // 

  const NumericMetricValue::ValueOptional& NumericMetricValue::
  Value () const
  {
    return this->Value_;
  }

  NumericMetricValue::ValueOptional& NumericMetricValue::
  Value ()
  {
    return this->Value_;
  }

  void NumericMetricValue::
  Value (const ValueType& x)
  {
    this->Value_.set (x);
  }

  void NumericMetricValue::
  Value (const ValueOptional& x)
  {
    this->Value_ = x;
  }


  // RealTimeSampleArrayValue
  // 

  const RealTimeSampleArrayValue::AnnotationSequence& RealTimeSampleArrayValue::
  Annotation () const
  {
    return this->Annotation_;
  }

  RealTimeSampleArrayValue::AnnotationSequence& RealTimeSampleArrayValue::
  Annotation ()
  {
    return this->Annotation_;
  }

  void RealTimeSampleArrayValue::
  Annotation (const AnnotationSequence& s)
  {
    this->Annotation_ = s;
  }

  const RealTimeSampleArrayValue::SamplesOptional& RealTimeSampleArrayValue::
  Samples () const
  {
    return this->Samples_;
  }

  RealTimeSampleArrayValue::SamplesOptional& RealTimeSampleArrayValue::
  Samples ()
  {
    return this->Samples_;
  }

  void RealTimeSampleArrayValue::
  Samples (const SamplesType& x)
  {
    this->Samples_.set (x);
  }

  void RealTimeSampleArrayValue::
  Samples (const SamplesOptional& x)
  {
    this->Samples_ = x;
  }

  void RealTimeSampleArrayValue::
  Samples (::std::unique_ptr< SamplesType > x)
  {
    this->Samples_.set (std::move (x));
  }


  // RTValueType
  //

  RTValueType::
  RTValueType ()
  : ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal > (this)
  {
  }

  RTValueType::
  RTValueType (size_type n, const ::xml_schema::Decimal& x)
  : ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal > (n, x, this)
  {
  }

  RTValueType::
  RTValueType (const RTValueType& o,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal > (o, f, this)
  {
  }

  // StringMetricValue
  // 

  const StringMetricValue::ValueOptional& StringMetricValue::
  Value () const
  {
    return this->Value_;
  }

  StringMetricValue::ValueOptional& StringMetricValue::
  Value ()
  {
    return this->Value_;
  }

  void StringMetricValue::
  Value (const ValueType& x)
  {
    this->Value_.set (x);
  }

  void StringMetricValue::
  Value (const ValueOptional& x)
  {
    this->Value_ = x;
  }

  void StringMetricValue::
  Value (::std::unique_ptr< ValueType > x)
  {
    this->Value_.set (std::move (x));
  }


  // ArgumentDescriptorType
  // 

  const ArgumentDescriptorType::ArgNameType& ArgumentDescriptorType::
  ArgName () const
  {
    return this->ArgName_.get ();
  }

  ArgumentDescriptorType::ArgNameType& ArgumentDescriptorType::
  ArgName ()
  {
    return this->ArgName_.get ();
  }

  void ArgumentDescriptorType::
  ArgName (const ArgNameType& x)
  {
    this->ArgName_.set (x);
  }

  void ArgumentDescriptorType::
  ArgName (::std::unique_ptr< ArgNameType > x)
  {
    this->ArgName_.set (std::move (x));
  }

  const ArgumentDescriptorType::ArgTypeType& ArgumentDescriptorType::
  ArgType () const
  {
    return this->ArgType_.get ();
  }

  ArgumentDescriptorType::ArgTypeType& ArgumentDescriptorType::
  ArgType ()
  {
    return this->ArgType_.get ();
  }

  void ArgumentDescriptorType::
  ArgType (const ArgTypeType& x)
  {
    this->ArgType_.set (x);
  }

  void ArgumentDescriptorType::
  ArgType (::std::unique_ptr< ArgTypeType > x)
  {
    this->ArgType_.set (std::move (x));
  }


  // SCODescriptor
  // 

  const SCODescriptor::OperationSequence& SCODescriptor::
  Operation () const
  {
    return this->Operation_;
  }

  SCODescriptor::OperationSequence& SCODescriptor::
  Operation ()
  {
    return this->Operation_;
  }

  void SCODescriptor::
  Operation (const OperationSequence& s)
  {
    this->Operation_ = s;
  }


  // AbstractOperationDescriptor
  // 

  const AbstractOperationDescriptor::ModifiableElementSequence& AbstractOperationDescriptor::
  ModifiableElement () const
  {
    return this->ModifiableElement_;
  }

  AbstractOperationDescriptor::ModifiableElementSequence& AbstractOperationDescriptor::
  ModifiableElement ()
  {
    return this->ModifiableElement_;
  }

  void AbstractOperationDescriptor::
  ModifiableElement (const ModifiableElementSequence& s)
  {
    this->ModifiableElement_ = s;
  }

  const AbstractOperationDescriptor::OperationTargetType& AbstractOperationDescriptor::
  OperationTarget () const
  {
    return this->OperationTarget_.get ();
  }

  AbstractOperationDescriptor::OperationTargetType& AbstractOperationDescriptor::
  OperationTarget ()
  {
    return this->OperationTarget_.get ();
  }

  void AbstractOperationDescriptor::
  OperationTarget (const OperationTargetType& x)
  {
    this->OperationTarget_.set (x);
  }

  void AbstractOperationDescriptor::
  OperationTarget (::std::unique_ptr< OperationTargetType > x)
  {
    this->OperationTarget_.set (std::move (x));
  }


  // SetValueOperationDescriptor
  // 


  // SetStringOperationDescriptor
  // 


  // ActivateOperationDescriptor
  // 

  const ActivateOperationDescriptor::ArgumentSequence& ActivateOperationDescriptor::
  Argument () const
  {
    return this->Argument_;
  }

  ActivateOperationDescriptor::ArgumentSequence& ActivateOperationDescriptor::
  Argument ()
  {
    return this->Argument_;
  }

  void ActivateOperationDescriptor::
  Argument (const ArgumentSequence& s)
  {
    this->Argument_ = s;
  }

  const ActivateOperationDescriptor::ActivationDurationOptional& ActivateOperationDescriptor::
  ActivationDuration () const
  {
    return this->ActivationDuration_;
  }

  ActivateOperationDescriptor::ActivationDurationOptional& ActivateOperationDescriptor::
  ActivationDuration ()
  {
    return this->ActivationDuration_;
  }

  void ActivateOperationDescriptor::
  ActivationDuration (const ActivationDurationType& x)
  {
    this->ActivationDuration_.set (x);
  }

  void ActivateOperationDescriptor::
  ActivationDuration (const ActivationDurationOptional& x)
  {
    this->ActivationDuration_ = x;
  }

  void ActivateOperationDescriptor::
  ActivationDuration (::std::unique_ptr< ActivationDurationType > x)
  {
    this->ActivationDuration_.set (std::move (x));
  }


  // NonGenericOperationDescriptor
  // 


  // SetAlertStateOperationDescriptor
  // 


  // SetRangeOperationDescriptor
  // 

  const SetRangeOperationDescriptor::AllowedMaxRangeType& SetRangeOperationDescriptor::
  AllowedMaxRange () const
  {
    return this->AllowedMaxRange_.get ();
  }

  SetRangeOperationDescriptor::AllowedMaxRangeType& SetRangeOperationDescriptor::
  AllowedMaxRange ()
  {
    return this->AllowedMaxRange_.get ();
  }

  void SetRangeOperationDescriptor::
  AllowedMaxRange (const AllowedMaxRangeType& x)
  {
    this->AllowedMaxRange_.set (x);
  }

  void SetRangeOperationDescriptor::
  AllowedMaxRange (::std::unique_ptr< AllowedMaxRangeType > x)
  {
    this->AllowedMaxRange_.set (std::move (x));
  }


  // SetContextOperationDescriptor
  // 


  // OperatingMode
  // 

  OperatingMode::
  OperatingMode (Value v)
  : ::xml_schema::String (_xsd_OperatingMode_literals_[v])
  {
  }

  OperatingMode::
  OperatingMode (const char* v)
  : ::xml_schema::String (v)
  {
  }

  OperatingMode::
  OperatingMode (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  OperatingMode::
  OperatingMode (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  OperatingMode::
  OperatingMode (const OperatingMode& v,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  OperatingMode& OperatingMode::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_OperatingMode_literals_[v]);

    return *this;
  }


  // OperationState
  // 

  const OperationState::OperatingModeType& OperationState::
  OperatingMode () const
  {
    return this->OperatingMode_.get ();
  }

  OperationState::OperatingModeType& OperationState::
  OperatingMode ()
  {
    return this->OperatingMode_.get ();
  }

  void OperationState::
  OperatingMode (const OperatingModeType& x)
  {
    this->OperatingMode_.set (x);
  }

  void OperationState::
  OperatingMode (::std::unique_ptr< OperatingModeType > x)
  {
    this->OperatingMode_.set (std::move (x));
  }


  // SetValueOperationState
  // 

  const SetValueOperationState::AllowedRangeSequence& SetValueOperationState::
  allowedRange () const
  {
    return this->allowedRange_;
  }

  SetValueOperationState::AllowedRangeSequence& SetValueOperationState::
  allowedRange ()
  {
    return this->allowedRange_;
  }

  void SetValueOperationState::
  allowedRange (const AllowedRangeSequence& s)
  {
    this->allowedRange_ = s;
  }


  // SetRangeOperationState
  // 

  const SetRangeOperationState::AllowedRangeSequence& SetRangeOperationState::
  allowedRange () const
  {
    return this->allowedRange_;
  }

  SetRangeOperationState::AllowedRangeSequence& SetRangeOperationState::
  allowedRange ()
  {
    return this->allowedRange_;
  }

  void SetRangeOperationState::
  allowedRange (const AllowedRangeSequence& s)
  {
    this->allowedRange_ = s;
  }


  // TimeZone
  // 


  // ClockDescriptor
  // 

  const ClockDescriptor::TimeProtocolSequence& ClockDescriptor::
  TimeProtocol () const
  {
    return this->TimeProtocol_;
  }

  ClockDescriptor::TimeProtocolSequence& ClockDescriptor::
  TimeProtocol ()
  {
    return this->TimeProtocol_;
  }

  void ClockDescriptor::
  TimeProtocol (const TimeProtocolSequence& s)
  {
    this->TimeProtocol_ = s;
  }

  const ClockDescriptor::ResolutionOptional& ClockDescriptor::
  Resolution () const
  {
    return this->Resolution_;
  }

  ClockDescriptor::ResolutionOptional& ClockDescriptor::
  Resolution ()
  {
    return this->Resolution_;
  }

  void ClockDescriptor::
  Resolution (const ResolutionType& x)
  {
    this->Resolution_.set (x);
  }

  void ClockDescriptor::
  Resolution (const ResolutionOptional& x)
  {
    this->Resolution_ = x;
  }

  void ClockDescriptor::
  Resolution (::std::unique_ptr< ResolutionType > x)
  {
    this->Resolution_.set (std::move (x));
  }


  // ClockState
  // 

  const ClockState::ActiveSyncProtocolOptional& ClockState::
  ActiveSyncProtocol () const
  {
    return this->ActiveSyncProtocol_;
  }

  ClockState::ActiveSyncProtocolOptional& ClockState::
  ActiveSyncProtocol ()
  {
    return this->ActiveSyncProtocol_;
  }

  void ClockState::
  ActiveSyncProtocol (const ActiveSyncProtocolType& x)
  {
    this->ActiveSyncProtocol_.set (x);
  }

  void ClockState::
  ActiveSyncProtocol (const ActiveSyncProtocolOptional& x)
  {
    this->ActiveSyncProtocol_ = x;
  }

  void ClockState::
  ActiveSyncProtocol (::std::unique_ptr< ActiveSyncProtocolType > x)
  {
    this->ActiveSyncProtocol_.set (std::move (x));
  }

  const ClockState::DateAndTimeOptional& ClockState::
  DateAndTime () const
  {
    return this->DateAndTime_;
  }

  ClockState::DateAndTimeOptional& ClockState::
  DateAndTime ()
  {
    return this->DateAndTime_;
  }

  void ClockState::
  DateAndTime (const DateAndTimeType& x)
  {
    this->DateAndTime_.set (x);
  }

  void ClockState::
  DateAndTime (const DateAndTimeOptional& x)
  {
    this->DateAndTime_ = x;
  }

  void ClockState::
  DateAndTime (::std::unique_ptr< DateAndTimeType > x)
  {
    this->DateAndTime_.set (std::move (x));
  }

  const ClockState::RemoteSyncType& ClockState::
  RemoteSync () const
  {
    return this->RemoteSync_.get ();
  }

  ClockState::RemoteSyncType& ClockState::
  RemoteSync ()
  {
    return this->RemoteSync_.get ();
  }

  void ClockState::
  RemoteSync (const RemoteSyncType& x)
  {
    this->RemoteSync_.set (x);
  }

  const ClockState::ReferenceSourceOptional& ClockState::
  ReferenceSource () const
  {
    return this->ReferenceSource_;
  }

  ClockState::ReferenceSourceOptional& ClockState::
  ReferenceSource ()
  {
    return this->ReferenceSource_;
  }

  void ClockState::
  ReferenceSource (const ReferenceSourceType& x)
  {
    this->ReferenceSource_.set (x);
  }

  void ClockState::
  ReferenceSource (const ReferenceSourceOptional& x)
  {
    this->ReferenceSource_ = x;
  }

  void ClockState::
  ReferenceSource (::std::unique_ptr< ReferenceSourceType > x)
  {
    this->ReferenceSource_.set (std::move (x));
  }

  const ClockState::AccuracyOptional& ClockState::
  Accuracy () const
  {
    return this->Accuracy_;
  }

  ClockState::AccuracyOptional& ClockState::
  Accuracy ()
  {
    return this->Accuracy_;
  }

  void ClockState::
  Accuracy (const AccuracyType& x)
  {
    this->Accuracy_.set (x);
  }

  void ClockState::
  Accuracy (const AccuracyOptional& x)
  {
    this->Accuracy_ = x;
  }

  const ClockState::LastSetOptional& ClockState::
  LastSet () const
  {
    return this->LastSet_;
  }

  ClockState::LastSetOptional& ClockState::
  LastSet ()
  {
    return this->LastSet_;
  }

  void ClockState::
  LastSet (const LastSetType& x)
  {
    this->LastSet_.set (x);
  }

  void ClockState::
  LastSet (const LastSetOptional& x)
  {
    this->LastSet_ = x;
  }

  void ClockState::
  LastSet (::std::unique_ptr< LastSetType > x)
  {
    this->LastSet_.set (std::move (x));
  }

  const ClockState::TimeZoneOptional& ClockState::
  TimeZone () const
  {
    return this->TimeZone_;
  }

  ClockState::TimeZoneOptional& ClockState::
  TimeZone ()
  {
    return this->TimeZone_;
  }

  void ClockState::
  TimeZone (const TimeZoneType& x)
  {
    this->TimeZone_.set (x);
  }

  void ClockState::
  TimeZone (const TimeZoneOptional& x)
  {
    this->TimeZone_ = x;
  }

  void ClockState::
  TimeZone (::std::unique_ptr< TimeZoneType > x)
  {
    this->TimeZone_.set (std::move (x));
  }

  const ClockState::CriticalUseOptional& ClockState::
  CriticalUse () const
  {
    return this->CriticalUse_;
  }

  ClockState::CriticalUseOptional& ClockState::
  CriticalUse ()
  {
    return this->CriticalUse_;
  }

  void ClockState::
  CriticalUse (const CriticalUseType& x)
  {
    this->CriticalUse_.set (x);
  }

  void ClockState::
  CriticalUse (const CriticalUseOptional& x)
  {
    this->CriticalUse_ = x;
  }


  // AbstractContextDescriptor
  // 


  // LocationContextDescriptor
  // 


  // EnsembleContextDescriptor
  // 


  // OperatorContextDescriptor
  // 


  // WorkflowContextDescriptor
  // 


  // AbstractContextState
  // 

  const AbstractContextState::ValidatorSequence& AbstractContextState::
  Validator () const
  {
    return this->Validator_;
  }

  AbstractContextState::ValidatorSequence& AbstractContextState::
  Validator ()
  {
    return this->Validator_;
  }

  void AbstractContextState::
  Validator (const ValidatorSequence& s)
  {
    this->Validator_ = s;
  }

  const AbstractContextState::ContextAssociationOptional& AbstractContextState::
  ContextAssociation () const
  {
    return this->ContextAssociation_;
  }

  AbstractContextState::ContextAssociationOptional& AbstractContextState::
  ContextAssociation ()
  {
    return this->ContextAssociation_;
  }

  void AbstractContextState::
  ContextAssociation (const ContextAssociationType& x)
  {
    this->ContextAssociation_.set (x);
  }

  void AbstractContextState::
  ContextAssociation (const ContextAssociationOptional& x)
  {
    this->ContextAssociation_ = x;
  }

  void AbstractContextState::
  ContextAssociation (::std::unique_ptr< ContextAssociationType > x)
  {
    this->ContextAssociation_.set (std::move (x));
  }

  const AbstractContextState::BindingMDIBVersionType& AbstractContextState::
  BindingMDIBVersion () const
  {
    return this->BindingMDIBVersion_.get ();
  }

  AbstractContextState::BindingMDIBVersionType& AbstractContextState::
  BindingMDIBVersion ()
  {
    return this->BindingMDIBVersion_.get ();
  }

  void AbstractContextState::
  BindingMDIBVersion (const BindingMDIBVersionType& x)
  {
    this->BindingMDIBVersion_.set (x);
  }

  void AbstractContextState::
  BindingMDIBVersion (::std::unique_ptr< BindingMDIBVersionType > x)
  {
    this->BindingMDIBVersion_.set (std::move (x));
  }

  const AbstractContextState::UnbindingMDIBVersionOptional& AbstractContextState::
  UnbindingMDIBVersion () const
  {
    return this->UnbindingMDIBVersion_;
  }

  AbstractContextState::UnbindingMDIBVersionOptional& AbstractContextState::
  UnbindingMDIBVersion ()
  {
    return this->UnbindingMDIBVersion_;
  }

  void AbstractContextState::
  UnbindingMDIBVersion (const UnbindingMDIBVersionType& x)
  {
    this->UnbindingMDIBVersion_.set (x);
  }

  void AbstractContextState::
  UnbindingMDIBVersion (const UnbindingMDIBVersionOptional& x)
  {
    this->UnbindingMDIBVersion_ = x;
  }

  void AbstractContextState::
  UnbindingMDIBVersion (::std::unique_ptr< UnbindingMDIBVersionType > x)
  {
    this->UnbindingMDIBVersion_.set (std::move (x));
  }

  const AbstractContextState::BindingStartTimeOptional& AbstractContextState::
  BindingStartTime () const
  {
    return this->BindingStartTime_;
  }

  AbstractContextState::BindingStartTimeOptional& AbstractContextState::
  BindingStartTime ()
  {
    return this->BindingStartTime_;
  }

  void AbstractContextState::
  BindingStartTime (const BindingStartTimeType& x)
  {
    this->BindingStartTime_.set (x);
  }

  void AbstractContextState::
  BindingStartTime (const BindingStartTimeOptional& x)
  {
    this->BindingStartTime_ = x;
  }

  void AbstractContextState::
  BindingStartTime (::std::unique_ptr< BindingStartTimeType > x)
  {
    this->BindingStartTime_.set (std::move (x));
  }

  const AbstractContextState::BindingEndTimeOptional& AbstractContextState::
  BindingEndTime () const
  {
    return this->BindingEndTime_;
  }

  AbstractContextState::BindingEndTimeOptional& AbstractContextState::
  BindingEndTime ()
  {
    return this->BindingEndTime_;
  }

  void AbstractContextState::
  BindingEndTime (const BindingEndTimeType& x)
  {
    this->BindingEndTime_.set (x);
  }

  void AbstractContextState::
  BindingEndTime (const BindingEndTimeOptional& x)
  {
    this->BindingEndTime_ = x;
  }

  void AbstractContextState::
  BindingEndTime (::std::unique_ptr< BindingEndTimeType > x)
  {
    this->BindingEndTime_.set (std::move (x));
  }


  // AbstractIdentifiableContextState
  // 

  const AbstractIdentifiableContextState::IdentificationSequence& AbstractIdentifiableContextState::
  Identification () const
  {
    return this->Identification_;
  }

  AbstractIdentifiableContextState::IdentificationSequence& AbstractIdentifiableContextState::
  Identification ()
  {
    return this->Identification_;
  }

  void AbstractIdentifiableContextState::
  Identification (const IdentificationSequence& s)
  {
    this->Identification_ = s;
  }


  // LocationContextState
  // 


  // EnsembleContextState
  // 


  // WorkflowContextState
  // 

  const WorkflowContextState::OrderDetailOptional& WorkflowContextState::
  OrderDetail () const
  {
    return this->OrderDetail_;
  }

  WorkflowContextState::OrderDetailOptional& WorkflowContextState::
  OrderDetail ()
  {
    return this->OrderDetail_;
  }

  void WorkflowContextState::
  OrderDetail (const OrderDetailType& x)
  {
    this->OrderDetail_.set (x);
  }

  void WorkflowContextState::
  OrderDetail (const OrderDetailOptional& x)
  {
    this->OrderDetail_ = x;
  }

  void WorkflowContextState::
  OrderDetail (::std::unique_ptr< OrderDetailType > x)
  {
    this->OrderDetail_.set (std::move (x));
  }


  // OperatorContextState
  // 


  // ContextAssociation
  // 

  ContextAssociation::
  ContextAssociation (Value v)
  : ::xml_schema::String (_xsd_ContextAssociation_literals_[v])
  {
  }

  ContextAssociation::
  ContextAssociation (const char* v)
  : ::xml_schema::String (v)
  {
  }

  ContextAssociation::
  ContextAssociation (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  ContextAssociation::
  ContextAssociation (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  ContextAssociation::
  ContextAssociation (const ContextAssociation& v,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  ContextAssociation& ContextAssociation::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_ContextAssociation_literals_[v]);

    return *this;
  }


  // PatientContextDescriptor
  // 


  // BaseDemographics
  // 

  const BaseDemographics::ExtensionOptional& BaseDemographics::
  Extension () const
  {
    return this->Extension_;
  }

  BaseDemographics::ExtensionOptional& BaseDemographics::
  Extension ()
  {
    return this->Extension_;
  }

  void BaseDemographics::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void BaseDemographics::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void BaseDemographics::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const BaseDemographics::GivennameOptional& BaseDemographics::
  Givenname () const
  {
    return this->Givenname_;
  }

  BaseDemographics::GivennameOptional& BaseDemographics::
  Givenname ()
  {
    return this->Givenname_;
  }

  void BaseDemographics::
  Givenname (const GivennameType& x)
  {
    this->Givenname_.set (x);
  }

  void BaseDemographics::
  Givenname (const GivennameOptional& x)
  {
    this->Givenname_ = x;
  }

  void BaseDemographics::
  Givenname (::std::unique_ptr< GivennameType > x)
  {
    this->Givenname_.set (std::move (x));
  }

  const BaseDemographics::MiddlenameSequence& BaseDemographics::
  Middlename () const
  {
    return this->Middlename_;
  }

  BaseDemographics::MiddlenameSequence& BaseDemographics::
  Middlename ()
  {
    return this->Middlename_;
  }

  void BaseDemographics::
  Middlename (const MiddlenameSequence& s)
  {
    this->Middlename_ = s;
  }

  const BaseDemographics::FamilynameOptional& BaseDemographics::
  Familyname () const
  {
    return this->Familyname_;
  }

  BaseDemographics::FamilynameOptional& BaseDemographics::
  Familyname ()
  {
    return this->Familyname_;
  }

  void BaseDemographics::
  Familyname (const FamilynameType& x)
  {
    this->Familyname_.set (x);
  }

  void BaseDemographics::
  Familyname (const FamilynameOptional& x)
  {
    this->Familyname_ = x;
  }

  void BaseDemographics::
  Familyname (::std::unique_ptr< FamilynameType > x)
  {
    this->Familyname_.set (std::move (x));
  }

  const BaseDemographics::BirthnameOptional& BaseDemographics::
  Birthname () const
  {
    return this->Birthname_;
  }

  BaseDemographics::BirthnameOptional& BaseDemographics::
  Birthname ()
  {
    return this->Birthname_;
  }

  void BaseDemographics::
  Birthname (const BirthnameType& x)
  {
    this->Birthname_.set (x);
  }

  void BaseDemographics::
  Birthname (const BirthnameOptional& x)
  {
    this->Birthname_ = x;
  }

  void BaseDemographics::
  Birthname (::std::unique_ptr< BirthnameType > x)
  {
    this->Birthname_.set (std::move (x));
  }

  const BaseDemographics::TitleOptional& BaseDemographics::
  Title () const
  {
    return this->Title_;
  }

  BaseDemographics::TitleOptional& BaseDemographics::
  Title ()
  {
    return this->Title_;
  }

  void BaseDemographics::
  Title (const TitleType& x)
  {
    this->Title_.set (x);
  }

  void BaseDemographics::
  Title (const TitleOptional& x)
  {
    this->Title_ = x;
  }

  void BaseDemographics::
  Title (::std::unique_ptr< TitleType > x)
  {
    this->Title_.set (std::move (x));
  }


  // PatientDemographicsCoreData
  // 

  const PatientDemographicsCoreData::SexOptional& PatientDemographicsCoreData::
  Sex () const
  {
    return this->Sex_;
  }

  PatientDemographicsCoreData::SexOptional& PatientDemographicsCoreData::
  Sex ()
  {
    return this->Sex_;
  }

  void PatientDemographicsCoreData::
  Sex (const SexType& x)
  {
    this->Sex_.set (x);
  }

  void PatientDemographicsCoreData::
  Sex (const SexOptional& x)
  {
    this->Sex_ = x;
  }

  void PatientDemographicsCoreData::
  Sex (::std::unique_ptr< SexType > x)
  {
    this->Sex_.set (std::move (x));
  }

  const PatientDemographicsCoreData::PatientTypeOptional& PatientDemographicsCoreData::
  PatientType () const
  {
    return this->PatientType_;
  }

  PatientDemographicsCoreData::PatientTypeOptional& PatientDemographicsCoreData::
  PatientType ()
  {
    return this->PatientType_;
  }

  void PatientDemographicsCoreData::
  PatientType (const PatientTypeType& x)
  {
    this->PatientType_.set (x);
  }

  void PatientDemographicsCoreData::
  PatientType (const PatientTypeOptional& x)
  {
    this->PatientType_ = x;
  }

  void PatientDemographicsCoreData::
  PatientType (::std::unique_ptr< PatientTypeType > x)
  {
    this->PatientType_.set (std::move (x));
  }

  const PatientDemographicsCoreData::DateOfBirthOptional& PatientDemographicsCoreData::
  DateOfBirth () const
  {
    return this->DateOfBirth_;
  }

  PatientDemographicsCoreData::DateOfBirthOptional& PatientDemographicsCoreData::
  DateOfBirth ()
  {
    return this->DateOfBirth_;
  }

  void PatientDemographicsCoreData::
  DateOfBirth (const DateOfBirthType& x)
  {
    this->DateOfBirth_.set (x);
  }

  void PatientDemographicsCoreData::
  DateOfBirth (const DateOfBirthOptional& x)
  {
    this->DateOfBirth_ = x;
  }

  void PatientDemographicsCoreData::
  DateOfBirth (::std::unique_ptr< DateOfBirthType > x)
  {
    this->DateOfBirth_.set (std::move (x));
  }

  const PatientDemographicsCoreData::HeightOptional& PatientDemographicsCoreData::
  Height () const
  {
    return this->Height_;
  }

  PatientDemographicsCoreData::HeightOptional& PatientDemographicsCoreData::
  Height ()
  {
    return this->Height_;
  }

  void PatientDemographicsCoreData::
  Height (const HeightType& x)
  {
    this->Height_.set (x);
  }

  void PatientDemographicsCoreData::
  Height (const HeightOptional& x)
  {
    this->Height_ = x;
  }

  void PatientDemographicsCoreData::
  Height (::std::unique_ptr< HeightType > x)
  {
    this->Height_.set (std::move (x));
  }

  const PatientDemographicsCoreData::WeightOptional& PatientDemographicsCoreData::
  Weight () const
  {
    return this->Weight_;
  }

  PatientDemographicsCoreData::WeightOptional& PatientDemographicsCoreData::
  Weight ()
  {
    return this->Weight_;
  }

  void PatientDemographicsCoreData::
  Weight (const WeightType& x)
  {
    this->Weight_.set (x);
  }

  void PatientDemographicsCoreData::
  Weight (const WeightOptional& x)
  {
    this->Weight_ = x;
  }

  void PatientDemographicsCoreData::
  Weight (::std::unique_ptr< WeightType > x)
  {
    this->Weight_.set (std::move (x));
  }

  const PatientDemographicsCoreData::RaceOptional& PatientDemographicsCoreData::
  Race () const
  {
    return this->Race_;
  }

  PatientDemographicsCoreData::RaceOptional& PatientDemographicsCoreData::
  Race ()
  {
    return this->Race_;
  }

  void PatientDemographicsCoreData::
  Race (const RaceType& x)
  {
    this->Race_.set (x);
  }

  void PatientDemographicsCoreData::
  Race (const RaceOptional& x)
  {
    this->Race_ = x;
  }

  void PatientDemographicsCoreData::
  Race (::std::unique_ptr< RaceType > x)
  {
    this->Race_.set (std::move (x));
  }


  // PersonReference
  // 

  const PersonReference::ExtensionOptional& PersonReference::
  Extension () const
  {
    return this->Extension_;
  }

  PersonReference::ExtensionOptional& PersonReference::
  Extension ()
  {
    return this->Extension_;
  }

  void PersonReference::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void PersonReference::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void PersonReference::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const PersonReference::IdentificationSequence& PersonReference::
  Identification () const
  {
    return this->Identification_;
  }

  PersonReference::IdentificationSequence& PersonReference::
  Identification ()
  {
    return this->Identification_;
  }

  void PersonReference::
  Identification (const IdentificationSequence& s)
  {
    this->Identification_ = s;
  }

  const PersonReference::NameSequence& PersonReference::
  Name () const
  {
    return this->Name_;
  }

  PersonReference::NameSequence& PersonReference::
  Name ()
  {
    return this->Name_;
  }

  void PersonReference::
  Name (const NameSequence& s)
  {
    this->Name_ = s;
  }


  // PersonParticipation
  // 

  const PersonParticipation::RoleSequence& PersonParticipation::
  Role () const
  {
    return this->Role_;
  }

  PersonParticipation::RoleSequence& PersonParticipation::
  Role ()
  {
    return this->Role_;
  }

  void PersonParticipation::
  Role (const RoleSequence& s)
  {
    this->Role_ = s;
  }


  // NeonatalPatientDemographicsCoreData
  // 

  const NeonatalPatientDemographicsCoreData::Gestational_AgeOptional& NeonatalPatientDemographicsCoreData::
  Gestational_Age () const
  {
    return this->Gestational_Age_;
  }

  NeonatalPatientDemographicsCoreData::Gestational_AgeOptional& NeonatalPatientDemographicsCoreData::
  Gestational_Age ()
  {
    return this->Gestational_Age_;
  }

  void NeonatalPatientDemographicsCoreData::
  Gestational_Age (const Gestational_AgeType& x)
  {
    this->Gestational_Age_.set (x);
  }

  void NeonatalPatientDemographicsCoreData::
  Gestational_Age (const Gestational_AgeOptional& x)
  {
    this->Gestational_Age_ = x;
  }

  void NeonatalPatientDemographicsCoreData::
  Gestational_Age (::std::unique_ptr< Gestational_AgeType > x)
  {
    this->Gestational_Age_.set (std::move (x));
  }

  const NeonatalPatientDemographicsCoreData::BirthLengthOptional& NeonatalPatientDemographicsCoreData::
  BirthLength () const
  {
    return this->BirthLength_;
  }

  NeonatalPatientDemographicsCoreData::BirthLengthOptional& NeonatalPatientDemographicsCoreData::
  BirthLength ()
  {
    return this->BirthLength_;
  }

  void NeonatalPatientDemographicsCoreData::
  BirthLength (const BirthLengthType& x)
  {
    this->BirthLength_.set (x);
  }

  void NeonatalPatientDemographicsCoreData::
  BirthLength (const BirthLengthOptional& x)
  {
    this->BirthLength_ = x;
  }

  void NeonatalPatientDemographicsCoreData::
  BirthLength (::std::unique_ptr< BirthLengthType > x)
  {
    this->BirthLength_.set (std::move (x));
  }

  const NeonatalPatientDemographicsCoreData::BirthWeightOptional& NeonatalPatientDemographicsCoreData::
  BirthWeight () const
  {
    return this->BirthWeight_;
  }

  NeonatalPatientDemographicsCoreData::BirthWeightOptional& NeonatalPatientDemographicsCoreData::
  BirthWeight ()
  {
    return this->BirthWeight_;
  }

  void NeonatalPatientDemographicsCoreData::
  BirthWeight (const BirthWeightType& x)
  {
    this->BirthWeight_.set (x);
  }

  void NeonatalPatientDemographicsCoreData::
  BirthWeight (const BirthWeightOptional& x)
  {
    this->BirthWeight_ = x;
  }

  void NeonatalPatientDemographicsCoreData::
  BirthWeight (::std::unique_ptr< BirthWeightType > x)
  {
    this->BirthWeight_.set (std::move (x));
  }

  const NeonatalPatientDemographicsCoreData::HeadCircumferenceOptional& NeonatalPatientDemographicsCoreData::
  HeadCircumference () const
  {
    return this->HeadCircumference_;
  }

  NeonatalPatientDemographicsCoreData::HeadCircumferenceOptional& NeonatalPatientDemographicsCoreData::
  HeadCircumference ()
  {
    return this->HeadCircumference_;
  }

  void NeonatalPatientDemographicsCoreData::
  HeadCircumference (const HeadCircumferenceType& x)
  {
    this->HeadCircumference_.set (x);
  }

  void NeonatalPatientDemographicsCoreData::
  HeadCircumference (const HeadCircumferenceOptional& x)
  {
    this->HeadCircumference_ = x;
  }

  void NeonatalPatientDemographicsCoreData::
  HeadCircumference (::std::unique_ptr< HeadCircumferenceType > x)
  {
    this->HeadCircumference_.set (std::move (x));
  }

  const NeonatalPatientDemographicsCoreData::MotherOptional& NeonatalPatientDemographicsCoreData::
  Mother () const
  {
    return this->Mother_;
  }

  NeonatalPatientDemographicsCoreData::MotherOptional& NeonatalPatientDemographicsCoreData::
  Mother ()
  {
    return this->Mother_;
  }

  void NeonatalPatientDemographicsCoreData::
  Mother (const MotherType& x)
  {
    this->Mother_.set (x);
  }

  void NeonatalPatientDemographicsCoreData::
  Mother (const MotherOptional& x)
  {
    this->Mother_ = x;
  }

  void NeonatalPatientDemographicsCoreData::
  Mother (::std::unique_ptr< MotherType > x)
  {
    this->Mother_.set (std::move (x));
  }


  // PatientContextState
  // 

  const PatientContextState::CoreDataOptional& PatientContextState::
  CoreData () const
  {
    return this->CoreData_;
  }

  PatientContextState::CoreDataOptional& PatientContextState::
  CoreData ()
  {
    return this->CoreData_;
  }

  void PatientContextState::
  CoreData (const CoreDataType& x)
  {
    this->CoreData_.set (x);
  }

  void PatientContextState::
  CoreData (const CoreDataOptional& x)
  {
    this->CoreData_ = x;
  }

  void PatientContextState::
  CoreData (::std::unique_ptr< CoreDataType > x)
  {
    this->CoreData_.set (std::move (x));
  }


  // Sex
  // 

  Sex::
  Sex (Value v)
  : ::xml_schema::String (_xsd_Sex_literals_[v])
  {
  }

  Sex::
  Sex (const char* v)
  : ::xml_schema::String (v)
  {
  }

  Sex::
  Sex (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  Sex::
  Sex (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Sex::
  Sex (const Sex& v,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Sex& Sex::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Sex_literals_[v]);

    return *this;
  }


  // PatientType
  // 

  PatientType::
  PatientType (Value v)
  : ::xml_schema::String (_xsd_PatientType_literals_[v])
  {
  }

  PatientType::
  PatientType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  PatientType::
  PatientType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  PatientType::
  PatientType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  PatientType::
  PatientType (const PatientType& v,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  PatientType& PatientType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_PatientType_literals_[v]);

    return *this;
  }


  // ContainmentTree
  // 

  const ContainmentTree::ExtensionOptional& ContainmentTree::
  Extension () const
  {
    return this->Extension_;
  }

  ContainmentTree::ExtensionOptional& ContainmentTree::
  Extension ()
  {
    return this->Extension_;
  }

  void ContainmentTree::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void ContainmentTree::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void ContainmentTree::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const ContainmentTree::EntrySequence& ContainmentTree::
  Entry () const
  {
    return this->Entry_;
  }

  ContainmentTree::EntrySequence& ContainmentTree::
  Entry ()
  {
    return this->Entry_;
  }

  void ContainmentTree::
  Entry (const EntrySequence& s)
  {
    this->Entry_ = s;
  }

  const ContainmentTree::HandleRefOptional& ContainmentTree::
  HandleRef () const
  {
    return this->HandleRef_;
  }

  ContainmentTree::HandleRefOptional& ContainmentTree::
  HandleRef ()
  {
    return this->HandleRef_;
  }

  void ContainmentTree::
  HandleRef (const HandleRefType& x)
  {
    this->HandleRef_.set (x);
  }

  void ContainmentTree::
  HandleRef (const HandleRefOptional& x)
  {
    this->HandleRef_ = x;
  }

  void ContainmentTree::
  HandleRef (::std::unique_ptr< HandleRefType > x)
  {
    this->HandleRef_.set (std::move (x));
  }

  const ContainmentTree::ParentHandleRefOptional& ContainmentTree::
  ParentHandleRef () const
  {
    return this->ParentHandleRef_;
  }

  ContainmentTree::ParentHandleRefOptional& ContainmentTree::
  ParentHandleRef ()
  {
    return this->ParentHandleRef_;
  }

  void ContainmentTree::
  ParentHandleRef (const ParentHandleRefType& x)
  {
    this->ParentHandleRef_.set (x);
  }

  void ContainmentTree::
  ParentHandleRef (const ParentHandleRefOptional& x)
  {
    this->ParentHandleRef_ = x;
  }

  void ContainmentTree::
  ParentHandleRef (::std::unique_ptr< ParentHandleRefType > x)
  {
    this->ParentHandleRef_.set (std::move (x));
  }

  const ContainmentTree::EntryTypeOptional& ContainmentTree::
  EntryType1 () const
  {
    return this->EntryType_;
  }

  ContainmentTree::EntryTypeOptional& ContainmentTree::
  EntryType1 ()
  {
    return this->EntryType_;
  }

  void ContainmentTree::
  EntryType1 (const EntryTypeType& x)
  {
    this->EntryType_.set (x);
  }

  void ContainmentTree::
  EntryType1 (const EntryTypeOptional& x)
  {
    this->EntryType_ = x;
  }

  void ContainmentTree::
  EntryType1 (::std::unique_ptr< EntryTypeType > x)
  {
    this->EntryType_.set (std::move (x));
  }

  const ContainmentTree::ChildrenCountOptional& ContainmentTree::
  ChildrenCount () const
  {
    return this->ChildrenCount_;
  }

  ContainmentTree::ChildrenCountOptional& ContainmentTree::
  ChildrenCount ()
  {
    return this->ChildrenCount_;
  }

  void ContainmentTree::
  ChildrenCount (const ChildrenCountType& x)
  {
    this->ChildrenCount_.set (x);
  }

  void ContainmentTree::
  ChildrenCount (const ChildrenCountOptional& x)
  {
    this->ChildrenCount_ = x;
  }


  // ContainmentTreeEntry
  // 

  const ContainmentTreeEntry::ExtensionOptional& ContainmentTreeEntry::
  Extension () const
  {
    return this->Extension_;
  }

  ContainmentTreeEntry::ExtensionOptional& ContainmentTreeEntry::
  Extension ()
  {
    return this->Extension_;
  }

  void ContainmentTreeEntry::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void ContainmentTreeEntry::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void ContainmentTreeEntry::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const ContainmentTreeEntry::TypeOptional& ContainmentTreeEntry::
  Type () const
  {
    return this->Type_;
  }

  ContainmentTreeEntry::TypeOptional& ContainmentTreeEntry::
  Type ()
  {
    return this->Type_;
  }

  void ContainmentTreeEntry::
  Type (const TypeType& x)
  {
    this->Type_.set (x);
  }

  void ContainmentTreeEntry::
  Type (const TypeOptional& x)
  {
    this->Type_ = x;
  }

  void ContainmentTreeEntry::
  Type (::std::unique_ptr< TypeType > x)
  {
    this->Type_.set (std::move (x));
  }

  const ContainmentTreeEntry::HandleRefOptional& ContainmentTreeEntry::
  HandleRef () const
  {
    return this->HandleRef_;
  }

  ContainmentTreeEntry::HandleRefOptional& ContainmentTreeEntry::
  HandleRef ()
  {
    return this->HandleRef_;
  }

  void ContainmentTreeEntry::
  HandleRef (const HandleRefType& x)
  {
    this->HandleRef_.set (x);
  }

  void ContainmentTreeEntry::
  HandleRef (const HandleRefOptional& x)
  {
    this->HandleRef_ = x;
  }

  void ContainmentTreeEntry::
  HandleRef (::std::unique_ptr< HandleRefType > x)
  {
    this->HandleRef_.set (std::move (x));
  }

  const ContainmentTreeEntry::ParentHandleRefOptional& ContainmentTreeEntry::
  ParentHandleRef () const
  {
    return this->ParentHandleRef_;
  }

  ContainmentTreeEntry::ParentHandleRefOptional& ContainmentTreeEntry::
  ParentHandleRef ()
  {
    return this->ParentHandleRef_;
  }

  void ContainmentTreeEntry::
  ParentHandleRef (const ParentHandleRefType& x)
  {
    this->ParentHandleRef_.set (x);
  }

  void ContainmentTreeEntry::
  ParentHandleRef (const ParentHandleRefOptional& x)
  {
    this->ParentHandleRef_ = x;
  }

  void ContainmentTreeEntry::
  ParentHandleRef (::std::unique_ptr< ParentHandleRefType > x)
  {
    this->ParentHandleRef_.set (std::move (x));
  }

  const ContainmentTreeEntry::EntryTypeOptional& ContainmentTreeEntry::
  EntryType () const
  {
    return this->EntryType_;
  }

  ContainmentTreeEntry::EntryTypeOptional& ContainmentTreeEntry::
  EntryType ()
  {
    return this->EntryType_;
  }

  void ContainmentTreeEntry::
  EntryType (const EntryTypeType& x)
  {
    this->EntryType_.set (x);
  }

  void ContainmentTreeEntry::
  EntryType (const EntryTypeOptional& x)
  {
    this->EntryType_ = x;
  }

  void ContainmentTreeEntry::
  EntryType (::std::unique_ptr< EntryTypeType > x)
  {
    this->EntryType_.set (std::move (x));
  }

  const ContainmentTreeEntry::ChildrenCountOptional& ContainmentTreeEntry::
  ChildrenCount () const
  {
    return this->ChildrenCount_;
  }

  ContainmentTreeEntry::ChildrenCountOptional& ContainmentTreeEntry::
  ChildrenCount ()
  {
    return this->ChildrenCount_;
  }

  void ContainmentTreeEntry::
  ChildrenCount (const ChildrenCountType& x)
  {
    this->ChildrenCount_.set (x);
  }

  void ContainmentTreeEntry::
  ChildrenCount (const ChildrenCountOptional& x)
  {
    this->ChildrenCount_ = x;
  }


  // ClinicalInfo
  // 

  const ClinicalInfo::ExtensionOptional& ClinicalInfo::
  Extension () const
  {
    return this->Extension_;
  }

  ClinicalInfo::ExtensionOptional& ClinicalInfo::
  Extension ()
  {
    return this->Extension_;
  }

  void ClinicalInfo::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void ClinicalInfo::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void ClinicalInfo::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const ClinicalInfo::TypeType& ClinicalInfo::
  Type () const
  {
    return this->Type_.get ();
  }

  ClinicalInfo::TypeType& ClinicalInfo::
  Type ()
  {
    return this->Type_.get ();
  }

  void ClinicalInfo::
  Type (const TypeType& x)
  {
    this->Type_.set (x);
  }

  void ClinicalInfo::
  Type (::std::unique_ptr< TypeType > x)
  {
    this->Type_.set (std::move (x));
  }

  const ClinicalInfo::RelatedMeasurementSequence& ClinicalInfo::
  RelatedMeasurement () const
  {
    return this->RelatedMeasurement_;
  }

  ClinicalInfo::RelatedMeasurementSequence& ClinicalInfo::
  RelatedMeasurement ()
  {
    return this->RelatedMeasurement_;
  }

  void ClinicalInfo::
  RelatedMeasurement (const RelatedMeasurementSequence& s)
  {
    this->RelatedMeasurement_ = s;
  }

  const ClinicalInfo::MeasuredValueOptional& ClinicalInfo::
  MeasuredValue () const
  {
    return this->MeasuredValue_;
  }

  ClinicalInfo::MeasuredValueOptional& ClinicalInfo::
  MeasuredValue ()
  {
    return this->MeasuredValue_;
  }

  void ClinicalInfo::
  MeasuredValue (const MeasuredValueType& x)
  {
    this->MeasuredValue_.set (x);
  }

  void ClinicalInfo::
  MeasuredValue (const MeasuredValueOptional& x)
  {
    this->MeasuredValue_ = x;
  }


  // Order
  // 

  const Order::ExtensionOptional& Order::
  Extension () const
  {
    return this->Extension_;
  }

  Order::ExtensionOptional& Order::
  Extension ()
  {
    return this->Extension_;
  }

  void Order::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void Order::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void Order::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const Order::VisitNumberOptional& Order::
  VisitNumber () const
  {
    return this->VisitNumber_;
  }

  Order::VisitNumberOptional& Order::
  VisitNumber ()
  {
    return this->VisitNumber_;
  }

  void Order::
  VisitNumber (const VisitNumberType& x)
  {
    this->VisitNumber_.set (x);
  }

  void Order::
  VisitNumber (const VisitNumberOptional& x)
  {
    this->VisitNumber_ = x;
  }

  void Order::
  VisitNumber (::std::unique_ptr< VisitNumberType > x)
  {
    this->VisitNumber_.set (std::move (x));
  }

  const Order::PlacerOrderNumberType& Order::
  PlacerOrderNumber () const
  {
    return this->PlacerOrderNumber_.get ();
  }

  Order::PlacerOrderNumberType& Order::
  PlacerOrderNumber ()
  {
    return this->PlacerOrderNumber_.get ();
  }

  void Order::
  PlacerOrderNumber (const PlacerOrderNumberType& x)
  {
    this->PlacerOrderNumber_.set (x);
  }

  void Order::
  PlacerOrderNumber (::std::unique_ptr< PlacerOrderNumberType > x)
  {
    this->PlacerOrderNumber_.set (std::move (x));
  }

  const Order::FillerOrderNumberOptional& Order::
  FillerOrderNumber () const
  {
    return this->FillerOrderNumber_;
  }

  Order::FillerOrderNumberOptional& Order::
  FillerOrderNumber ()
  {
    return this->FillerOrderNumber_;
  }

  void Order::
  FillerOrderNumber (const FillerOrderNumberType& x)
  {
    this->FillerOrderNumber_.set (x);
  }

  void Order::
  FillerOrderNumber (const FillerOrderNumberOptional& x)
  {
    this->FillerOrderNumber_ = x;
  }

  void Order::
  FillerOrderNumber (::std::unique_ptr< FillerOrderNumberType > x)
  {
    this->FillerOrderNumber_.set (std::move (x));
  }

  const Order::PatientType& Order::
  Patient () const
  {
    return this->Patient_.get ();
  }

  Order::PatientType& Order::
  Patient ()
  {
    return this->Patient_.get ();
  }

  void Order::
  Patient (const PatientType& x)
  {
    this->Patient_.set (x);
  }

  void Order::
  Patient (::std::unique_ptr< PatientType > x)
  {
    this->Patient_.set (std::move (x));
  }

  const Order::ReferringPhysicianOptional& Order::
  ReferringPhysician () const
  {
    return this->ReferringPhysician_;
  }

  Order::ReferringPhysicianOptional& Order::
  ReferringPhysician ()
  {
    return this->ReferringPhysician_;
  }

  void Order::
  ReferringPhysician (const ReferringPhysicianType& x)
  {
    this->ReferringPhysician_.set (x);
  }

  void Order::
  ReferringPhysician (const ReferringPhysicianOptional& x)
  {
    this->ReferringPhysician_ = x;
  }

  void Order::
  ReferringPhysician (::std::unique_ptr< ReferringPhysicianType > x)
  {
    this->ReferringPhysician_.set (std::move (x));
  }

  const Order::RequestingPhysicianOptional& Order::
  RequestingPhysician () const
  {
    return this->RequestingPhysician_;
  }

  Order::RequestingPhysicianOptional& Order::
  RequestingPhysician ()
  {
    return this->RequestingPhysician_;
  }

  void Order::
  RequestingPhysician (const RequestingPhysicianType& x)
  {
    this->RequestingPhysician_.set (x);
  }

  void Order::
  RequestingPhysician (const RequestingPhysicianOptional& x)
  {
    this->RequestingPhysician_ = x;
  }

  void Order::
  RequestingPhysician (::std::unique_ptr< RequestingPhysicianType > x)
  {
    this->RequestingPhysician_.set (std::move (x));
  }

  const Order::ReasonSequence& Order::
  Reason () const
  {
    return this->Reason_;
  }

  Order::ReasonSequence& Order::
  Reason ()
  {
    return this->Reason_;
  }

  void Order::
  Reason (const ReasonSequence& s)
  {
    this->Reason_ = s;
  }

  const Order::DangerCodeSequence& Order::
  DangerCode () const
  {
    return this->DangerCode_;
  }

  Order::DangerCodeSequence& Order::
  DangerCode ()
  {
    return this->DangerCode_;
  }

  void Order::
  DangerCode (const DangerCodeSequence& s)
  {
    this->DangerCode_ = s;
  }

  const Order::RelevantClinicalInfoSequence& Order::
  RelevantClinicalInfo () const
  {
    return this->RelevantClinicalInfo_;
  }

  Order::RelevantClinicalInfoSequence& Order::
  RelevantClinicalInfo ()
  {
    return this->RelevantClinicalInfo_;
  }

  void Order::
  RelevantClinicalInfo (const RelevantClinicalInfoSequence& s)
  {
    this->RelevantClinicalInfo_ = s;
  }

  const Order::ImagingProcedureSequence& Order::
  ImagingProcedure () const
  {
    return this->ImagingProcedure_;
  }

  Order::ImagingProcedureSequence& Order::
  ImagingProcedure ()
  {
    return this->ImagingProcedure_;
  }

  void Order::
  ImagingProcedure (const ImagingProcedureSequence& s)
  {
    this->ImagingProcedure_ = s;
  }

  const Order::RequestedOrderDetailOptional& Order::
  RequestedOrderDetail () const
  {
    return this->RequestedOrderDetail_;
  }

  Order::RequestedOrderDetailOptional& Order::
  RequestedOrderDetail ()
  {
    return this->RequestedOrderDetail_;
  }

  void Order::
  RequestedOrderDetail (const RequestedOrderDetailType& x)
  {
    this->RequestedOrderDetail_.set (x);
  }

  void Order::
  RequestedOrderDetail (const RequestedOrderDetailOptional& x)
  {
    this->RequestedOrderDetail_ = x;
  }

  void Order::
  RequestedOrderDetail (::std::unique_ptr< RequestedOrderDetailType > x)
  {
    this->RequestedOrderDetail_.set (std::move (x));
  }

  const Order::PerformedOrderDetailOptional& Order::
  PerformedOrderDetail () const
  {
    return this->PerformedOrderDetail_;
  }

  Order::PerformedOrderDetailOptional& Order::
  PerformedOrderDetail ()
  {
    return this->PerformedOrderDetail_;
  }

  void Order::
  PerformedOrderDetail (const PerformedOrderDetailType& x)
  {
    this->PerformedOrderDetail_.set (x);
  }

  void Order::
  PerformedOrderDetail (const PerformedOrderDetailOptional& x)
  {
    this->PerformedOrderDetail_ = x;
  }

  void Order::
  PerformedOrderDetail (::std::unique_ptr< PerformedOrderDetailType > x)
  {
    this->PerformedOrderDetail_.set (std::move (x));
  }


  // OrderDetail
  // 

  const OrderDetail::ExtensionOptional& OrderDetail::
  Extension () const
  {
    return this->Extension_;
  }

  OrderDetail::ExtensionOptional& OrderDetail::
  Extension ()
  {
    return this->Extension_;
  }

  void OrderDetail::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void OrderDetail::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void OrderDetail::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const OrderDetail::StartOptional& OrderDetail::
  Start () const
  {
    return this->Start_;
  }

  OrderDetail::StartOptional& OrderDetail::
  Start ()
  {
    return this->Start_;
  }

  void OrderDetail::
  Start (const StartType& x)
  {
    this->Start_.set (x);
  }

  void OrderDetail::
  Start (const StartOptional& x)
  {
    this->Start_ = x;
  }

  void OrderDetail::
  Start (::std::unique_ptr< StartType > x)
  {
    this->Start_.set (std::move (x));
  }

  const OrderDetail::EndOptional& OrderDetail::
  End () const
  {
    return this->End_;
  }

  OrderDetail::EndOptional& OrderDetail::
  End ()
  {
    return this->End_;
  }

  void OrderDetail::
  End (const EndType& x)
  {
    this->End_.set (x);
  }

  void OrderDetail::
  End (const EndOptional& x)
  {
    this->End_ = x;
  }

  void OrderDetail::
  End (::std::unique_ptr< EndType > x)
  {
    this->End_.set (std::move (x));
  }

  const OrderDetail::PerformerSequence& OrderDetail::
  Performer () const
  {
    return this->Performer_;
  }

  OrderDetail::PerformerSequence& OrderDetail::
  Performer ()
  {
    return this->Performer_;
  }

  void OrderDetail::
  Performer (const PerformerSequence& s)
  {
    this->Performer_ = s;
  }

  const OrderDetail::ServiceSequence& OrderDetail::
  Service () const
  {
    return this->Service_;
  }

  OrderDetail::ServiceSequence& OrderDetail::
  Service ()
  {
    return this->Service_;
  }

  void OrderDetail::
  Service (const ServiceSequence& s)
  {
    this->Service_ = s;
  }


  // ImagingProcedure
  // 

  const ImagingProcedure::ExtensionOptional& ImagingProcedure::
  Extension () const
  {
    return this->Extension_;
  }

  ImagingProcedure::ExtensionOptional& ImagingProcedure::
  Extension ()
  {
    return this->Extension_;
  }

  void ImagingProcedure::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void ImagingProcedure::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void ImagingProcedure::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const ImagingProcedure::AccessionIdentifierType& ImagingProcedure::
  AccessionIdentifier () const
  {
    return this->AccessionIdentifier_.get ();
  }

  ImagingProcedure::AccessionIdentifierType& ImagingProcedure::
  AccessionIdentifier ()
  {
    return this->AccessionIdentifier_.get ();
  }

  void ImagingProcedure::
  AccessionIdentifier (const AccessionIdentifierType& x)
  {
    this->AccessionIdentifier_.set (x);
  }

  void ImagingProcedure::
  AccessionIdentifier (::std::unique_ptr< AccessionIdentifierType > x)
  {
    this->AccessionIdentifier_.set (std::move (x));
  }

  const ImagingProcedure::RequestedProcedureIDType& ImagingProcedure::
  RequestedProcedureID () const
  {
    return this->RequestedProcedureID_.get ();
  }

  ImagingProcedure::RequestedProcedureIDType& ImagingProcedure::
  RequestedProcedureID ()
  {
    return this->RequestedProcedureID_.get ();
  }

  void ImagingProcedure::
  RequestedProcedureID (const RequestedProcedureIDType& x)
  {
    this->RequestedProcedureID_.set (x);
  }

  void ImagingProcedure::
  RequestedProcedureID (::std::unique_ptr< RequestedProcedureIDType > x)
  {
    this->RequestedProcedureID_.set (std::move (x));
  }

  const ImagingProcedure::StudyInstanceUIDType& ImagingProcedure::
  StudyInstanceUID () const
  {
    return this->StudyInstanceUID_.get ();
  }

  ImagingProcedure::StudyInstanceUIDType& ImagingProcedure::
  StudyInstanceUID ()
  {
    return this->StudyInstanceUID_.get ();
  }

  void ImagingProcedure::
  StudyInstanceUID (const StudyInstanceUIDType& x)
  {
    this->StudyInstanceUID_.set (x);
  }

  void ImagingProcedure::
  StudyInstanceUID (::std::unique_ptr< StudyInstanceUIDType > x)
  {
    this->StudyInstanceUID_.set (std::move (x));
  }

  const ImagingProcedure::ScheduledProcedureStepIDType& ImagingProcedure::
  ScheduledProcedureStepID () const
  {
    return this->ScheduledProcedureStepID_.get ();
  }

  ImagingProcedure::ScheduledProcedureStepIDType& ImagingProcedure::
  ScheduledProcedureStepID ()
  {
    return this->ScheduledProcedureStepID_.get ();
  }

  void ImagingProcedure::
  ScheduledProcedureStepID (const ScheduledProcedureStepIDType& x)
  {
    this->ScheduledProcedureStepID_.set (x);
  }

  void ImagingProcedure::
  ScheduledProcedureStepID (::std::unique_ptr< ScheduledProcedureStepIDType > x)
  {
    this->ScheduledProcedureStepID_.set (std::move (x));
  }

  const ImagingProcedure::ModalityOptional& ImagingProcedure::
  Modality () const
  {
    return this->Modality_;
  }

  ImagingProcedure::ModalityOptional& ImagingProcedure::
  Modality ()
  {
    return this->Modality_;
  }

  void ImagingProcedure::
  Modality (const ModalityType& x)
  {
    this->Modality_.set (x);
  }

  void ImagingProcedure::
  Modality (const ModalityOptional& x)
  {
    this->Modality_ = x;
  }

  void ImagingProcedure::
  Modality (::std::unique_ptr< ModalityType > x)
  {
    this->Modality_.set (std::move (x));
  }

  const ImagingProcedure::ProtocolCodeOptional& ImagingProcedure::
  ProtocolCode () const
  {
    return this->ProtocolCode_;
  }

  ImagingProcedure::ProtocolCodeOptional& ImagingProcedure::
  ProtocolCode ()
  {
    return this->ProtocolCode_;
  }

  void ImagingProcedure::
  ProtocolCode (const ProtocolCodeType& x)
  {
    this->ProtocolCode_.set (x);
  }

  void ImagingProcedure::
  ProtocolCode (const ProtocolCodeOptional& x)
  {
    this->ProtocolCode_ = x;
  }

  void ImagingProcedure::
  ProtocolCode (::std::unique_ptr< ProtocolCodeType > x)
  {
    this->ProtocolCode_.set (std::move (x));
  }


  // MDIBContainmentTree
  // 
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace CDM
{
  // Handle
  //

  Handle::
  Handle ()
  : ::xml_schema::String ()
  {
  }

  Handle::
  Handle (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  Handle::
  Handle (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  Handle::
  Handle (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  Handle::
  Handle (const Handle& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  Handle::
  Handle (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  Handle::
  Handle (const ::xercesc::DOMAttr& a,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  Handle::
  Handle (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  Handle* Handle::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Handle (*this, f, c);
  }

  Handle::
  ~Handle ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Handle >
  _xsd_Handle_type_factory_init (
    "Handle",
    "http://domain-model-uri/15/04");

  // HandleRef
  //

  HandleRef::
  HandleRef ()
  : ::xml_schema::String ()
  {
  }

  HandleRef::
  HandleRef (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  HandleRef::
  HandleRef (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  HandleRef::
  HandleRef (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  HandleRef::
  HandleRef (const HandleRef& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  HandleRef::
  HandleRef (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  HandleRef::
  HandleRef (const ::xercesc::DOMAttr& a,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  HandleRef::
  HandleRef (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  HandleRef* HandleRef::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HandleRef (*this, f, c);
  }

  HandleRef::
  ~HandleRef ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, HandleRef >
  _xsd_HandleRef_type_factory_init (
    "HandleRef",
    "http://domain-model-uri/15/04");

  // Timestamp
  //

  Timestamp::
  Timestamp (const ::xml_schema::UnsignedLong& _xsd_UnsignedLong_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (_xsd_UnsignedLong_base)
  {
  }

  Timestamp::
  Timestamp (const Timestamp& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  Timestamp::
  Timestamp (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  Timestamp::
  Timestamp (const ::xercesc::DOMAttr& a,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  Timestamp::
  Timestamp (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  Timestamp* Timestamp::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Timestamp (*this, f, c);
  }

  Timestamp::
  ~Timestamp ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Timestamp >
  _xsd_Timestamp_type_factory_init (
    "Timestamp",
    "http://domain-model-uri/15/04");

  // VersionCounter
  //

  VersionCounter::
  VersionCounter (const ::xml_schema::UnsignedLong& _xsd_UnsignedLong_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (_xsd_UnsignedLong_base)
  {
  }

  VersionCounter::
  VersionCounter (const VersionCounter& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  VersionCounter::
  VersionCounter (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  VersionCounter::
  VersionCounter (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  VersionCounter::
  VersionCounter (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  VersionCounter* VersionCounter::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VersionCounter (*this, f, c);
  }

  VersionCounter::
  ~VersionCounter ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, VersionCounter >
  _xsd_VersionCounter_type_factory_init (
    "VersionCounter",
    "http://domain-model-uri/15/04");

  // ReferencedVersion
  //

  ReferencedVersion::
  ReferencedVersion (const ::xml_schema::UnsignedLong& _xsd_UnsignedLong_base)
  : ::CDM::VersionCounter (_xsd_UnsignedLong_base)
  {
  }

  ReferencedVersion::
  ReferencedVersion (const ReferencedVersion& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::VersionCounter (x, f, c)
  {
  }

  ReferencedVersion::
  ReferencedVersion (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::VersionCounter (e, f, c)
  {
  }

  ReferencedVersion::
  ReferencedVersion (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::VersionCounter (a, f, c)
  {
  }

  ReferencedVersion::
  ReferencedVersion (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::VersionCounter (s, e, f, c)
  {
  }

  ReferencedVersion* ReferencedVersion::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReferencedVersion (*this, f, c);
  }

  ReferencedVersion::
  ~ReferencedVersion ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ReferencedVersion >
  _xsd_ReferencedVersion_type_factory_init (
    "ReferencedVersion",
    "http://domain-model-uri/15/04");

  // Activation
  //

  Activation::
  Activation (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Activation_convert ();
  }

  Activation::
  Activation (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Activation_convert ();
  }

  Activation::
  Activation (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Activation_convert ();
  }

  Activation* Activation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Activation (*this, f, c);
  }

  Activation::Value Activation::
  _xsd_Activation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Activation_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Activation_indexes_,
                      _xsd_Activation_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_Activation_indexes_ + 2 || _xsd_Activation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Activation::
  _xsd_Activation_literals_[2] =
  {
    "On",
    "Off"
  };

  const Activation::Value Activation::
  _xsd_Activation_indexes_[2] =
  {
    ::CDM::Activation::Off,
    ::CDM::Activation::On
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Activation >
  _xsd_Activation_type_factory_init (
    "Activation",
    "http://domain-model-uri/15/04");

  // CodeIdentifier
  //

  CodeIdentifier::
  CodeIdentifier ()
  : ::xml_schema::String ()
  {
  }

  CodeIdentifier::
  CodeIdentifier (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  CodeIdentifier::
  CodeIdentifier (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  CodeIdentifier::
  CodeIdentifier (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  CodeIdentifier::
  CodeIdentifier (const CodeIdentifier& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  CodeIdentifier::
  CodeIdentifier (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  CodeIdentifier::
  CodeIdentifier (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  CodeIdentifier::
  CodeIdentifier (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  CodeIdentifier* CodeIdentifier::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CodeIdentifier (*this, f, c);
  }

  CodeIdentifier::
  ~CodeIdentifier ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CodeIdentifier >
  _xsd_CodeIdentifier_type_factory_init (
    "CodeIdentifier",
    "http://domain-model-uri/15/04");

  // LocalizedTextRef
  //

  LocalizedTextRef::
  LocalizedTextRef ()
  : ::xml_schema::String ()
  {
  }

  LocalizedTextRef::
  LocalizedTextRef (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  LocalizedTextRef::
  LocalizedTextRef (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  LocalizedTextRef::
  LocalizedTextRef (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  LocalizedTextRef::
  LocalizedTextRef (const LocalizedTextRef& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  LocalizedTextRef::
  LocalizedTextRef (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  LocalizedTextRef::
  LocalizedTextRef (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  LocalizedTextRef::
  LocalizedTextRef (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  LocalizedTextRef* LocalizedTextRef::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LocalizedTextRef (*this, f, c);
  }

  LocalizedTextRef::
  ~LocalizedTextRef ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LocalizedTextRef >
  _xsd_LocalizedTextRef_type_factory_init (
    "LocalizedTextRef",
    "http://domain-model-uri/15/04");

  // LocalizedText
  //

  LocalizedText::
  LocalizedText ()
  : ::xml_schema::String (),
    Lang_ (this),
    Ref_ (this),
    Version_ (this)
  {
  }

  LocalizedText::
  LocalizedText (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    Lang_ (this),
    Ref_ (this),
    Version_ (this)
  {
  }

  LocalizedText::
  LocalizedText (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    Lang_ (this),
    Ref_ (this),
    Version_ (this)
  {
  }

  LocalizedText::
  LocalizedText (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    Lang_ (this),
    Ref_ (this),
    Version_ (this)
  {
  }

  LocalizedText::
  LocalizedText (const LocalizedText& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c),
    Lang_ (x.Lang_, f, this),
    Ref_ (x.Ref_, f, this),
    Version_ (x.Version_, f, this)
  {
  }

  LocalizedText::
  LocalizedText (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (e, f | ::xml_schema::Flags::base, c),
    Lang_ (this),
    Ref_ (this),
    Version_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void LocalizedText::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Lang" && n.namespace_ ().empty ())
      {
        this->Lang_.set (LangTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Ref" && n.namespace_ ().empty ())
      {
        this->Ref_.set (RefTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Version" && n.namespace_ ().empty ())
      {
        this->Version_.set (VersionTraits::create (i, f, this));
        continue;
      }
    }
  }

  LocalizedText* LocalizedText::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LocalizedText (*this, f, c);
  }

  LocalizedText& LocalizedText::
  operator= (const LocalizedText& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::String& > (*this) = x;
      this->Lang_ = x.Lang_;
      this->Ref_ = x.Ref_;
      this->Version_ = x.Version_;
    }

    return *this;
  }

  LocalizedText::
  ~LocalizedText ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LocalizedText >
  _xsd_LocalizedText_type_factory_init (
    "LocalizedText",
    "http://domain-model-uri/15/04");

  // InstanceIdentifier
  //

  InstanceIdentifier::
  InstanceIdentifier (const RootType& root)
  : ::xml_schema::Type (),
    Extension_ (this),
    IdentifierName_ (this),
    root_ (root, this),
    extension_ (this)
  {
  }

  InstanceIdentifier::
  InstanceIdentifier (const InstanceIdentifier& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    IdentifierName_ (x.IdentifierName_, f, this),
    root_ (x.root_, f, this),
    extension_ (x.extension_, f, this)
  {
  }

  InstanceIdentifier::
  InstanceIdentifier (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    IdentifierName_ (this),
    root_ (this),
    extension_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void InstanceIdentifier::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // IdentifierName
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "IdentifierName",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< IdentifierNameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< IdentifierNameType > r (
            dynamic_cast< IdentifierNameType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->IdentifierName_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "root" && n.namespace_ ().empty ())
      {
        this->root_.set (RootTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "extension" && n.namespace_ ().empty ())
      {
        this->extension_.set (ExtensionTraits1::create (i, f, this));
        continue;
      }
    }

    if (!root_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "root",
        "");
    }
  }

  InstanceIdentifier* InstanceIdentifier::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InstanceIdentifier (*this, f, c);
  }

  InstanceIdentifier& InstanceIdentifier::
  operator= (const InstanceIdentifier& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->IdentifierName_ = x.IdentifierName_;
      this->root_ = x.root_;
      this->extension_ = x.extension_;
    }

    return *this;
  }

  InstanceIdentifier::
  ~InstanceIdentifier ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, InstanceIdentifier >
  _xsd_InstanceIdentifier_type_factory_init (
    "InstanceIdentifier",
    "http://domain-model-uri/15/04");

  // CodedValue
  //

  CodedValue::
  CodedValue (const CodeIdType& CodeId)
  : ::xml_schema::Type (),
    Extension_ (this),
    CodingSystemId_ (this),
    CodingSystemName_ (this),
    VersionId_ (this),
    CodeId_ (CodeId, this),
    ConceptDescription_ (this)
  {
  }

  CodedValue::
  CodedValue (::std::unique_ptr< CodeIdType > CodeId)
  : ::xml_schema::Type (),
    Extension_ (this),
    CodingSystemId_ (this),
    CodingSystemName_ (this),
    VersionId_ (this),
    CodeId_ (std::move (CodeId), this),
    ConceptDescription_ (this)
  {
  }

  CodedValue::
  CodedValue (const CodedValue& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    CodingSystemId_ (x.CodingSystemId_, f, this),
    CodingSystemName_ (x.CodingSystemName_, f, this),
    VersionId_ (x.VersionId_, f, this),
    CodeId_ (x.CodeId_, f, this),
    ConceptDescription_ (x.ConceptDescription_, f, this)
  {
  }

  CodedValue::
  CodedValue (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    CodingSystemId_ (this),
    CodingSystemName_ (this),
    VersionId_ (this),
    CodeId_ (this),
    ConceptDescription_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CodedValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // CodingSystemId
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CodingSystemId",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< CodingSystemIdType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CodingSystemId_)
          {
            ::std::unique_ptr< CodingSystemIdType > r (
              dynamic_cast< CodingSystemIdType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CodingSystemId_.set (::std::move (r));
            continue;
          }
        }
      }

      // CodingSystemName
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CodingSystemName",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< CodingSystemNameType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< CodingSystemNameType > r (
            dynamic_cast< CodingSystemNameType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->CodingSystemName_.push_back (::std::move (r));
          continue;
        }
      }

      // VersionId
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "VersionId",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< VersionIdType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->VersionId_)
          {
            ::std::unique_ptr< VersionIdType > r (
              dynamic_cast< VersionIdType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->VersionId_.set (::std::move (r));
            continue;
          }
        }
      }

      // CodeId
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CodeId",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< CodeIdType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!CodeId_.present ())
          {
            ::std::unique_ptr< CodeIdType > r (
              dynamic_cast< CodeIdType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CodeId_.set (::std::move (r));
            continue;
          }
        }
      }

      // ConceptDescription
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ConceptDescription",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ConceptDescriptionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ConceptDescriptionType > r (
            dynamic_cast< ConceptDescriptionType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ConceptDescription_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!CodeId_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CodeId",
        "http://domain-model-uri/15/04");
    }
  }

  CodedValue* CodedValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CodedValue (*this, f, c);
  }

  CodedValue& CodedValue::
  operator= (const CodedValue& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->CodingSystemId_ = x.CodingSystemId_;
      this->CodingSystemName_ = x.CodingSystemName_;
      this->VersionId_ = x.VersionId_;
      this->CodeId_ = x.CodeId_;
      this->ConceptDescription_ = x.ConceptDescription_;
    }

    return *this;
  }

  CodedValue::
  ~CodedValue ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CodedValue >
  _xsd_CodedValue_type_factory_init (
    "CodedValue",
    "http://domain-model-uri/15/04");

  // CodedWithTranslations
  //

  CodedWithTranslations::
  CodedWithTranslations (const CodeIdType& CodeId)
  : ::CDM::CodedValue (CodeId),
    Translation_ (this)
  {
  }

  CodedWithTranslations::
  CodedWithTranslations (::std::unique_ptr< CodeIdType > CodeId)
  : ::CDM::CodedValue (std::move (CodeId)),
    Translation_ (this)
  {
  }

  CodedWithTranslations::
  CodedWithTranslations (const CodedWithTranslations& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::CodedValue (x, f, c),
    Translation_ (x.Translation_, f, this)
  {
  }

  CodedWithTranslations::
  CodedWithTranslations (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::CodedValue (e, f | ::xml_schema::Flags::base, c),
    Translation_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CodedWithTranslations::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::CodedValue::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Translation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Translation",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< TranslationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< TranslationType > r (
            dynamic_cast< TranslationType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Translation_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  CodedWithTranslations* CodedWithTranslations::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CodedWithTranslations (*this, f, c);
  }

  CodedWithTranslations& CodedWithTranslations::
  operator= (const CodedWithTranslations& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::CodedValue& > (*this) = x;
      this->Translation_ = x.Translation_;
    }

    return *this;
  }

  CodedWithTranslations::
  ~CodedWithTranslations ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CodedWithTranslations >
  _xsd_CodedWithTranslations_type_factory_init (
    "CodedWithTranslations",
    "http://domain-model-uri/15/04");

  // CauseInfo
  //

  CauseInfo::
  CauseInfo ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Remedy_ (this),
    Description_ (this)
  {
  }

  CauseInfo::
  CauseInfo (const CauseInfo& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Remedy_ (x.Remedy_, f, this),
    Description_ (x.Description_, f, this)
  {
  }

  CauseInfo::
  CauseInfo (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Remedy_ (this),
    Description_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CauseInfo::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // Remedy
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Remedy",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< RemedyType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Remedy_)
          {
            ::std::unique_ptr< RemedyType > r (
              dynamic_cast< RemedyType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Remedy_.set (::std::move (r));
            continue;
          }
        }
      }

      // Description
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Description",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< DescriptionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< DescriptionType > r (
            dynamic_cast< DescriptionType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Description_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  CauseInfo* CauseInfo::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CauseInfo (*this, f, c);
  }

  CauseInfo& CauseInfo::
  operator= (const CauseInfo& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Remedy_ = x.Remedy_;
      this->Description_ = x.Description_;
    }

    return *this;
  }

  CauseInfo::
  ~CauseInfo ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CauseInfo >
  _xsd_CauseInfo_type_factory_init (
    "CauseInfo",
    "http://domain-model-uri/15/04");

  // RemedyInfo
  //

  RemedyInfo::
  RemedyInfo ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Description_ (this)
  {
  }

  RemedyInfo::
  RemedyInfo (const RemedyInfo& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Description_ (x.Description_, f, this)
  {
  }

  RemedyInfo::
  RemedyInfo (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Description_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void RemedyInfo::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // Description
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Description",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< DescriptionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< DescriptionType > r (
            dynamic_cast< DescriptionType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Description_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  RemedyInfo* RemedyInfo::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RemedyInfo (*this, f, c);
  }

  RemedyInfo& RemedyInfo::
  operator= (const RemedyInfo& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Description_ = x.Description_;
    }

    return *this;
  }

  RemedyInfo::
  ~RemedyInfo ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RemedyInfo >
  _xsd_RemedyInfo_type_factory_init (
    "RemedyInfo",
    "http://domain-model-uri/15/04");

  // Range
  //

  Range::
  Range ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Lower_ (this),
    Upper_ (this),
    StepWidth_ (this)
  {
  }

  Range::
  Range (const Range& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Lower_ (x.Lower_, f, this),
    Upper_ (x.Upper_, f, this),
    StepWidth_ (x.StepWidth_, f, this)
  {
  }

  Range::
  Range (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Lower_ (this),
    Upper_ (this),
    StepWidth_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Range::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Lower" && n.namespace_ ().empty ())
      {
        this->Lower_.set (LowerTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Upper" && n.namespace_ ().empty ())
      {
        this->Upper_.set (UpperTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "StepWidth" && n.namespace_ ().empty ())
      {
        this->StepWidth_.set (StepWidthTraits::create (i, f, this));
        continue;
      }
    }
  }

  Range* Range::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Range (*this, f, c);
  }

  Range& Range::
  operator= (const Range& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Lower_ = x.Lower_;
      this->Upper_ = x.Upper_;
      this->StepWidth_ = x.StepWidth_;
    }

    return *this;
  }

  Range::
  ~Range ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Range >
  _xsd_Range_type_factory_init (
    "Range",
    "http://domain-model-uri/15/04");

  // Measure
  //

  Measure::
  Measure (const MeasurementUnitType& MeasurementUnit)
  : ::xml_schema::Type (),
    Extension_ (this),
    MeasurementUnit_ (MeasurementUnit, this),
    MeasuredValue_ (this)
  {
  }

  Measure::
  Measure (::std::unique_ptr< MeasurementUnitType > MeasurementUnit)
  : ::xml_schema::Type (),
    Extension_ (this),
    MeasurementUnit_ (std::move (MeasurementUnit), this),
    MeasuredValue_ (this)
  {
  }

  Measure::
  Measure (const Measure& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    MeasurementUnit_ (x.MeasurementUnit_, f, this),
    MeasuredValue_ (x.MeasuredValue_, f, this)
  {
  }

  Measure::
  Measure (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    MeasurementUnit_ (this),
    MeasuredValue_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Measure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // MeasurementUnit
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MeasurementUnit",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< MeasurementUnitType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MeasurementUnit_.present ())
          {
            ::std::unique_ptr< MeasurementUnitType > r (
              dynamic_cast< MeasurementUnitType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MeasurementUnit_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!MeasurementUnit_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MeasurementUnit",
        "http://domain-model-uri/15/04");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MeasuredValue" && n.namespace_ ().empty ())
      {
        this->MeasuredValue_.set (MeasuredValueTraits::create (i, f, this));
        continue;
      }
    }
  }

  Measure* Measure::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Measure (*this, f, c);
  }

  Measure& Measure::
  operator= (const Measure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->MeasurementUnit_ = x.MeasurementUnit_;
      this->MeasuredValue_ = x.MeasuredValue_;
    }

    return *this;
  }

  Measure::
  ~Measure ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Measure >
  _xsd_Measure_type_factory_init (
    "Measure",
    "http://domain-model-uri/15/04");

  // IntendedUse
  //

  IntendedUse::
  IntendedUse (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_IntendedUse_convert ();
  }

  IntendedUse::
  IntendedUse (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_IntendedUse_convert ();
  }

  IntendedUse::
  IntendedUse (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_IntendedUse_convert ();
  }

  IntendedUse* IntendedUse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class IntendedUse (*this, f, c);
  }

  IntendedUse::Value IntendedUse::
  _xsd_IntendedUse_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_IntendedUse_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_IntendedUse_indexes_,
                      _xsd_IntendedUse_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_IntendedUse_indexes_ + 4 || _xsd_IntendedUse_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const IntendedUse::
  _xsd_IntendedUse_literals_[4] =
  {
    "Inf",
    "MedA",
    "MedB",
    "MedC"
  };

  const IntendedUse::Value IntendedUse::
  _xsd_IntendedUse_indexes_[4] =
  {
    ::CDM::IntendedUse::Inf,
    ::CDM::IntendedUse::MedA,
    ::CDM::IntendedUse::MedB,
    ::CDM::IntendedUse::MedC
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, IntendedUse >
  _xsd_IntendedUse_type_factory_init (
    "IntendedUse",
    "http://domain-model-uri/15/04");

  // AbstractDescriptor
  //

  AbstractDescriptor::
  AbstractDescriptor (const HandleType& Handle)
  : ::xml_schema::Type (),
    Extension_ (this),
    Type_ (this),
    Handle_ (Handle, this),
    DescriptorVersion_ (this),
    IntendedUse_ (this)
  {
  }

  AbstractDescriptor::
  AbstractDescriptor (const AbstractDescriptor& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Type_ (x.Type_, f, this),
    Handle_ (x.Handle_, f, this),
    DescriptorVersion_ (x.DescriptorVersion_, f, this),
    IntendedUse_ (x.IntendedUse_, f, this)
  {
  }

  AbstractDescriptor::
  AbstractDescriptor (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Type_ (this),
    Handle_ (this),
    DescriptorVersion_ (this),
    IntendedUse_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // Type
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Type",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< TypeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Type_)
          {
            ::std::unique_ptr< TypeType > r (
              dynamic_cast< TypeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Type_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Handle" && n.namespace_ ().empty ())
      {
        this->Handle_.set (HandleTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "DescriptorVersion" && n.namespace_ ().empty ())
      {
        this->DescriptorVersion_.set (DescriptorVersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "IntendedUse" && n.namespace_ ().empty ())
      {
        this->IntendedUse_.set (IntendedUseTraits::create (i, f, this));
        continue;
      }
    }

    if (!Handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Handle",
        "");
    }
  }

  AbstractDescriptor* AbstractDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractDescriptor (*this, f, c);
  }

  AbstractDescriptor& AbstractDescriptor::
  operator= (const AbstractDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Type_ = x.Type_;
      this->Handle_ = x.Handle_;
      this->DescriptorVersion_ = x.DescriptorVersion_;
      this->IntendedUse_ = x.IntendedUse_;
    }

    return *this;
  }

  AbstractDescriptor::
  ~AbstractDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractDescriptor >
  _xsd_AbstractDescriptor_type_factory_init (
    "AbstractDescriptor",
    "http://domain-model-uri/15/04");

  // AbstractState
  //

  AbstractState::
  AbstractState (const DescriptorHandleType& DescriptorHandle)
  : ::xml_schema::Type (),
    Extension_ (this),
    Handle_ (this),
    StateVersion_ (this),
    DescriptorHandle_ (DescriptorHandle, this),
    DescriptorVersion_ (this)
  {
  }

  AbstractState::
  AbstractState (const AbstractState& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Handle_ (x.Handle_, f, this),
    StateVersion_ (x.StateVersion_, f, this),
    DescriptorHandle_ (x.DescriptorHandle_, f, this),
    DescriptorVersion_ (x.DescriptorVersion_, f, this)
  {
  }

  AbstractState::
  AbstractState (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Handle_ (this),
    StateVersion_ (this),
    DescriptorHandle_ (this),
    DescriptorVersion_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Handle" && n.namespace_ ().empty ())
      {
        this->Handle_.set (HandleTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "StateVersion" && n.namespace_ ().empty ())
      {
        this->StateVersion_.set (StateVersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "DescriptorHandle" && n.namespace_ ().empty ())
      {
        this->DescriptorHandle_.set (DescriptorHandleTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "DescriptorVersion" && n.namespace_ ().empty ())
      {
        this->DescriptorVersion_.set (DescriptorVersionTraits::create (i, f, this));
        continue;
      }
    }

    if (!DescriptorHandle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "DescriptorHandle",
        "");
    }
  }

  AbstractState* AbstractState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractState (*this, f, c);
  }

  AbstractState& AbstractState::
  operator= (const AbstractState& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Handle_ = x.Handle_;
      this->StateVersion_ = x.StateVersion_;
      this->DescriptorHandle_ = x.DescriptorHandle_;
      this->DescriptorVersion_ = x.DescriptorVersion_;
    }

    return *this;
  }

  AbstractState::
  ~AbstractState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractState >
  _xsd_AbstractState_type_factory_init (
    "AbstractState",
    "http://domain-model-uri/15/04");

  // MDDescription
  //

  MDDescription::
  MDDescription ()
  : ::xml_schema::Type (),
    Extension_ (this),
    MDS_ (this),
    DescriptionVersion_ (this)
  {
  }

  MDDescription::
  MDDescription (const MDDescription& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    MDS_ (x.MDS_, f, this),
    DescriptionVersion_ (x.DescriptionVersion_, f, this)
  {
  }

  MDDescription::
  MDDescription (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    MDS_ (this),
    DescriptionVersion_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MDDescription::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // MDS
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MDS",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< MDSType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< MDSType > r (
            dynamic_cast< MDSType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->MDS_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "DescriptionVersion" && n.namespace_ ().empty ())
      {
        this->DescriptionVersion_.set (DescriptionVersionTraits::create (i, f, this));
        continue;
      }
    }
  }

  MDDescription* MDDescription::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MDDescription (*this, f, c);
  }

  MDDescription& MDDescription::
  operator= (const MDDescription& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->MDS_ = x.MDS_;
      this->DescriptionVersion_ = x.DescriptionVersion_;
    }

    return *this;
  }

  MDDescription::
  ~MDDescription ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MDDescription >
  _xsd_MDDescription_type_factory_init (
    "MDDescription",
    "http://domain-model-uri/15/04");

  // MDState
  //

  MDState::
  MDState ()
  : ::xml_schema::Type (),
    Extension_ (this),
    State_ (this),
    StateVersion_ (this)
  {
  }

  MDState::
  MDState (const MDState& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    State_ (x.State_, f, this),
    StateVersion_ (x.StateVersion_, f, this)
  {
  }

  MDState::
  MDState (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    State_ (this),
    StateVersion_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MDState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // State
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "State",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< StateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< StateType > r (
            dynamic_cast< StateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->State_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "StateVersion" && n.namespace_ ().empty ())
      {
        this->StateVersion_.set (StateVersionTraits::create (i, f, this));
        continue;
      }
    }
  }

  MDState* MDState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MDState (*this, f, c);
  }

  MDState& MDState::
  operator= (const MDState& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->State_ = x.State_;
      this->StateVersion_ = x.StateVersion_;
    }

    return *this;
  }

  MDState::
  ~MDState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MDState >
  _xsd_MDState_type_factory_init (
    "MDState",
    "http://domain-model-uri/15/04");

  // MDIB
  //

  MDIB::
  MDIB (const MDDescriptionType& MDDescription,
        const MDStateType& MDState,
        const MDIBVersionType& MDIBVersion)
  : ::xml_schema::Type (),
    Extension_ (this),
    MDDescription_ (MDDescription, this),
    MDState_ (MDState, this),
    MDIBVersion_ (MDIBVersion, this)
  {
  }

  MDIB::
  MDIB (::std::unique_ptr< MDDescriptionType > MDDescription,
        ::std::unique_ptr< MDStateType > MDState,
        const MDIBVersionType& MDIBVersion)
  : ::xml_schema::Type (),
    Extension_ (this),
    MDDescription_ (std::move (MDDescription), this),
    MDState_ (std::move (MDState), this),
    MDIBVersion_ (MDIBVersion, this)
  {
  }

  MDIB::
  MDIB (const MDIB& x,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    MDDescription_ (x.MDDescription_, f, this),
    MDState_ (x.MDState_, f, this),
    MDIBVersion_ (x.MDIBVersion_, f, this)
  {
  }

  MDIB::
  MDIB (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    MDDescription_ (this),
    MDState_ (this),
    MDIBVersion_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MDIB::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // MDDescription
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MDDescription",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< MDDescriptionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MDDescription_.present ())
          {
            ::std::unique_ptr< MDDescriptionType > r (
              dynamic_cast< MDDescriptionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MDDescription_.set (::std::move (r));
            continue;
          }
        }
      }

      // MDState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MDState",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< MDStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MDState_.present ())
          {
            ::std::unique_ptr< MDStateType > r (
              dynamic_cast< MDStateType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MDState_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!MDDescription_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MDDescription",
        "http://domain-model-uri/15/04");
    }

    if (!MDState_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MDState",
        "http://domain-model-uri/15/04");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MDIBVersion" && n.namespace_ () == "http://domain-model-uri/15/04")
      {
        this->MDIBVersion_.set (MDIBVersionTraits::create (i, f, this));
        continue;
      }
    }

    if (!MDIBVersion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "MDIBVersion",
        "http://domain-model-uri/15/04");
    }
  }

  MDIB* MDIB::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MDIB (*this, f, c);
  }

  MDIB& MDIB::
  operator= (const MDIB& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->MDDescription_ = x.MDDescription_;
      this->MDState_ = x.MDState_;
      this->MDIBVersion_ = x.MDIBVersion_;
    }

    return *this;
  }

  MDIB::
  ~MDIB ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MDIB >
  _xsd_MDIB_type_factory_init (
    "MDIB",
    "http://domain-model-uri/15/04");

  // ProductionSpecification
  //

  ProductionSpecification::
  ProductionSpecification (const SpecTypeType& specType,
                           const ProductionSpecType& productionSpec)
  : ::xml_schema::Type (),
    specType_ (specType, this),
    productionSpec_ (productionSpec, this),
    componentId_ (this)
  {
  }

  ProductionSpecification::
  ProductionSpecification (::std::unique_ptr< SpecTypeType > specType,
                           const ProductionSpecType& productionSpec)
  : ::xml_schema::Type (),
    specType_ (std::move (specType), this),
    productionSpec_ (productionSpec, this),
    componentId_ (this)
  {
  }

  ProductionSpecification::
  ProductionSpecification (::std::unique_ptr< SpecTypeType > specType,
                           ::std::unique_ptr< ProductionSpecType > productionSpec)
  : ::xml_schema::Type (),
    specType_ (std::move (specType), this),
    productionSpec_ (std::move (productionSpec), this),
    componentId_ (this)
  {
  }

  ProductionSpecification::
  ProductionSpecification (const ProductionSpecification& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    specType_ (x.specType_, f, this),
    productionSpec_ (x.productionSpec_, f, this),
    componentId_ (x.componentId_, f, this)
  {
  }

  ProductionSpecification::
  ProductionSpecification (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    specType_ (this),
    productionSpec_ (this),
    componentId_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ProductionSpecification::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // specType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "specType",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< SpecTypeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!specType_.present ())
          {
            ::std::unique_ptr< SpecTypeType > r (
              dynamic_cast< SpecTypeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->specType_.set (::std::move (r));
            continue;
          }
        }
      }

      // productionSpec
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "productionSpec",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ProductionSpecType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!productionSpec_.present ())
          {
            ::std::unique_ptr< ProductionSpecType > r (
              dynamic_cast< ProductionSpecType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->productionSpec_.set (::std::move (r));
            continue;
          }
        }
      }

      // componentId
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "componentId",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ComponentIdType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->componentId_)
          {
            ::std::unique_ptr< ComponentIdType > r (
              dynamic_cast< ComponentIdType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->componentId_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!specType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "specType",
        "http://domain-model-uri/15/04");
    }

    if (!productionSpec_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "productionSpec",
        "http://domain-model-uri/15/04");
    }
  }

  ProductionSpecification* ProductionSpecification::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ProductionSpecification (*this, f, c);
  }

  ProductionSpecification& ProductionSpecification::
  operator= (const ProductionSpecification& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->specType_ = x.specType_;
      this->productionSpec_ = x.productionSpec_;
      this->componentId_ = x.componentId_;
    }

    return *this;
  }

  ProductionSpecification::
  ~ProductionSpecification ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ProductionSpecification >
  _xsd_ProductionSpecification_type_factory_init (
    "ProductionSpecification",
    "http://domain-model-uri/15/04");

  // SystemMetaData
  //

  SystemMetaData::
  SystemMetaData ()
  : ::xml_schema::Type (),
    Extension_ (this),
    UDI_ (this),
    Manufacturer_ (this),
    ModelName_ (this),
    ModelNumber_ (this),
    SerialNumber_ (this)
  {
  }

  SystemMetaData::
  SystemMetaData (const SystemMetaData& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    UDI_ (x.UDI_, f, this),
    Manufacturer_ (x.Manufacturer_, f, this),
    ModelName_ (x.ModelName_, f, this),
    ModelNumber_ (x.ModelNumber_, f, this),
    SerialNumber_ (x.SerialNumber_, f, this)
  {
  }

  SystemMetaData::
  SystemMetaData (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    UDI_ (this),
    Manufacturer_ (this),
    ModelName_ (this),
    ModelNumber_ (this),
    SerialNumber_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SystemMetaData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // UDI
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "UDI",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< UDIType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->UDI_)
          {
            ::std::unique_ptr< UDIType > r (
              dynamic_cast< UDIType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->UDI_.set (::std::move (r));
            continue;
          }
        }
      }

      // Manufacturer
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Manufacturer",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ManufacturerType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ManufacturerType > r (
            dynamic_cast< ManufacturerType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Manufacturer_.push_back (::std::move (r));
          continue;
        }
      }

      // ModelName
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ModelName",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ModelNameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ModelNameType > r (
            dynamic_cast< ModelNameType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ModelName_.push_back (::std::move (r));
          continue;
        }
      }

      // ModelNumber
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ModelNumber",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ModelNumberType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ModelNumberType > r (
            dynamic_cast< ModelNumberType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ModelNumber_.push_back (::std::move (r));
          continue;
        }
      }

      // SerialNumber
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SerialNumber",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< SerialNumberType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< SerialNumberType > r (
            dynamic_cast< SerialNumberType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->SerialNumber_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SystemMetaData* SystemMetaData::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SystemMetaData (*this, f, c);
  }

  SystemMetaData& SystemMetaData::
  operator= (const SystemMetaData& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->UDI_ = x.UDI_;
      this->Manufacturer_ = x.Manufacturer_;
      this->ModelName_ = x.ModelName_;
      this->ModelNumber_ = x.ModelNumber_;
      this->SerialNumber_ = x.SerialNumber_;
    }

    return *this;
  }

  SystemMetaData::
  ~SystemMetaData ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SystemMetaData >
  _xsd_SystemMetaData_type_factory_init (
    "SystemMetaData",
    "http://domain-model-uri/15/04");

  // SystemContext
  //

  SystemContext::
  SystemContext (const HandleType& Handle)
  : ::CDM::AbstractDescriptor (Handle),
    PatientContext_ (this),
    LocationContext_ (this),
    EnsembleContext_ (this),
    OperatorContext_ (this),
    WorkflowContext_ (this)
  {
  }

  SystemContext::
  SystemContext (const SystemContext& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (x, f, c),
    PatientContext_ (x.PatientContext_, f, this),
    LocationContext_ (x.LocationContext_, f, this),
    EnsembleContext_ (x.EnsembleContext_, f, this),
    OperatorContext_ (x.OperatorContext_, f, this),
    WorkflowContext_ (x.WorkflowContext_, f, this)
  {
  }

  SystemContext::
  SystemContext (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (e, f | ::xml_schema::Flags::base, c),
    PatientContext_ (this),
    LocationContext_ (this),
    EnsembleContext_ (this),
    OperatorContext_ (this),
    WorkflowContext_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SystemContext::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PatientContext
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "PatientContext",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< PatientContextType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->PatientContext_)
          {
            ::std::unique_ptr< PatientContextType > r (
              dynamic_cast< PatientContextType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->PatientContext_.set (::std::move (r));
            continue;
          }
        }
      }

      // LocationContext
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "LocationContext",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< LocationContextType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->LocationContext_)
          {
            ::std::unique_ptr< LocationContextType > r (
              dynamic_cast< LocationContextType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->LocationContext_.set (::std::move (r));
            continue;
          }
        }
      }

      // EnsembleContext
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "EnsembleContext",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< EnsembleContextType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->EnsembleContext_)
          {
            ::std::unique_ptr< EnsembleContextType > r (
              dynamic_cast< EnsembleContextType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->EnsembleContext_.set (::std::move (r));
            continue;
          }
        }
      }

      // OperatorContext
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OperatorContext",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< OperatorContextType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->OperatorContext_)
          {
            ::std::unique_ptr< OperatorContextType > r (
              dynamic_cast< OperatorContextType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OperatorContext_.set (::std::move (r));
            continue;
          }
        }
      }

      // WorkflowContext
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "WorkflowContext",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< WorkflowContextType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->WorkflowContext_)
          {
            ::std::unique_ptr< WorkflowContextType > r (
              dynamic_cast< WorkflowContextType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->WorkflowContext_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  SystemContext* SystemContext::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SystemContext (*this, f, c);
  }

  SystemContext& SystemContext::
  operator= (const SystemContext& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDescriptor& > (*this) = x;
      this->PatientContext_ = x.PatientContext_;
      this->LocationContext_ = x.LocationContext_;
      this->EnsembleContext_ = x.EnsembleContext_;
      this->OperatorContext_ = x.OperatorContext_;
      this->WorkflowContext_ = x.WorkflowContext_;
    }

    return *this;
  }

  SystemContext::
  ~SystemContext ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SystemContext >
  _xsd_SystemContext_type_factory_init (
    "SystemContext",
    "http://domain-model-uri/15/04");

  // AbstractDeviceComponent
  //

  AbstractDeviceComponent::
  AbstractDeviceComponent (const HandleType& Handle)
  : ::CDM::AbstractDescriptor (Handle),
    ProductionSpecification_ (this)
  {
  }

  AbstractDeviceComponent::
  AbstractDeviceComponent (const AbstractDeviceComponent& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (x, f, c),
    ProductionSpecification_ (x.ProductionSpecification_, f, this)
  {
  }

  AbstractDeviceComponent::
  AbstractDeviceComponent (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (e, f | ::xml_schema::Flags::base, c),
    ProductionSpecification_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractDeviceComponent::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ProductionSpecification
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ProductionSpecification",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ProductionSpecificationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ProductionSpecificationType > r (
            dynamic_cast< ProductionSpecificationType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ProductionSpecification_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  AbstractDeviceComponent* AbstractDeviceComponent::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractDeviceComponent (*this, f, c);
  }

  AbstractDeviceComponent& AbstractDeviceComponent::
  operator= (const AbstractDeviceComponent& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDescriptor& > (*this) = x;
      this->ProductionSpecification_ = x.ProductionSpecification_;
    }

    return *this;
  }

  AbstractDeviceComponent::
  ~AbstractDeviceComponent ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractDeviceComponent >
  _xsd_AbstractDeviceComponent_type_factory_init (
    "AbstractDeviceComponent",
    "http://domain-model-uri/15/04");

  // AbstractMDSDescriptor
  //

  AbstractMDSDescriptor::
  AbstractMDSDescriptor (const HandleType& Handle,
                         const ContextType& Context)
  : ::CDM::AbstractDeviceComponent (Handle),
    MetaData_ (this),
    Context_ (Context, this),
    Clock_ (this)
  {
  }

  AbstractMDSDescriptor::
  AbstractMDSDescriptor (const HandleType& Handle,
                         ::std::unique_ptr< ContextType > Context)
  : ::CDM::AbstractDeviceComponent (Handle),
    MetaData_ (this),
    Context_ (std::move (Context), this),
    Clock_ (this)
  {
  }

  AbstractMDSDescriptor::
  AbstractMDSDescriptor (const AbstractMDSDescriptor& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponent (x, f, c),
    MetaData_ (x.MetaData_, f, this),
    Context_ (x.Context_, f, this),
    Clock_ (x.Clock_, f, this)
  {
  }

  AbstractMDSDescriptor::
  AbstractMDSDescriptor (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponent (e, f | ::xml_schema::Flags::base, c),
    MetaData_ (this),
    Context_ (this),
    Clock_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractMDSDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDeviceComponent::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MetaData
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MetaData",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< MetaDataType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->MetaData_)
          {
            ::std::unique_ptr< MetaDataType > r (
              dynamic_cast< MetaDataType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MetaData_.set (::std::move (r));
            continue;
          }
        }
      }

      // Context
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Context",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ContextType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Context_.present ())
          {
            ::std::unique_ptr< ContextType > r (
              dynamic_cast< ContextType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Context_.set (::std::move (r));
            continue;
          }
        }
      }

      // Clock
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Clock",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ClockType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Clock_)
          {
            ::std::unique_ptr< ClockType > r (
              dynamic_cast< ClockType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Clock_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Context_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Context",
        "http://domain-model-uri/15/04");
    }
  }

  AbstractMDSDescriptor* AbstractMDSDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractMDSDescriptor (*this, f, c);
  }

  AbstractMDSDescriptor& AbstractMDSDescriptor::
  operator= (const AbstractMDSDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDeviceComponent& > (*this) = x;
      this->MetaData_ = x.MetaData_;
      this->Context_ = x.Context_;
      this->Clock_ = x.Clock_;
    }

    return *this;
  }

  AbstractMDSDescriptor::
  ~AbstractMDSDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractMDSDescriptor >
  _xsd_AbstractMDSDescriptor_type_factory_init (
    "AbstractMDSDescriptor",
    "http://domain-model-uri/15/04");

  // HydraMDSDescriptor
  //

  HydraMDSDescriptor::
  HydraMDSDescriptor (const HandleType& Handle,
                      const ContextType& Context)
  : ::CDM::AbstractMDSDescriptor (Handle,
                                  Context),
    SCO_ (this),
    AlertSystem_ (this),
    VMD_ (this)
  {
  }

  HydraMDSDescriptor::
  HydraMDSDescriptor (const HandleType& Handle,
                      ::std::unique_ptr< ContextType > Context)
  : ::CDM::AbstractMDSDescriptor (Handle,
                                  std::move (Context)),
    SCO_ (this),
    AlertSystem_ (this),
    VMD_ (this)
  {
  }

  HydraMDSDescriptor::
  HydraMDSDescriptor (const HydraMDSDescriptor& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractMDSDescriptor (x, f, c),
    SCO_ (x.SCO_, f, this),
    AlertSystem_ (x.AlertSystem_, f, this),
    VMD_ (x.VMD_, f, this)
  {
  }

  HydraMDSDescriptor::
  HydraMDSDescriptor (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractMDSDescriptor (e, f | ::xml_schema::Flags::base, c),
    SCO_ (this),
    AlertSystem_ (this),
    VMD_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void HydraMDSDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMDSDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SCO
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SCO",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< SCOType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->SCO_)
          {
            ::std::unique_ptr< SCOType > r (
              dynamic_cast< SCOType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SCO_.set (::std::move (r));
            continue;
          }
        }
      }

      // AlertSystem
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AlertSystem",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< AlertSystemType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AlertSystem_)
          {
            ::std::unique_ptr< AlertSystemType > r (
              dynamic_cast< AlertSystemType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AlertSystem_.set (::std::move (r));
            continue;
          }
        }
      }

      // VMD
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "VMD",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< VMDType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< VMDType > r (
            dynamic_cast< VMDType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->VMD_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  HydraMDSDescriptor* HydraMDSDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HydraMDSDescriptor (*this, f, c);
  }

  HydraMDSDescriptor& HydraMDSDescriptor::
  operator= (const HydraMDSDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMDSDescriptor& > (*this) = x;
      this->SCO_ = x.SCO_;
      this->AlertSystem_ = x.AlertSystem_;
      this->VMD_ = x.VMD_;
    }

    return *this;
  }

  HydraMDSDescriptor::
  ~HydraMDSDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, HydraMDSDescriptor >
  _xsd_HydraMDSDescriptor_type_factory_init (
    "HydraMDSDescriptor",
    "http://domain-model-uri/15/04");

  // ComponentState
  //

  ComponentState::
  ComponentState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractState (DescriptorHandle),
    CalibrationInfo_ (this),
    ComponentActivationState_ (this),
    OperatingHours_ (this),
    OperatingCycles_ (this)
  {
  }

  ComponentState::
  ComponentState (const ComponentState& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::CDM::AbstractState (x, f, c),
    CalibrationInfo_ (x.CalibrationInfo_, f, this),
    ComponentActivationState_ (x.ComponentActivationState_, f, this),
    OperatingHours_ (x.OperatingHours_, f, this),
    OperatingCycles_ (x.OperatingCycles_, f, this)
  {
  }

  ComponentState::
  ComponentState (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::CDM::AbstractState (e, f | ::xml_schema::Flags::base, c),
    CalibrationInfo_ (this),
    ComponentActivationState_ (this),
    OperatingHours_ (this),
    OperatingCycles_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ComponentState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CalibrationInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CalibrationInfo",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< CalibrationInfoType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CalibrationInfo_)
          {
            ::std::unique_ptr< CalibrationInfoType > r (
              dynamic_cast< CalibrationInfoType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CalibrationInfo_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ComponentActivationState" && n.namespace_ () == "http://domain-model-uri/15/04")
      {
        this->ComponentActivationState_.set (ComponentActivationStateTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "OperatingHours" && n.namespace_ ().empty ())
      {
        this->OperatingHours_.set (OperatingHoursTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "OperatingCycles" && n.namespace_ ().empty ())
      {
        this->OperatingCycles_.set (OperatingCyclesTraits::create (i, f, this));
        continue;
      }
    }
  }

  ComponentState* ComponentState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ComponentState (*this, f, c);
  }

  ComponentState& ComponentState::
  operator= (const ComponentState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractState& > (*this) = x;
      this->CalibrationInfo_ = x.CalibrationInfo_;
      this->ComponentActivationState_ = x.ComponentActivationState_;
      this->OperatingHours_ = x.OperatingHours_;
      this->OperatingCycles_ = x.OperatingCycles_;
    }

    return *this;
  }

  ComponentState::
  ~ComponentState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ComponentState >
  _xsd_ComponentState_type_factory_init (
    "ComponentState",
    "http://domain-model-uri/15/04");

  // AbstractMDSState
  //

  AbstractMDSState::
  AbstractMDSState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::ComponentState (DescriptorHandle),
    Lang_ (this)
  {
  }

  AbstractMDSState::
  AbstractMDSState (const AbstractMDSState& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::CDM::ComponentState (x, f, c),
    Lang_ (x.Lang_, f, this)
  {
  }

  AbstractMDSState::
  AbstractMDSState (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::CDM::ComponentState (e, f | ::xml_schema::Flags::base, c),
    Lang_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractMDSState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::ComponentState::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Lang" && n.namespace_ ().empty ())
      {
        this->Lang_.set (LangTraits::create (i, f, this));
        continue;
      }
    }
  }

  AbstractMDSState* AbstractMDSState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractMDSState (*this, f, c);
  }

  AbstractMDSState& AbstractMDSState::
  operator= (const AbstractMDSState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::ComponentState& > (*this) = x;
      this->Lang_ = x.Lang_;
    }

    return *this;
  }

  AbstractMDSState::
  ~AbstractMDSState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractMDSState >
  _xsd_AbstractMDSState_type_factory_init (
    "AbstractMDSState",
    "http://domain-model-uri/15/04");

  // HydraMDSState
  //

  HydraMDSState::
  HydraMDSState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractMDSState (DescriptorHandle)
  {
  }

  HydraMDSState::
  HydraMDSState (const HydraMDSState& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AbstractMDSState (x, f, c)
  {
  }

  HydraMDSState::
  HydraMDSState (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AbstractMDSState (e, f, c)
  {
  }

  HydraMDSState* HydraMDSState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HydraMDSState (*this, f, c);
  }

  HydraMDSState::
  ~HydraMDSState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, HydraMDSState >
  _xsd_HydraMDSState_type_factory_init (
    "HydraMDSState",
    "http://domain-model-uri/15/04");

  // AlertConditionKind
  //

  AlertConditionKind::
  AlertConditionKind (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_AlertConditionKind_convert ();
  }

  AlertConditionKind::
  AlertConditionKind (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_AlertConditionKind_convert ();
  }

  AlertConditionKind::
  AlertConditionKind (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_AlertConditionKind_convert ();
  }

  AlertConditionKind* AlertConditionKind::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertConditionKind (*this, f, c);
  }

  AlertConditionKind::Value AlertConditionKind::
  _xsd_AlertConditionKind_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AlertConditionKind_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_AlertConditionKind_indexes_,
                      _xsd_AlertConditionKind_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_AlertConditionKind_indexes_ + 3 || _xsd_AlertConditionKind_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const AlertConditionKind::
  _xsd_AlertConditionKind_literals_[3] =
  {
    "Phy",
    "Tec",
    "Oth"
  };

  const AlertConditionKind::Value AlertConditionKind::
  _xsd_AlertConditionKind_indexes_[3] =
  {
    ::CDM::AlertConditionKind::Oth,
    ::CDM::AlertConditionKind::Phy,
    ::CDM::AlertConditionKind::Tec
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertConditionKind >
  _xsd_AlertConditionKind_type_factory_init (
    "AlertConditionKind",
    "http://domain-model-uri/15/04");

  // AlertConditionPriority
  //

  AlertConditionPriority::
  AlertConditionPriority (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_AlertConditionPriority_convert ();
  }

  AlertConditionPriority::
  AlertConditionPriority (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_AlertConditionPriority_convert ();
  }

  AlertConditionPriority::
  AlertConditionPriority (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_AlertConditionPriority_convert ();
  }

  AlertConditionPriority* AlertConditionPriority::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertConditionPriority (*this, f, c);
  }

  AlertConditionPriority::Value AlertConditionPriority::
  _xsd_AlertConditionPriority_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AlertConditionPriority_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_AlertConditionPriority_indexes_,
                      _xsd_AlertConditionPriority_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_AlertConditionPriority_indexes_ + 4 || _xsd_AlertConditionPriority_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const AlertConditionPriority::
  _xsd_AlertConditionPriority_literals_[4] =
  {
    "Lo",
    "Me",
    "Hi",
    "None"
  };

  const AlertConditionPriority::Value AlertConditionPriority::
  _xsd_AlertConditionPriority_indexes_[4] =
  {
    ::CDM::AlertConditionPriority::Hi,
    ::CDM::AlertConditionPriority::Lo,
    ::CDM::AlertConditionPriority::Me,
    ::CDM::AlertConditionPriority::None
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertConditionPriority >
  _xsd_AlertConditionPriority_type_factory_init (
    "AlertConditionPriority",
    "http://domain-model-uri/15/04");

  // AlertSignalManifestation
  //

  AlertSignalManifestation::
  AlertSignalManifestation (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_AlertSignalManifestation_convert ();
  }

  AlertSignalManifestation::
  AlertSignalManifestation (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_AlertSignalManifestation_convert ();
  }

  AlertSignalManifestation::
  AlertSignalManifestation (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_AlertSignalManifestation_convert ();
  }

  AlertSignalManifestation* AlertSignalManifestation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertSignalManifestation (*this, f, c);
  }

  AlertSignalManifestation::Value AlertSignalManifestation::
  _xsd_AlertSignalManifestation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AlertSignalManifestation_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_AlertSignalManifestation_indexes_,
                      _xsd_AlertSignalManifestation_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_AlertSignalManifestation_indexes_ + 3 || _xsd_AlertSignalManifestation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const AlertSignalManifestation::
  _xsd_AlertSignalManifestation_literals_[3] =
  {
    "Aud",
    "Vis",
    "Tan"
  };

  const AlertSignalManifestation::Value AlertSignalManifestation::
  _xsd_AlertSignalManifestation_indexes_[3] =
  {
    ::CDM::AlertSignalManifestation::Aud,
    ::CDM::AlertSignalManifestation::Tan,
    ::CDM::AlertSignalManifestation::Vis
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertSignalManifestation >
  _xsd_AlertSignalManifestation_type_factory_init (
    "AlertSignalManifestation",
    "http://domain-model-uri/15/04");

  // AbstractAlertDescriptor
  //

  AbstractAlertDescriptor::
  AbstractAlertDescriptor (const HandleType& Handle)
  : ::CDM::AbstractDescriptor (Handle)
  {
  }

  AbstractAlertDescriptor::
  AbstractAlertDescriptor (const AbstractAlertDescriptor& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (x, f, c)
  {
  }

  AbstractAlertDescriptor::
  AbstractAlertDescriptor (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (e, f, c)
  {
  }

  AbstractAlertDescriptor* AbstractAlertDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractAlertDescriptor (*this, f, c);
  }

  AbstractAlertDescriptor::
  ~AbstractAlertDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractAlertDescriptor >
  _xsd_AbstractAlertDescriptor_type_factory_init (
    "AbstractAlertDescriptor",
    "http://domain-model-uri/15/04");

  // AlertSystemDescriptor
  //

  AlertSystemDescriptor::
  AlertSystemDescriptor (const HandleType& Handle)
  : ::CDM::AbstractAlertDescriptor (Handle),
    AlertCondition_ (this),
    AlertSignal_ (this),
    MaxPhysiologicalAlarmListEntries_ (this),
    MaxTechnicalAlarmListEntries_ (this),
    SelfCheckPeriod_ (this)
  {
  }

  AlertSystemDescriptor::
  AlertSystemDescriptor (const AlertSystemDescriptor& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::AbstractAlertDescriptor (x, f, c),
    AlertCondition_ (x.AlertCondition_, f, this),
    AlertSignal_ (x.AlertSignal_, f, this),
    MaxPhysiologicalAlarmListEntries_ (x.MaxPhysiologicalAlarmListEntries_, f, this),
    MaxTechnicalAlarmListEntries_ (x.MaxTechnicalAlarmListEntries_, f, this),
    SelfCheckPeriod_ (x.SelfCheckPeriod_, f, this)
  {
  }

  AlertSystemDescriptor::
  AlertSystemDescriptor (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::AbstractAlertDescriptor (e, f | ::xml_schema::Flags::base, c),
    AlertCondition_ (this),
    AlertSignal_ (this),
    MaxPhysiologicalAlarmListEntries_ (this),
    MaxTechnicalAlarmListEntries_ (this),
    SelfCheckPeriod_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AlertSystemDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractAlertDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AlertCondition
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AlertCondition",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< AlertConditionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< AlertConditionType > r (
            dynamic_cast< AlertConditionType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->AlertCondition_.push_back (::std::move (r));
          continue;
        }
      }

      // AlertSignal
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AlertSignal",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< AlertSignalType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< AlertSignalType > r (
            dynamic_cast< AlertSignalType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->AlertSignal_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MaxPhysiologicalAlarmListEntries" && n.namespace_ ().empty ())
      {
        this->MaxPhysiologicalAlarmListEntries_.set (MaxPhysiologicalAlarmListEntriesTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "MaxTechnicalAlarmListEntries" && n.namespace_ ().empty ())
      {
        this->MaxTechnicalAlarmListEntries_.set (MaxTechnicalAlarmListEntriesTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "SelfCheckPeriod" && n.namespace_ ().empty ())
      {
        this->SelfCheckPeriod_.set (SelfCheckPeriodTraits::create (i, f, this));
        continue;
      }
    }
  }

  AlertSystemDescriptor* AlertSystemDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertSystemDescriptor (*this, f, c);
  }

  AlertSystemDescriptor& AlertSystemDescriptor::
  operator= (const AlertSystemDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractAlertDescriptor& > (*this) = x;
      this->AlertCondition_ = x.AlertCondition_;
      this->AlertSignal_ = x.AlertSignal_;
      this->MaxPhysiologicalAlarmListEntries_ = x.MaxPhysiologicalAlarmListEntries_;
      this->MaxTechnicalAlarmListEntries_ = x.MaxTechnicalAlarmListEntries_;
      this->SelfCheckPeriod_ = x.SelfCheckPeriod_;
    }

    return *this;
  }

  AlertSystemDescriptor::
  ~AlertSystemDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertSystemDescriptor >
  _xsd_AlertSystemDescriptor_type_factory_init (
    "AlertSystemDescriptor",
    "http://domain-model-uri/15/04");

  // AlertConditionDescriptor
  //

  AlertConditionDescriptor::
  AlertConditionDescriptor (const HandleType& Handle,
                            const KindType& Kind,
                            const PriorityType& Priority)
  : ::CDM::AbstractAlertDescriptor (Handle),
    Kind_ (Kind, this),
    Source_ (this),
    Priority_ (Priority, this),
    CauseInfo_ (this)
  {
  }

  AlertConditionDescriptor::
  AlertConditionDescriptor (const HandleType& Handle,
                            ::std::unique_ptr< KindType > Kind,
                            ::std::unique_ptr< PriorityType > Priority)
  : ::CDM::AbstractAlertDescriptor (Handle),
    Kind_ (std::move (Kind), this),
    Source_ (this),
    Priority_ (std::move (Priority), this),
    CauseInfo_ (this)
  {
  }

  AlertConditionDescriptor::
  AlertConditionDescriptor (const AlertConditionDescriptor& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AbstractAlertDescriptor (x, f, c),
    Kind_ (x.Kind_, f, this),
    Source_ (x.Source_, f, this),
    Priority_ (x.Priority_, f, this),
    CauseInfo_ (x.CauseInfo_, f, this)
  {
  }

  AlertConditionDescriptor::
  AlertConditionDescriptor (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AbstractAlertDescriptor (e, f | ::xml_schema::Flags::base, c),
    Kind_ (this),
    Source_ (this),
    Priority_ (this),
    CauseInfo_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AlertConditionDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractAlertDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Kind
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Kind",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< KindType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Kind_.present ())
          {
            ::std::unique_ptr< KindType > r (
              dynamic_cast< KindType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Kind_.set (::std::move (r));
            continue;
          }
        }
      }

      // Source
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Source",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< SourceType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< SourceType > r (
            dynamic_cast< SourceType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Source_.push_back (::std::move (r));
          continue;
        }
      }

      // Priority
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Priority",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< PriorityType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Priority_.present ())
          {
            ::std::unique_ptr< PriorityType > r (
              dynamic_cast< PriorityType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Priority_.set (::std::move (r));
            continue;
          }
        }
      }

      // CauseInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CauseInfo",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< CauseInfoType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< CauseInfoType > r (
            dynamic_cast< CauseInfoType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->CauseInfo_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!Kind_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Kind",
        "http://domain-model-uri/15/04");
    }

    if (!Priority_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Priority",
        "http://domain-model-uri/15/04");
    }
  }

  AlertConditionDescriptor* AlertConditionDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertConditionDescriptor (*this, f, c);
  }

  AlertConditionDescriptor& AlertConditionDescriptor::
  operator= (const AlertConditionDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractAlertDescriptor& > (*this) = x;
      this->Kind_ = x.Kind_;
      this->Source_ = x.Source_;
      this->Priority_ = x.Priority_;
      this->CauseInfo_ = x.CauseInfo_;
    }

    return *this;
  }

  AlertConditionDescriptor::
  ~AlertConditionDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertConditionDescriptor >
  _xsd_AlertConditionDescriptor_type_factory_init (
    "AlertConditionDescriptor",
    "http://domain-model-uri/15/04");

  // AlertSignalDescriptor
  //

  AlertSignalDescriptor::
  AlertSignalDescriptor (const HandleType& Handle,
                         const ConditionSignaledType& ConditionSignaled,
                         const ManifestationType& Manifestation,
                         const LatchingType& Latching)
  : ::CDM::AbstractAlertDescriptor (Handle),
    ConditionSignaled_ (ConditionSignaled, this),
    Manifestation_ (Manifestation, this),
    Latching_ (Latching, this),
    DefaultSignalGenerationDelay_ (this),
    SignalDelegationSupported_ (this),
    AcknowledgementSupported_ (this),
    AcknowledgeTimeout_ (this)
  {
  }

  AlertSignalDescriptor::
  AlertSignalDescriptor (const HandleType& Handle,
                         ::std::unique_ptr< ConditionSignaledType > ConditionSignaled,
                         ::std::unique_ptr< ManifestationType > Manifestation,
                         const LatchingType& Latching)
  : ::CDM::AbstractAlertDescriptor (Handle),
    ConditionSignaled_ (std::move (ConditionSignaled), this),
    Manifestation_ (std::move (Manifestation), this),
    Latching_ (Latching, this),
    DefaultSignalGenerationDelay_ (this),
    SignalDelegationSupported_ (this),
    AcknowledgementSupported_ (this),
    AcknowledgeTimeout_ (this)
  {
  }

  AlertSignalDescriptor::
  AlertSignalDescriptor (const AlertSignalDescriptor& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::AbstractAlertDescriptor (x, f, c),
    ConditionSignaled_ (x.ConditionSignaled_, f, this),
    Manifestation_ (x.Manifestation_, f, this),
    Latching_ (x.Latching_, f, this),
    DefaultSignalGenerationDelay_ (x.DefaultSignalGenerationDelay_, f, this),
    SignalDelegationSupported_ (x.SignalDelegationSupported_, f, this),
    AcknowledgementSupported_ (x.AcknowledgementSupported_, f, this),
    AcknowledgeTimeout_ (x.AcknowledgeTimeout_, f, this)
  {
  }

  AlertSignalDescriptor::
  AlertSignalDescriptor (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::AbstractAlertDescriptor (e, f | ::xml_schema::Flags::base, c),
    ConditionSignaled_ (this),
    Manifestation_ (this),
    Latching_ (this),
    DefaultSignalGenerationDelay_ (this),
    SignalDelegationSupported_ (this),
    AcknowledgementSupported_ (this),
    AcknowledgeTimeout_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AlertSignalDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractAlertDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ConditionSignaled
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ConditionSignaled",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ConditionSignaledType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ConditionSignaled_.present ())
          {
            ::std::unique_ptr< ConditionSignaledType > r (
              dynamic_cast< ConditionSignaledType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ConditionSignaled_.set (::std::move (r));
            continue;
          }
        }
      }

      // Manifestation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Manifestation",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ManifestationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Manifestation_.present ())
          {
            ::std::unique_ptr< ManifestationType > r (
              dynamic_cast< ManifestationType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Manifestation_.set (::std::move (r));
            continue;
          }
        }
      }

      // Latching
      //
      if (n.name () == "Latching" && n.namespace_ () == "http://domain-model-uri/15/04")
      {
        if (!Latching_.present ())
        {
          this->Latching_.set (LatchingTraits::create (i, f, this));
          continue;
        }
      }

      // DefaultSignalGenerationDelay
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DefaultSignalGenerationDelay",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< DefaultSignalGenerationDelayType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DefaultSignalGenerationDelay_)
          {
            ::std::unique_ptr< DefaultSignalGenerationDelayType > r (
              dynamic_cast< DefaultSignalGenerationDelayType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DefaultSignalGenerationDelay_.set (::std::move (r));
            continue;
          }
        }
      }

      // SignalDelegationSupported
      //
      if (n.name () == "SignalDelegationSupported" && n.namespace_ () == "http://domain-model-uri/15/04")
      {
        if (!this->SignalDelegationSupported_)
        {
          this->SignalDelegationSupported_.set (SignalDelegationSupportedTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!ConditionSignaled_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ConditionSignaled",
        "http://domain-model-uri/15/04");
    }

    if (!Manifestation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Manifestation",
        "http://domain-model-uri/15/04");
    }

    if (!Latching_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Latching",
        "http://domain-model-uri/15/04");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "AcknowledgementSupported" && n.namespace_ ().empty ())
      {
        this->AcknowledgementSupported_.set (AcknowledgementSupportedTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "AcknowledgeTimeout" && n.namespace_ ().empty ())
      {
        this->AcknowledgeTimeout_.set (AcknowledgeTimeoutTraits::create (i, f, this));
        continue;
      }
    }
  }

  AlertSignalDescriptor* AlertSignalDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertSignalDescriptor (*this, f, c);
  }

  AlertSignalDescriptor& AlertSignalDescriptor::
  operator= (const AlertSignalDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractAlertDescriptor& > (*this) = x;
      this->ConditionSignaled_ = x.ConditionSignaled_;
      this->Manifestation_ = x.Manifestation_;
      this->Latching_ = x.Latching_;
      this->DefaultSignalGenerationDelay_ = x.DefaultSignalGenerationDelay_;
      this->SignalDelegationSupported_ = x.SignalDelegationSupported_;
      this->AcknowledgementSupported_ = x.AcknowledgementSupported_;
      this->AcknowledgeTimeout_ = x.AcknowledgeTimeout_;
    }

    return *this;
  }

  AlertSignalDescriptor::
  ~AlertSignalDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertSignalDescriptor >
  _xsd_AlertSignalDescriptor_type_factory_init (
    "AlertSignalDescriptor",
    "http://domain-model-uri/15/04");

  // LimitAlertConditionDescriptor
  //

  LimitAlertConditionDescriptor::
  LimitAlertConditionDescriptor (const HandleType& Handle,
                                 const KindType& Kind,
                                 const PriorityType& Priority,
                                 const MaxLimitsType& MaxLimits)
  : ::CDM::AlertConditionDescriptor (Handle,
                                     Kind,
                                     Priority),
    MaxLimits_ (MaxLimits, this),
    AutoLimitSupported_ (this)
  {
  }

  LimitAlertConditionDescriptor::
  LimitAlertConditionDescriptor (const HandleType& Handle,
                                 const KindType& Kind,
                                 const PriorityType& Priority,
                                 ::std::unique_ptr< MaxLimitsType > MaxLimits)
  : ::CDM::AlertConditionDescriptor (Handle,
                                     Kind,
                                     Priority),
    MaxLimits_ (std::move (MaxLimits), this),
    AutoLimitSupported_ (this)
  {
  }

  LimitAlertConditionDescriptor::
  LimitAlertConditionDescriptor (const HandleType& Handle,
                                 ::std::unique_ptr< KindType > Kind,
                                 ::std::unique_ptr< PriorityType > Priority,
                                 ::std::unique_ptr< MaxLimitsType > MaxLimits)
  : ::CDM::AlertConditionDescriptor (Handle,
                                     std::move (Kind),
                                     std::move (Priority)),
    MaxLimits_ (std::move (MaxLimits), this),
    AutoLimitSupported_ (this)
  {
  }

  LimitAlertConditionDescriptor::
  LimitAlertConditionDescriptor (const LimitAlertConditionDescriptor& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::CDM::AlertConditionDescriptor (x, f, c),
    MaxLimits_ (x.MaxLimits_, f, this),
    AutoLimitSupported_ (x.AutoLimitSupported_, f, this)
  {
  }

  LimitAlertConditionDescriptor::
  LimitAlertConditionDescriptor (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::CDM::AlertConditionDescriptor (e, f | ::xml_schema::Flags::base, c),
    MaxLimits_ (this),
    AutoLimitSupported_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void LimitAlertConditionDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AlertConditionDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MaxLimits
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MaxLimits",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< MaxLimitsType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MaxLimits_.present ())
          {
            ::std::unique_ptr< MaxLimitsType > r (
              dynamic_cast< MaxLimitsType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MaxLimits_.set (::std::move (r));
            continue;
          }
        }
      }

      // AutoLimitSupported
      //
      if (n.name () == "AutoLimitSupported" && n.namespace_ () == "http://domain-model-uri/15/04")
      {
        if (!this->AutoLimitSupported_)
        {
          this->AutoLimitSupported_.set (AutoLimitSupportedTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!MaxLimits_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MaxLimits",
        "http://domain-model-uri/15/04");
    }
  }

  LimitAlertConditionDescriptor* LimitAlertConditionDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LimitAlertConditionDescriptor (*this, f, c);
  }

  LimitAlertConditionDescriptor& LimitAlertConditionDescriptor::
  operator= (const LimitAlertConditionDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AlertConditionDescriptor& > (*this) = x;
      this->MaxLimits_ = x.MaxLimits_;
      this->AutoLimitSupported_ = x.AutoLimitSupported_;
    }

    return *this;
  }

  LimitAlertConditionDescriptor::
  ~LimitAlertConditionDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LimitAlertConditionDescriptor >
  _xsd_LimitAlertConditionDescriptor_type_factory_init (
    "LimitAlertConditionDescriptor",
    "http://domain-model-uri/15/04");

  // PausableActivation
  //

  PausableActivation::
  PausableActivation (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_PausableActivation_convert ();
  }

  PausableActivation::
  PausableActivation (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_PausableActivation_convert ();
  }

  PausableActivation::
  PausableActivation (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_PausableActivation_convert ();
  }

  PausableActivation* PausableActivation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PausableActivation (*this, f, c);
  }

  PausableActivation::Value PausableActivation::
  _xsd_PausableActivation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_PausableActivation_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_PausableActivation_indexes_,
                      _xsd_PausableActivation_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_PausableActivation_indexes_ + 3 || _xsd_PausableActivation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const PausableActivation::
  _xsd_PausableActivation_literals_[3] =
  {
    "On",
    "Off",
    "Psd"
  };

  const PausableActivation::Value PausableActivation::
  _xsd_PausableActivation_indexes_[3] =
  {
    ::CDM::PausableActivation::Off,
    ::CDM::PausableActivation::On,
    ::CDM::PausableActivation::Psd
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, PausableActivation >
  _xsd_PausableActivation_type_factory_init (
    "PausableActivation",
    "http://domain-model-uri/15/04");

  // SignalPresence
  //

  SignalPresence::
  SignalPresence (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_SignalPresence_convert ();
  }

  SignalPresence::
  SignalPresence (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_SignalPresence_convert ();
  }

  SignalPresence::
  SignalPresence (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_SignalPresence_convert ();
  }

  SignalPresence* SignalPresence::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SignalPresence (*this, f, c);
  }

  SignalPresence::Value SignalPresence::
  _xsd_SignalPresence_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_SignalPresence_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_SignalPresence_indexes_,
                      _xsd_SignalPresence_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_SignalPresence_indexes_ + 4 || _xsd_SignalPresence_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const SignalPresence::
  _xsd_SignalPresence_literals_[4] =
  {
    "On",
    "Off",
    "Latch",
    "Ack"
  };

  const SignalPresence::Value SignalPresence::
  _xsd_SignalPresence_indexes_[4] =
  {
    ::CDM::SignalPresence::Ack,
    ::CDM::SignalPresence::Latch,
    ::CDM::SignalPresence::Off,
    ::CDM::SignalPresence::On
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SignalPresence >
  _xsd_SignalPresence_type_factory_init (
    "SignalPresence",
    "http://domain-model-uri/15/04");

  // PrimaryAlertSignalLocation
  //

  PrimaryAlertSignalLocation::
  PrimaryAlertSignalLocation (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_PrimaryAlertSignalLocation_convert ();
  }

  PrimaryAlertSignalLocation::
  PrimaryAlertSignalLocation (const ::xercesc::DOMAttr& a,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_PrimaryAlertSignalLocation_convert ();
  }

  PrimaryAlertSignalLocation::
  PrimaryAlertSignalLocation (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_PrimaryAlertSignalLocation_convert ();
  }

  PrimaryAlertSignalLocation* PrimaryAlertSignalLocation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PrimaryAlertSignalLocation (*this, f, c);
  }

  PrimaryAlertSignalLocation::Value PrimaryAlertSignalLocation::
  _xsd_PrimaryAlertSignalLocation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_PrimaryAlertSignalLocation_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_PrimaryAlertSignalLocation_indexes_,
                      _xsd_PrimaryAlertSignalLocation_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_PrimaryAlertSignalLocation_indexes_ + 2 || _xsd_PrimaryAlertSignalLocation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const PrimaryAlertSignalLocation::
  _xsd_PrimaryAlertSignalLocation_literals_[2] =
  {
    "Loc",
    "Rem"
  };

  const PrimaryAlertSignalLocation::Value PrimaryAlertSignalLocation::
  _xsd_PrimaryAlertSignalLocation_indexes_[2] =
  {
    ::CDM::PrimaryAlertSignalLocation::Loc,
    ::CDM::PrimaryAlertSignalLocation::Rem
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, PrimaryAlertSignalLocation >
  _xsd_PrimaryAlertSignalLocation_type_factory_init (
    "PrimaryAlertSignalLocation",
    "http://domain-model-uri/15/04");

  // MonitoredAlertLimits
  //

  MonitoredAlertLimits::
  MonitoredAlertLimits (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_MonitoredAlertLimits_convert ();
  }

  MonitoredAlertLimits::
  MonitoredAlertLimits (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_MonitoredAlertLimits_convert ();
  }

  MonitoredAlertLimits::
  MonitoredAlertLimits (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_MonitoredAlertLimits_convert ();
  }

  MonitoredAlertLimits* MonitoredAlertLimits::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MonitoredAlertLimits (*this, f, c);
  }

  MonitoredAlertLimits::Value MonitoredAlertLimits::
  _xsd_MonitoredAlertLimits_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MonitoredAlertLimits_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_MonitoredAlertLimits_indexes_,
                      _xsd_MonitoredAlertLimits_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_MonitoredAlertLimits_indexes_ + 4 || _xsd_MonitoredAlertLimits_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const MonitoredAlertLimits::
  _xsd_MonitoredAlertLimits_literals_[4] =
  {
    "All",
    "LoOff",
    "HiOff",
    "None"
  };

  const MonitoredAlertLimits::Value MonitoredAlertLimits::
  _xsd_MonitoredAlertLimits_indexes_[4] =
  {
    ::CDM::MonitoredAlertLimits::All,
    ::CDM::MonitoredAlertLimits::HiOff,
    ::CDM::MonitoredAlertLimits::LoOff,
    ::CDM::MonitoredAlertLimits::None
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MonitoredAlertLimits >
  _xsd_MonitoredAlertLimits_type_factory_init (
    "MonitoredAlertLimits",
    "http://domain-model-uri/15/04");

  // AbstractAlertState
  //

  AbstractAlertState::
  AbstractAlertState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractState (DescriptorHandle)
  {
  }

  AbstractAlertState::
  AbstractAlertState (const AbstractAlertState& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractState (x, f, c)
  {
  }

  AbstractAlertState::
  AbstractAlertState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractState (e, f, c)
  {
  }

  AbstractAlertState* AbstractAlertState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractAlertState (*this, f, c);
  }

  AbstractAlertState::
  ~AbstractAlertState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractAlertState >
  _xsd_AbstractAlertState_type_factory_init (
    "AbstractAlertState",
    "http://domain-model-uri/15/04");

  // AlertConditionState
  //

  AlertConditionState::
  AlertConditionState (const DescriptorHandleType& DescriptorHandle,
                       const ActivationStateType& ActivationState,
                       const PresenceType& Presence)
  : ::CDM::AbstractAlertState (DescriptorHandle),
    ActivationState_ (ActivationState, this),
    ActualPriority_ (this),
    Rank_ (this),
    Presence_ (Presence, this),
    ObservationTime_ (this)
  {
  }

  AlertConditionState::
  AlertConditionState (const AlertConditionState& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::AbstractAlertState (x, f, c),
    ActivationState_ (x.ActivationState_, f, this),
    ActualPriority_ (x.ActualPriority_, f, this),
    Rank_ (x.Rank_, f, this),
    Presence_ (x.Presence_, f, this),
    ObservationTime_ (x.ObservationTime_, f, this)
  {
  }

  AlertConditionState::
  AlertConditionState (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::AbstractAlertState (e, f | ::xml_schema::Flags::base, c),
    ActivationState_ (this),
    ActualPriority_ (this),
    Rank_ (this),
    Presence_ (this),
    ObservationTime_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AlertConditionState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractAlertState::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ActivationState" && n.namespace_ ().empty ())
      {
        this->ActivationState_.set (ActivationStateTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ActualPriority" && n.namespace_ ().empty ())
      {
        this->ActualPriority_.set (ActualPriorityTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Rank" && n.namespace_ ().empty ())
      {
        this->Rank_.set (RankTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Presence" && n.namespace_ ().empty ())
      {
        this->Presence_.set (PresenceTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ObservationTime" && n.namespace_ ().empty ())
      {
        this->ObservationTime_.set (ObservationTimeTraits::create (i, f, this));
        continue;
      }
    }

    if (!ActivationState_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ActivationState",
        "");
    }

    if (!Presence_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Presence",
        "");
    }
  }

  AlertConditionState* AlertConditionState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertConditionState (*this, f, c);
  }

  AlertConditionState& AlertConditionState::
  operator= (const AlertConditionState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractAlertState& > (*this) = x;
      this->ActivationState_ = x.ActivationState_;
      this->ActualPriority_ = x.ActualPriority_;
      this->Rank_ = x.Rank_;
      this->Presence_ = x.Presence_;
      this->ObservationTime_ = x.ObservationTime_;
    }

    return *this;
  }

  AlertConditionState::
  ~AlertConditionState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertConditionState >
  _xsd_AlertConditionState_type_factory_init (
    "AlertConditionState",
    "http://domain-model-uri/15/04");

  // AlertSignalState
  //

  AlertSignalState::
  AlertSignalState (const DescriptorHandleType& DescriptorHandle,
                    const ActivationStateType& ActivationState)
  : ::CDM::AbstractAlertState (DescriptorHandle),
    ActivationState_ (ActivationState, this),
    Presence_ (this),
    Location_ (this),
    Slot_ (this)
  {
  }

  AlertSignalState::
  AlertSignalState (const AlertSignalState& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::CDM::AbstractAlertState (x, f, c),
    ActivationState_ (x.ActivationState_, f, this),
    Presence_ (x.Presence_, f, this),
    Location_ (x.Location_, f, this),
    Slot_ (x.Slot_, f, this)
  {
  }

  AlertSignalState::
  AlertSignalState (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::CDM::AbstractAlertState (e, f | ::xml_schema::Flags::base, c),
    ActivationState_ (this),
    Presence_ (this),
    Location_ (this),
    Slot_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AlertSignalState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractAlertState::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ActivationState" && n.namespace_ ().empty ())
      {
        this->ActivationState_.set (ActivationStateTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Presence" && n.namespace_ ().empty ())
      {
        this->Presence_.set (PresenceTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Location" && n.namespace_ ().empty ())
      {
        this->Location_.set (LocationTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Slot" && n.namespace_ ().empty ())
      {
        this->Slot_.set (SlotTraits::create (i, f, this));
        continue;
      }
    }

    if (!ActivationState_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ActivationState",
        "");
    }
  }

  AlertSignalState* AlertSignalState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertSignalState (*this, f, c);
  }

  AlertSignalState& AlertSignalState::
  operator= (const AlertSignalState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractAlertState& > (*this) = x;
      this->ActivationState_ = x.ActivationState_;
      this->Presence_ = x.Presence_;
      this->Location_ = x.Location_;
      this->Slot_ = x.Slot_;
    }

    return *this;
  }

  AlertSignalState::
  ~AlertSignalState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertSignalState >
  _xsd_AlertSignalState_type_factory_init (
    "AlertSignalState",
    "http://domain-model-uri/15/04");

  // AlertSystemState
  //

  AlertSystemState::
  AlertSystemState (const DescriptorHandleType& DescriptorHandle,
                    const ActivationStateType& ActivationState)
  : ::CDM::AbstractAlertState (DescriptorHandle),
    ActivationState_ (ActivationState, this),
    LastSelfCheck_ (this),
    SelfCheckCount_ (this),
    PresentPhysiologicalAlarmConditions_ (this),
    PresentTechnicalAlarmConditions_ (this)
  {
  }

  AlertSystemState::
  AlertSystemState (const AlertSystemState& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::CDM::AbstractAlertState (x, f, c),
    ActivationState_ (x.ActivationState_, f, this),
    LastSelfCheck_ (x.LastSelfCheck_, f, this),
    SelfCheckCount_ (x.SelfCheckCount_, f, this),
    PresentPhysiologicalAlarmConditions_ (x.PresentPhysiologicalAlarmConditions_, f, this),
    PresentTechnicalAlarmConditions_ (x.PresentTechnicalAlarmConditions_, f, this)
  {
  }

  AlertSystemState::
  AlertSystemState (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::CDM::AbstractAlertState (e, f | ::xml_schema::Flags::base, c),
    ActivationState_ (this),
    LastSelfCheck_ (this),
    SelfCheckCount_ (this),
    PresentPhysiologicalAlarmConditions_ (this),
    PresentTechnicalAlarmConditions_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AlertSystemState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractAlertState::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ActivationState" && n.namespace_ ().empty ())
      {
        this->ActivationState_.set (ActivationStateTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "LastSelfCheck" && n.namespace_ ().empty ())
      {
        this->LastSelfCheck_.set (LastSelfCheckTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "SelfCheckCount" && n.namespace_ ().empty ())
      {
        this->SelfCheckCount_.set (SelfCheckCountTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "PresentPhysiologicalAlarmConditions" && n.namespace_ ().empty ())
      {
        this->PresentPhysiologicalAlarmConditions_.set (PresentPhysiologicalAlarmConditionsTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "PresentTechnicalAlarmConditions" && n.namespace_ ().empty ())
      {
        this->PresentTechnicalAlarmConditions_.set (PresentTechnicalAlarmConditionsTraits::create (i, f, this));
        continue;
      }
    }

    if (!ActivationState_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ActivationState",
        "");
    }
  }

  AlertSystemState* AlertSystemState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertSystemState (*this, f, c);
  }

  AlertSystemState& AlertSystemState::
  operator= (const AlertSystemState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractAlertState& > (*this) = x;
      this->ActivationState_ = x.ActivationState_;
      this->LastSelfCheck_ = x.LastSelfCheck_;
      this->SelfCheckCount_ = x.SelfCheckCount_;
      this->PresentPhysiologicalAlarmConditions_ = x.PresentPhysiologicalAlarmConditions_;
      this->PresentTechnicalAlarmConditions_ = x.PresentTechnicalAlarmConditions_;
    }

    return *this;
  }

  AlertSystemState::
  ~AlertSystemState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertSystemState >
  _xsd_AlertSystemState_type_factory_init (
    "AlertSystemState",
    "http://domain-model-uri/15/04");

  // AlertConditionReference
  //

  AlertConditionReference::
  AlertConditionReference (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (e, f, c),
    ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (e, f, this)
  {
  }

  AlertConditionReference::
  AlertConditionReference (const ::xercesc::DOMAttr& a,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (a, f, c),
    ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (a, f, this)
  {
  }

  AlertConditionReference::
  AlertConditionReference (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (s, e, f, c),
    ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (s, e, f, this)
  {
  }

  AlertConditionReference* AlertConditionReference::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AlertConditionReference (*this, f, c);
  }

  AlertConditionReference::
  ~AlertConditionReference ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlertConditionReference >
  _xsd_AlertConditionReference_type_factory_init (
    "AlertConditionReference",
    "http://domain-model-uri/15/04");

  // LimitAlertConditionState
  //

  LimitAlertConditionState::
  LimitAlertConditionState (const DescriptorHandleType& DescriptorHandle,
                            const ActivationStateType& ActivationState,
                            const PresenceType& Presence,
                            const MonitoredAlertLimitsType& MonitoredAlertLimits)
  : ::CDM::AlertConditionState (DescriptorHandle,
                                ActivationState,
                                Presence),
    Limits_ (this),
    MonitoredAlertLimits_ (MonitoredAlertLimits, this),
    AutoLimitActivationState_ (this)
  {
  }

  LimitAlertConditionState::
  LimitAlertConditionState (const LimitAlertConditionState& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AlertConditionState (x, f, c),
    Limits_ (x.Limits_, f, this),
    MonitoredAlertLimits_ (x.MonitoredAlertLimits_, f, this),
    AutoLimitActivationState_ (x.AutoLimitActivationState_, f, this)
  {
  }

  LimitAlertConditionState::
  LimitAlertConditionState (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AlertConditionState (e, f | ::xml_schema::Flags::base, c),
    Limits_ (this),
    MonitoredAlertLimits_ (this),
    AutoLimitActivationState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void LimitAlertConditionState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AlertConditionState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Limits
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Limits",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< LimitsType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Limits_)
          {
            ::std::unique_ptr< LimitsType > r (
              dynamic_cast< LimitsType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Limits_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MonitoredAlertLimits" && n.namespace_ ().empty ())
      {
        this->MonitoredAlertLimits_.set (MonitoredAlertLimitsTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "AutoLimitActivationState" && n.namespace_ ().empty ())
      {
        this->AutoLimitActivationState_.set (AutoLimitActivationStateTraits::create (i, f, this));
        continue;
      }
    }

    if (!MonitoredAlertLimits_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "MonitoredAlertLimits",
        "");
    }
  }

  LimitAlertConditionState* LimitAlertConditionState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LimitAlertConditionState (*this, f, c);
  }

  LimitAlertConditionState& LimitAlertConditionState::
  operator= (const LimitAlertConditionState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AlertConditionState& > (*this) = x;
      this->Limits_ = x.Limits_;
      this->MonitoredAlertLimits_ = x.MonitoredAlertLimits_;
      this->AutoLimitActivationState_ = x.AutoLimitActivationState_;
    }

    return *this;
  }

  LimitAlertConditionState::
  ~LimitAlertConditionState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LimitAlertConditionState >
  _xsd_LimitAlertConditionState_type_factory_init (
    "LimitAlertConditionState",
    "http://domain-model-uri/15/04");

  // MetricCategory
  //

  MetricCategory::
  MetricCategory (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_MetricCategory_convert ();
  }

  MetricCategory::
  MetricCategory (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_MetricCategory_convert ();
  }

  MetricCategory::
  MetricCategory (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_MetricCategory_convert ();
  }

  MetricCategory* MetricCategory::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MetricCategory (*this, f, c);
  }

  MetricCategory::Value MetricCategory::
  _xsd_MetricCategory_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MetricCategory_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_MetricCategory_indexes_,
                      _xsd_MetricCategory_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_MetricCategory_indexes_ + 6 || _xsd_MetricCategory_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const MetricCategory::
  _xsd_MetricCategory_literals_[6] =
  {
    "Unspec",
    "Msrmt",
    "Clc",
    "Set",
    "Preset",
    "Rcmm"
  };

  const MetricCategory::Value MetricCategory::
  _xsd_MetricCategory_indexes_[6] =
  {
    ::CDM::MetricCategory::Clc,
    ::CDM::MetricCategory::Msrmt,
    ::CDM::MetricCategory::Preset,
    ::CDM::MetricCategory::Rcmm,
    ::CDM::MetricCategory::Set,
    ::CDM::MetricCategory::Unspec
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MetricCategory >
  _xsd_MetricCategory_type_factory_init (
    "MetricCategory",
    "http://domain-model-uri/15/04");

  // MetricAvailability
  //

  MetricAvailability::
  MetricAvailability (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_MetricAvailability_convert ();
  }

  MetricAvailability::
  MetricAvailability (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_MetricAvailability_convert ();
  }

  MetricAvailability::
  MetricAvailability (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_MetricAvailability_convert ();
  }

  MetricAvailability* MetricAvailability::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MetricAvailability (*this, f, c);
  }

  MetricAvailability::Value MetricAvailability::
  _xsd_MetricAvailability_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MetricAvailability_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_MetricAvailability_indexes_,
                      _xsd_MetricAvailability_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_MetricAvailability_indexes_ + 2 || _xsd_MetricAvailability_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const MetricAvailability::
  _xsd_MetricAvailability_literals_[2] =
  {
    "Intr",
    "Cont"
  };

  const MetricAvailability::Value MetricAvailability::
  _xsd_MetricAvailability_indexes_[2] =
  {
    ::CDM::MetricAvailability::Cont,
    ::CDM::MetricAvailability::Intr
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MetricAvailability >
  _xsd_MetricAvailability_type_factory_init (
    "MetricAvailability",
    "http://domain-model-uri/15/04");

  // VMDDescriptor
  //

  VMDDescriptor::
  VMDDescriptor (const HandleType& Handle)
  : ::CDM::AbstractDeviceComponent (Handle),
    Channel_ (this),
    AlertSystem_ (this)
  {
  }

  VMDDescriptor::
  VMDDescriptor (const VMDDescriptor& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponent (x, f, c),
    Channel_ (x.Channel_, f, this),
    AlertSystem_ (x.AlertSystem_, f, this)
  {
  }

  VMDDescriptor::
  VMDDescriptor (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponent (e, f | ::xml_schema::Flags::base, c),
    Channel_ (this),
    AlertSystem_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void VMDDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDeviceComponent::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Channel
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Channel",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ChannelType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ChannelType > r (
            dynamic_cast< ChannelType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Channel_.push_back (::std::move (r));
          continue;
        }
      }

      // AlertSystem
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AlertSystem",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< AlertSystemType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AlertSystem_)
          {
            ::std::unique_ptr< AlertSystemType > r (
              dynamic_cast< AlertSystemType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AlertSystem_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  VMDDescriptor* VMDDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VMDDescriptor (*this, f, c);
  }

  VMDDescriptor& VMDDescriptor::
  operator= (const VMDDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDeviceComponent& > (*this) = x;
      this->Channel_ = x.Channel_;
      this->AlertSystem_ = x.AlertSystem_;
    }

    return *this;
  }

  VMDDescriptor::
  ~VMDDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, VMDDescriptor >
  _xsd_VMDDescriptor_type_factory_init (
    "VMDDescriptor",
    "http://domain-model-uri/15/04");

  // ChannelDescriptor
  //

  ChannelDescriptor::
  ChannelDescriptor (const HandleType& Handle)
  : ::CDM::AbstractDeviceComponent (Handle),
    Metric_ (this),
    AlertSystem_ (this)
  {
  }

  ChannelDescriptor::
  ChannelDescriptor (const ChannelDescriptor& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponent (x, f, c),
    Metric_ (x.Metric_, f, this),
    AlertSystem_ (x.AlertSystem_, f, this)
  {
  }

  ChannelDescriptor::
  ChannelDescriptor (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponent (e, f | ::xml_schema::Flags::base, c),
    Metric_ (this),
    AlertSystem_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ChannelDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDeviceComponent::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Metric
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Metric",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< MetricType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< MetricType > r (
            dynamic_cast< MetricType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Metric_.push_back (::std::move (r));
          continue;
        }
      }

      // AlertSystem
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AlertSystem",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< AlertSystemType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AlertSystem_)
          {
            ::std::unique_ptr< AlertSystemType > r (
              dynamic_cast< AlertSystemType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AlertSystem_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  ChannelDescriptor* ChannelDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ChannelDescriptor (*this, f, c);
  }

  ChannelDescriptor& ChannelDescriptor::
  operator= (const ChannelDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDeviceComponent& > (*this) = x;
      this->Metric_ = x.Metric_;
      this->AlertSystem_ = x.AlertSystem_;
    }

    return *this;
  }

  ChannelDescriptor::
  ~ChannelDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ChannelDescriptor >
  _xsd_ChannelDescriptor_type_factory_init (
    "ChannelDescriptor",
    "http://domain-model-uri/15/04");

  // AbstractMetricDescriptor
  //

  AbstractMetricDescriptor::
  AbstractMetricDescriptor (const HandleType& Handle,
                            const UnitType& Unit,
                            const MetricCategoryType& MetricCategory,
                            const AvailabilityType& Availability)
  : ::CDM::AbstractDescriptor (Handle),
    Unit_ (Unit, this),
    BodySite_ (this),
    MetricCategory_ (MetricCategory, this),
    Availability_ (Availability, this),
    MaxDelayTime_ (this)
  {
  }

  AbstractMetricDescriptor::
  AbstractMetricDescriptor (const HandleType& Handle,
                            ::std::unique_ptr< UnitType > Unit,
                            const MetricCategoryType& MetricCategory,
                            const AvailabilityType& Availability)
  : ::CDM::AbstractDescriptor (Handle),
    Unit_ (std::move (Unit), this),
    BodySite_ (this),
    MetricCategory_ (MetricCategory, this),
    Availability_ (Availability, this),
    MaxDelayTime_ (this)
  {
  }

  AbstractMetricDescriptor::
  AbstractMetricDescriptor (const HandleType& Handle,
                            ::std::unique_ptr< UnitType > Unit,
                            ::std::unique_ptr< MetricCategoryType > MetricCategory,
                            ::std::unique_ptr< AvailabilityType > Availability)
  : ::CDM::AbstractDescriptor (Handle),
    Unit_ (std::move (Unit), this),
    BodySite_ (this),
    MetricCategory_ (std::move (MetricCategory), this),
    Availability_ (std::move (Availability), this),
    MaxDelayTime_ (this)
  {
  }

  AbstractMetricDescriptor::
  AbstractMetricDescriptor (const AbstractMetricDescriptor& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (x, f, c),
    Unit_ (x.Unit_, f, this),
    BodySite_ (x.BodySite_, f, this),
    MetricCategory_ (x.MetricCategory_, f, this),
    Availability_ (x.Availability_, f, this),
    MaxDelayTime_ (x.MaxDelayTime_, f, this)
  {
  }

  AbstractMetricDescriptor::
  AbstractMetricDescriptor (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (e, f | ::xml_schema::Flags::base, c),
    Unit_ (this),
    BodySite_ (this),
    MetricCategory_ (this),
    Availability_ (this),
    MaxDelayTime_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractMetricDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Unit
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Unit",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< UnitType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Unit_.present ())
          {
            ::std::unique_ptr< UnitType > r (
              dynamic_cast< UnitType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Unit_.set (::std::move (r));
            continue;
          }
        }
      }

      // BodySite
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "BodySite",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< BodySiteType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< BodySiteType > r (
            dynamic_cast< BodySiteType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->BodySite_.push_back (::std::move (r));
          continue;
        }
      }

      // MetricCategory
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MetricCategory",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< MetricCategoryType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MetricCategory_.present ())
          {
            ::std::unique_ptr< MetricCategoryType > r (
              dynamic_cast< MetricCategoryType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MetricCategory_.set (::std::move (r));
            continue;
          }
        }
      }

      // Availability
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Availability",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< AvailabilityType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Availability_.present ())
          {
            ::std::unique_ptr< AvailabilityType > r (
              dynamic_cast< AvailabilityType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Availability_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Unit_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Unit",
        "http://domain-model-uri/15/04");
    }

    if (!MetricCategory_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MetricCategory",
        "http://domain-model-uri/15/04");
    }

    if (!Availability_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Availability",
        "http://domain-model-uri/15/04");
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MaxDelayTime" && n.namespace_ ().empty ())
      {
        this->MaxDelayTime_.set (MaxDelayTimeTraits::create (i, f, this));
        continue;
      }
    }
  }

  AbstractMetricDescriptor* AbstractMetricDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractMetricDescriptor (*this, f, c);
  }

  AbstractMetricDescriptor& AbstractMetricDescriptor::
  operator= (const AbstractMetricDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDescriptor& > (*this) = x;
      this->Unit_ = x.Unit_;
      this->BodySite_ = x.BodySite_;
      this->MetricCategory_ = x.MetricCategory_;
      this->Availability_ = x.Availability_;
      this->MaxDelayTime_ = x.MaxDelayTime_;
    }

    return *this;
  }

  AbstractMetricDescriptor::
  ~AbstractMetricDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractMetricDescriptor >
  _xsd_AbstractMetricDescriptor_type_factory_init (
    "AbstractMetricDescriptor",
    "http://domain-model-uri/15/04");

  // NumericMetricDescriptor
  //

  NumericMetricDescriptor::
  NumericMetricDescriptor (const HandleType& Handle,
                           const UnitType& Unit,
                           const MetricCategoryType& MetricCategory,
                           const AvailabilityType& Availability,
                           const ResolutionType& Resolution)
  : ::CDM::AbstractMetricDescriptor (Handle,
                                     Unit,
                                     MetricCategory,
                                     Availability),
    Resolution_ (Resolution, this),
    MeasurePeriod_ (this),
    AveragingPeriod_ (this),
    TechnicalRange_ (this)
  {
  }

  NumericMetricDescriptor::
  NumericMetricDescriptor (const HandleType& Handle,
                           ::std::unique_ptr< UnitType > Unit,
                           const MetricCategoryType& MetricCategory,
                           const AvailabilityType& Availability,
                           const ResolutionType& Resolution)
  : ::CDM::AbstractMetricDescriptor (Handle,
                                     std::move (Unit),
                                     MetricCategory,
                                     Availability),
    Resolution_ (Resolution, this),
    MeasurePeriod_ (this),
    AveragingPeriod_ (this),
    TechnicalRange_ (this)
  {
  }

  NumericMetricDescriptor::
  NumericMetricDescriptor (const HandleType& Handle,
                           ::std::unique_ptr< UnitType > Unit,
                           ::std::unique_ptr< MetricCategoryType > MetricCategory,
                           ::std::unique_ptr< AvailabilityType > Availability,
                           const ResolutionType& Resolution)
  : ::CDM::AbstractMetricDescriptor (Handle,
                                     std::move (Unit),
                                     std::move (MetricCategory),
                                     std::move (Availability)),
    Resolution_ (Resolution, this),
    MeasurePeriod_ (this),
    AveragingPeriod_ (this),
    TechnicalRange_ (this)
  {
  }

  NumericMetricDescriptor::
  NumericMetricDescriptor (const NumericMetricDescriptor& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::CDM::AbstractMetricDescriptor (x, f, c),
    Resolution_ (x.Resolution_, f, this),
    MeasurePeriod_ (x.MeasurePeriod_, f, this),
    AveragingPeriod_ (x.AveragingPeriod_, f, this),
    TechnicalRange_ (x.TechnicalRange_, f, this)
  {
  }

  NumericMetricDescriptor::
  NumericMetricDescriptor (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::CDM::AbstractMetricDescriptor (e, f | ::xml_schema::Flags::base, c),
    Resolution_ (this),
    MeasurePeriod_ (this),
    AveragingPeriod_ (this),
    TechnicalRange_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void NumericMetricDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Resolution
      //
      if (n.name () == "Resolution" && n.namespace_ () == "http://domain-model-uri/15/04")
      {
        if (!Resolution_.present ())
        {
          this->Resolution_.set (ResolutionTraits::create (i, f, this));
          continue;
        }
      }

      // MeasurePeriod
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MeasurePeriod",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< MeasurePeriodType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->MeasurePeriod_)
          {
            ::std::unique_ptr< MeasurePeriodType > r (
              dynamic_cast< MeasurePeriodType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MeasurePeriod_.set (::std::move (r));
            continue;
          }
        }
      }

      // AveragingPeriod
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AveragingPeriod",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< AveragingPeriodType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AveragingPeriod_)
          {
            ::std::unique_ptr< AveragingPeriodType > r (
              dynamic_cast< AveragingPeriodType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AveragingPeriod_.set (::std::move (r));
            continue;
          }
        }
      }

      // TechnicalRange
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TechnicalRange",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< TechnicalRangeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< TechnicalRangeType > r (
            dynamic_cast< TechnicalRangeType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TechnicalRange_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!Resolution_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Resolution",
        "http://domain-model-uri/15/04");
    }
  }

  NumericMetricDescriptor* NumericMetricDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NumericMetricDescriptor (*this, f, c);
  }

  NumericMetricDescriptor& NumericMetricDescriptor::
  operator= (const NumericMetricDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricDescriptor& > (*this) = x;
      this->Resolution_ = x.Resolution_;
      this->MeasurePeriod_ = x.MeasurePeriod_;
      this->AveragingPeriod_ = x.AveragingPeriod_;
      this->TechnicalRange_ = x.TechnicalRange_;
    }

    return *this;
  }

  NumericMetricDescriptor::
  ~NumericMetricDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, NumericMetricDescriptor >
  _xsd_NumericMetricDescriptor_type_factory_init (
    "NumericMetricDescriptor",
    "http://domain-model-uri/15/04");

  // StringMetricDescriptor
  //

  StringMetricDescriptor::
  StringMetricDescriptor (const HandleType& Handle,
                          const UnitType& Unit,
                          const MetricCategoryType& MetricCategory,
                          const AvailabilityType& Availability)
  : ::CDM::AbstractMetricDescriptor (Handle,
                                     Unit,
                                     MetricCategory,
                                     Availability)
  {
  }

  StringMetricDescriptor::
  StringMetricDescriptor (const HandleType& Handle,
                          ::std::unique_ptr< UnitType > Unit,
                          const MetricCategoryType& MetricCategory,
                          const AvailabilityType& Availability)
  : ::CDM::AbstractMetricDescriptor (Handle,
                                     std::move (Unit),
                                     MetricCategory,
                                     Availability)
  {
  }

  StringMetricDescriptor::
  StringMetricDescriptor (const HandleType& Handle,
                          ::std::unique_ptr< UnitType > Unit,
                          ::std::unique_ptr< MetricCategoryType > MetricCategory,
                          ::std::unique_ptr< AvailabilityType > Availability)
  : ::CDM::AbstractMetricDescriptor (Handle,
                                     std::move (Unit),
                                     std::move (MetricCategory),
                                     std::move (Availability))
  {
  }

  StringMetricDescriptor::
  StringMetricDescriptor (const StringMetricDescriptor& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::AbstractMetricDescriptor (x, f, c)
  {
  }

  StringMetricDescriptor::
  StringMetricDescriptor (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::AbstractMetricDescriptor (e, f, c)
  {
  }

  StringMetricDescriptor* StringMetricDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class StringMetricDescriptor (*this, f, c);
  }

  StringMetricDescriptor::
  ~StringMetricDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, StringMetricDescriptor >
  _xsd_StringMetricDescriptor_type_factory_init (
    "StringMetricDescriptor",
    "http://domain-model-uri/15/04");

  // EnumNomenRef
  //

  EnumNomenRef::
  EnumNomenRef (const CodeType& Code)
  : ::xml_schema::Type (),
    Extension_ (this),
    Code_ (Code, this),
    EnumIndex_ (this)
  {
  }

  EnumNomenRef::
  EnumNomenRef (::std::unique_ptr< CodeType > Code)
  : ::xml_schema::Type (),
    Extension_ (this),
    Code_ (std::move (Code), this),
    EnumIndex_ (this)
  {
  }

  EnumNomenRef::
  EnumNomenRef (const EnumNomenRef& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Code_ (x.Code_, f, this),
    EnumIndex_ (x.EnumIndex_, f, this)
  {
  }

  EnumNomenRef::
  EnumNomenRef (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Code_ (this),
    EnumIndex_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void EnumNomenRef::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // Code
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Code",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< CodeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Code_.present ())
          {
            ::std::unique_ptr< CodeType > r (
              dynamic_cast< CodeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Code_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Code_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Code",
        "http://domain-model-uri/15/04");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "EnumIndex" && n.namespace_ ().empty ())
      {
        this->EnumIndex_.set (EnumIndexTraits::create (i, f, this));
        continue;
      }
    }
  }

  EnumNomenRef* EnumNomenRef::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EnumNomenRef (*this, f, c);
  }

  EnumNomenRef& EnumNomenRef::
  operator= (const EnumNomenRef& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Code_ = x.Code_;
      this->EnumIndex_ = x.EnumIndex_;
    }

    return *this;
  }

  EnumNomenRef::
  ~EnumNomenRef ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumNomenRef >
  _xsd_EnumNomenRef_type_factory_init (
    "EnumNomenRef",
    "http://domain-model-uri/15/04");

  // EnumStringMetricDescriptor
  //

  EnumStringMetricDescriptor::
  EnumStringMetricDescriptor (const HandleType& Handle,
                              const UnitType& Unit,
                              const MetricCategoryType& MetricCategory,
                              const AvailabilityType& Availability)
  : ::CDM::StringMetricDescriptor (Handle,
                                   Unit,
                                   MetricCategory,
                                   Availability),
    AllowedValue_ (this),
    EnumCodes_ (this)
  {
  }

  EnumStringMetricDescriptor::
  EnumStringMetricDescriptor (const HandleType& Handle,
                              ::std::unique_ptr< UnitType > Unit,
                              const MetricCategoryType& MetricCategory,
                              const AvailabilityType& Availability)
  : ::CDM::StringMetricDescriptor (Handle,
                                   std::move (Unit),
                                   MetricCategory,
                                   Availability),
    AllowedValue_ (this),
    EnumCodes_ (this)
  {
  }

  EnumStringMetricDescriptor::
  EnumStringMetricDescriptor (const HandleType& Handle,
                              ::std::unique_ptr< UnitType > Unit,
                              ::std::unique_ptr< MetricCategoryType > MetricCategory,
                              ::std::unique_ptr< AvailabilityType > Availability)
  : ::CDM::StringMetricDescriptor (Handle,
                                   std::move (Unit),
                                   std::move (MetricCategory),
                                   std::move (Availability)),
    AllowedValue_ (this),
    EnumCodes_ (this)
  {
  }

  EnumStringMetricDescriptor::
  EnumStringMetricDescriptor (const EnumStringMetricDescriptor& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::CDM::StringMetricDescriptor (x, f, c),
    AllowedValue_ (x.AllowedValue_, f, this),
    EnumCodes_ (x.EnumCodes_, f, this)
  {
  }

  EnumStringMetricDescriptor::
  EnumStringMetricDescriptor (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::CDM::StringMetricDescriptor (e, f | ::xml_schema::Flags::base, c),
    AllowedValue_ (this),
    EnumCodes_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void EnumStringMetricDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::StringMetricDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AllowedValue
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AllowedValue",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< AllowedValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< AllowedValueType > r (
            dynamic_cast< AllowedValueType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->AllowedValue_.push_back (::std::move (r));
          continue;
        }
      }

      // EnumCodes
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "EnumCodes",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< EnumCodesType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< EnumCodesType > r (
            dynamic_cast< EnumCodesType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->EnumCodes_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  EnumStringMetricDescriptor* EnumStringMetricDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EnumStringMetricDescriptor (*this, f, c);
  }

  EnumStringMetricDescriptor& EnumStringMetricDescriptor::
  operator= (const EnumStringMetricDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::StringMetricDescriptor& > (*this) = x;
      this->AllowedValue_ = x.AllowedValue_;
      this->EnumCodes_ = x.EnumCodes_;
    }

    return *this;
  }

  EnumStringMetricDescriptor::
  ~EnumStringMetricDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumStringMetricDescriptor >
  _xsd_EnumStringMetricDescriptor_type_factory_init (
    "EnumStringMetricDescriptor",
    "http://domain-model-uri/15/04");

  // RealTimeSampleArrayMetricDescriptor
  //

  RealTimeSampleArrayMetricDescriptor::
  RealTimeSampleArrayMetricDescriptor (const HandleType& Handle,
                                       const UnitType& Unit,
                                       const MetricCategoryType& MetricCategory,
                                       const AvailabilityType& Availability,
                                       const SamplePeriodType& SamplePeriod,
                                       const ResolutionType& Resolution)
  : ::CDM::AbstractMetricDescriptor (Handle,
                                     Unit,
                                     MetricCategory,
                                     Availability),
    SamplePeriod_ (SamplePeriod, this),
    Resolution_ (Resolution, this),
    TechnicalRange_ (this)
  {
  }

  RealTimeSampleArrayMetricDescriptor::
  RealTimeSampleArrayMetricDescriptor (const HandleType& Handle,
                                       ::std::unique_ptr< UnitType > Unit,
                                       const MetricCategoryType& MetricCategory,
                                       const AvailabilityType& Availability,
                                       const SamplePeriodType& SamplePeriod,
                                       const ResolutionType& Resolution)
  : ::CDM::AbstractMetricDescriptor (Handle,
                                     std::move (Unit),
                                     MetricCategory,
                                     Availability),
    SamplePeriod_ (SamplePeriod, this),
    Resolution_ (Resolution, this),
    TechnicalRange_ (this)
  {
  }

  RealTimeSampleArrayMetricDescriptor::
  RealTimeSampleArrayMetricDescriptor (const HandleType& Handle,
                                       ::std::unique_ptr< UnitType > Unit,
                                       ::std::unique_ptr< MetricCategoryType > MetricCategory,
                                       ::std::unique_ptr< AvailabilityType > Availability,
                                       ::std::unique_ptr< SamplePeriodType > SamplePeriod,
                                       const ResolutionType& Resolution)
  : ::CDM::AbstractMetricDescriptor (Handle,
                                     std::move (Unit),
                                     std::move (MetricCategory),
                                     std::move (Availability)),
    SamplePeriod_ (std::move (SamplePeriod), this),
    Resolution_ (Resolution, this),
    TechnicalRange_ (this)
  {
  }

  RealTimeSampleArrayMetricDescriptor::
  RealTimeSampleArrayMetricDescriptor (const RealTimeSampleArrayMetricDescriptor& x,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::CDM::AbstractMetricDescriptor (x, f, c),
    SamplePeriod_ (x.SamplePeriod_, f, this),
    Resolution_ (x.Resolution_, f, this),
    TechnicalRange_ (x.TechnicalRange_, f, this)
  {
  }

  RealTimeSampleArrayMetricDescriptor::
  RealTimeSampleArrayMetricDescriptor (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::CDM::AbstractMetricDescriptor (e, f | ::xml_schema::Flags::base, c),
    SamplePeriod_ (this),
    Resolution_ (this),
    TechnicalRange_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void RealTimeSampleArrayMetricDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SamplePeriod
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SamplePeriod",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< SamplePeriodType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!SamplePeriod_.present ())
          {
            ::std::unique_ptr< SamplePeriodType > r (
              dynamic_cast< SamplePeriodType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SamplePeriod_.set (::std::move (r));
            continue;
          }
        }
      }

      // Resolution
      //
      if (n.name () == "Resolution" && n.namespace_ () == "http://domain-model-uri/15/04")
      {
        if (!Resolution_.present ())
        {
          this->Resolution_.set (ResolutionTraits::create (i, f, this));
          continue;
        }
      }

      // TechnicalRange
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TechnicalRange",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< TechnicalRangeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< TechnicalRangeType > r (
            dynamic_cast< TechnicalRangeType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TechnicalRange_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!SamplePeriod_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SamplePeriod",
        "http://domain-model-uri/15/04");
    }

    if (!Resolution_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Resolution",
        "http://domain-model-uri/15/04");
    }
  }

  RealTimeSampleArrayMetricDescriptor* RealTimeSampleArrayMetricDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RealTimeSampleArrayMetricDescriptor (*this, f, c);
  }

  RealTimeSampleArrayMetricDescriptor& RealTimeSampleArrayMetricDescriptor::
  operator= (const RealTimeSampleArrayMetricDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricDescriptor& > (*this) = x;
      this->SamplePeriod_ = x.SamplePeriod_;
      this->Resolution_ = x.Resolution_;
      this->TechnicalRange_ = x.TechnicalRange_;
    }

    return *this;
  }

  RealTimeSampleArrayMetricDescriptor::
  ~RealTimeSampleArrayMetricDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RealTimeSampleArrayMetricDescriptor >
  _xsd_RealTimeSampleArrayMetricDescriptor_type_factory_init (
    "RealTimeSampleArrayMetricDescriptor",
    "http://domain-model-uri/15/04");

  // CalibrationState
  //

  CalibrationState::
  CalibrationState (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_CalibrationState_convert ();
  }

  CalibrationState::
  CalibrationState (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_CalibrationState_convert ();
  }

  CalibrationState::
  CalibrationState (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_CalibrationState_convert ();
  }

  CalibrationState* CalibrationState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CalibrationState (*this, f, c);
  }

  CalibrationState::Value CalibrationState::
  _xsd_CalibrationState_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CalibrationState_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_CalibrationState_indexes_,
                      _xsd_CalibrationState_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_CalibrationState_indexes_ + 3 || _xsd_CalibrationState_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const CalibrationState::
  _xsd_CalibrationState_literals_[3] =
  {
    "No",
    "Req",
    "Cal"
  };

  const CalibrationState::Value CalibrationState::
  _xsd_CalibrationState_indexes_[3] =
  {
    ::CDM::CalibrationState::Cal,
    ::CDM::CalibrationState::No,
    ::CDM::CalibrationState::Req
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CalibrationState >
  _xsd_CalibrationState_type_factory_init (
    "CalibrationState",
    "http://domain-model-uri/15/04");

  // ComponentActivation
  //

  ComponentActivation::
  ComponentActivation (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_ComponentActivation_convert ();
  }

  ComponentActivation::
  ComponentActivation (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_ComponentActivation_convert ();
  }

  ComponentActivation::
  ComponentActivation (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_ComponentActivation_convert ();
  }

  ComponentActivation* ComponentActivation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ComponentActivation (*this, f, c);
  }

  ComponentActivation::Value ComponentActivation::
  _xsd_ComponentActivation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ComponentActivation_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_ComponentActivation_indexes_,
                      _xsd_ComponentActivation_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_ComponentActivation_indexes_ + 5 || _xsd_ComponentActivation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ComponentActivation::
  _xsd_ComponentActivation_literals_[5] =
  {
    "On",
    "NotRdy",
    "StndBy",
    "Off",
    "Shtdn"
  };

  const ComponentActivation::Value ComponentActivation::
  _xsd_ComponentActivation_indexes_[5] =
  {
    ::CDM::ComponentActivation::NotRdy,
    ::CDM::ComponentActivation::Off,
    ::CDM::ComponentActivation::On,
    ::CDM::ComponentActivation::Shtdn,
    ::CDM::ComponentActivation::StndBy
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ComponentActivation >
  _xsd_ComponentActivation_type_factory_init (
    "ComponentActivation",
    "http://domain-model-uri/15/04");

  // MetricMeasurementValidity
  //

  MetricMeasurementValidity::
  MetricMeasurementValidity (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_MetricMeasurementValidity_convert ();
  }

  MetricMeasurementValidity::
  MetricMeasurementValidity (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_MetricMeasurementValidity_convert ();
  }

  MetricMeasurementValidity::
  MetricMeasurementValidity (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_MetricMeasurementValidity_convert ();
  }

  MetricMeasurementValidity* MetricMeasurementValidity::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MetricMeasurementValidity (*this, f, c);
  }

  MetricMeasurementValidity::Value MetricMeasurementValidity::
  _xsd_MetricMeasurementValidity_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MetricMeasurementValidity_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_MetricMeasurementValidity_indexes_,
                      _xsd_MetricMeasurementValidity_indexes_ + 7,
                      *this,
                      c));

    if (i == _xsd_MetricMeasurementValidity_indexes_ + 7 || _xsd_MetricMeasurementValidity_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const MetricMeasurementValidity::
  _xsd_MetricMeasurementValidity_literals_[7] =
  {
    "Vld",
    "Vldated",
    "Qst",
    "Calib",
    "Inv",
    "Oflw",
    "Uflw"
  };

  const MetricMeasurementValidity::Value MetricMeasurementValidity::
  _xsd_MetricMeasurementValidity_indexes_[7] =
  {
    ::CDM::MetricMeasurementValidity::Calib,
    ::CDM::MetricMeasurementValidity::Inv,
    ::CDM::MetricMeasurementValidity::Oflw,
    ::CDM::MetricMeasurementValidity::Qst,
    ::CDM::MetricMeasurementValidity::Uflw,
    ::CDM::MetricMeasurementValidity::Vld,
    ::CDM::MetricMeasurementValidity::Vldated
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MetricMeasurementValidity >
  _xsd_MetricMeasurementValidity_type_factory_init (
    "MetricMeasurementValidity",
    "http://domain-model-uri/15/04");

  // GenerationMode
  //

  GenerationMode::
  GenerationMode (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_GenerationMode_convert ();
  }

  GenerationMode::
  GenerationMode (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_GenerationMode_convert ();
  }

  GenerationMode::
  GenerationMode (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_GenerationMode_convert ();
  }

  GenerationMode* GenerationMode::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GenerationMode (*this, f, c);
  }

  GenerationMode::Value GenerationMode::
  _xsd_GenerationMode_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_GenerationMode_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_GenerationMode_indexes_,
                      _xsd_GenerationMode_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_GenerationMode_indexes_ + 3 || _xsd_GenerationMode_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const GenerationMode::
  _xsd_GenerationMode_literals_[3] =
  {
    "Real",
    "Test",
    "Demo"
  };

  const GenerationMode::Value GenerationMode::
  _xsd_GenerationMode_indexes_[3] =
  {
    ::CDM::GenerationMode::Demo,
    ::CDM::GenerationMode::Real,
    ::CDM::GenerationMode::Test
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, GenerationMode >
  _xsd_GenerationMode_type_factory_init (
    "GenerationMode",
    "http://domain-model-uri/15/04");

  // CalibrationInfo
  //

  CalibrationInfo::
  CalibrationInfo ()
  : ::xml_schema::Type (),
    Extension_ (this),
    ComponentCalibrationState_ (this)
  {
  }

  CalibrationInfo::
  CalibrationInfo (const CalibrationInfo& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    ComponentCalibrationState_ (x.ComponentCalibrationState_, f, this)
  {
  }

  CalibrationInfo::
  CalibrationInfo (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    ComponentCalibrationState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void CalibrationInfo::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ComponentCalibrationState" && n.namespace_ () == "http://domain-model-uri/15/04")
      {
        this->ComponentCalibrationState_.set (ComponentCalibrationStateTraits::create (i, f, this));
        continue;
      }
    }
  }

  CalibrationInfo* CalibrationInfo::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CalibrationInfo (*this, f, c);
  }

  CalibrationInfo& CalibrationInfo::
  operator= (const CalibrationInfo& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->ComponentCalibrationState_ = x.ComponentCalibrationState_;
    }

    return *this;
  }

  CalibrationInfo::
  ~CalibrationInfo ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CalibrationInfo >
  _xsd_CalibrationInfo_type_factory_init (
    "CalibrationInfo",
    "http://domain-model-uri/15/04");

  // AbstractMetricState
  //

  AbstractMetricState::
  AbstractMetricState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::ComponentState (DescriptorHandle),
    MeasurementPeriod_ (this),
    AveragingPeriod_ (this),
    BodySite_ (this)
  {
  }

  AbstractMetricState::
  AbstractMetricState (const AbstractMetricState& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::ComponentState (x, f, c),
    MeasurementPeriod_ (x.MeasurementPeriod_, f, this),
    AveragingPeriod_ (x.AveragingPeriod_, f, this),
    BodySite_ (x.BodySite_, f, this)
  {
  }

  AbstractMetricState::
  AbstractMetricState (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::ComponentState (e, f | ::xml_schema::Flags::base, c),
    MeasurementPeriod_ (this),
    AveragingPeriod_ (this),
    BodySite_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractMetricState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::ComponentState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MeasurementPeriod
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MeasurementPeriod",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< MeasurementPeriodType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->MeasurementPeriod_)
          {
            ::std::unique_ptr< MeasurementPeriodType > r (
              dynamic_cast< MeasurementPeriodType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MeasurementPeriod_.set (::std::move (r));
            continue;
          }
        }
      }

      // AveragingPeriod
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AveragingPeriod",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< AveragingPeriodType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->AveragingPeriod_)
          {
            ::std::unique_ptr< AveragingPeriodType > r (
              dynamic_cast< AveragingPeriodType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AveragingPeriod_.set (::std::move (r));
            continue;
          }
        }
      }

      // BodySite
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "BodySite",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< BodySiteType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< BodySiteType > r (
            dynamic_cast< BodySiteType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->BodySite_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  AbstractMetricState* AbstractMetricState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractMetricState (*this, f, c);
  }

  AbstractMetricState& AbstractMetricState::
  operator= (const AbstractMetricState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::ComponentState& > (*this) = x;
      this->MeasurementPeriod_ = x.MeasurementPeriod_;
      this->AveragingPeriod_ = x.AveragingPeriod_;
      this->BodySite_ = x.BodySite_;
    }

    return *this;
  }

  AbstractMetricState::
  ~AbstractMetricState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractMetricState >
  _xsd_AbstractMetricState_type_factory_init (
    "AbstractMetricState",
    "http://domain-model-uri/15/04");

  // NumericMetricState
  //

  NumericMetricState::
  NumericMetricState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractMetricState (DescriptorHandle),
    ObservedValue_ (this),
    PhysiologicalRange_ (this)
  {
  }

  NumericMetricState::
  NumericMetricState (const NumericMetricState& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractMetricState (x, f, c),
    ObservedValue_ (x.ObservedValue_, f, this),
    PhysiologicalRange_ (x.PhysiologicalRange_, f, this)
  {
  }

  NumericMetricState::
  NumericMetricState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractMetricState (e, f | ::xml_schema::Flags::base, c),
    ObservedValue_ (this),
    PhysiologicalRange_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void NumericMetricState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ObservedValue
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ObservedValue",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ObservedValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ObservedValue_)
          {
            ::std::unique_ptr< ObservedValueType > r (
              dynamic_cast< ObservedValueType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ObservedValue_.set (::std::move (r));
            continue;
          }
        }
      }

      // PhysiologicalRange
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "PhysiologicalRange",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< PhysiologicalRangeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< PhysiologicalRangeType > r (
            dynamic_cast< PhysiologicalRangeType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->PhysiologicalRange_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  NumericMetricState* NumericMetricState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NumericMetricState (*this, f, c);
  }

  NumericMetricState& NumericMetricState::
  operator= (const NumericMetricState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricState& > (*this) = x;
      this->ObservedValue_ = x.ObservedValue_;
      this->PhysiologicalRange_ = x.PhysiologicalRange_;
    }

    return *this;
  }

  NumericMetricState::
  ~NumericMetricState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, NumericMetricState >
  _xsd_NumericMetricState_type_factory_init (
    "NumericMetricState",
    "http://domain-model-uri/15/04");

  // RealTimeSampleArrayMetricState
  //

  RealTimeSampleArrayMetricState::
  RealTimeSampleArrayMetricState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractMetricState (DescriptorHandle),
    ObservedValue_ (this)
  {
  }

  RealTimeSampleArrayMetricState::
  RealTimeSampleArrayMetricState (const RealTimeSampleArrayMetricState& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::CDM::AbstractMetricState (x, f, c),
    ObservedValue_ (x.ObservedValue_, f, this)
  {
  }

  RealTimeSampleArrayMetricState::
  RealTimeSampleArrayMetricState (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::CDM::AbstractMetricState (e, f | ::xml_schema::Flags::base, c),
    ObservedValue_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void RealTimeSampleArrayMetricState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ObservedValue
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ObservedValue",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ObservedValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ObservedValue_)
          {
            ::std::unique_ptr< ObservedValueType > r (
              dynamic_cast< ObservedValueType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ObservedValue_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  RealTimeSampleArrayMetricState* RealTimeSampleArrayMetricState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RealTimeSampleArrayMetricState (*this, f, c);
  }

  RealTimeSampleArrayMetricState& RealTimeSampleArrayMetricState::
  operator= (const RealTimeSampleArrayMetricState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricState& > (*this) = x;
      this->ObservedValue_ = x.ObservedValue_;
    }

    return *this;
  }

  RealTimeSampleArrayMetricState::
  ~RealTimeSampleArrayMetricState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RealTimeSampleArrayMetricState >
  _xsd_RealTimeSampleArrayMetricState_type_factory_init (
    "RealTimeSampleArrayMetricState",
    "http://domain-model-uri/15/04");

  // StringMetricState
  //

  StringMetricState::
  StringMetricState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::AbstractMetricState (DescriptorHandle),
    ObservedValue_ (this)
  {
  }

  StringMetricState::
  StringMetricState (const StringMetricState& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::AbstractMetricState (x, f, c),
    ObservedValue_ (x.ObservedValue_, f, this)
  {
  }

  StringMetricState::
  StringMetricState (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::AbstractMetricState (e, f | ::xml_schema::Flags::base, c),
    ObservedValue_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void StringMetricState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ObservedValue
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ObservedValue",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ObservedValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ObservedValue_)
          {
            ::std::unique_ptr< ObservedValueType > r (
              dynamic_cast< ObservedValueType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ObservedValue_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  StringMetricState* StringMetricState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class StringMetricState (*this, f, c);
  }

  StringMetricState& StringMetricState::
  operator= (const StringMetricState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricState& > (*this) = x;
      this->ObservedValue_ = x.ObservedValue_;
    }

    return *this;
  }

  StringMetricState::
  ~StringMetricState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, StringMetricState >
  _xsd_StringMetricState_type_factory_init (
    "StringMetricState",
    "http://domain-model-uri/15/04");

  // EnumStringMetricState
  //

  EnumStringMetricState::
  EnumStringMetricState (const DescriptorHandleType& DescriptorHandle)
  : ::CDM::StringMetricState (DescriptorHandle)
  {
  }

  EnumStringMetricState::
  EnumStringMetricState (const EnumStringMetricState& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::StringMetricState (x, f, c)
  {
  }

  EnumStringMetricState::
  EnumStringMetricState (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::CDM::StringMetricState (e, f, c)
  {
  }

  EnumStringMetricState* EnumStringMetricState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EnumStringMetricState (*this, f, c);
  }

  EnumStringMetricState::
  ~EnumStringMetricState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumStringMetricState >
  _xsd_EnumStringMetricState_type_factory_init (
    "EnumStringMetricState",
    "http://domain-model-uri/15/04");

  // QualityIndicator
  //

  QualityIndicator::
  QualityIndicator (const ::xml_schema::Decimal& _xsd_Decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (_xsd_Decimal_base)
  {
  }

  QualityIndicator::
  QualityIndicator (const QualityIndicator& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
  }

  QualityIndicator::
  QualityIndicator (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
  }

  QualityIndicator::
  QualityIndicator (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
  }

  QualityIndicator::
  QualityIndicator (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
  }

  QualityIndicator* QualityIndicator::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class QualityIndicator (*this, f, c);
  }

  QualityIndicator::
  ~QualityIndicator ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, QualityIndicator >
  _xsd_QualityIndicator_type_factory_init (
    "QualityIndicator",
    "http://domain-model-uri/15/04");

  // MeasurementState
  //

  MeasurementState::
  MeasurementState (const ValidityType& Validity)
  : ::xml_schema::Type (),
    Extension_ (this),
    Validity_ (Validity, this),
    Mode_ (this),
    QI_ (this)
  {
  }

  MeasurementState::
  MeasurementState (const MeasurementState& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Validity_ (x.Validity_, f, this),
    Mode_ (x.Mode_, f, this),
    QI_ (x.QI_, f, this)
  {
  }

  MeasurementState::
  MeasurementState (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Validity_ (this),
    Mode_ (this),
    QI_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MeasurementState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Validity" && n.namespace_ ().empty ())
      {
        this->Validity_.set (ValidityTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Mode" && n.namespace_ ().empty ())
      {
        this->Mode_.set (ModeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "QI" && n.namespace_ ().empty ())
      {
        this->QI_.set (QITraits::create (i, f, this));
        continue;
      }
    }

    if (!Validity_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Validity",
        "");
    }
  }

  MeasurementState* MeasurementState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MeasurementState (*this, f, c);
  }

  MeasurementState& MeasurementState::
  operator= (const MeasurementState& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Validity_ = x.Validity_;
      this->Mode_ = x.Mode_;
      this->QI_ = x.QI_;
    }

    return *this;
  }

  MeasurementState::
  ~MeasurementState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MeasurementState >
  _xsd_MeasurementState_type_factory_init (
    "MeasurementState",
    "http://domain-model-uri/15/04");

  // SampleIndex
  //

  SampleIndex::
  SampleIndex (const ::xml_schema::UnsignedInt& _xsd_UnsignedInt_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType > (_xsd_UnsignedInt_base)
  {
  }

  SampleIndex::
  SampleIndex (const SampleIndex& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  SampleIndex::
  SampleIndex (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  SampleIndex::
  SampleIndex (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  SampleIndex::
  SampleIndex (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  SampleIndex* SampleIndex::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SampleIndex (*this, f, c);
  }

  SampleIndex::
  ~SampleIndex ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SampleIndex >
  _xsd_SampleIndex_type_factory_init (
    "SampleIndex",
    "http://domain-model-uri/15/04");

  // Annotation
  //

  Annotation::
  Annotation (const CodeType& Code)
  : ::xml_schema::Type (),
    Extension_ (this),
    Code_ (Code, this),
    SampleIndex_ (this)
  {
  }

  Annotation::
  Annotation (::std::unique_ptr< CodeType > Code)
  : ::xml_schema::Type (),
    Extension_ (this),
    Code_ (std::move (Code), this),
    SampleIndex_ (this)
  {
  }

  Annotation::
  Annotation (const Annotation& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Code_ (x.Code_, f, this),
    SampleIndex_ (x.SampleIndex_, f, this)
  {
  }

  Annotation::
  Annotation (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Code_ (this),
    SampleIndex_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Annotation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // Code
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Code",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< CodeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Code_.present ())
          {
            ::std::unique_ptr< CodeType > r (
              dynamic_cast< CodeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Code_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Code_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Code",
        "http://domain-model-uri/15/04");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "SampleIndex" && n.namespace_ ().empty ())
      {
        this->SampleIndex_.set (SampleIndexTraits::create (i, f, this));
        continue;
      }
    }
  }

  Annotation* Annotation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Annotation (*this, f, c);
  }

  Annotation& Annotation::
  operator= (const Annotation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Code_ = x.Code_;
      this->SampleIndex_ = x.SampleIndex_;
    }

    return *this;
  }

  Annotation::
  ~Annotation ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Annotation >
  _xsd_Annotation_type_factory_init (
    "Annotation",
    "http://domain-model-uri/15/04");

  // AbstractMetricValue
  //

  AbstractMetricValue::
  AbstractMetricValue (const MeasurementStateType& MeasurementState)
  : ::xml_schema::Type (),
    Extension_ (this),
    MeasurementState_ (MeasurementState, this),
    Start_Time_ (this),
    Stop_Time_ (this),
    ObservationTime_ (this)
  {
  }

  AbstractMetricValue::
  AbstractMetricValue (::std::unique_ptr< MeasurementStateType > MeasurementState)
  : ::xml_schema::Type (),
    Extension_ (this),
    MeasurementState_ (std::move (MeasurementState), this),
    Start_Time_ (this),
    Stop_Time_ (this),
    ObservationTime_ (this)
  {
  }

  AbstractMetricValue::
  AbstractMetricValue (const AbstractMetricValue& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    MeasurementState_ (x.MeasurementState_, f, this),
    Start_Time_ (x.Start_Time_, f, this),
    Stop_Time_ (x.Stop_Time_, f, this),
    ObservationTime_ (x.ObservationTime_, f, this)
  {
  }

  AbstractMetricValue::
  AbstractMetricValue (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    MeasurementState_ (this),
    Start_Time_ (this),
    Stop_Time_ (this),
    ObservationTime_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractMetricValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // MeasurementState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MeasurementState",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< MeasurementStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MeasurementState_.present ())
          {
            ::std::unique_ptr< MeasurementStateType > r (
              dynamic_cast< MeasurementStateType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MeasurementState_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!MeasurementState_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MeasurementState",
        "http://domain-model-uri/15/04");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Start-Time" && n.namespace_ ().empty ())
      {
        this->Start_Time_.set (Start_TimeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Stop-Time" && n.namespace_ ().empty ())
      {
        this->Stop_Time_.set (Stop_TimeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ObservationTime" && n.namespace_ ().empty ())
      {
        this->ObservationTime_.set (ObservationTimeTraits::create (i, f, this));
        continue;
      }
    }
  }

  AbstractMetricValue* AbstractMetricValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractMetricValue (*this, f, c);
  }

  AbstractMetricValue& AbstractMetricValue::
  operator= (const AbstractMetricValue& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->MeasurementState_ = x.MeasurementState_;
      this->Start_Time_ = x.Start_Time_;
      this->Stop_Time_ = x.Stop_Time_;
      this->ObservationTime_ = x.ObservationTime_;
    }

    return *this;
  }

  AbstractMetricValue::
  ~AbstractMetricValue ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractMetricValue >
  _xsd_AbstractMetricValue_type_factory_init (
    "AbstractMetricValue",
    "http://domain-model-uri/15/04");

  // NumericMetricValue
  //

  NumericMetricValue::
  NumericMetricValue (const MeasurementStateType& MeasurementState)
  : ::CDM::AbstractMetricValue (MeasurementState),
    Value_ (this)
  {
  }

  NumericMetricValue::
  NumericMetricValue (::std::unique_ptr< MeasurementStateType > MeasurementState)
  : ::CDM::AbstractMetricValue (std::move (MeasurementState)),
    Value_ (this)
  {
  }

  NumericMetricValue::
  NumericMetricValue (const NumericMetricValue& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractMetricValue (x, f, c),
    Value_ (x.Value_, f, this)
  {
  }

  NumericMetricValue::
  NumericMetricValue (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::CDM::AbstractMetricValue (e, f | ::xml_schema::Flags::base, c),
    Value_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void NumericMetricValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricValue::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Value" && n.namespace_ ().empty ())
      {
        this->Value_.set (ValueTraits::create (i, f, this));
        continue;
      }
    }
  }

  NumericMetricValue* NumericMetricValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NumericMetricValue (*this, f, c);
  }

  NumericMetricValue& NumericMetricValue::
  operator= (const NumericMetricValue& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricValue& > (*this) = x;
      this->Value_ = x.Value_;
    }

    return *this;
  }

  NumericMetricValue::
  ~NumericMetricValue ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, NumericMetricValue >
  _xsd_NumericMetricValue_type_factory_init (
    "NumericMetricValue",
    "http://domain-model-uri/15/04");

  // RealTimeSampleArrayValue
  //

  RealTimeSampleArrayValue::
  RealTimeSampleArrayValue (const MeasurementStateType& MeasurementState)
  : ::CDM::AbstractMetricValue (MeasurementState),
    Annotation_ (this),
    Samples_ (this)
  {
  }

  RealTimeSampleArrayValue::
  RealTimeSampleArrayValue (::std::unique_ptr< MeasurementStateType > MeasurementState)
  : ::CDM::AbstractMetricValue (std::move (MeasurementState)),
    Annotation_ (this),
    Samples_ (this)
  {
  }

  RealTimeSampleArrayValue::
  RealTimeSampleArrayValue (const RealTimeSampleArrayValue& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AbstractMetricValue (x, f, c),
    Annotation_ (x.Annotation_, f, this),
    Samples_ (x.Samples_, f, this)
  {
  }

  RealTimeSampleArrayValue::
  RealTimeSampleArrayValue (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AbstractMetricValue (e, f | ::xml_schema::Flags::base, c),
    Annotation_ (this),
    Samples_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void RealTimeSampleArrayValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricValue::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Annotation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Annotation",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< AnnotationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< AnnotationType > r (
            dynamic_cast< AnnotationType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Annotation_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Samples" && n.namespace_ ().empty ())
      {
        this->Samples_.set (SamplesTraits::create (i, f, this));
        continue;
      }
    }
  }

  RealTimeSampleArrayValue* RealTimeSampleArrayValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RealTimeSampleArrayValue (*this, f, c);
  }

  RealTimeSampleArrayValue& RealTimeSampleArrayValue::
  operator= (const RealTimeSampleArrayValue& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricValue& > (*this) = x;
      this->Annotation_ = x.Annotation_;
      this->Samples_ = x.Samples_;
    }

    return *this;
  }

  RealTimeSampleArrayValue::
  ~RealTimeSampleArrayValue ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RealTimeSampleArrayValue >
  _xsd_RealTimeSampleArrayValue_type_factory_init (
    "RealTimeSampleArrayValue",
    "http://domain-model-uri/15/04");

  // RTValueType
  //

  RTValueType::
  RTValueType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal > (e, f, this)
  {
  }

  RTValueType::
  RTValueType (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal > (a, f, this)
  {
  }

  RTValueType::
  RTValueType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, this)
  {
  }

  RTValueType* RTValueType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RTValueType (*this, f, c);
  }

  RTValueType::
  ~RTValueType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RTValueType >
  _xsd_RTValueType_type_factory_init (
    "RTValueType",
    "http://domain-model-uri/15/04");

  // StringMetricValue
  //

  StringMetricValue::
  StringMetricValue (const MeasurementStateType& MeasurementState)
  : ::CDM::AbstractMetricValue (MeasurementState),
    Value_ (this)
  {
  }

  StringMetricValue::
  StringMetricValue (::std::unique_ptr< MeasurementStateType > MeasurementState)
  : ::CDM::AbstractMetricValue (std::move (MeasurementState)),
    Value_ (this)
  {
  }

  StringMetricValue::
  StringMetricValue (const StringMetricValue& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::AbstractMetricValue (x, f, c),
    Value_ (x.Value_, f, this)
  {
  }

  StringMetricValue::
  StringMetricValue (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::CDM::AbstractMetricValue (e, f | ::xml_schema::Flags::base, c),
    Value_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void StringMetricValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractMetricValue::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Value" && n.namespace_ ().empty ())
      {
        this->Value_.set (ValueTraits::create (i, f, this));
        continue;
      }
    }
  }

  StringMetricValue* StringMetricValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class StringMetricValue (*this, f, c);
  }

  StringMetricValue& StringMetricValue::
  operator= (const StringMetricValue& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractMetricValue& > (*this) = x;
      this->Value_ = x.Value_;
    }

    return *this;
  }

  StringMetricValue::
  ~StringMetricValue ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, StringMetricValue >
  _xsd_StringMetricValue_type_factory_init (
    "StringMetricValue",
    "http://domain-model-uri/15/04");

  // ArgumentDescriptorType
  //

  ArgumentDescriptorType::
  ArgumentDescriptorType (const HandleType& Handle,
                          const ArgNameType& ArgName,
                          const ArgTypeType& ArgType)
  : ::CDM::AbstractDescriptor (Handle),
    ArgName_ (ArgName, this),
    ArgType_ (ArgType, this)
  {
  }

  ArgumentDescriptorType::
  ArgumentDescriptorType (const HandleType& Handle,
                          ::std::unique_ptr< ArgNameType > ArgName,
                          const ArgTypeType& ArgType)
  : ::CDM::AbstractDescriptor (Handle),
    ArgName_ (std::move (ArgName), this),
    ArgType_ (ArgType, this)
  {
  }

  ArgumentDescriptorType::
  ArgumentDescriptorType (const HandleType& Handle,
                          ::std::unique_ptr< ArgNameType > ArgName,
                          ::std::unique_ptr< ArgTypeType > ArgType)
  : ::CDM::AbstractDescriptor (Handle),
    ArgName_ (std::move (ArgName), this),
    ArgType_ (std::move (ArgType), this)
  {
  }

  ArgumentDescriptorType::
  ArgumentDescriptorType (const ArgumentDescriptorType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (x, f, c),
    ArgName_ (x.ArgName_, f, this),
    ArgType_ (x.ArgType_, f, this)
  {
  }

  ArgumentDescriptorType::
  ArgumentDescriptorType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (e, f | ::xml_schema::Flags::base, c),
    ArgName_ (this),
    ArgType_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ArgumentDescriptorType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ArgName
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ArgName",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ArgNameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ArgName_.present ())
          {
            ::std::unique_ptr< ArgNameType > r (
              dynamic_cast< ArgNameType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ArgName_.set (::std::move (r));
            continue;
          }
        }
      }

      // ArgType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ArgType",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ArgTypeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ArgType_.present ())
          {
            ::std::unique_ptr< ArgTypeType > r (
              dynamic_cast< ArgTypeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ArgType_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ArgName_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ArgName",
        "http://domain-model-uri/15/04");
    }

    if (!ArgType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ArgType",
        "http://domain-model-uri/15/04");
    }
  }

  ArgumentDescriptorType* ArgumentDescriptorType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ArgumentDescriptorType (*this, f, c);
  }

  ArgumentDescriptorType& ArgumentDescriptorType::
  operator= (const ArgumentDescriptorType& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDescriptor& > (*this) = x;
      this->ArgName_ = x.ArgName_;
      this->ArgType_ = x.ArgType_;
    }

    return *this;
  }

  ArgumentDescriptorType::
  ~ArgumentDescriptorType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ArgumentDescriptorType >
  _xsd_ArgumentDescriptorType_type_factory_init (
    "ArgumentDescriptorType",
    "http://domain-model-uri/15/04");

  // SCODescriptor
  //

  SCODescriptor::
  SCODescriptor (const HandleType& Handle)
  : ::CDM::AbstractDeviceComponent (Handle),
    Operation_ (this)
  {
  }

  SCODescriptor::
  SCODescriptor (const SCODescriptor& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponent (x, f, c),
    Operation_ (x.Operation_, f, this)
  {
  }

  SCODescriptor::
  SCODescriptor (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::CDM::AbstractDeviceComponent (e, f | ::xml_schema::Flags::base, c),
    Operation_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SCODescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDeviceComponent::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Operation
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Operation",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< OperationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< OperationType > r (
            dynamic_cast< OperationType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Operation_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SCODescriptor* SCODescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SCODescriptor (*this, f, c);
  }

  SCODescriptor& SCODescriptor::
  operator= (const SCODescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDeviceComponent& > (*this) = x;
      this->Operation_ = x.Operation_;
    }

    return *this;
  }

  SCODescriptor::
  ~SCODescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SCODescriptor >
  _xsd_SCODescriptor_type_factory_init (
    "SCODescriptor",
    "http://domain-model-uri/15/04");

  // AbstractOperationDescriptor
  //

  AbstractOperationDescriptor::
  AbstractOperationDescriptor (const HandleType& Handle,
                               const OperationTargetType& OperationTarget)
  : ::CDM::AbstractDescriptor (Handle),
    ModifiableElement_ (this),
    OperationTarget_ (OperationTarget, this)
  {
  }

  AbstractOperationDescriptor::
  AbstractOperationDescriptor (const AbstractOperationDescriptor& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (x, f, c),
    ModifiableElement_ (x.ModifiableElement_, f, this),
    OperationTarget_ (x.OperationTarget_, f, this)
  {
  }

  AbstractOperationDescriptor::
  AbstractOperationDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (e, f | ::xml_schema::Flags::base, c),
    ModifiableElement_ (this),
    OperationTarget_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractOperationDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ModifiableElement
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ModifiableElement",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ModifiableElementType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ModifiableElementType > r (
            dynamic_cast< ModifiableElementType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ModifiableElement_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "OperationTarget" && n.namespace_ ().empty ())
      {
        this->OperationTarget_.set (OperationTargetTraits::create (i, f, this));
        continue;
      }
    }

    if (!OperationTarget_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "OperationTarget",
        "");
    }
  }

  AbstractOperationDescriptor* AbstractOperationDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractOperationDescriptor (*this, f, c);
  }

  AbstractOperationDescriptor& AbstractOperationDescriptor::
  operator= (const AbstractOperationDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDescriptor& > (*this) = x;
      this->ModifiableElement_ = x.ModifiableElement_;
      this->OperationTarget_ = x.OperationTarget_;
    }

    return *this;
  }

  AbstractOperationDescriptor::
  ~AbstractOperationDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractOperationDescriptor >
  _xsd_AbstractOperationDescriptor_type_factory_init (
    "AbstractOperationDescriptor",
    "http://domain-model-uri/15/04");

  // SetValueOperationDescriptor
  //

  SetValueOperationDescriptor::
  SetValueOperationDescriptor (const HandleType& Handle,
                               const OperationTargetType& OperationTarget)
  : ::CDM::AbstractOperationDescriptor (Handle,
                                        OperationTarget)
  {
  }

  SetValueOperationDescriptor::
  SetValueOperationDescriptor (const SetValueOperationDescriptor& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (x, f, c)
  {
  }

  SetValueOperationDescriptor::
  SetValueOperationDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (e, f, c)
  {
  }

  SetValueOperationDescriptor* SetValueOperationDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetValueOperationDescriptor (*this, f, c);
  }

  SetValueOperationDescriptor::
  ~SetValueOperationDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetValueOperationDescriptor >
  _xsd_SetValueOperationDescriptor_type_factory_init (
    "SetValueOperationDescriptor",
    "http://domain-model-uri/15/04");

  // SetStringOperationDescriptor
  //

  SetStringOperationDescriptor::
  SetStringOperationDescriptor (const HandleType& Handle,
                                const OperationTargetType& OperationTarget)
  : ::CDM::AbstractOperationDescriptor (Handle,
                                        OperationTarget)
  {
  }

  SetStringOperationDescriptor::
  SetStringOperationDescriptor (const SetStringOperationDescriptor& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (x, f, c)
  {
  }

  SetStringOperationDescriptor::
  SetStringOperationDescriptor (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (e, f, c)
  {
  }

  SetStringOperationDescriptor* SetStringOperationDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetStringOperationDescriptor (*this, f, c);
  }

  SetStringOperationDescriptor::
  ~SetStringOperationDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetStringOperationDescriptor >
  _xsd_SetStringOperationDescriptor_type_factory_init (
    "SetStringOperationDescriptor",
    "http://domain-model-uri/15/04");

  // ActivateOperationDescriptor
  //

  ActivateOperationDescriptor::
  ActivateOperationDescriptor (const HandleType& Handle,
                               const OperationTargetType& OperationTarget)
  : ::CDM::AbstractOperationDescriptor (Handle,
                                        OperationTarget),
    Argument_ (this),
    ActivationDuration_ (this)
  {
  }

  ActivateOperationDescriptor::
  ActivateOperationDescriptor (const ActivateOperationDescriptor& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (x, f, c),
    Argument_ (x.Argument_, f, this),
    ActivationDuration_ (x.ActivationDuration_, f, this)
  {
  }

  ActivateOperationDescriptor::
  ActivateOperationDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (e, f | ::xml_schema::Flags::base, c),
    Argument_ (this),
    ActivationDuration_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ActivateOperationDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractOperationDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Argument
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Argument",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ArgumentType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ArgumentType > r (
            dynamic_cast< ArgumentType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Argument_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ActivationDuration" && n.namespace_ ().empty ())
      {
        this->ActivationDuration_.set (ActivationDurationTraits::create (i, f, this));
        continue;
      }
    }
  }

  ActivateOperationDescriptor* ActivateOperationDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ActivateOperationDescriptor (*this, f, c);
  }

  ActivateOperationDescriptor& ActivateOperationDescriptor::
  operator= (const ActivateOperationDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractOperationDescriptor& > (*this) = x;
      this->Argument_ = x.Argument_;
      this->ActivationDuration_ = x.ActivationDuration_;
    }

    return *this;
  }

  ActivateOperationDescriptor::
  ~ActivateOperationDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ActivateOperationDescriptor >
  _xsd_ActivateOperationDescriptor_type_factory_init (
    "ActivateOperationDescriptor",
    "http://domain-model-uri/15/04");

  // NonGenericOperationDescriptor
  //

  NonGenericOperationDescriptor::
  NonGenericOperationDescriptor (const HandleType& Handle,
                                 const OperationTargetType& OperationTarget)
  : ::CDM::AbstractOperationDescriptor (Handle,
                                        OperationTarget)
  {
  }

  NonGenericOperationDescriptor::
  NonGenericOperationDescriptor (const NonGenericOperationDescriptor& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (x, f, c)
  {
  }

  NonGenericOperationDescriptor::
  NonGenericOperationDescriptor (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (e, f, c)
  {
  }

  NonGenericOperationDescriptor* NonGenericOperationDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NonGenericOperationDescriptor (*this, f, c);
  }

  NonGenericOperationDescriptor::
  ~NonGenericOperationDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, NonGenericOperationDescriptor >
  _xsd_NonGenericOperationDescriptor_type_factory_init (
    "NonGenericOperationDescriptor",
    "http://domain-model-uri/15/04");

  // SetAlertStateOperationDescriptor
  //

  SetAlertStateOperationDescriptor::
  SetAlertStateOperationDescriptor (const HandleType& Handle,
                                    const OperationTargetType& OperationTarget)
  : ::CDM::AbstractOperationDescriptor (Handle,
                                        OperationTarget)
  {
  }

  SetAlertStateOperationDescriptor::
  SetAlertStateOperationDescriptor (const SetAlertStateOperationDescriptor& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (x, f, c)
  {
  }

  SetAlertStateOperationDescriptor::
  SetAlertStateOperationDescriptor (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (e, f, c)
  {
  }

  SetAlertStateOperationDescriptor* SetAlertStateOperationDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetAlertStateOperationDescriptor (*this, f, c);
  }

  SetAlertStateOperationDescriptor::
  ~SetAlertStateOperationDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetAlertStateOperationDescriptor >
  _xsd_SetAlertStateOperationDescriptor_type_factory_init (
    "SetAlertStateOperationDescriptor",
    "http://domain-model-uri/15/04");

  // SetRangeOperationDescriptor
  //

  SetRangeOperationDescriptor::
  SetRangeOperationDescriptor (const HandleType& Handle,
                               const OperationTargetType& OperationTarget,
                               const AllowedMaxRangeType& AllowedMaxRange)
  : ::CDM::AbstractOperationDescriptor (Handle,
                                        OperationTarget),
    AllowedMaxRange_ (AllowedMaxRange, this)
  {
  }

  SetRangeOperationDescriptor::
  SetRangeOperationDescriptor (const HandleType& Handle,
                               const OperationTargetType& OperationTarget,
                               ::std::unique_ptr< AllowedMaxRangeType > AllowedMaxRange)
  : ::CDM::AbstractOperationDescriptor (Handle,
                                        OperationTarget),
    AllowedMaxRange_ (std::move (AllowedMaxRange), this)
  {
  }

  SetRangeOperationDescriptor::
  SetRangeOperationDescriptor (const SetRangeOperationDescriptor& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (x, f, c),
    AllowedMaxRange_ (x.AllowedMaxRange_, f, this)
  {
  }

  SetRangeOperationDescriptor::
  SetRangeOperationDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (e, f | ::xml_schema::Flags::base, c),
    AllowedMaxRange_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SetRangeOperationDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractOperationDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AllowedMaxRange
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AllowedMaxRange",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< AllowedMaxRangeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!AllowedMaxRange_.present ())
          {
            ::std::unique_ptr< AllowedMaxRangeType > r (
              dynamic_cast< AllowedMaxRangeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AllowedMaxRange_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!AllowedMaxRange_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AllowedMaxRange",
        "http://domain-model-uri/15/04");
    }
  }

  SetRangeOperationDescriptor* SetRangeOperationDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetRangeOperationDescriptor (*this, f, c);
  }

  SetRangeOperationDescriptor& SetRangeOperationDescriptor::
  operator= (const SetRangeOperationDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractOperationDescriptor& > (*this) = x;
      this->AllowedMaxRange_ = x.AllowedMaxRange_;
    }

    return *this;
  }

  SetRangeOperationDescriptor::
  ~SetRangeOperationDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetRangeOperationDescriptor >
  _xsd_SetRangeOperationDescriptor_type_factory_init (
    "SetRangeOperationDescriptor",
    "http://domain-model-uri/15/04");

  // SetContextOperationDescriptor
  //

  SetContextOperationDescriptor::
  SetContextOperationDescriptor (const HandleType& Handle,
                                 const OperationTargetType& OperationTarget)
  : ::CDM::AbstractOperationDescriptor (Handle,
                                        OperationTarget)
  {
  }

  SetContextOperationDescriptor::
  SetContextOperationDescriptor (const SetContextOperationDescriptor& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (x, f, c)
  {
  }

  SetContextOperationDescriptor::
  SetContextOperationDescriptor (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::CDM::AbstractOperationDescriptor (e, f, c)
  {
  }

  SetContextOperationDescriptor* SetContextOperationDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetContextOperationDescriptor (*this, f, c);
  }

  SetContextOperationDescriptor::
  ~SetContextOperationDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetContextOperationDescriptor >
  _xsd_SetContextOperationDescriptor_type_factory_init (
    "SetContextOperationDescriptor",
    "http://domain-model-uri/15/04");

  // OperatingMode
  //

  OperatingMode::
  OperatingMode (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_OperatingMode_convert ();
  }

  OperatingMode::
  OperatingMode (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_OperatingMode_convert ();
  }

  OperatingMode::
  OperatingMode (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_OperatingMode_convert ();
  }

  OperatingMode* OperatingMode::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OperatingMode (*this, f, c);
  }

  OperatingMode::Value OperatingMode::
  _xsd_OperatingMode_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_OperatingMode_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_OperatingMode_indexes_,
                      _xsd_OperatingMode_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_OperatingMode_indexes_ + 3 || _xsd_OperatingMode_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const OperatingMode::
  _xsd_OperatingMode_literals_[3] =
  {
    "Dis",
    "En",
    "NA"
  };

  const OperatingMode::Value OperatingMode::
  _xsd_OperatingMode_indexes_[3] =
  {
    ::CDM::OperatingMode::Dis,
    ::CDM::OperatingMode::En,
    ::CDM::OperatingMode::NA
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OperatingMode >
  _xsd_OperatingMode_type_factory_init (
    "OperatingMode",
    "http://domain-model-uri/15/04");

  // OperationState
  //

  OperationState::
  OperationState (const DescriptorHandleType& DescriptorHandle,
                  const OperatingModeType& OperatingMode)
  : ::CDM::AbstractState (DescriptorHandle),
    OperatingMode_ (OperatingMode, this)
  {
  }

  OperationState::
  OperationState (const OperationState& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::CDM::AbstractState (x, f, c),
    OperatingMode_ (x.OperatingMode_, f, this)
  {
  }

  OperationState::
  OperationState (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::CDM::AbstractState (e, f | ::xml_schema::Flags::base, c),
    OperatingMode_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void OperationState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractState::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "OperatingMode" && n.namespace_ ().empty ())
      {
        this->OperatingMode_.set (OperatingModeTraits::create (i, f, this));
        continue;
      }
    }

    if (!OperatingMode_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "OperatingMode",
        "");
    }
  }

  OperationState* OperationState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OperationState (*this, f, c);
  }

  OperationState& OperationState::
  operator= (const OperationState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractState& > (*this) = x;
      this->OperatingMode_ = x.OperatingMode_;
    }

    return *this;
  }

  OperationState::
  ~OperationState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OperationState >
  _xsd_OperationState_type_factory_init (
    "OperationState",
    "http://domain-model-uri/15/04");

  // SetValueOperationState
  //

  SetValueOperationState::
  SetValueOperationState (const DescriptorHandleType& DescriptorHandle,
                          const OperatingModeType& OperatingMode)
  : ::CDM::OperationState (DescriptorHandle,
                           OperatingMode),
    allowedRange_ (this)
  {
  }

  SetValueOperationState::
  SetValueOperationState (const SetValueOperationState& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::OperationState (x, f, c),
    allowedRange_ (x.allowedRange_, f, this)
  {
  }

  SetValueOperationState::
  SetValueOperationState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::OperationState (e, f | ::xml_schema::Flags::base, c),
    allowedRange_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SetValueOperationState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::OperationState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // allowedRange
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "allowedRange",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< AllowedRangeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< AllowedRangeType > r (
            dynamic_cast< AllowedRangeType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->allowedRange_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SetValueOperationState* SetValueOperationState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetValueOperationState (*this, f, c);
  }

  SetValueOperationState& SetValueOperationState::
  operator= (const SetValueOperationState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::OperationState& > (*this) = x;
      this->allowedRange_ = x.allowedRange_;
    }

    return *this;
  }

  SetValueOperationState::
  ~SetValueOperationState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetValueOperationState >
  _xsd_SetValueOperationState_type_factory_init (
    "SetValueOperationState",
    "http://domain-model-uri/15/04");

  // SetRangeOperationState
  //

  SetRangeOperationState::
  SetRangeOperationState (const DescriptorHandleType& DescriptorHandle,
                          const OperatingModeType& OperatingMode)
  : ::CDM::OperationState (DescriptorHandle,
                           OperatingMode),
    allowedRange_ (this)
  {
  }

  SetRangeOperationState::
  SetRangeOperationState (const SetRangeOperationState& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::OperationState (x, f, c),
    allowedRange_ (x.allowedRange_, f, this)
  {
  }

  SetRangeOperationState::
  SetRangeOperationState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::CDM::OperationState (e, f | ::xml_schema::Flags::base, c),
    allowedRange_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SetRangeOperationState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::OperationState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // allowedRange
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "allowedRange",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< AllowedRangeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< AllowedRangeType > r (
            dynamic_cast< AllowedRangeType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->allowedRange_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SetRangeOperationState* SetRangeOperationState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetRangeOperationState (*this, f, c);
  }

  SetRangeOperationState& SetRangeOperationState::
  operator= (const SetRangeOperationState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::OperationState& > (*this) = x;
      this->allowedRange_ = x.allowedRange_;
    }

    return *this;
  }

  SetRangeOperationState::
  ~SetRangeOperationState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SetRangeOperationState >
  _xsd_SetRangeOperationState_type_factory_init (
    "SetRangeOperationState",
    "http://domain-model-uri/15/04");

  // TimeZone
  //

  TimeZone::
  TimeZone ()
  : ::xml_schema::String ()
  {
  }

  TimeZone::
  TimeZone (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  TimeZone::
  TimeZone (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  TimeZone::
  TimeZone (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  TimeZone::
  TimeZone (const TimeZone& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  TimeZone::
  TimeZone (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  TimeZone::
  TimeZone (const ::xercesc::DOMAttr& a,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  TimeZone::
  TimeZone (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  TimeZone* TimeZone::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimeZone (*this, f, c);
  }

  TimeZone::
  ~TimeZone ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, TimeZone >
  _xsd_TimeZone_type_factory_init (
    "TimeZone",
    "http://domain-model-uri/15/04");

  // ClockDescriptor
  //

  ClockDescriptor::
  ClockDescriptor (const HandleType& Handle)
  : ::CDM::AbstractDescriptor (Handle),
    TimeProtocol_ (this),
    Resolution_ (this)
  {
  }

  ClockDescriptor::
  ClockDescriptor (const ClockDescriptor& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (x, f, c),
    TimeProtocol_ (x.TimeProtocol_, f, this),
    Resolution_ (x.Resolution_, f, this)
  {
  }

  ClockDescriptor::
  ClockDescriptor (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (e, f | ::xml_schema::Flags::base, c),
    TimeProtocol_ (this),
    Resolution_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ClockDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractDescriptor::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TimeProtocol
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TimeProtocol",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< TimeProtocolType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< TimeProtocolType > r (
            dynamic_cast< TimeProtocolType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TimeProtocol_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Resolution" && n.namespace_ ().empty ())
      {
        this->Resolution_.set (ResolutionTraits::create (i, f, this));
        continue;
      }
    }
  }

  ClockDescriptor* ClockDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ClockDescriptor (*this, f, c);
  }

  ClockDescriptor& ClockDescriptor::
  operator= (const ClockDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractDescriptor& > (*this) = x;
      this->TimeProtocol_ = x.TimeProtocol_;
      this->Resolution_ = x.Resolution_;
    }

    return *this;
  }

  ClockDescriptor::
  ~ClockDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ClockDescriptor >
  _xsd_ClockDescriptor_type_factory_init (
    "ClockDescriptor",
    "http://domain-model-uri/15/04");

  // ClockState
  //

  ClockState::
  ClockState (const DescriptorHandleType& DescriptorHandle,
              const RemoteSyncType& RemoteSync)
  : ::CDM::AbstractState (DescriptorHandle),
    ActiveSyncProtocol_ (this),
    DateAndTime_ (this),
    RemoteSync_ (RemoteSync, this),
    ReferenceSource_ (this),
    Accuracy_ (this),
    LastSet_ (this),
    TimeZone_ (this),
    CriticalUse_ (this)
  {
  }

  ClockState::
  ClockState (const ClockState& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::CDM::AbstractState (x, f, c),
    ActiveSyncProtocol_ (x.ActiveSyncProtocol_, f, this),
    DateAndTime_ (x.DateAndTime_, f, this),
    RemoteSync_ (x.RemoteSync_, f, this),
    ReferenceSource_ (x.ReferenceSource_, f, this),
    Accuracy_ (x.Accuracy_, f, this),
    LastSet_ (x.LastSet_, f, this),
    TimeZone_ (x.TimeZone_, f, this),
    CriticalUse_ (x.CriticalUse_, f, this)
  {
  }

  ClockState::
  ClockState (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::CDM::AbstractState (e, f | ::xml_schema::Flags::base, c),
    ActiveSyncProtocol_ (this),
    DateAndTime_ (this),
    RemoteSync_ (this),
    ReferenceSource_ (this),
    Accuracy_ (this),
    LastSet_ (this),
    TimeZone_ (this),
    CriticalUse_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ClockState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ActiveSyncProtocol
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ActiveSyncProtocol",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ActiveSyncProtocolType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ActiveSyncProtocol_)
          {
            ::std::unique_ptr< ActiveSyncProtocolType > r (
              dynamic_cast< ActiveSyncProtocolType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ActiveSyncProtocol_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "DateAndTime" && n.namespace_ ().empty ())
      {
        this->DateAndTime_.set (DateAndTimeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "RemoteSync" && n.namespace_ ().empty ())
      {
        this->RemoteSync_.set (RemoteSyncTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ReferenceSource" && n.namespace_ ().empty ())
      {
        this->ReferenceSource_.set (ReferenceSourceTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Accuracy" && n.namespace_ ().empty ())
      {
        this->Accuracy_.set (AccuracyTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "LastSet" && n.namespace_ ().empty ())
      {
        this->LastSet_.set (LastSetTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "TimeZone" && n.namespace_ ().empty ())
      {
        this->TimeZone_.set (TimeZoneTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "CriticalUse" && n.namespace_ ().empty ())
      {
        this->CriticalUse_.set (CriticalUseTraits::create (i, f, this));
        continue;
      }
    }

    if (!RemoteSync_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "RemoteSync",
        "");
    }
  }

  ClockState* ClockState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ClockState (*this, f, c);
  }

  ClockState& ClockState::
  operator= (const ClockState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractState& > (*this) = x;
      this->ActiveSyncProtocol_ = x.ActiveSyncProtocol_;
      this->DateAndTime_ = x.DateAndTime_;
      this->RemoteSync_ = x.RemoteSync_;
      this->ReferenceSource_ = x.ReferenceSource_;
      this->Accuracy_ = x.Accuracy_;
      this->LastSet_ = x.LastSet_;
      this->TimeZone_ = x.TimeZone_;
      this->CriticalUse_ = x.CriticalUse_;
    }

    return *this;
  }

  ClockState::
  ~ClockState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ClockState >
  _xsd_ClockState_type_factory_init (
    "ClockState",
    "http://domain-model-uri/15/04");

  // AbstractContextDescriptor
  //

  AbstractContextDescriptor::
  AbstractContextDescriptor (const HandleType& Handle)
  : ::CDM::AbstractDescriptor (Handle)
  {
  }

  AbstractContextDescriptor::
  AbstractContextDescriptor (const AbstractContextDescriptor& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (x, f, c)
  {
  }

  AbstractContextDescriptor::
  AbstractContextDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractDescriptor (e, f, c)
  {
  }

  AbstractContextDescriptor* AbstractContextDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractContextDescriptor (*this, f, c);
  }

  AbstractContextDescriptor::
  ~AbstractContextDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractContextDescriptor >
  _xsd_AbstractContextDescriptor_type_factory_init (
    "AbstractContextDescriptor",
    "http://domain-model-uri/15/04");

  // LocationContextDescriptor
  //

  LocationContextDescriptor::
  LocationContextDescriptor (const HandleType& Handle)
  : ::CDM::AbstractContextDescriptor (Handle)
  {
  }

  LocationContextDescriptor::
  LocationContextDescriptor (const LocationContextDescriptor& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (x, f, c)
  {
  }

  LocationContextDescriptor::
  LocationContextDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (e, f, c)
  {
  }

  LocationContextDescriptor* LocationContextDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LocationContextDescriptor (*this, f, c);
  }

  LocationContextDescriptor::
  ~LocationContextDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LocationContextDescriptor >
  _xsd_LocationContextDescriptor_type_factory_init (
    "LocationContextDescriptor",
    "http://domain-model-uri/15/04");

  // EnsembleContextDescriptor
  //

  EnsembleContextDescriptor::
  EnsembleContextDescriptor (const HandleType& Handle)
  : ::CDM::AbstractContextDescriptor (Handle)
  {
  }

  EnsembleContextDescriptor::
  EnsembleContextDescriptor (const EnsembleContextDescriptor& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (x, f, c)
  {
  }

  EnsembleContextDescriptor::
  EnsembleContextDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (e, f, c)
  {
  }

  EnsembleContextDescriptor* EnsembleContextDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EnsembleContextDescriptor (*this, f, c);
  }

  EnsembleContextDescriptor::
  ~EnsembleContextDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnsembleContextDescriptor >
  _xsd_EnsembleContextDescriptor_type_factory_init (
    "EnsembleContextDescriptor",
    "http://domain-model-uri/15/04");

  // OperatorContextDescriptor
  //

  OperatorContextDescriptor::
  OperatorContextDescriptor (const HandleType& Handle)
  : ::CDM::AbstractContextDescriptor (Handle)
  {
  }

  OperatorContextDescriptor::
  OperatorContextDescriptor (const OperatorContextDescriptor& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (x, f, c)
  {
  }

  OperatorContextDescriptor::
  OperatorContextDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (e, f, c)
  {
  }

  OperatorContextDescriptor* OperatorContextDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OperatorContextDescriptor (*this, f, c);
  }

  OperatorContextDescriptor::
  ~OperatorContextDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OperatorContextDescriptor >
  _xsd_OperatorContextDescriptor_type_factory_init (
    "OperatorContextDescriptor",
    "http://domain-model-uri/15/04");

  // WorkflowContextDescriptor
  //

  WorkflowContextDescriptor::
  WorkflowContextDescriptor (const HandleType& Handle)
  : ::CDM::AbstractContextDescriptor (Handle)
  {
  }

  WorkflowContextDescriptor::
  WorkflowContextDescriptor (const WorkflowContextDescriptor& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (x, f, c)
  {
  }

  WorkflowContextDescriptor::
  WorkflowContextDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (e, f, c)
  {
  }

  WorkflowContextDescriptor* WorkflowContextDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class WorkflowContextDescriptor (*this, f, c);
  }

  WorkflowContextDescriptor::
  ~WorkflowContextDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, WorkflowContextDescriptor >
  _xsd_WorkflowContextDescriptor_type_factory_init (
    "WorkflowContextDescriptor",
    "http://domain-model-uri/15/04");

  // AbstractContextState
  //

  AbstractContextState::
  AbstractContextState (const DescriptorHandleType& DescriptorHandle,
                        const BindingMDIBVersionType& BindingMDIBVersion)
  : ::CDM::AbstractState (DescriptorHandle),
    Validator_ (this),
    ContextAssociation_ (this),
    BindingMDIBVersion_ (BindingMDIBVersion, this),
    UnbindingMDIBVersion_ (this),
    BindingStartTime_ (this),
    BindingEndTime_ (this)
  {
  }

  AbstractContextState::
  AbstractContextState (const AbstractContextState& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractState (x, f, c),
    Validator_ (x.Validator_, f, this),
    ContextAssociation_ (x.ContextAssociation_, f, this),
    BindingMDIBVersion_ (x.BindingMDIBVersion_, f, this),
    UnbindingMDIBVersion_ (x.UnbindingMDIBVersion_, f, this),
    BindingStartTime_ (x.BindingStartTime_, f, this),
    BindingEndTime_ (x.BindingEndTime_, f, this)
  {
  }

  AbstractContextState::
  AbstractContextState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractState (e, f | ::xml_schema::Flags::base, c),
    Validator_ (this),
    ContextAssociation_ (this),
    BindingMDIBVersion_ (this),
    UnbindingMDIBVersion_ (this),
    BindingStartTime_ (this),
    BindingEndTime_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractContextState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Validator
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Validator",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ValidatorType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ValidatorType > r (
            dynamic_cast< ValidatorType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Validator_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ContextAssociation" && n.namespace_ ().empty ())
      {
        this->ContextAssociation_.set (ContextAssociationTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "BindingMDIBVersion" && n.namespace_ ().empty ())
      {
        this->BindingMDIBVersion_.set (BindingMDIBVersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "UnbindingMDIBVersion" && n.namespace_ ().empty ())
      {
        this->UnbindingMDIBVersion_.set (UnbindingMDIBVersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "BindingStartTime" && n.namespace_ ().empty ())
      {
        this->BindingStartTime_.set (BindingStartTimeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "BindingEndTime" && n.namespace_ ().empty ())
      {
        this->BindingEndTime_.set (BindingEndTimeTraits::create (i, f, this));
        continue;
      }
    }

    if (!BindingMDIBVersion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "BindingMDIBVersion",
        "");
    }
  }

  AbstractContextState* AbstractContextState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractContextState (*this, f, c);
  }

  AbstractContextState& AbstractContextState::
  operator= (const AbstractContextState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractState& > (*this) = x;
      this->Validator_ = x.Validator_;
      this->ContextAssociation_ = x.ContextAssociation_;
      this->BindingMDIBVersion_ = x.BindingMDIBVersion_;
      this->UnbindingMDIBVersion_ = x.UnbindingMDIBVersion_;
      this->BindingStartTime_ = x.BindingStartTime_;
      this->BindingEndTime_ = x.BindingEndTime_;
    }

    return *this;
  }

  AbstractContextState::
  ~AbstractContextState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractContextState >
  _xsd_AbstractContextState_type_factory_init (
    "AbstractContextState",
    "http://domain-model-uri/15/04");

  // AbstractIdentifiableContextState
  //

  AbstractIdentifiableContextState::
  AbstractIdentifiableContextState (const DescriptorHandleType& DescriptorHandle,
                                    const BindingMDIBVersionType& BindingMDIBVersion)
  : ::CDM::AbstractContextState (DescriptorHandle,
                                 BindingMDIBVersion),
    Identification_ (this)
  {
  }

  AbstractIdentifiableContextState::
  AbstractIdentifiableContextState (const AbstractIdentifiableContextState& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::CDM::AbstractContextState (x, f, c),
    Identification_ (x.Identification_, f, this)
  {
  }

  AbstractIdentifiableContextState::
  AbstractIdentifiableContextState (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::CDM::AbstractContextState (e, f | ::xml_schema::Flags::base, c),
    Identification_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractIdentifiableContextState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractContextState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Identification
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Identification",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< IdentificationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< IdentificationType > r (
            dynamic_cast< IdentificationType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Identification_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  AbstractIdentifiableContextState* AbstractIdentifiableContextState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractIdentifiableContextState (*this, f, c);
  }

  AbstractIdentifiableContextState& AbstractIdentifiableContextState::
  operator= (const AbstractIdentifiableContextState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractContextState& > (*this) = x;
      this->Identification_ = x.Identification_;
    }

    return *this;
  }

  AbstractIdentifiableContextState::
  ~AbstractIdentifiableContextState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractIdentifiableContextState >
  _xsd_AbstractIdentifiableContextState_type_factory_init (
    "AbstractIdentifiableContextState",
    "http://domain-model-uri/15/04");

  // LocationContextState
  //

  LocationContextState::
  LocationContextState (const DescriptorHandleType& DescriptorHandle,
                        const BindingMDIBVersionType& BindingMDIBVersion)
  : ::CDM::AbstractIdentifiableContextState (DescriptorHandle,
                                             BindingMDIBVersion)
  {
  }

  LocationContextState::
  LocationContextState (const LocationContextState& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractIdentifiableContextState (x, f, c)
  {
  }

  LocationContextState::
  LocationContextState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractIdentifiableContextState (e, f, c)
  {
  }

  LocationContextState* LocationContextState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LocationContextState (*this, f, c);
  }

  LocationContextState::
  ~LocationContextState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, LocationContextState >
  _xsd_LocationContextState_type_factory_init (
    "LocationContextState",
    "http://domain-model-uri/15/04");

  // EnsembleContextState
  //

  EnsembleContextState::
  EnsembleContextState (const DescriptorHandleType& DescriptorHandle,
                        const BindingMDIBVersionType& BindingMDIBVersion)
  : ::CDM::AbstractIdentifiableContextState (DescriptorHandle,
                                             BindingMDIBVersion)
  {
  }

  EnsembleContextState::
  EnsembleContextState (const EnsembleContextState& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractIdentifiableContextState (x, f, c)
  {
  }

  EnsembleContextState::
  EnsembleContextState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractIdentifiableContextState (e, f, c)
  {
  }

  EnsembleContextState* EnsembleContextState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EnsembleContextState (*this, f, c);
  }

  EnsembleContextState::
  ~EnsembleContextState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnsembleContextState >
  _xsd_EnsembleContextState_type_factory_init (
    "EnsembleContextState",
    "http://domain-model-uri/15/04");

  // WorkflowContextState
  //

  WorkflowContextState::
  WorkflowContextState (const DescriptorHandleType& DescriptorHandle,
                        const BindingMDIBVersionType& BindingMDIBVersion)
  : ::CDM::AbstractIdentifiableContextState (DescriptorHandle,
                                             BindingMDIBVersion),
    OrderDetail_ (this)
  {
  }

  WorkflowContextState::
  WorkflowContextState (const WorkflowContextState& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractIdentifiableContextState (x, f, c),
    OrderDetail_ (x.OrderDetail_, f, this)
  {
  }

  WorkflowContextState::
  WorkflowContextState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractIdentifiableContextState (e, f | ::xml_schema::Flags::base, c),
    OrderDetail_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void WorkflowContextState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractIdentifiableContextState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OrderDetail
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OrderDetail",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< OrderDetailType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->OrderDetail_)
          {
            ::std::unique_ptr< OrderDetailType > r (
              dynamic_cast< OrderDetailType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OrderDetail_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  WorkflowContextState* WorkflowContextState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class WorkflowContextState (*this, f, c);
  }

  WorkflowContextState& WorkflowContextState::
  operator= (const WorkflowContextState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractIdentifiableContextState& > (*this) = x;
      this->OrderDetail_ = x.OrderDetail_;
    }

    return *this;
  }

  WorkflowContextState::
  ~WorkflowContextState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, WorkflowContextState >
  _xsd_WorkflowContextState_type_factory_init (
    "WorkflowContextState",
    "http://domain-model-uri/15/04");

  // OperatorContextState
  //

  OperatorContextState::
  OperatorContextState (const DescriptorHandleType& DescriptorHandle,
                        const BindingMDIBVersionType& BindingMDIBVersion)
  : ::CDM::AbstractIdentifiableContextState (DescriptorHandle,
                                             BindingMDIBVersion)
  {
  }

  OperatorContextState::
  OperatorContextState (const OperatorContextState& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractIdentifiableContextState (x, f, c)
  {
  }

  OperatorContextState::
  OperatorContextState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::CDM::AbstractIdentifiableContextState (e, f, c)
  {
  }

  OperatorContextState* OperatorContextState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OperatorContextState (*this, f, c);
  }

  OperatorContextState::
  ~OperatorContextState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OperatorContextState >
  _xsd_OperatorContextState_type_factory_init (
    "OperatorContextState",
    "http://domain-model-uri/15/04");

  // ContextAssociation
  //

  ContextAssociation::
  ContextAssociation (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_ContextAssociation_convert ();
  }

  ContextAssociation::
  ContextAssociation (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_ContextAssociation_convert ();
  }

  ContextAssociation::
  ContextAssociation (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_ContextAssociation_convert ();
  }

  ContextAssociation* ContextAssociation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ContextAssociation (*this, f, c);
  }

  ContextAssociation::Value ContextAssociation::
  _xsd_ContextAssociation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ContextAssociation_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_ContextAssociation_indexes_,
                      _xsd_ContextAssociation_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_ContextAssociation_indexes_ + 4 || _xsd_ContextAssociation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ContextAssociation::
  _xsd_ContextAssociation_literals_[4] =
  {
    "No",
    "Pre",
    "Assoc",
    "Dis"
  };

  const ContextAssociation::Value ContextAssociation::
  _xsd_ContextAssociation_indexes_[4] =
  {
    ::CDM::ContextAssociation::Assoc,
    ::CDM::ContextAssociation::Dis,
    ::CDM::ContextAssociation::No,
    ::CDM::ContextAssociation::Pre
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ContextAssociation >
  _xsd_ContextAssociation_type_factory_init (
    "ContextAssociation",
    "http://domain-model-uri/15/04");

  // PatientContextDescriptor
  //

  PatientContextDescriptor::
  PatientContextDescriptor (const HandleType& Handle)
  : ::CDM::AbstractContextDescriptor (Handle)
  {
  }

  PatientContextDescriptor::
  PatientContextDescriptor (const PatientContextDescriptor& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (x, f, c)
  {
  }

  PatientContextDescriptor::
  PatientContextDescriptor (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::CDM::AbstractContextDescriptor (e, f, c)
  {
  }

  PatientContextDescriptor* PatientContextDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PatientContextDescriptor (*this, f, c);
  }

  PatientContextDescriptor::
  ~PatientContextDescriptor ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, PatientContextDescriptor >
  _xsd_PatientContextDescriptor_type_factory_init (
    "PatientContextDescriptor",
    "http://domain-model-uri/15/04");

  // BaseDemographics
  //

  BaseDemographics::
  BaseDemographics ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Givenname_ (this),
    Middlename_ (this),
    Familyname_ (this),
    Birthname_ (this),
    Title_ (this)
  {
  }

  BaseDemographics::
  BaseDemographics (const BaseDemographics& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Givenname_ (x.Givenname_, f, this),
    Middlename_ (x.Middlename_, f, this),
    Familyname_ (x.Familyname_, f, this),
    Birthname_ (x.Birthname_, f, this),
    Title_ (x.Title_, f, this)
  {
  }

  BaseDemographics::
  BaseDemographics (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Givenname_ (this),
    Middlename_ (this),
    Familyname_ (this),
    Birthname_ (this),
    Title_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void BaseDemographics::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // Givenname
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Givenname",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< GivennameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Givenname_)
          {
            ::std::unique_ptr< GivennameType > r (
              dynamic_cast< GivennameType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Givenname_.set (::std::move (r));
            continue;
          }
        }
      }

      // Middlename
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Middlename",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< MiddlenameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< MiddlenameType > r (
            dynamic_cast< MiddlenameType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Middlename_.push_back (::std::move (r));
          continue;
        }
      }

      // Familyname
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Familyname",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< FamilynameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Familyname_)
          {
            ::std::unique_ptr< FamilynameType > r (
              dynamic_cast< FamilynameType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Familyname_.set (::std::move (r));
            continue;
          }
        }
      }

      // Birthname
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Birthname",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< BirthnameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Birthname_)
          {
            ::std::unique_ptr< BirthnameType > r (
              dynamic_cast< BirthnameType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Birthname_.set (::std::move (r));
            continue;
          }
        }
      }

      // Title
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Title",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< TitleType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Title_)
          {
            ::std::unique_ptr< TitleType > r (
              dynamic_cast< TitleType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Title_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  BaseDemographics* BaseDemographics::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BaseDemographics (*this, f, c);
  }

  BaseDemographics& BaseDemographics::
  operator= (const BaseDemographics& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Givenname_ = x.Givenname_;
      this->Middlename_ = x.Middlename_;
      this->Familyname_ = x.Familyname_;
      this->Birthname_ = x.Birthname_;
      this->Title_ = x.Title_;
    }

    return *this;
  }

  BaseDemographics::
  ~BaseDemographics ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, BaseDemographics >
  _xsd_BaseDemographics_type_factory_init (
    "BaseDemographics",
    "http://domain-model-uri/15/04");

  // PatientDemographicsCoreData
  //

  PatientDemographicsCoreData::
  PatientDemographicsCoreData ()
  : ::CDM::BaseDemographics (),
    Sex_ (this),
    PatientType_ (this),
    DateOfBirth_ (this),
    Height_ (this),
    Weight_ (this),
    Race_ (this)
  {
  }

  PatientDemographicsCoreData::
  PatientDemographicsCoreData (const PatientDemographicsCoreData& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::BaseDemographics (x, f, c),
    Sex_ (x.Sex_, f, this),
    PatientType_ (x.PatientType_, f, this),
    DateOfBirth_ (x.DateOfBirth_, f, this),
    Height_ (x.Height_, f, this),
    Weight_ (x.Weight_, f, this),
    Race_ (x.Race_, f, this)
  {
  }

  PatientDemographicsCoreData::
  PatientDemographicsCoreData (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::CDM::BaseDemographics (e, f | ::xml_schema::Flags::base, c),
    Sex_ (this),
    PatientType_ (this),
    DateOfBirth_ (this),
    Height_ (this),
    Weight_ (this),
    Race_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PatientDemographicsCoreData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::BaseDemographics::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Sex
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Sex",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< SexType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Sex_)
          {
            ::std::unique_ptr< SexType > r (
              dynamic_cast< SexType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Sex_.set (::std::move (r));
            continue;
          }
        }
      }

      // PatientType
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "PatientType",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< PatientTypeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->PatientType_)
          {
            ::std::unique_ptr< PatientTypeType > r (
              dynamic_cast< PatientTypeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->PatientType_.set (::std::move (r));
            continue;
          }
        }
      }

      // DateOfBirth
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DateOfBirth",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< DateOfBirthType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DateOfBirth_)
          {
            ::std::unique_ptr< DateOfBirthType > r (
              dynamic_cast< DateOfBirthType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DateOfBirth_.set (::std::move (r));
            continue;
          }
        }
      }

      // Height
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Height",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< HeightType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Height_)
          {
            ::std::unique_ptr< HeightType > r (
              dynamic_cast< HeightType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Height_.set (::std::move (r));
            continue;
          }
        }
      }

      // Weight
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Weight",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< WeightType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Weight_)
          {
            ::std::unique_ptr< WeightType > r (
              dynamic_cast< WeightType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Weight_.set (::std::move (r));
            continue;
          }
        }
      }

      // Race
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Race",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< RaceType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Race_)
          {
            ::std::unique_ptr< RaceType > r (
              dynamic_cast< RaceType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Race_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  PatientDemographicsCoreData* PatientDemographicsCoreData::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PatientDemographicsCoreData (*this, f, c);
  }

  PatientDemographicsCoreData& PatientDemographicsCoreData::
  operator= (const PatientDemographicsCoreData& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::BaseDemographics& > (*this) = x;
      this->Sex_ = x.Sex_;
      this->PatientType_ = x.PatientType_;
      this->DateOfBirth_ = x.DateOfBirth_;
      this->Height_ = x.Height_;
      this->Weight_ = x.Weight_;
      this->Race_ = x.Race_;
    }

    return *this;
  }

  PatientDemographicsCoreData::
  ~PatientDemographicsCoreData ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, PatientDemographicsCoreData >
  _xsd_PatientDemographicsCoreData_type_factory_init (
    "PatientDemographicsCoreData",
    "http://domain-model-uri/15/04");

  // PersonReference
  //

  PersonReference::
  PersonReference ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Identification_ (this),
    Name_ (this)
  {
  }

  PersonReference::
  PersonReference (const PersonReference& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Identification_ (x.Identification_, f, this),
    Name_ (x.Name_, f, this)
  {
  }

  PersonReference::
  PersonReference (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Identification_ (this),
    Name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PersonReference::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // Identification
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Identification",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< IdentificationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< IdentificationType > r (
            dynamic_cast< IdentificationType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Identification_.push_back (::std::move (r));
          continue;
        }
      }

      // Name
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Name",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< NameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< NameType > r (
            dynamic_cast< NameType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Name_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  PersonReference* PersonReference::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PersonReference (*this, f, c);
  }

  PersonReference& PersonReference::
  operator= (const PersonReference& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Identification_ = x.Identification_;
      this->Name_ = x.Name_;
    }

    return *this;
  }

  PersonReference::
  ~PersonReference ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, PersonReference >
  _xsd_PersonReference_type_factory_init (
    "PersonReference",
    "http://domain-model-uri/15/04");

  // PersonParticipation
  //

  PersonParticipation::
  PersonParticipation ()
  : ::CDM::PersonReference (),
    Role_ (this)
  {
  }

  PersonParticipation::
  PersonParticipation (const PersonParticipation& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::PersonReference (x, f, c),
    Role_ (x.Role_, f, this)
  {
  }

  PersonParticipation::
  PersonParticipation (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::PersonReference (e, f | ::xml_schema::Flags::base, c),
    Role_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PersonParticipation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::PersonReference::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Role
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Role",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< RoleType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< RoleType > r (
            dynamic_cast< RoleType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Role_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  PersonParticipation* PersonParticipation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PersonParticipation (*this, f, c);
  }

  PersonParticipation& PersonParticipation::
  operator= (const PersonParticipation& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::PersonReference& > (*this) = x;
      this->Role_ = x.Role_;
    }

    return *this;
  }

  PersonParticipation::
  ~PersonParticipation ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, PersonParticipation >
  _xsd_PersonParticipation_type_factory_init (
    "PersonParticipation",
    "http://domain-model-uri/15/04");

  // NeonatalPatientDemographicsCoreData
  //

  NeonatalPatientDemographicsCoreData::
  NeonatalPatientDemographicsCoreData ()
  : ::CDM::PatientDemographicsCoreData (),
    Gestational_Age_ (this),
    BirthLength_ (this),
    BirthWeight_ (this),
    HeadCircumference_ (this),
    Mother_ (this)
  {
  }

  NeonatalPatientDemographicsCoreData::
  NeonatalPatientDemographicsCoreData (const NeonatalPatientDemographicsCoreData& x,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::CDM::PatientDemographicsCoreData (x, f, c),
    Gestational_Age_ (x.Gestational_Age_, f, this),
    BirthLength_ (x.BirthLength_, f, this),
    BirthWeight_ (x.BirthWeight_, f, this),
    HeadCircumference_ (x.HeadCircumference_, f, this),
    Mother_ (x.Mother_, f, this)
  {
  }

  NeonatalPatientDemographicsCoreData::
  NeonatalPatientDemographicsCoreData (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::CDM::PatientDemographicsCoreData (e, f | ::xml_schema::Flags::base, c),
    Gestational_Age_ (this),
    BirthLength_ (this),
    BirthWeight_ (this),
    HeadCircumference_ (this),
    Mother_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void NeonatalPatientDemographicsCoreData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::PatientDemographicsCoreData::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Gestational-Age
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Gestational-Age",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< Gestational_AgeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Gestational_Age_)
          {
            ::std::unique_ptr< Gestational_AgeType > r (
              dynamic_cast< Gestational_AgeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Gestational_Age_.set (::std::move (r));
            continue;
          }
        }
      }

      // BirthLength
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "BirthLength",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< BirthLengthType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->BirthLength_)
          {
            ::std::unique_ptr< BirthLengthType > r (
              dynamic_cast< BirthLengthType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->BirthLength_.set (::std::move (r));
            continue;
          }
        }
      }

      // BirthWeight
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "BirthWeight",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< BirthWeightType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->BirthWeight_)
          {
            ::std::unique_ptr< BirthWeightType > r (
              dynamic_cast< BirthWeightType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->BirthWeight_.set (::std::move (r));
            continue;
          }
        }
      }

      // HeadCircumference
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "HeadCircumference",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< HeadCircumferenceType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->HeadCircumference_)
          {
            ::std::unique_ptr< HeadCircumferenceType > r (
              dynamic_cast< HeadCircumferenceType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->HeadCircumference_.set (::std::move (r));
            continue;
          }
        }
      }

      // Mother
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Mother",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< MotherType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Mother_)
          {
            ::std::unique_ptr< MotherType > r (
              dynamic_cast< MotherType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Mother_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  NeonatalPatientDemographicsCoreData* NeonatalPatientDemographicsCoreData::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NeonatalPatientDemographicsCoreData (*this, f, c);
  }

  NeonatalPatientDemographicsCoreData& NeonatalPatientDemographicsCoreData::
  operator= (const NeonatalPatientDemographicsCoreData& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::PatientDemographicsCoreData& > (*this) = x;
      this->Gestational_Age_ = x.Gestational_Age_;
      this->BirthLength_ = x.BirthLength_;
      this->BirthWeight_ = x.BirthWeight_;
      this->HeadCircumference_ = x.HeadCircumference_;
      this->Mother_ = x.Mother_;
    }

    return *this;
  }

  NeonatalPatientDemographicsCoreData::
  ~NeonatalPatientDemographicsCoreData ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, NeonatalPatientDemographicsCoreData >
  _xsd_NeonatalPatientDemographicsCoreData_type_factory_init (
    "NeonatalPatientDemographicsCoreData",
    "http://domain-model-uri/15/04");

  // PatientContextState
  //

  PatientContextState::
  PatientContextState (const DescriptorHandleType& DescriptorHandle,
                       const BindingMDIBVersionType& BindingMDIBVersion)
  : ::CDM::AbstractIdentifiableContextState (DescriptorHandle,
                                             BindingMDIBVersion),
    CoreData_ (this)
  {
  }

  PatientContextState::
  PatientContextState (const PatientContextState& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::AbstractIdentifiableContextState (x, f, c),
    CoreData_ (x.CoreData_, f, this)
  {
  }

  PatientContextState::
  PatientContextState (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::AbstractIdentifiableContextState (e, f | ::xml_schema::Flags::base, c),
    CoreData_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void PatientContextState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::CDM::AbstractIdentifiableContextState::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CoreData
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "CoreData",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< CoreDataType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->CoreData_)
          {
            ::std::unique_ptr< CoreDataType > r (
              dynamic_cast< CoreDataType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->CoreData_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  PatientContextState* PatientContextState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PatientContextState (*this, f, c);
  }

  PatientContextState& PatientContextState::
  operator= (const PatientContextState& x)
  {
    if (this != &x)
    {
      static_cast< ::CDM::AbstractIdentifiableContextState& > (*this) = x;
      this->CoreData_ = x.CoreData_;
    }

    return *this;
  }

  PatientContextState::
  ~PatientContextState ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, PatientContextState >
  _xsd_PatientContextState_type_factory_init (
    "PatientContextState",
    "http://domain-model-uri/15/04");

  // Sex
  //

  Sex::
  Sex (const ::xercesc::DOMElement& e,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Sex_convert ();
  }

  Sex::
  Sex (const ::xercesc::DOMAttr& a,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Sex_convert ();
  }

  Sex::
  Sex (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Sex_convert ();
  }

  Sex* Sex::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Sex (*this, f, c);
  }

  Sex::Value Sex::
  _xsd_Sex_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Sex_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Sex_indexes_,
                      _xsd_Sex_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_Sex_indexes_ + 4 || _xsd_Sex_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Sex::
  _xsd_Sex_literals_[4] =
  {
    "Unspec",
    "M",
    "F",
    "Unkn"
  };

  const Sex::Value Sex::
  _xsd_Sex_indexes_[4] =
  {
    ::CDM::Sex::F,
    ::CDM::Sex::M,
    ::CDM::Sex::Unkn,
    ::CDM::Sex::Unspec
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Sex >
  _xsd_Sex_type_factory_init (
    "Sex",
    "http://domain-model-uri/15/04");

  // PatientType
  //

  PatientType::
  PatientType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_PatientType_convert ();
  }

  PatientType::
  PatientType (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_PatientType_convert ();
  }

  PatientType::
  PatientType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_PatientType_convert ();
  }

  PatientType* PatientType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PatientType (*this, f, c);
  }

  PatientType::Value PatientType::
  _xsd_PatientType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_PatientType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_PatientType_indexes_,
                      _xsd_PatientType_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_PatientType_indexes_ + 4 || _xsd_PatientType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const PatientType::
  _xsd_PatientType_literals_[4] =
  {
    "Unspec",
    "Ad",
    "Ped",
    "Neo"
  };

  const PatientType::Value PatientType::
  _xsd_PatientType_indexes_[4] =
  {
    ::CDM::PatientType::Ad,
    ::CDM::PatientType::Neo,
    ::CDM::PatientType::Ped,
    ::CDM::PatientType::Unspec
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, PatientType >
  _xsd_PatientType_type_factory_init (
    "PatientType",
    "http://domain-model-uri/15/04");

  // ContainmentTree
  //

  ContainmentTree::
  ContainmentTree ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Entry_ (this),
    HandleRef_ (this),
    ParentHandleRef_ (this),
    EntryType_ (this),
    ChildrenCount_ (this)
  {
  }

  ContainmentTree::
  ContainmentTree (const ContainmentTree& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Entry_ (x.Entry_, f, this),
    HandleRef_ (x.HandleRef_, f, this),
    ParentHandleRef_ (x.ParentHandleRef_, f, this),
    EntryType_ (x.EntryType_, f, this),
    ChildrenCount_ (x.ChildrenCount_, f, this)
  {
  }

  ContainmentTree::
  ContainmentTree (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Entry_ (this),
    HandleRef_ (this),
    ParentHandleRef_ (this),
    EntryType_ (this),
    ChildrenCount_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ContainmentTree::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // Entry
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Entry",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< EntryType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< EntryType > r (
            dynamic_cast< EntryType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Entry_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "HandleRef" && n.namespace_ ().empty ())
      {
        this->HandleRef_.set (HandleRefTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ParentHandleRef" && n.namespace_ ().empty ())
      {
        this->ParentHandleRef_.set (ParentHandleRefTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "EntryType" && n.namespace_ ().empty ())
      {
        this->EntryType_.set (EntryTypeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ChildrenCount" && n.namespace_ ().empty ())
      {
        this->ChildrenCount_.set (ChildrenCountTraits::create (i, f, this));
        continue;
      }
    }
  }

  ContainmentTree* ContainmentTree::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ContainmentTree (*this, f, c);
  }

  ContainmentTree& ContainmentTree::
  operator= (const ContainmentTree& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Entry_ = x.Entry_;
      this->HandleRef_ = x.HandleRef_;
      this->ParentHandleRef_ = x.ParentHandleRef_;
      this->EntryType_ = x.EntryType_;
      this->ChildrenCount_ = x.ChildrenCount_;
    }

    return *this;
  }

  ContainmentTree::
  ~ContainmentTree ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ContainmentTree >
  _xsd_ContainmentTree_type_factory_init (
    "ContainmentTree",
    "http://domain-model-uri/15/04");

  // ContainmentTreeEntry
  //

  ContainmentTreeEntry::
  ContainmentTreeEntry ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Type_ (this),
    HandleRef_ (this),
    ParentHandleRef_ (this),
    EntryType_ (this),
    ChildrenCount_ (this)
  {
  }

  ContainmentTreeEntry::
  ContainmentTreeEntry (const ContainmentTreeEntry& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Type_ (x.Type_, f, this),
    HandleRef_ (x.HandleRef_, f, this),
    ParentHandleRef_ (x.ParentHandleRef_, f, this),
    EntryType_ (x.EntryType_, f, this),
    ChildrenCount_ (x.ChildrenCount_, f, this)
  {
  }

  ContainmentTreeEntry::
  ContainmentTreeEntry (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Type_ (this),
    HandleRef_ (this),
    ParentHandleRef_ (this),
    EntryType_ (this),
    ChildrenCount_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ContainmentTreeEntry::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // Type
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Type",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< TypeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Type_)
          {
            ::std::unique_ptr< TypeType > r (
              dynamic_cast< TypeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Type_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "HandleRef" && n.namespace_ ().empty ())
      {
        this->HandleRef_.set (HandleRefTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ParentHandleRef" && n.namespace_ ().empty ())
      {
        this->ParentHandleRef_.set (ParentHandleRefTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "EntryType" && n.namespace_ ().empty ())
      {
        this->EntryType_.set (EntryTypeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ChildrenCount" && n.namespace_ ().empty ())
      {
        this->ChildrenCount_.set (ChildrenCountTraits::create (i, f, this));
        continue;
      }
    }
  }

  ContainmentTreeEntry* ContainmentTreeEntry::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ContainmentTreeEntry (*this, f, c);
  }

  ContainmentTreeEntry& ContainmentTreeEntry::
  operator= (const ContainmentTreeEntry& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Type_ = x.Type_;
      this->HandleRef_ = x.HandleRef_;
      this->ParentHandleRef_ = x.ParentHandleRef_;
      this->EntryType_ = x.EntryType_;
      this->ChildrenCount_ = x.ChildrenCount_;
    }

    return *this;
  }

  ContainmentTreeEntry::
  ~ContainmentTreeEntry ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ContainmentTreeEntry >
  _xsd_ContainmentTreeEntry_type_factory_init (
    "ContainmentTreeEntry",
    "http://domain-model-uri/15/04");

  // ClinicalInfo
  //

  ClinicalInfo::
  ClinicalInfo (const TypeType& Type)
  : ::xml_schema::Type (),
    Extension_ (this),
    Type_ (Type, this),
    RelatedMeasurement_ (this),
    MeasuredValue_ (this)
  {
  }

  ClinicalInfo::
  ClinicalInfo (::std::unique_ptr< TypeType > Type)
  : ::xml_schema::Type (),
    Extension_ (this),
    Type_ (std::move (Type), this),
    RelatedMeasurement_ (this),
    MeasuredValue_ (this)
  {
  }

  ClinicalInfo::
  ClinicalInfo (const ClinicalInfo& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Type_ (x.Type_, f, this),
    RelatedMeasurement_ (x.RelatedMeasurement_, f, this),
    MeasuredValue_ (x.MeasuredValue_, f, this)
  {
  }

  ClinicalInfo::
  ClinicalInfo (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Type_ (this),
    RelatedMeasurement_ (this),
    MeasuredValue_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ClinicalInfo::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // Type
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Type",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< TypeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Type_.present ())
          {
            ::std::unique_ptr< TypeType > r (
              dynamic_cast< TypeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Type_.set (::std::move (r));
            continue;
          }
        }
      }

      // RelatedMeasurement
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "RelatedMeasurement",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< RelatedMeasurementType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< RelatedMeasurementType > r (
            dynamic_cast< RelatedMeasurementType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RelatedMeasurement_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!Type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Type",
        "http://domain-model-uri/15/04");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MeasuredValue" && n.namespace_ ().empty ())
      {
        this->MeasuredValue_.set (MeasuredValueTraits::create (i, f, this));
        continue;
      }
    }
  }

  ClinicalInfo* ClinicalInfo::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ClinicalInfo (*this, f, c);
  }

  ClinicalInfo& ClinicalInfo::
  operator= (const ClinicalInfo& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Type_ = x.Type_;
      this->RelatedMeasurement_ = x.RelatedMeasurement_;
      this->MeasuredValue_ = x.MeasuredValue_;
    }

    return *this;
  }

  ClinicalInfo::
  ~ClinicalInfo ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ClinicalInfo >
  _xsd_ClinicalInfo_type_factory_init (
    "ClinicalInfo",
    "http://domain-model-uri/15/04");

  // Order
  //

  Order::
  Order (const PlacerOrderNumberType& PlacerOrderNumber,
         const PatientType& Patient)
  : ::xml_schema::Type (),
    Extension_ (this),
    VisitNumber_ (this),
    PlacerOrderNumber_ (PlacerOrderNumber, this),
    FillerOrderNumber_ (this),
    Patient_ (Patient, this),
    ReferringPhysician_ (this),
    RequestingPhysician_ (this),
    Reason_ (this),
    DangerCode_ (this),
    RelevantClinicalInfo_ (this),
    ImagingProcedure_ (this),
    RequestedOrderDetail_ (this),
    PerformedOrderDetail_ (this)
  {
  }

  Order::
  Order (::std::unique_ptr< PlacerOrderNumberType > PlacerOrderNumber,
         ::std::unique_ptr< PatientType > Patient)
  : ::xml_schema::Type (),
    Extension_ (this),
    VisitNumber_ (this),
    PlacerOrderNumber_ (std::move (PlacerOrderNumber), this),
    FillerOrderNumber_ (this),
    Patient_ (std::move (Patient), this),
    ReferringPhysician_ (this),
    RequestingPhysician_ (this),
    Reason_ (this),
    DangerCode_ (this),
    RelevantClinicalInfo_ (this),
    ImagingProcedure_ (this),
    RequestedOrderDetail_ (this),
    PerformedOrderDetail_ (this)
  {
  }

  Order::
  Order (const Order& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    VisitNumber_ (x.VisitNumber_, f, this),
    PlacerOrderNumber_ (x.PlacerOrderNumber_, f, this),
    FillerOrderNumber_ (x.FillerOrderNumber_, f, this),
    Patient_ (x.Patient_, f, this),
    ReferringPhysician_ (x.ReferringPhysician_, f, this),
    RequestingPhysician_ (x.RequestingPhysician_, f, this),
    Reason_ (x.Reason_, f, this),
    DangerCode_ (x.DangerCode_, f, this),
    RelevantClinicalInfo_ (x.RelevantClinicalInfo_, f, this),
    ImagingProcedure_ (x.ImagingProcedure_, f, this),
    RequestedOrderDetail_ (x.RequestedOrderDetail_, f, this),
    PerformedOrderDetail_ (x.PerformedOrderDetail_, f, this)
  {
  }

  Order::
  Order (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    VisitNumber_ (this),
    PlacerOrderNumber_ (this),
    FillerOrderNumber_ (this),
    Patient_ (this),
    ReferringPhysician_ (this),
    RequestingPhysician_ (this),
    Reason_ (this),
    DangerCode_ (this),
    RelevantClinicalInfo_ (this),
    ImagingProcedure_ (this),
    RequestedOrderDetail_ (this),
    PerformedOrderDetail_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Order::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // VisitNumber
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "VisitNumber",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< VisitNumberType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->VisitNumber_)
          {
            ::std::unique_ptr< VisitNumberType > r (
              dynamic_cast< VisitNumberType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->VisitNumber_.set (::std::move (r));
            continue;
          }
        }
      }

      // PlacerOrderNumber
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "PlacerOrderNumber",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< PlacerOrderNumberType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!PlacerOrderNumber_.present ())
          {
            ::std::unique_ptr< PlacerOrderNumberType > r (
              dynamic_cast< PlacerOrderNumberType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->PlacerOrderNumber_.set (::std::move (r));
            continue;
          }
        }
      }

      // FillerOrderNumber
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "FillerOrderNumber",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< FillerOrderNumberType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->FillerOrderNumber_)
          {
            ::std::unique_ptr< FillerOrderNumberType > r (
              dynamic_cast< FillerOrderNumberType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FillerOrderNumber_.set (::std::move (r));
            continue;
          }
        }
      }

      // Patient
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Patient",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< PatientType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Patient_.present ())
          {
            ::std::unique_ptr< PatientType > r (
              dynamic_cast< PatientType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Patient_.set (::std::move (r));
            continue;
          }
        }
      }

      // ReferringPhysician
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ReferringPhysician",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ReferringPhysicianType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ReferringPhysician_)
          {
            ::std::unique_ptr< ReferringPhysicianType > r (
              dynamic_cast< ReferringPhysicianType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ReferringPhysician_.set (::std::move (r));
            continue;
          }
        }
      }

      // RequestingPhysician
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "RequestingPhysician",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< RequestingPhysicianType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->RequestingPhysician_)
          {
            ::std::unique_ptr< RequestingPhysicianType > r (
              dynamic_cast< RequestingPhysicianType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->RequestingPhysician_.set (::std::move (r));
            continue;
          }
        }
      }

      // Reason
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Reason",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ReasonType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ReasonType > r (
            dynamic_cast< ReasonType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Reason_.push_back (::std::move (r));
          continue;
        }
      }

      // DangerCode
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DangerCode",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< DangerCodeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< DangerCodeType > r (
            dynamic_cast< DangerCodeType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->DangerCode_.push_back (::std::move (r));
          continue;
        }
      }

      // RelevantClinicalInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "RelevantClinicalInfo",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< RelevantClinicalInfoType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< RelevantClinicalInfoType > r (
            dynamic_cast< RelevantClinicalInfoType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RelevantClinicalInfo_.push_back (::std::move (r));
          continue;
        }
      }

      // ImagingProcedure
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ImagingProcedure",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ImagingProcedureType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ImagingProcedureType > r (
            dynamic_cast< ImagingProcedureType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ImagingProcedure_.push_back (::std::move (r));
          continue;
        }
      }

      // RequestedOrderDetail
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "RequestedOrderDetail",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< RequestedOrderDetailType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->RequestedOrderDetail_)
          {
            ::std::unique_ptr< RequestedOrderDetailType > r (
              dynamic_cast< RequestedOrderDetailType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->RequestedOrderDetail_.set (::std::move (r));
            continue;
          }
        }
      }

      // PerformedOrderDetail
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "PerformedOrderDetail",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< PerformedOrderDetailType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->PerformedOrderDetail_)
          {
            ::std::unique_ptr< PerformedOrderDetailType > r (
              dynamic_cast< PerformedOrderDetailType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->PerformedOrderDetail_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!PlacerOrderNumber_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PlacerOrderNumber",
        "http://domain-model-uri/15/04");
    }

    if (!Patient_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Patient",
        "http://domain-model-uri/15/04");
    }
  }

  Order* Order::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Order (*this, f, c);
  }

  Order& Order::
  operator= (const Order& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->VisitNumber_ = x.VisitNumber_;
      this->PlacerOrderNumber_ = x.PlacerOrderNumber_;
      this->FillerOrderNumber_ = x.FillerOrderNumber_;
      this->Patient_ = x.Patient_;
      this->ReferringPhysician_ = x.ReferringPhysician_;
      this->RequestingPhysician_ = x.RequestingPhysician_;
      this->Reason_ = x.Reason_;
      this->DangerCode_ = x.DangerCode_;
      this->RelevantClinicalInfo_ = x.RelevantClinicalInfo_;
      this->ImagingProcedure_ = x.ImagingProcedure_;
      this->RequestedOrderDetail_ = x.RequestedOrderDetail_;
      this->PerformedOrderDetail_ = x.PerformedOrderDetail_;
    }

    return *this;
  }

  Order::
  ~Order ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Order >
  _xsd_Order_type_factory_init (
    "Order",
    "http://domain-model-uri/15/04");

  // OrderDetail
  //

  OrderDetail::
  OrderDetail ()
  : ::xml_schema::Type (),
    Extension_ (this),
    Start_ (this),
    End_ (this),
    Performer_ (this),
    Service_ (this)
  {
  }

  OrderDetail::
  OrderDetail (const OrderDetail& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Start_ (x.Start_, f, this),
    End_ (x.End_, f, this),
    Performer_ (x.Performer_, f, this),
    Service_ (x.Service_, f, this)
  {
  }

  OrderDetail::
  OrderDetail (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Start_ (this),
    End_ (this),
    Performer_ (this),
    Service_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void OrderDetail::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // Start
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Start",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< StartType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Start_)
          {
            ::std::unique_ptr< StartType > r (
              dynamic_cast< StartType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Start_.set (::std::move (r));
            continue;
          }
        }
      }

      // End
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "End",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< EndType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->End_)
          {
            ::std::unique_ptr< EndType > r (
              dynamic_cast< EndType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->End_.set (::std::move (r));
            continue;
          }
        }
      }

      // Performer
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Performer",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< PerformerType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< PerformerType > r (
            dynamic_cast< PerformerType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Performer_.push_back (::std::move (r));
          continue;
        }
      }

      // Service
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Service",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ServiceType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ServiceType > r (
            dynamic_cast< ServiceType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Service_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  OrderDetail* OrderDetail::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OrderDetail (*this, f, c);
  }

  OrderDetail& OrderDetail::
  operator= (const OrderDetail& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Start_ = x.Start_;
      this->End_ = x.End_;
      this->Performer_ = x.Performer_;
      this->Service_ = x.Service_;
    }

    return *this;
  }

  OrderDetail::
  ~OrderDetail ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, OrderDetail >
  _xsd_OrderDetail_type_factory_init (
    "OrderDetail",
    "http://domain-model-uri/15/04");

  // ImagingProcedure
  //

  ImagingProcedure::
  ImagingProcedure (const AccessionIdentifierType& AccessionIdentifier,
                    const RequestedProcedureIDType& RequestedProcedureID,
                    const StudyInstanceUIDType& StudyInstanceUID,
                    const ScheduledProcedureStepIDType& ScheduledProcedureStepID)
  : ::xml_schema::Type (),
    Extension_ (this),
    AccessionIdentifier_ (AccessionIdentifier, this),
    RequestedProcedureID_ (RequestedProcedureID, this),
    StudyInstanceUID_ (StudyInstanceUID, this),
    ScheduledProcedureStepID_ (ScheduledProcedureStepID, this),
    Modality_ (this),
    ProtocolCode_ (this)
  {
  }

  ImagingProcedure::
  ImagingProcedure (::std::unique_ptr< AccessionIdentifierType > AccessionIdentifier,
                    ::std::unique_ptr< RequestedProcedureIDType > RequestedProcedureID,
                    ::std::unique_ptr< StudyInstanceUIDType > StudyInstanceUID,
                    ::std::unique_ptr< ScheduledProcedureStepIDType > ScheduledProcedureStepID)
  : ::xml_schema::Type (),
    Extension_ (this),
    AccessionIdentifier_ (std::move (AccessionIdentifier), this),
    RequestedProcedureID_ (std::move (RequestedProcedureID), this),
    StudyInstanceUID_ (std::move (StudyInstanceUID), this),
    ScheduledProcedureStepID_ (std::move (ScheduledProcedureStepID), this),
    Modality_ (this),
    ProtocolCode_ (this)
  {
  }

  ImagingProcedure::
  ImagingProcedure (const ImagingProcedure& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    AccessionIdentifier_ (x.AccessionIdentifier_, f, this),
    RequestedProcedureID_ (x.RequestedProcedureID_, f, this),
    StudyInstanceUID_ (x.StudyInstanceUID_, f, this),
    ScheduledProcedureStepID_ (x.ScheduledProcedureStepID_, f, this),
    Modality_ (x.Modality_, f, this),
    ProtocolCode_ (x.ProtocolCode_, f, this)
  {
  }

  ImagingProcedure::
  ImagingProcedure (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    AccessionIdentifier_ (this),
    RequestedProcedureID_ (this),
    StudyInstanceUID_ (this),
    ScheduledProcedureStepID_ (this),
    Modality_ (this),
    ProtocolCode_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ImagingProcedure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      if (n.name () == "Extension" && n.namespace_ () == "http://extension-point-uri/15/03")
      {
        ::std::unique_ptr< ExtensionType > r (
          ExtensionTraits::create (i, f, this));

        if (!this->Extension_)
        {
          this->Extension_.set (::std::move (r));
          continue;
        }
      }

      // AccessionIdentifier
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AccessionIdentifier",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< AccessionIdentifierType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!AccessionIdentifier_.present ())
          {
            ::std::unique_ptr< AccessionIdentifierType > r (
              dynamic_cast< AccessionIdentifierType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AccessionIdentifier_.set (::std::move (r));
            continue;
          }
        }
      }

      // RequestedProcedureID
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "RequestedProcedureID",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< RequestedProcedureIDType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!RequestedProcedureID_.present ())
          {
            ::std::unique_ptr< RequestedProcedureIDType > r (
              dynamic_cast< RequestedProcedureIDType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->RequestedProcedureID_.set (::std::move (r));
            continue;
          }
        }
      }

      // StudyInstanceUID
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "StudyInstanceUID",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< StudyInstanceUIDType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!StudyInstanceUID_.present ())
          {
            ::std::unique_ptr< StudyInstanceUIDType > r (
              dynamic_cast< StudyInstanceUIDType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->StudyInstanceUID_.set (::std::move (r));
            continue;
          }
        }
      }

      // ScheduledProcedureStepID
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ScheduledProcedureStepID",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ScheduledProcedureStepIDType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ScheduledProcedureStepID_.present ())
          {
            ::std::unique_ptr< ScheduledProcedureStepIDType > r (
              dynamic_cast< ScheduledProcedureStepIDType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ScheduledProcedureStepID_.set (::std::move (r));
            continue;
          }
        }
      }

      // Modality
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Modality",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ModalityType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Modality_)
          {
            ::std::unique_ptr< ModalityType > r (
              dynamic_cast< ModalityType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Modality_.set (::std::move (r));
            continue;
          }
        }
      }

      // ProtocolCode
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ProtocolCode",
            "http://domain-model-uri/15/04",
            &::xsd::cxx::tree::factory_impl< ProtocolCodeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ProtocolCode_)
          {
            ::std::unique_ptr< ProtocolCodeType > r (
              dynamic_cast< ProtocolCodeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ProtocolCode_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!AccessionIdentifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AccessionIdentifier",
        "http://domain-model-uri/15/04");
    }

    if (!RequestedProcedureID_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "RequestedProcedureID",
        "http://domain-model-uri/15/04");
    }

    if (!StudyInstanceUID_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "StudyInstanceUID",
        "http://domain-model-uri/15/04");
    }

    if (!ScheduledProcedureStepID_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ScheduledProcedureStepID",
        "http://domain-model-uri/15/04");
    }
  }

  ImagingProcedure* ImagingProcedure::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImagingProcedure (*this, f, c);
  }

  ImagingProcedure& ImagingProcedure::
  operator= (const ImagingProcedure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->AccessionIdentifier_ = x.AccessionIdentifier_;
      this->RequestedProcedureID_ = x.RequestedProcedureID_;
      this->StudyInstanceUID_ = x.StudyInstanceUID_;
      this->ScheduledProcedureStepID_ = x.ScheduledProcedureStepID_;
      this->Modality_ = x.Modality_;
      this->ProtocolCode_ = x.ProtocolCode_;
    }

    return *this;
  }

  ImagingProcedure::
  ~ImagingProcedure ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ImagingProcedure >
  _xsd_ImagingProcedure_type_factory_init (
    "ImagingProcedure",
    "http://domain-model-uri/15/04");

  // MDIBContainmentTree
  //

  MDIBContainmentTree::
  MDIBContainmentTree ()
  : ::CDM::ContainmentTree ()
  {
  }

  MDIBContainmentTree::
  MDIBContainmentTree (const MDIBContainmentTree& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::ContainmentTree (x, f, c)
  {
  }

  MDIBContainmentTree::
  MDIBContainmentTree (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::CDM::ContainmentTree (e, f, c)
  {
  }

  MDIBContainmentTree* MDIBContainmentTree::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MDIBContainmentTree (*this, f, c);
  }

  MDIBContainmentTree::
  ~MDIBContainmentTree ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace CDM
{
  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (const ::std::string& u,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::xml_schema::Uri > (
      ::CDM::CodingSystemId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (const ::std::string& u,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::xml_schema::Uri > (
      ::CDM::CodingSystemId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::xml_schema::Uri > (
      ::CDM::CodingSystemId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::std::istream& is,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::CodingSystemId (isrc, f, p);
  }

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::std::istream& is,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::CodingSystemId (isrc, h, f, p);
  }

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::CodingSystemId (isrc, h, f, p);
  }

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::CodingSystemId (isrc, f, p);
  }

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::CodingSystemId (isrc, h, f, p);
  }

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::CodingSystemId (isrc, h, f, p);
  }

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::xercesc::InputSource& i,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::xml_schema::Uri > (
      ::CDM::CodingSystemId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::xercesc::InputSource& i,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::xml_schema::Uri > (
      ::CDM::CodingSystemId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::xml_schema::Uri > (
      ::CDM::CodingSystemId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::xml_schema::Uri > (
        ::CDM::CodingSystemId (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "CodingSystemId",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::xml_schema::Uri >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {
      ::std::unique_ptr< ::xml_schema::Uri > r (
        dynamic_cast< ::xml_schema::Uri* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CodingSystemId",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "CodingSystemId",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::xml_schema::Uri >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {

      ::std::unique_ptr< ::xml_schema::Uri > r (
        dynamic_cast< ::xml_schema::Uri* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CodingSystemId",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (const ::std::string& u,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::LocalizedText > (
      ::CDM::CodingSystemName (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (const ::std::string& u,
                    ::xml_schema::ErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::LocalizedText > (
      ::CDM::CodingSystemName (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::LocalizedText > (
      ::CDM::CodingSystemName (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::std::istream& is,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::CodingSystemName (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::std::istream& is,
                    ::xml_schema::ErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::CodingSystemName (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::CodingSystemName (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::CodingSystemName (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::ErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::CodingSystemName (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::CodingSystemName (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::xercesc::InputSource& i,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::LocalizedText > (
      ::CDM::CodingSystemName (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::xercesc::InputSource& i,
                    ::xml_schema::ErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::LocalizedText > (
      ::CDM::CodingSystemName (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::LocalizedText > (
      ::CDM::CodingSystemName (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::CDM::LocalizedText > (
        ::CDM::CodingSystemName (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "CodingSystemName",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::CDM::LocalizedText >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {
      ::std::unique_ptr< ::CDM::LocalizedText > r (
        dynamic_cast< ::CDM::LocalizedText* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CodingSystemName",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "CodingSystemName",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::CDM::LocalizedText >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {

      ::std::unique_ptr< ::CDM::LocalizedText > r (
        dynamic_cast< ::CDM::LocalizedText* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CodingSystemName",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (const ::std::string& u,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::xml_schema::String > (
      ::CDM::VersionId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (const ::std::string& u,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::xml_schema::String > (
      ::CDM::VersionId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::xml_schema::String > (
      ::CDM::VersionId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::std::istream& is,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::VersionId (isrc, f, p);
  }

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::std::istream& is,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::VersionId (isrc, h, f, p);
  }

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::VersionId (isrc, h, f, p);
  }

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::VersionId (isrc, f, p);
  }

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::VersionId (isrc, h, f, p);
  }

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::VersionId (isrc, h, f, p);
  }

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::xercesc::InputSource& i,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::xml_schema::String > (
      ::CDM::VersionId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::xercesc::InputSource& i,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::xml_schema::String > (
      ::CDM::VersionId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::xml_schema::String > (
      ::CDM::VersionId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (const ::xercesc::DOMDocument& doc,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::xml_schema::String > (
        ::CDM::VersionId (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "VersionId",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::xml_schema::String >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {
      ::std::unique_ptr< ::xml_schema::String > r (
        dynamic_cast< ::xml_schema::String* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "VersionId",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "VersionId",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::xml_schema::String >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {

      ::std::unique_ptr< ::xml_schema::String > r (
        dynamic_cast< ::xml_schema::String* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "VersionId",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (const ::std::string& u,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::CodeIdentifier > (
      ::CDM::CodeId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (const ::std::string& u,
          ::xml_schema::ErrorHandler& h,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::CodeIdentifier > (
      ::CDM::CodeId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::CodeIdentifier > (
      ::CDM::CodeId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::std::istream& is,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::CodeId (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::std::istream& is,
          ::xml_schema::ErrorHandler& h,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::CodeId (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::CodeId (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::CodeId (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::ErrorHandler& h,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::CodeId (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::CodeId (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::xercesc::InputSource& i,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::CodeIdentifier > (
      ::CDM::CodeId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::xercesc::InputSource& i,
          ::xml_schema::ErrorHandler& h,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::CodeIdentifier > (
      ::CDM::CodeId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::CodeIdentifier > (
      ::CDM::CodeId (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (const ::xercesc::DOMDocument& doc,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::CDM::CodeIdentifier > (
        ::CDM::CodeId (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "CodeId",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::CDM::CodeIdentifier >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {
      ::std::unique_ptr< ::CDM::CodeIdentifier > r (
        dynamic_cast< ::CDM::CodeIdentifier* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CodeId",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::Flags f,
          const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "CodeId",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::CDM::CodeIdentifier >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {

      ::std::unique_ptr< ::CDM::CodeIdentifier > r (
        dynamic_cast< ::CDM::CodeIdentifier* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CodeId",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (const ::std::string& u,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::Type (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (const ::std::string& u,
        ::xml_schema::ErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::Type (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::Type (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::std::istream& is,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::Type (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::std::istream& is,
        ::xml_schema::ErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::Type (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::Type (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::Type (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::ErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::Type (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::Type (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::xercesc::InputSource& i,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::Type (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::xercesc::InputSource& i,
        ::xml_schema::ErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::Type (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::Type (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (const ::xercesc::DOMDocument& doc,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::CDM::CodedValue > (
        ::CDM::Type (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "Type",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::CDM::CodedValue >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {
      ::std::unique_ptr< ::CDM::CodedValue > r (
        dynamic_cast< ::CDM::CodedValue* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Type",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "Type",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::CDM::CodedValue >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {

      ::std::unique_ptr< ::CDM::CodedValue > r (
        dynamic_cast< ::CDM::CodedValue* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Type",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (const ::std::string& u,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::Unit (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (const ::std::string& u,
        ::xml_schema::ErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::Unit (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::Unit (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::std::istream& is,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::Unit (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::std::istream& is,
        ::xml_schema::ErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::Unit (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::Unit (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::Unit (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::ErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::Unit (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::Unit (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::xercesc::InputSource& i,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::Unit (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::xercesc::InputSource& i,
        ::xml_schema::ErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::Unit (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::Unit (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (const ::xercesc::DOMDocument& doc,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::CDM::CodedValue > (
        ::CDM::Unit (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "Unit",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::CDM::CodedValue >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {
      ::std::unique_ptr< ::CDM::CodedValue > r (
        dynamic_cast< ::CDM::CodedValue* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Unit",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::Flags f,
        const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "Unit",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::CDM::CodedValue >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {

      ::std::unique_ptr< ::CDM::CodedValue > r (
        dynamic_cast< ::CDM::CodedValue* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Unit",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (const ::std::string& u,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::BodySite (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (const ::std::string& u,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::BodySite (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::BodySite (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::std::istream& is,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::BodySite (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::std::istream& is,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::BodySite (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::BodySite (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::BodySite (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::BodySite (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::BodySite (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::xercesc::InputSource& i,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::BodySite (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::xercesc::InputSource& i,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::BodySite (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::CodedValue > (
      ::CDM::BodySite (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (const ::xercesc::DOMDocument& doc,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::CDM::CodedValue > (
        ::CDM::BodySite (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "BodySite",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::CDM::CodedValue >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {
      ::std::unique_ptr< ::CDM::CodedValue > r (
        dynamic_cast< ::CDM::CodedValue* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "BodySite",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "BodySite",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::CDM::CodedValue >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {

      ::std::unique_ptr< ::CDM::CodedValue > r (
        dynamic_cast< ::CDM::CodedValue* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "BodySite",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (const ::std::string& u,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::xml_schema::Decimal > (
      ::CDM::Resolution (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (const ::std::string& u,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::xml_schema::Decimal > (
      ::CDM::Resolution (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::xml_schema::Decimal > (
      ::CDM::Resolution (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::std::istream& is,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::Resolution (isrc, f, p);
  }

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::std::istream& is,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::Resolution (isrc, h, f, p);
  }

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::Resolution (isrc, h, f, p);
  }

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::Resolution (isrc, f, p);
  }

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::Resolution (isrc, h, f, p);
  }

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::Resolution (isrc, h, f, p);
  }

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::xercesc::InputSource& i,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::xml_schema::Decimal > (
      ::CDM::Resolution (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::xercesc::InputSource& i,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::xml_schema::Decimal > (
      ::CDM::Resolution (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::xml_schema::Decimal > (
      ::CDM::Resolution (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (const ::xercesc::DOMDocument& doc,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::xml_schema::Decimal > (
        ::CDM::Resolution (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Resolution" &&
        n.namespace_ () == "http://domain-model-uri/15/04")
    {
      ::std::unique_ptr< ::xml_schema::Decimal > r (
        new ::xml_schema::Decimal (
          ::xsd::cxx::tree::traits< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal >::create (
            e, f, 0)));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Resolution",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Resolution" &&
        n.namespace_ () == "http://domain-model-uri/15/04")
    {
      ::std::unique_ptr< ::xml_schema::Decimal > r (
        new ::xml_schema::Decimal (
          ::xsd::cxx::tree::traits< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal >::create (
            e, f, 0)));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Resolution",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (const ::std::string& u,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::MetricCategory > (
      ::CDM::MetricCategory_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (const ::std::string& u,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::MetricCategory > (
      ::CDM::MetricCategory_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::MetricCategory > (
      ::CDM::MetricCategory_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::std::istream& is,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::MetricCategory_ (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::std::istream& is,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::MetricCategory_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::MetricCategory_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::MetricCategory_ (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::MetricCategory_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::MetricCategory_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::xercesc::InputSource& i,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::MetricCategory > (
      ::CDM::MetricCategory_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::xercesc::InputSource& i,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::MetricCategory > (
      ::CDM::MetricCategory_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::MetricCategory > (
      ::CDM::MetricCategory_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::CDM::MetricCategory > (
        ::CDM::MetricCategory_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "MetricCategory",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::CDM::MetricCategory >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {
      ::std::unique_ptr< ::CDM::MetricCategory > r (
        dynamic_cast< ::CDM::MetricCategory* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MetricCategory",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "MetricCategory",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::CDM::MetricCategory >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {

      ::std::unique_ptr< ::CDM::MetricCategory > r (
        dynamic_cast< ::CDM::MetricCategory* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MetricCategory",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (const ::std::string& u,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::MetricAvailability > (
      ::CDM::Availability (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (const ::std::string& u,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::MetricAvailability > (
      ::CDM::Availability (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::MetricAvailability > (
      ::CDM::Availability (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::std::istream& is,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::Availability (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::std::istream& is,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::Availability (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::Availability (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::Availability (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::Availability (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::Availability (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::xercesc::InputSource& i,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::MetricAvailability > (
      ::CDM::Availability (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::xercesc::InputSource& i,
                ::xml_schema::ErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::MetricAvailability > (
      ::CDM::Availability (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::MetricAvailability > (
      ::CDM::Availability (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (const ::xercesc::DOMDocument& doc,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::CDM::MetricAvailability > (
        ::CDM::Availability (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "Availability",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::CDM::MetricAvailability >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {
      ::std::unique_ptr< ::CDM::MetricAvailability > r (
        dynamic_cast< ::CDM::MetricAvailability* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Availability",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::Flags f,
                const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "Availability",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::CDM::MetricAvailability >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {

      ::std::unique_ptr< ::CDM::MetricAvailability > r (
        dynamic_cast< ::CDM::MetricAvailability* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Availability",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (const ::std::string& u,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::MDIBContainmentTree > (
      ::CDM::MDIBContainmentTree_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (const ::std::string& u,
                        ::xml_schema::ErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::MDIBContainmentTree > (
      ::CDM::MDIBContainmentTree_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::MDIBContainmentTree > (
      ::CDM::MDIBContainmentTree_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::std::istream& is,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::MDIBContainmentTree_ (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::std::istream& is,
                        ::xml_schema::ErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::MDIBContainmentTree_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::MDIBContainmentTree_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::MDIBContainmentTree_ (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::ErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::MDIBContainmentTree_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::MDIBContainmentTree_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::xercesc::InputSource& i,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::MDIBContainmentTree > (
      ::CDM::MDIBContainmentTree_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::xercesc::InputSource& i,
                        ::xml_schema::ErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::MDIBContainmentTree > (
      ::CDM::MDIBContainmentTree_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::MDIBContainmentTree > (
      ::CDM::MDIBContainmentTree_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (const ::xercesc::DOMDocument& doc,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::CDM::MDIBContainmentTree > (
        ::CDM::MDIBContainmentTree_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "MDIBContainmentTree" &&
        n.namespace_ () == "http://domain-model-uri/15/04")
    {
      ::std::unique_ptr< ::CDM::MDIBContainmentTree > r (
        ::xsd::cxx::tree::traits< ::CDM::MDIBContainmentTree, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MDIBContainmentTree",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "MDIBContainmentTree" &&
        n.namespace_ () == "http://domain-model-uri/15/04")
    {
      ::std::unique_ptr< ::CDM::MDIBContainmentTree > r (
        ::xsd::cxx::tree::traits< ::CDM::MDIBContainmentTree, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MDIBContainmentTree",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (const ::std::string& u,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::MDIB > (
      ::CDM::MDIBContainer (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (const ::std::string& u,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::MDIB > (
      ::CDM::MDIBContainer (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::MDIB > (
      ::CDM::MDIBContainer (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::std::istream& is,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::MDIBContainer (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::std::istream& is,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::MDIBContainer (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::CDM::MDIBContainer (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::MDIBContainer (isrc, f, p);
  }

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::MDIBContainer (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::CDM::MDIBContainer (isrc, h, f, p);
  }

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::xercesc::InputSource& i,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::CDM::MDIB > (
      ::CDM::MDIBContainer (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::xercesc::InputSource& i,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::MDIB > (
      ::CDM::MDIBContainer (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::CDM::MDIB > (
      ::CDM::MDIBContainer (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::CDM::MDIB > (
        ::CDM::MDIBContainer (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "MDIBContainer",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::CDM::MDIB >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {
      ::std::unique_ptr< ::CDM::MDIB > r (
        dynamic_cast< ::CDM::MDIB* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MDIBContainer",
      "http://domain-model-uri/15/04");
  }

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
      ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
        "MDIBContainer",
        "http://domain-model-uri/15/04",
        &::xsd::cxx::tree::factory_impl< ::CDM::MDIB >,
        true, true, e, n, f, 0));

    if (tmp.get () != 0)
    {

      ::std::unique_ptr< ::CDM::MDIB > r (
        dynamic_cast< ::CDM::MDIB* > (tmp.get ()));

      if (r.get ())
        tmp.release ();
      else
        throw ::xsd::cxx::tree::not_derived< char > ();

      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MDIBContainer",
      "http://domain-model-uri/15/04");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace CDM
{
  void
  operator<< (::xercesc::DOMElement& e, const Handle& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Handle& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Handle& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Handle >
  _xsd_Handle_type_serializer_init (
    "Handle",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const HandleRef& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const HandleRef& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const HandleRef& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, HandleRef >
  _xsd_HandleRef_type_serializer_init (
    "HandleRef",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const Timestamp& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Timestamp& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Timestamp& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Timestamp >
  _xsd_Timestamp_type_serializer_init (
    "Timestamp",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const VersionCounter& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const VersionCounter& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const VersionCounter& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, VersionCounter >
  _xsd_VersionCounter_type_serializer_init (
    "VersionCounter",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const ReferencedVersion& i)
  {
    e << static_cast< const ::CDM::VersionCounter& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ReferencedVersion& i)
  {
    a << static_cast< const ::CDM::VersionCounter& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const ReferencedVersion& i)
  {
    l << static_cast< const ::CDM::VersionCounter& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ReferencedVersion >
  _xsd_ReferencedVersion_type_serializer_init (
    "ReferencedVersion",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const Activation& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Activation& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Activation& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Activation >
  _xsd_Activation_type_serializer_init (
    "Activation",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const CodeIdentifier& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CodeIdentifier& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CodeIdentifier& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CodeIdentifier >
  _xsd_CodeIdentifier_type_serializer_init (
    "CodeIdentifier",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const LocalizedTextRef& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const LocalizedTextRef& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const LocalizedTextRef& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LocalizedTextRef >
  _xsd_LocalizedTextRef_type_serializer_init (
    "LocalizedTextRef",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const LocalizedText& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);

    // Lang
    //
    if (i.Lang ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Lang",
          e));

      a << *i.Lang ();
    }

    // Ref
    //
    if (i.Ref ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Ref",
          e));

      a << *i.Ref ();
    }

    // Version
    //
    if (i.Version ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Version",
          e));

      a << *i.Version ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LocalizedText >
  _xsd_LocalizedText_type_serializer_init (
    "LocalizedText",
    "http://domain-model-uri/15/04");


  void
  CodingSystemId (::std::ostream& o,
                  const ::xml_schema::Uri& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodingSystemId (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  CodingSystemId (::std::ostream& o,
                  const ::xml_schema::Uri& s,
                  ::xml_schema::ErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodingSystemId (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CodingSystemId (::std::ostream& o,
                  const ::xml_schema::Uri& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodingSystemId (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CodingSystemId (::xercesc::XMLFormatTarget& t,
                  const ::xml_schema::Uri& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodingSystemId (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  CodingSystemId (::xercesc::XMLFormatTarget& t,
                  const ::xml_schema::Uri& s,
                  ::xml_schema::ErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodingSystemId (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CodingSystemId (::xercesc::XMLFormatTarget& t,
                  const ::xml_schema::Uri& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodingSystemId (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CodingSystemId (::xercesc::DOMDocument& d,
                  const ::xml_schema::Uri& s,
                  ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (typeid (::xml_schema::Uri) == typeid (s))
    {
      if (n.name () == "CodingSystemId" &&
          n.namespace_ () == "http://domain-model-uri/15/04")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "CodingSystemId",
          "http://domain-model-uri/15/04");
      }
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "CodingSystemId",
        "http://domain-model-uri/15/04",
        e, n, s);
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  CodingSystemId (const ::xml_schema::Uri& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

    if (typeid (::xml_schema::Uri) == typeid (s))
    {
      d = ::xsd::cxx::xml::dom::serialize< char > (
        "CodingSystemId",
        "http://domain-model-uri/15/04",
        m, f);
    }
    else
    {
      d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "CodingSystemId",
        "http://domain-model-uri/15/04",
        m, s, f);
    }

    ::CDM::CodingSystemId (*d, s, f);
    return d;
  }

  void
  CodingSystemName (::std::ostream& o,
                    const ::CDM::LocalizedText& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodingSystemName (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  CodingSystemName (::std::ostream& o,
                    const ::CDM::LocalizedText& s,
                    ::xml_schema::ErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodingSystemName (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CodingSystemName (::std::ostream& o,
                    const ::CDM::LocalizedText& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodingSystemName (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CodingSystemName (::xercesc::XMLFormatTarget& t,
                    const ::CDM::LocalizedText& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodingSystemName (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  CodingSystemName (::xercesc::XMLFormatTarget& t,
                    const ::CDM::LocalizedText& s,
                    ::xml_schema::ErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodingSystemName (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CodingSystemName (::xercesc::XMLFormatTarget& t,
                    const ::CDM::LocalizedText& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodingSystemName (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CodingSystemName (::xercesc::DOMDocument& d,
                    const ::CDM::LocalizedText& s,
                    ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (typeid (::CDM::LocalizedText) == typeid (s))
    {
      if (n.name () == "CodingSystemName" &&
          n.namespace_ () == "http://domain-model-uri/15/04")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "CodingSystemName",
          "http://domain-model-uri/15/04");
      }
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "CodingSystemName",
        "http://domain-model-uri/15/04",
        e, n, s);
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  CodingSystemName (const ::CDM::LocalizedText& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

    if (typeid (::CDM::LocalizedText) == typeid (s))
    {
      d = ::xsd::cxx::xml::dom::serialize< char > (
        "CodingSystemName",
        "http://domain-model-uri/15/04",
        m, f);
    }
    else
    {
      d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "CodingSystemName",
        "http://domain-model-uri/15/04",
        m, s, f);
    }

    ::CDM::CodingSystemName (*d, s, f);
    return d;
  }

  void
  VersionId (::std::ostream& o,
             const ::xml_schema::String& s,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::VersionId (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  VersionId (::std::ostream& o,
             const ::xml_schema::String& s,
             ::xml_schema::ErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::VersionId (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  VersionId (::std::ostream& o,
             const ::xml_schema::String& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::VersionId (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  VersionId (::xercesc::XMLFormatTarget& t,
             const ::xml_schema::String& s,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::VersionId (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  VersionId (::xercesc::XMLFormatTarget& t,
             const ::xml_schema::String& s,
             ::xml_schema::ErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::VersionId (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  VersionId (::xercesc::XMLFormatTarget& t,
             const ::xml_schema::String& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::VersionId (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  VersionId (::xercesc::DOMDocument& d,
             const ::xml_schema::String& s,
             ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (typeid (::xml_schema::String) == typeid (s))
    {
      if (n.name () == "VersionId" &&
          n.namespace_ () == "http://domain-model-uri/15/04")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "VersionId",
          "http://domain-model-uri/15/04");
      }
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "VersionId",
        "http://domain-model-uri/15/04",
        e, n, s);
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  VersionId (const ::xml_schema::String& s,
             const ::xml_schema::NamespaceInfomap& m,
             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

    if (typeid (::xml_schema::String) == typeid (s))
    {
      d = ::xsd::cxx::xml::dom::serialize< char > (
        "VersionId",
        "http://domain-model-uri/15/04",
        m, f);
    }
    else
    {
      d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "VersionId",
        "http://domain-model-uri/15/04",
        m, s, f);
    }

    ::CDM::VersionId (*d, s, f);
    return d;
  }

  void
  CodeId (::std::ostream& o,
          const ::CDM::CodeIdentifier& s,
          const ::xml_schema::NamespaceInfomap& m,
          const ::std::string& e,
          ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodeId (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  CodeId (::std::ostream& o,
          const ::CDM::CodeIdentifier& s,
          ::xml_schema::ErrorHandler& h,
          const ::xml_schema::NamespaceInfomap& m,
          const ::std::string& e,
          ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodeId (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CodeId (::std::ostream& o,
          const ::CDM::CodeIdentifier& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::NamespaceInfomap& m,
          const ::std::string& e,
          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodeId (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CodeId (::xercesc::XMLFormatTarget& t,
          const ::CDM::CodeIdentifier& s,
          const ::xml_schema::NamespaceInfomap& m,
          const ::std::string& e,
          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodeId (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  CodeId (::xercesc::XMLFormatTarget& t,
          const ::CDM::CodeIdentifier& s,
          ::xml_schema::ErrorHandler& h,
          const ::xml_schema::NamespaceInfomap& m,
          const ::std::string& e,
          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodeId (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CodeId (::xercesc::XMLFormatTarget& t,
          const ::CDM::CodeIdentifier& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::NamespaceInfomap& m,
          const ::std::string& e,
          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::CodeId (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CodeId (::xercesc::DOMDocument& d,
          const ::CDM::CodeIdentifier& s,
          ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (typeid (::CDM::CodeIdentifier) == typeid (s))
    {
      if (n.name () == "CodeId" &&
          n.namespace_ () == "http://domain-model-uri/15/04")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "CodeId",
          "http://domain-model-uri/15/04");
      }
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "CodeId",
        "http://domain-model-uri/15/04",
        e, n, s);
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  CodeId (const ::CDM::CodeIdentifier& s,
          const ::xml_schema::NamespaceInfomap& m,
          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

    if (typeid (::CDM::CodeIdentifier) == typeid (s))
    {
      d = ::xsd::cxx::xml::dom::serialize< char > (
        "CodeId",
        "http://domain-model-uri/15/04",
        m, f);
    }
    else
    {
      d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "CodeId",
        "http://domain-model-uri/15/04",
        m, s, f);
    }

    ::CDM::CodeId (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const InstanceIdentifier& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // IdentifierName
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (InstanceIdentifier::IdentifierNameConstIterator
           b (i.IdentifierName ().begin ()), n (i.IdentifierName ().end ());
           b != n; ++b)
      {
        if (typeid (InstanceIdentifier::IdentifierNameType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "IdentifierName",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "IdentifierName",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // root
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "root",
          e));

      a << i.root ();
    }

    // extension
    //
    if (i.extension ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "extension",
          e));

      a << *i.extension ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, InstanceIdentifier >
  _xsd_InstanceIdentifier_type_serializer_init (
    "InstanceIdentifier",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const CodedValue& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // CodingSystemId
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CodingSystemId ())
      {
        const CodedValue::CodingSystemIdType& x (*i.CodingSystemId ());
        if (typeid (CodedValue::CodingSystemIdType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CodingSystemId",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CodingSystemId",
            "http://domain-model-uri/15/04",
            true, true, e, x);
      }
    }

    // CodingSystemName
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (CodedValue::CodingSystemNameConstIterator
           b (i.CodingSystemName ().begin ()), n (i.CodingSystemName ().end ());
           b != n; ++b)
      {
        if (typeid (CodedValue::CodingSystemNameType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CodingSystemName",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "CodingSystemName",
            "http://domain-model-uri/15/04",
            true, true, e, *b);
      }
    }

    // VersionId
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.VersionId ())
      {
        const CodedValue::VersionIdType& x (*i.VersionId ());
        if (typeid (CodedValue::VersionIdType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "VersionId",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "VersionId",
            "http://domain-model-uri/15/04",
            true, true, e, x);
      }
    }

    // CodeId
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const CodedValue::CodeIdType& x (i.CodeId ());
      if (typeid (CodedValue::CodeIdType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CodeId",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "CodeId",
          "http://domain-model-uri/15/04",
          true, true, e, x);
    }

    // ConceptDescription
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (CodedValue::ConceptDescriptionConstIterator
           b (i.ConceptDescription ().begin ()), n (i.ConceptDescription ().end ());
           b != n; ++b)
      {
        if (typeid (CodedValue::ConceptDescriptionType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ConceptDescription",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ConceptDescription",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CodedValue >
  _xsd_CodedValue_type_serializer_init (
    "CodedValue",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const CodedWithTranslations& i)
  {
    e << static_cast< const ::CDM::CodedValue& > (i);

    // Translation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (CodedWithTranslations::TranslationConstIterator
           b (i.Translation ().begin ()), n (i.Translation ().end ());
           b != n; ++b)
      {
        if (typeid (CodedWithTranslations::TranslationType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Translation",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Translation",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CodedWithTranslations >
  _xsd_CodedWithTranslations_type_serializer_init (
    "CodedWithTranslations",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const CauseInfo& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // Remedy
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Remedy ())
      {
        const CauseInfo::RemedyType& x (*i.Remedy ());
        if (typeid (CauseInfo::RemedyType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Remedy",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Remedy",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // Description
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (CauseInfo::DescriptionConstIterator
           b (i.Description ().begin ()), n (i.Description ().end ());
           b != n; ++b)
      {
        if (typeid (CauseInfo::DescriptionType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Description",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Description",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CauseInfo >
  _xsd_CauseInfo_type_serializer_init (
    "CauseInfo",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const RemedyInfo& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // Description
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (RemedyInfo::DescriptionConstIterator
           b (i.Description ().begin ()), n (i.Description ().end ());
           b != n; ++b)
      {
        if (typeid (RemedyInfo::DescriptionType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Description",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Description",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RemedyInfo >
  _xsd_RemedyInfo_type_serializer_init (
    "RemedyInfo",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const Range& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // Lower
    //
    if (i.Lower ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Lower",
          e));

      a << ::xml_schema::AsDecimal(*i.Lower ());
    }

    // Upper
    //
    if (i.Upper ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Upper",
          e));

      a << ::xml_schema::AsDecimal(*i.Upper ());
    }

    // StepWidth
    //
    if (i.StepWidth ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "StepWidth",
          e));

      a << ::xml_schema::AsDecimal(*i.StepWidth ());
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Range >
  _xsd_Range_type_serializer_init (
    "Range",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const Measure& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // MeasurementUnit
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const Measure::MeasurementUnitType& x (i.MeasurementUnit ());
      if (typeid (Measure::MeasurementUnitType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MeasurementUnit",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MeasurementUnit",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // MeasuredValue
    //
    if (i.MeasuredValue ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MeasuredValue",
          e));

      a << ::xml_schema::AsDecimal(*i.MeasuredValue ());
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Measure >
  _xsd_Measure_type_serializer_init (
    "Measure",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const IntendedUse& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const IntendedUse& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const IntendedUse& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IntendedUse >
  _xsd_IntendedUse_type_serializer_init (
    "IntendedUse",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractDescriptor& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // Type
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Type ())
      {
        const AbstractDescriptor::TypeType& x (*i.Type ());
        if (typeid (AbstractDescriptor::TypeType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Type",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Type",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // Handle
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Handle",
          e));

      a << i.Handle ();
    }

    // DescriptorVersion
    //
    if (i.DescriptorVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "DescriptorVersion",
          e));

      a << *i.DescriptorVersion ();
    }

    // IntendedUse
    //
    if (i.IntendedUse ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "IntendedUse",
          e));

      a << *i.IntendedUse ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractDescriptor >
  _xsd_AbstractDescriptor_type_serializer_init (
    "AbstractDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractState& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // Handle
    //
    if (i.Handle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Handle",
          e));

      a << *i.Handle ();
    }

    // StateVersion
    //
    if (i.StateVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "StateVersion",
          e));

      a << *i.StateVersion ();
    }

    // DescriptorHandle
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "DescriptorHandle",
          e));

      a << i.DescriptorHandle ();
    }

    // DescriptorVersion
    //
    if (i.DescriptorVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "DescriptorVersion",
          e));

      a << *i.DescriptorVersion ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractState >
  _xsd_AbstractState_type_serializer_init (
    "AbstractState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const MDDescription& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // MDS
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (MDDescription::MDSConstIterator
           b (i.MDS ().begin ()), n (i.MDS ().end ());
           b != n; ++b)
      {
        if (typeid (MDDescription::MDSType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MDS",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "MDS",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // DescriptionVersion
    //
    if (i.DescriptionVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "DescriptionVersion",
          e));

      a << *i.DescriptionVersion ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MDDescription >
  _xsd_MDDescription_type_serializer_init (
    "MDDescription",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const MDState& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // State
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (MDState::StateConstIterator
           b (i.State ().begin ()), n (i.State ().end ());
           b != n; ++b)
      {
        if (typeid (MDState::StateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "State",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "State",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // StateVersion
    //
    if (i.StateVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "StateVersion",
          e));

      a << *i.StateVersion ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MDState >
  _xsd_MDState_type_serializer_init (
    "MDState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const MDIB& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // MDDescription
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const MDIB::MDDescriptionType& x (i.MDDescription ());
      if (typeid (MDIB::MDDescriptionType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MDDescription",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MDDescription",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // MDState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const MDIB::MDStateType& x (i.MDState ());
      if (typeid (MDIB::MDStateType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MDState",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MDState",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // MDIBVersion
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MDIBVersion",
          "http://domain-model-uri/15/04",
          e));

      a << i.MDIBVersion ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MDIB >
  _xsd_MDIB_type_serializer_init (
    "MDIB",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const ProductionSpecification& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // specType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ProductionSpecification::SpecTypeType& x (i.specType ());
      if (typeid (ProductionSpecification::SpecTypeType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "specType",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "specType",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // productionSpec
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ProductionSpecification::ProductionSpecType& x (i.productionSpec ());
      if (typeid (ProductionSpecification::ProductionSpecType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "productionSpec",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "productionSpec",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // componentId
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.componentId ())
      {
        const ProductionSpecification::ComponentIdType& x (*i.componentId ());
        if (typeid (ProductionSpecification::ComponentIdType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "componentId",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "componentId",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ProductionSpecification >
  _xsd_ProductionSpecification_type_serializer_init (
    "ProductionSpecification",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const SystemMetaData& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // UDI
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.UDI ())
      {
        const SystemMetaData::UDIType& x (*i.UDI ());
        if (typeid (SystemMetaData::UDIType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "UDI",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "UDI",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // Manufacturer
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SystemMetaData::ManufacturerConstIterator
           b (i.Manufacturer ().begin ()), n (i.Manufacturer ().end ());
           b != n; ++b)
      {
        if (typeid (SystemMetaData::ManufacturerType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Manufacturer",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Manufacturer",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // ModelName
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SystemMetaData::ModelNameConstIterator
           b (i.ModelName ().begin ()), n (i.ModelName ().end ());
           b != n; ++b)
      {
        if (typeid (SystemMetaData::ModelNameType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ModelName",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ModelName",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // ModelNumber
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SystemMetaData::ModelNumberConstIterator
           b (i.ModelNumber ().begin ()), n (i.ModelNumber ().end ());
           b != n; ++b)
      {
        if (typeid (SystemMetaData::ModelNumberType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ModelNumber",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ModelNumber",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // SerialNumber
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SystemMetaData::SerialNumberConstIterator
           b (i.SerialNumber ().begin ()), n (i.SerialNumber ().end ());
           b != n; ++b)
      {
        if (typeid (SystemMetaData::SerialNumberType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SerialNumber",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "SerialNumber",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SystemMetaData >
  _xsd_SystemMetaData_type_serializer_init (
    "SystemMetaData",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const SystemContext& i)
  {
    e << static_cast< const ::CDM::AbstractDescriptor& > (i);

    // PatientContext
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.PatientContext ())
      {
        const SystemContext::PatientContextType& x (*i.PatientContext ());
        if (typeid (SystemContext::PatientContextType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PatientContext",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "PatientContext",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // LocationContext
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.LocationContext ())
      {
        const SystemContext::LocationContextType& x (*i.LocationContext ());
        if (typeid (SystemContext::LocationContextType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "LocationContext",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "LocationContext",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // EnsembleContext
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.EnsembleContext ())
      {
        const SystemContext::EnsembleContextType& x (*i.EnsembleContext ());
        if (typeid (SystemContext::EnsembleContextType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EnsembleContext",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EnsembleContext",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // OperatorContext
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.OperatorContext ())
      {
        const SystemContext::OperatorContextType& x (*i.OperatorContext ());
        if (typeid (SystemContext::OperatorContextType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OperatorContext",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "OperatorContext",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // WorkflowContext
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.WorkflowContext ())
      {
        const SystemContext::WorkflowContextType& x (*i.WorkflowContext ());
        if (typeid (SystemContext::WorkflowContextType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "WorkflowContext",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "WorkflowContext",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SystemContext >
  _xsd_SystemContext_type_serializer_init (
    "SystemContext",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractDeviceComponent& i)
  {
    e << static_cast< const ::CDM::AbstractDescriptor& > (i);

    // ProductionSpecification
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AbstractDeviceComponent::ProductionSpecificationConstIterator
           b (i.ProductionSpecification ().begin ()), n (i.ProductionSpecification ().end ());
           b != n; ++b)
      {
        if (typeid (AbstractDeviceComponent::ProductionSpecificationType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ProductionSpecification",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ProductionSpecification",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractDeviceComponent >
  _xsd_AbstractDeviceComponent_type_serializer_init (
    "AbstractDeviceComponent",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractMDSDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDeviceComponent& > (i);

    // MetaData
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.MetaData ())
      {
        const AbstractMDSDescriptor::MetaDataType& x (*i.MetaData ());
        if (typeid (AbstractMDSDescriptor::MetaDataType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MetaData",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "MetaData",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // Context
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AbstractMDSDescriptor::ContextType& x (i.Context ());
      if (typeid (AbstractMDSDescriptor::ContextType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Context",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Context",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // Clock
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Clock ())
      {
        const AbstractMDSDescriptor::ClockType& x (*i.Clock ());
        if (typeid (AbstractMDSDescriptor::ClockType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Clock",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Clock",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractMDSDescriptor >
  _xsd_AbstractMDSDescriptor_type_serializer_init (
    "AbstractMDSDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const HydraMDSDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractMDSDescriptor& > (i);

    // SCO
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.SCO ())
      {
        const HydraMDSDescriptor::SCOType& x (*i.SCO ());
        if (typeid (HydraMDSDescriptor::SCOType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SCO",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "SCO",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // AlertSystem
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AlertSystem ())
      {
        const HydraMDSDescriptor::AlertSystemType& x (*i.AlertSystem ());
        if (typeid (HydraMDSDescriptor::AlertSystemType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AlertSystem",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AlertSystem",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // VMD
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (HydraMDSDescriptor::VMDConstIterator
           b (i.VMD ().begin ()), n (i.VMD ().end ());
           b != n; ++b)
      {
        if (typeid (HydraMDSDescriptor::VMDType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "VMD",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "VMD",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, HydraMDSDescriptor >
  _xsd_HydraMDSDescriptor_type_serializer_init (
    "HydraMDSDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const ComponentState& i)
  {
    e << static_cast< const ::CDM::AbstractState& > (i);

    // CalibrationInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CalibrationInfo ())
      {
        const ComponentState::CalibrationInfoType& x (*i.CalibrationInfo ());
        if (typeid (ComponentState::CalibrationInfoType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CalibrationInfo",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CalibrationInfo",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // ComponentActivationState
    //
    if (i.ComponentActivationState ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ComponentActivationState",
          "http://domain-model-uri/15/04",
          e));

      a << *i.ComponentActivationState ();
    }

    // OperatingHours
    //
    if (i.OperatingHours ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "OperatingHours",
          e));

      a << *i.OperatingHours ();
    }

    // OperatingCycles
    //
    if (i.OperatingCycles ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "OperatingCycles",
          e));

      a << *i.OperatingCycles ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ComponentState >
  _xsd_ComponentState_type_serializer_init (
    "ComponentState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractMDSState& i)
  {
    e << static_cast< const ::CDM::ComponentState& > (i);

    // Lang
    //
    if (i.Lang ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Lang",
          e));

      a << *i.Lang ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractMDSState >
  _xsd_AbstractMDSState_type_serializer_init (
    "AbstractMDSState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const HydraMDSState& i)
  {
    e << static_cast< const ::CDM::AbstractMDSState& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, HydraMDSState >
  _xsd_HydraMDSState_type_serializer_init (
    "HydraMDSState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AlertConditionKind& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AlertConditionKind& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const AlertConditionKind& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertConditionKind >
  _xsd_AlertConditionKind_type_serializer_init (
    "AlertConditionKind",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AlertConditionPriority& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AlertConditionPriority& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const AlertConditionPriority& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertConditionPriority >
  _xsd_AlertConditionPriority_type_serializer_init (
    "AlertConditionPriority",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AlertSignalManifestation& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AlertSignalManifestation& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const AlertSignalManifestation& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertSignalManifestation >
  _xsd_AlertSignalManifestation_type_serializer_init (
    "AlertSignalManifestation",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractAlertDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractAlertDescriptor >
  _xsd_AbstractAlertDescriptor_type_serializer_init (
    "AbstractAlertDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AlertSystemDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractAlertDescriptor& > (i);

    // AlertCondition
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AlertSystemDescriptor::AlertConditionConstIterator
           b (i.AlertCondition ().begin ()), n (i.AlertCondition ().end ());
           b != n; ++b)
      {
        if (typeid (AlertSystemDescriptor::AlertConditionType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AlertCondition",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "AlertCondition",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // AlertSignal
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AlertSystemDescriptor::AlertSignalConstIterator
           b (i.AlertSignal ().begin ()), n (i.AlertSignal ().end ());
           b != n; ++b)
      {
        if (typeid (AlertSystemDescriptor::AlertSignalType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AlertSignal",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "AlertSignal",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // MaxPhysiologicalAlarmListEntries
    //
    if (i.MaxPhysiologicalAlarmListEntries ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MaxPhysiologicalAlarmListEntries",
          e));

      a << *i.MaxPhysiologicalAlarmListEntries ();
    }

    // MaxTechnicalAlarmListEntries
    //
    if (i.MaxTechnicalAlarmListEntries ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MaxTechnicalAlarmListEntries",
          e));

      a << *i.MaxTechnicalAlarmListEntries ();
    }

    // SelfCheckPeriod
    //
    if (i.SelfCheckPeriod ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "SelfCheckPeriod",
          e));

      a << *i.SelfCheckPeriod ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertSystemDescriptor >
  _xsd_AlertSystemDescriptor_type_serializer_init (
    "AlertSystemDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AlertConditionDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractAlertDescriptor& > (i);

    // Kind
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AlertConditionDescriptor::KindType& x (i.Kind ());
      if (typeid (AlertConditionDescriptor::KindType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Kind",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Kind",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // Source
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AlertConditionDescriptor::SourceConstIterator
           b (i.Source ().begin ()), n (i.Source ().end ());
           b != n; ++b)
      {
        if (typeid (AlertConditionDescriptor::SourceType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Source",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Source",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // Priority
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AlertConditionDescriptor::PriorityType& x (i.Priority ());
      if (typeid (AlertConditionDescriptor::PriorityType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Priority",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Priority",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // CauseInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AlertConditionDescriptor::CauseInfoConstIterator
           b (i.CauseInfo ().begin ()), n (i.CauseInfo ().end ());
           b != n; ++b)
      {
        if (typeid (AlertConditionDescriptor::CauseInfoType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CauseInfo",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "CauseInfo",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertConditionDescriptor >
  _xsd_AlertConditionDescriptor_type_serializer_init (
    "AlertConditionDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AlertSignalDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractAlertDescriptor& > (i);

    // ConditionSignaled
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AlertSignalDescriptor::ConditionSignaledType& x (i.ConditionSignaled ());
      if (typeid (AlertSignalDescriptor::ConditionSignaledType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ConditionSignaled",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ConditionSignaled",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // Manifestation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AlertSignalDescriptor::ManifestationType& x (i.Manifestation ());
      if (typeid (AlertSignalDescriptor::ManifestationType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Manifestation",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Manifestation",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // Latching
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Latching",
          "http://domain-model-uri/15/04",
          e));

      s << i.Latching ();
    }

    // DefaultSignalGenerationDelay
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DefaultSignalGenerationDelay ())
      {
        const AlertSignalDescriptor::DefaultSignalGenerationDelayType& x (*i.DefaultSignalGenerationDelay ());
        if (typeid (AlertSignalDescriptor::DefaultSignalGenerationDelayType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DefaultSignalGenerationDelay",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DefaultSignalGenerationDelay",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // SignalDelegationSupported
    //
    if (i.SignalDelegationSupported ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SignalDelegationSupported",
          "http://domain-model-uri/15/04",
          e));

      s << *i.SignalDelegationSupported ();
    }

    // AcknowledgementSupported
    //
    if (i.AcknowledgementSupported ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "AcknowledgementSupported",
          e));

      a << *i.AcknowledgementSupported ();
    }

    // AcknowledgeTimeout
    //
    if (i.AcknowledgeTimeout ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "AcknowledgeTimeout",
          e));

      a << *i.AcknowledgeTimeout ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertSignalDescriptor >
  _xsd_AlertSignalDescriptor_type_serializer_init (
    "AlertSignalDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const LimitAlertConditionDescriptor& i)
  {
    e << static_cast< const ::CDM::AlertConditionDescriptor& > (i);

    // MaxLimits
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const LimitAlertConditionDescriptor::MaxLimitsType& x (i.MaxLimits ());
      if (typeid (LimitAlertConditionDescriptor::MaxLimitsType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxLimits",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MaxLimits",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // AutoLimitSupported
    //
    if (i.AutoLimitSupported ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AutoLimitSupported",
          "http://domain-model-uri/15/04",
          e));

      s << *i.AutoLimitSupported ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LimitAlertConditionDescriptor >
  _xsd_LimitAlertConditionDescriptor_type_serializer_init (
    "LimitAlertConditionDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const PausableActivation& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const PausableActivation& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const PausableActivation& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PausableActivation >
  _xsd_PausableActivation_type_serializer_init (
    "PausableActivation",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const SignalPresence& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const SignalPresence& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const SignalPresence& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SignalPresence >
  _xsd_SignalPresence_type_serializer_init (
    "SignalPresence",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const PrimaryAlertSignalLocation& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const PrimaryAlertSignalLocation& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const PrimaryAlertSignalLocation& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PrimaryAlertSignalLocation >
  _xsd_PrimaryAlertSignalLocation_type_serializer_init (
    "PrimaryAlertSignalLocation",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const MonitoredAlertLimits& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const MonitoredAlertLimits& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const MonitoredAlertLimits& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MonitoredAlertLimits >
  _xsd_MonitoredAlertLimits_type_serializer_init (
    "MonitoredAlertLimits",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractAlertState& i)
  {
    e << static_cast< const ::CDM::AbstractState& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractAlertState >
  _xsd_AbstractAlertState_type_serializer_init (
    "AbstractAlertState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AlertConditionState& i)
  {
    e << static_cast< const ::CDM::AbstractAlertState& > (i);

    // ActivationState
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ActivationState",
          e));

      a << i.ActivationState ();
    }

    // ActualPriority
    //
    if (i.ActualPriority ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ActualPriority",
          e));

      a << *i.ActualPriority ();
    }

    // Rank
    //
    if (i.Rank ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Rank",
          e));

      a << *i.Rank ();
    }

    // Presence
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Presence",
          e));

      a << i.Presence ();
    }

    // ObservationTime
    //
    if (i.ObservationTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ObservationTime",
          e));

      a << *i.ObservationTime ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertConditionState >
  _xsd_AlertConditionState_type_serializer_init (
    "AlertConditionState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AlertSignalState& i)
  {
    e << static_cast< const ::CDM::AbstractAlertState& > (i);

    // ActivationState
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ActivationState",
          e));

      a << i.ActivationState ();
    }

    // Presence
    //
    if (i.Presence ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Presence",
          e));

      a << *i.Presence ();
    }

    // Location
    //
    if (i.Location ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Location",
          e));

      a << *i.Location ();
    }

    // Slot
    //
    if (i.Slot ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Slot",
          e));

      a << *i.Slot ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertSignalState >
  _xsd_AlertSignalState_type_serializer_init (
    "AlertSignalState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AlertSystemState& i)
  {
    e << static_cast< const ::CDM::AbstractAlertState& > (i);

    // ActivationState
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ActivationState",
          e));

      a << i.ActivationState ();
    }

    // LastSelfCheck
    //
    if (i.LastSelfCheck ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "LastSelfCheck",
          e));

      a << *i.LastSelfCheck ();
    }

    // SelfCheckCount
    //
    if (i.SelfCheckCount ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "SelfCheckCount",
          e));

      a << *i.SelfCheckCount ();
    }

    // PresentPhysiologicalAlarmConditions
    //
    if (i.PresentPhysiologicalAlarmConditions ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "PresentPhysiologicalAlarmConditions",
          e));

      a << *i.PresentPhysiologicalAlarmConditions ();
    }

    // PresentTechnicalAlarmConditions
    //
    if (i.PresentTechnicalAlarmConditions ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "PresentTechnicalAlarmConditions",
          e));

      a << *i.PresentTechnicalAlarmConditions ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertSystemState >
  _xsd_AlertSystemState_type_serializer_init (
    "AlertSystemState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AlertConditionReference& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::CDM::HandleRef, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AlertConditionReference& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::CDM::HandleRef, char >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const AlertConditionReference& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::CDM::HandleRef, char >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlertConditionReference >
  _xsd_AlertConditionReference_type_serializer_init (
    "AlertConditionReference",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const LimitAlertConditionState& i)
  {
    e << static_cast< const ::CDM::AlertConditionState& > (i);

    // Limits
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Limits ())
      {
        const LimitAlertConditionState::LimitsType& x (*i.Limits ());
        if (typeid (LimitAlertConditionState::LimitsType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Limits",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Limits",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // MonitoredAlertLimits
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MonitoredAlertLimits",
          e));

      a << i.MonitoredAlertLimits ();
    }

    // AutoLimitActivationState
    //
    if (i.AutoLimitActivationState ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "AutoLimitActivationState",
          e));

      a << *i.AutoLimitActivationState ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LimitAlertConditionState >
  _xsd_LimitAlertConditionState_type_serializer_init (
    "LimitAlertConditionState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const MetricCategory& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const MetricCategory& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const MetricCategory& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MetricCategory >
  _xsd_MetricCategory_type_serializer_init (
    "MetricCategory",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const MetricAvailability& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const MetricAvailability& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const MetricAvailability& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MetricAvailability >
  _xsd_MetricAvailability_type_serializer_init (
    "MetricAvailability",
    "http://domain-model-uri/15/04");


  void
  Type (::std::ostream& o,
        const ::CDM::CodedValue& s,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Type (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  Type (::std::ostream& o,
        const ::CDM::CodedValue& s,
        ::xml_schema::ErrorHandler& h,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Type (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Type (::std::ostream& o,
        const ::CDM::CodedValue& s,
        ::xercesc::DOMErrorHandler& h,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Type (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Type (::xercesc::XMLFormatTarget& t,
        const ::CDM::CodedValue& s,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Type (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  Type (::xercesc::XMLFormatTarget& t,
        const ::CDM::CodedValue& s,
        ::xml_schema::ErrorHandler& h,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Type (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Type (::xercesc::XMLFormatTarget& t,
        const ::CDM::CodedValue& s,
        ::xercesc::DOMErrorHandler& h,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Type (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Type (::xercesc::DOMDocument& d,
        const ::CDM::CodedValue& s,
        ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (typeid (::CDM::CodedValue) == typeid (s))
    {
      if (n.name () == "Type" &&
          n.namespace_ () == "http://domain-model-uri/15/04")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "Type",
          "http://domain-model-uri/15/04");
      }
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "Type",
        "http://domain-model-uri/15/04",
        e, n, s);
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  Type (const ::CDM::CodedValue& s,
        const ::xml_schema::NamespaceInfomap& m,
        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

    if (typeid (::CDM::CodedValue) == typeid (s))
    {
      d = ::xsd::cxx::xml::dom::serialize< char > (
        "Type",
        "http://domain-model-uri/15/04",
        m, f);
    }
    else
    {
      d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "Type",
        "http://domain-model-uri/15/04",
        m, s, f);
    }

    ::CDM::Type (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const VMDDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDeviceComponent& > (i);

    // Channel
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (VMDDescriptor::ChannelConstIterator
           b (i.Channel ().begin ()), n (i.Channel ().end ());
           b != n; ++b)
      {
        if (typeid (VMDDescriptor::ChannelType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Channel",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Channel",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // AlertSystem
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AlertSystem ())
      {
        const VMDDescriptor::AlertSystemType& x (*i.AlertSystem ());
        if (typeid (VMDDescriptor::AlertSystemType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AlertSystem",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AlertSystem",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, VMDDescriptor >
  _xsd_VMDDescriptor_type_serializer_init (
    "VMDDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const ChannelDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDeviceComponent& > (i);

    // Metric
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ChannelDescriptor::MetricConstIterator
           b (i.Metric ().begin ()), n (i.Metric ().end ());
           b != n; ++b)
      {
        if (typeid (ChannelDescriptor::MetricType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Metric",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Metric",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // AlertSystem
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AlertSystem ())
      {
        const ChannelDescriptor::AlertSystemType& x (*i.AlertSystem ());
        if (typeid (ChannelDescriptor::AlertSystemType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AlertSystem",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AlertSystem",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ChannelDescriptor >
  _xsd_ChannelDescriptor_type_serializer_init (
    "ChannelDescriptor",
    "http://domain-model-uri/15/04");


  void
  Unit (::std::ostream& o,
        const ::CDM::CodedValue& s,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Unit (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  Unit (::std::ostream& o,
        const ::CDM::CodedValue& s,
        ::xml_schema::ErrorHandler& h,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Unit (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Unit (::std::ostream& o,
        const ::CDM::CodedValue& s,
        ::xercesc::DOMErrorHandler& h,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Unit (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Unit (::xercesc::XMLFormatTarget& t,
        const ::CDM::CodedValue& s,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Unit (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  Unit (::xercesc::XMLFormatTarget& t,
        const ::CDM::CodedValue& s,
        ::xml_schema::ErrorHandler& h,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Unit (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Unit (::xercesc::XMLFormatTarget& t,
        const ::CDM::CodedValue& s,
        ::xercesc::DOMErrorHandler& h,
        const ::xml_schema::NamespaceInfomap& m,
        const ::std::string& e,
        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Unit (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Unit (::xercesc::DOMDocument& d,
        const ::CDM::CodedValue& s,
        ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (typeid (::CDM::CodedValue) == typeid (s))
    {
      if (n.name () == "Unit" &&
          n.namespace_ () == "http://domain-model-uri/15/04")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "Unit",
          "http://domain-model-uri/15/04");
      }
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "Unit",
        "http://domain-model-uri/15/04",
        e, n, s);
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  Unit (const ::CDM::CodedValue& s,
        const ::xml_schema::NamespaceInfomap& m,
        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

    if (typeid (::CDM::CodedValue) == typeid (s))
    {
      d = ::xsd::cxx::xml::dom::serialize< char > (
        "Unit",
        "http://domain-model-uri/15/04",
        m, f);
    }
    else
    {
      d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "Unit",
        "http://domain-model-uri/15/04",
        m, s, f);
    }

    ::CDM::Unit (*d, s, f);
    return d;
  }

  void
  BodySite (::std::ostream& o,
            const ::CDM::CodedValue& s,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::BodySite (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  BodySite (::std::ostream& o,
            const ::CDM::CodedValue& s,
            ::xml_schema::ErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::BodySite (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  BodySite (::std::ostream& o,
            const ::CDM::CodedValue& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::BodySite (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  BodySite (::xercesc::XMLFormatTarget& t,
            const ::CDM::CodedValue& s,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::BodySite (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  BodySite (::xercesc::XMLFormatTarget& t,
            const ::CDM::CodedValue& s,
            ::xml_schema::ErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::BodySite (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  BodySite (::xercesc::XMLFormatTarget& t,
            const ::CDM::CodedValue& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::BodySite (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  BodySite (::xercesc::DOMDocument& d,
            const ::CDM::CodedValue& s,
            ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (typeid (::CDM::CodedValue) == typeid (s))
    {
      if (n.name () == "BodySite" &&
          n.namespace_ () == "http://domain-model-uri/15/04")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "BodySite",
          "http://domain-model-uri/15/04");
      }
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "BodySite",
        "http://domain-model-uri/15/04",
        e, n, s);
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  BodySite (const ::CDM::CodedValue& s,
            const ::xml_schema::NamespaceInfomap& m,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

    if (typeid (::CDM::CodedValue) == typeid (s))
    {
      d = ::xsd::cxx::xml::dom::serialize< char > (
        "BodySite",
        "http://domain-model-uri/15/04",
        m, f);
    }
    else
    {
      d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "BodySite",
        "http://domain-model-uri/15/04",
        m, s, f);
    }

    ::CDM::BodySite (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const AbstractMetricDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDescriptor& > (i);

    // Unit
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AbstractMetricDescriptor::UnitType& x (i.Unit ());
      if (typeid (AbstractMetricDescriptor::UnitType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Unit",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Unit",
          "http://domain-model-uri/15/04",
          true, true, e, x);
    }

    // BodySite
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AbstractMetricDescriptor::BodySiteConstIterator
           b (i.BodySite ().begin ()), n (i.BodySite ().end ());
           b != n; ++b)
      {
        if (typeid (AbstractMetricDescriptor::BodySiteType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "BodySite",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "BodySite",
            "http://domain-model-uri/15/04",
            true, true, e, *b);
      }
    }

    // MetricCategory
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AbstractMetricDescriptor::MetricCategoryType& x (i.MetricCategory ());
      if (typeid (AbstractMetricDescriptor::MetricCategoryType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MetricCategory",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MetricCategory",
          "http://domain-model-uri/15/04",
          true, true, e, x);
    }

    // Availability
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AbstractMetricDescriptor::AvailabilityType& x (i.Availability ());
      if (typeid (AbstractMetricDescriptor::AvailabilityType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Availability",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Availability",
          "http://domain-model-uri/15/04",
          true, true, e, x);
    }

    // MaxDelayTime
    //
    if (i.MaxDelayTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MaxDelayTime",
          e));

      a << *i.MaxDelayTime ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractMetricDescriptor >
  _xsd_AbstractMetricDescriptor_type_serializer_init (
    "AbstractMetricDescriptor",
    "http://domain-model-uri/15/04");


  void
  Resolution (::std::ostream& o,
              const ::xml_schema::Decimal& s,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Resolution (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  Resolution (::std::ostream& o,
              const ::xml_schema::Decimal& s,
              ::xml_schema::ErrorHandler& h,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Resolution (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Resolution (::std::ostream& o,
              const ::xml_schema::Decimal& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Resolution (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Resolution (::xercesc::XMLFormatTarget& t,
              const ::xml_schema::Decimal& s,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Resolution (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  Resolution (::xercesc::XMLFormatTarget& t,
              const ::xml_schema::Decimal& s,
              ::xml_schema::ErrorHandler& h,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Resolution (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Resolution (::xercesc::XMLFormatTarget& t,
              const ::xml_schema::Decimal& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Resolution (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Resolution (::xercesc::DOMDocument& d,
              const ::xml_schema::Decimal& s,
              ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Resolution" &&
        n.namespace_ () == "http://domain-model-uri/15/04")
    {
      e << ::xml_schema::AsDecimal(s);
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Resolution",
        "http://domain-model-uri/15/04");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  Resolution (const ::xml_schema::Decimal& s,
              const ::xml_schema::NamespaceInfomap& m,
              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "Resolution",
        "http://domain-model-uri/15/04",
        m, f));

    ::CDM::Resolution (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const NumericMetricDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractMetricDescriptor& > (i);

    // Resolution
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Resolution",
          "http://domain-model-uri/15/04",
          e));

      s << ::xml_schema::AsDecimal(i.Resolution ());
    }

    // MeasurePeriod
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.MeasurePeriod ())
      {
        const NumericMetricDescriptor::MeasurePeriodType& x (*i.MeasurePeriod ());
        if (typeid (NumericMetricDescriptor::MeasurePeriodType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MeasurePeriod",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "MeasurePeriod",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // AveragingPeriod
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AveragingPeriod ())
      {
        const NumericMetricDescriptor::AveragingPeriodType& x (*i.AveragingPeriod ());
        if (typeid (NumericMetricDescriptor::AveragingPeriodType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AveragingPeriod",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AveragingPeriod",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // TechnicalRange
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (NumericMetricDescriptor::TechnicalRangeConstIterator
           b (i.TechnicalRange ().begin ()), n (i.TechnicalRange ().end ());
           b != n; ++b)
      {
        if (typeid (NumericMetricDescriptor::TechnicalRangeType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TechnicalRange",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "TechnicalRange",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, NumericMetricDescriptor >
  _xsd_NumericMetricDescriptor_type_serializer_init (
    "NumericMetricDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const StringMetricDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractMetricDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StringMetricDescriptor >
  _xsd_StringMetricDescriptor_type_serializer_init (
    "StringMetricDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const EnumNomenRef& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // Code
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const EnumNomenRef::CodeType& x (i.Code ());
      if (typeid (EnumNomenRef::CodeType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Code",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Code",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // EnumIndex
    //
    if (i.EnumIndex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "EnumIndex",
          e));

      a << *i.EnumIndex ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumNomenRef >
  _xsd_EnumNomenRef_type_serializer_init (
    "EnumNomenRef",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const EnumStringMetricDescriptor& i)
  {
    e << static_cast< const ::CDM::StringMetricDescriptor& > (i);

    // AllowedValue
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (EnumStringMetricDescriptor::AllowedValueConstIterator
           b (i.AllowedValue ().begin ()), n (i.AllowedValue ().end ());
           b != n; ++b)
      {
        if (typeid (EnumStringMetricDescriptor::AllowedValueType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AllowedValue",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "AllowedValue",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // EnumCodes
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (EnumStringMetricDescriptor::EnumCodesConstIterator
           b (i.EnumCodes ().begin ()), n (i.EnumCodes ().end ());
           b != n; ++b)
      {
        if (typeid (EnumStringMetricDescriptor::EnumCodesType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EnumCodes",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "EnumCodes",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumStringMetricDescriptor >
  _xsd_EnumStringMetricDescriptor_type_serializer_init (
    "EnumStringMetricDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const RealTimeSampleArrayMetricDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractMetricDescriptor& > (i);

    // SamplePeriod
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const RealTimeSampleArrayMetricDescriptor::SamplePeriodType& x (i.SamplePeriod ());
      if (typeid (RealTimeSampleArrayMetricDescriptor::SamplePeriodType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SamplePeriod",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "SamplePeriod",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // Resolution
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Resolution",
          "http://domain-model-uri/15/04",
          e));

      s << ::xml_schema::AsDecimal(i.Resolution ());
    }

    // TechnicalRange
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (RealTimeSampleArrayMetricDescriptor::TechnicalRangeConstIterator
           b (i.TechnicalRange ().begin ()), n (i.TechnicalRange ().end ());
           b != n; ++b)
      {
        if (typeid (RealTimeSampleArrayMetricDescriptor::TechnicalRangeType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TechnicalRange",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "TechnicalRange",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RealTimeSampleArrayMetricDescriptor >
  _xsd_RealTimeSampleArrayMetricDescriptor_type_serializer_init (
    "RealTimeSampleArrayMetricDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const CalibrationState& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CalibrationState& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CalibrationState& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CalibrationState >
  _xsd_CalibrationState_type_serializer_init (
    "CalibrationState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const ComponentActivation& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ComponentActivation& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const ComponentActivation& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ComponentActivation >
  _xsd_ComponentActivation_type_serializer_init (
    "ComponentActivation",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const MetricMeasurementValidity& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const MetricMeasurementValidity& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const MetricMeasurementValidity& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MetricMeasurementValidity >
  _xsd_MetricMeasurementValidity_type_serializer_init (
    "MetricMeasurementValidity",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const GenerationMode& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const GenerationMode& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const GenerationMode& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GenerationMode >
  _xsd_GenerationMode_type_serializer_init (
    "GenerationMode",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const CalibrationInfo& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // ComponentCalibrationState
    //
    if (i.ComponentCalibrationState ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ComponentCalibrationState",
          "http://domain-model-uri/15/04",
          e));

      a << *i.ComponentCalibrationState ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CalibrationInfo >
  _xsd_CalibrationInfo_type_serializer_init (
    "CalibrationInfo",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractMetricState& i)
  {
    e << static_cast< const ::CDM::ComponentState& > (i);

    // MeasurementPeriod
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.MeasurementPeriod ())
      {
        const AbstractMetricState::MeasurementPeriodType& x (*i.MeasurementPeriod ());
        if (typeid (AbstractMetricState::MeasurementPeriodType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MeasurementPeriod",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "MeasurementPeriod",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // AveragingPeriod
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.AveragingPeriod ())
      {
        const AbstractMetricState::AveragingPeriodType& x (*i.AveragingPeriod ());
        if (typeid (AbstractMetricState::AveragingPeriodType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AveragingPeriod",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "AveragingPeriod",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // BodySite
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AbstractMetricState::BodySiteConstIterator
           b (i.BodySite ().begin ()), n (i.BodySite ().end ());
           b != n; ++b)
      {
        if (typeid (AbstractMetricState::BodySiteType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "BodySite",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "BodySite",
            "http://domain-model-uri/15/04",
            true, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractMetricState >
  _xsd_AbstractMetricState_type_serializer_init (
    "AbstractMetricState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const NumericMetricState& i)
  {
    e << static_cast< const ::CDM::AbstractMetricState& > (i);

    // ObservedValue
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ObservedValue ())
      {
        const NumericMetricState::ObservedValueType& x (*i.ObservedValue ());
        if (typeid (NumericMetricState::ObservedValueType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ObservedValue",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ObservedValue",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // PhysiologicalRange
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (NumericMetricState::PhysiologicalRangeConstIterator
           b (i.PhysiologicalRange ().begin ()), n (i.PhysiologicalRange ().end ());
           b != n; ++b)
      {
        if (typeid (NumericMetricState::PhysiologicalRangeType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PhysiologicalRange",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "PhysiologicalRange",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, NumericMetricState >
  _xsd_NumericMetricState_type_serializer_init (
    "NumericMetricState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const RealTimeSampleArrayMetricState& i)
  {
    e << static_cast< const ::CDM::AbstractMetricState& > (i);

    // ObservedValue
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ObservedValue ())
      {
        const RealTimeSampleArrayMetricState::ObservedValueType& x (*i.ObservedValue ());
        if (typeid (RealTimeSampleArrayMetricState::ObservedValueType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ObservedValue",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ObservedValue",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RealTimeSampleArrayMetricState >
  _xsd_RealTimeSampleArrayMetricState_type_serializer_init (
    "RealTimeSampleArrayMetricState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const StringMetricState& i)
  {
    e << static_cast< const ::CDM::AbstractMetricState& > (i);

    // ObservedValue
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ObservedValue ())
      {
        const StringMetricState::ObservedValueType& x (*i.ObservedValue ());
        if (typeid (StringMetricState::ObservedValueType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ObservedValue",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ObservedValue",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StringMetricState >
  _xsd_StringMetricState_type_serializer_init (
    "StringMetricState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const EnumStringMetricState& i)
  {
    e << static_cast< const ::CDM::StringMetricState& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnumStringMetricState >
  _xsd_EnumStringMetricState_type_serializer_init (
    "EnumStringMetricState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const QualityIndicator& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const QualityIndicator& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const QualityIndicator& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, QualityIndicator >
  _xsd_QualityIndicator_type_serializer_init (
    "QualityIndicator",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const MeasurementState& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // Validity
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Validity",
          e));

      a << i.Validity ();
    }

    // Mode
    //
    if (i.Mode ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Mode",
          e));

      a << *i.Mode ();
    }

    // QI
    //
    if (i.QI ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "QI",
          e));

      a << *i.QI ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MeasurementState >
  _xsd_MeasurementState_type_serializer_init (
    "MeasurementState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const SampleIndex& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const SampleIndex& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const SampleIndex& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SampleIndex >
  _xsd_SampleIndex_type_serializer_init (
    "SampleIndex",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const Annotation& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // Code
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const Annotation::CodeType& x (i.Code ());
      if (typeid (Annotation::CodeType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Code",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Code",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // SampleIndex
    //
    if (i.SampleIndex ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "SampleIndex",
          e));

      a << *i.SampleIndex ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Annotation >
  _xsd_Annotation_type_serializer_init (
    "Annotation",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractMetricValue& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // MeasurementState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AbstractMetricValue::MeasurementStateType& x (i.MeasurementState ());
      if (typeid (AbstractMetricValue::MeasurementStateType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MeasurementState",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MeasurementState",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // Start-Time
    //
    if (i.Start_Time ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Start-Time",
          e));

      a << *i.Start_Time ();
    }

    // Stop-Time
    //
    if (i.Stop_Time ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Stop-Time",
          e));

      a << *i.Stop_Time ();
    }

    // ObservationTime
    //
    if (i.ObservationTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ObservationTime",
          e));

      a << *i.ObservationTime ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractMetricValue >
  _xsd_AbstractMetricValue_type_serializer_init (
    "AbstractMetricValue",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const NumericMetricValue& i)
  {
    e << static_cast< const ::CDM::AbstractMetricValue& > (i);

    // Value
    //
    if (i.Value ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Value",
          e));

      a << ::xml_schema::AsDecimal(*i.Value ());
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, NumericMetricValue >
  _xsd_NumericMetricValue_type_serializer_init (
    "NumericMetricValue",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const RealTimeSampleArrayValue& i)
  {
    e << static_cast< const ::CDM::AbstractMetricValue& > (i);

    // Annotation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (RealTimeSampleArrayValue::AnnotationConstIterator
           b (i.Annotation ().begin ()), n (i.Annotation ().end ());
           b != n; ++b)
      {
        if (typeid (RealTimeSampleArrayValue::AnnotationType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Annotation",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Annotation",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // Samples
    //
    if (i.Samples ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Samples",
          e));

      a << *i.Samples ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RealTimeSampleArrayValue >
  _xsd_RealTimeSampleArrayValue_type_serializer_init (
    "RealTimeSampleArrayValue",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const RTValueType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const RTValueType& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const RTValueType& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RTValueType >
  _xsd_RTValueType_type_serializer_init (
    "RTValueType",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const StringMetricValue& i)
  {
    e << static_cast< const ::CDM::AbstractMetricValue& > (i);

    // Value
    //
    if (i.Value ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Value",
          e));

      a << *i.Value ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, StringMetricValue >
  _xsd_StringMetricValue_type_serializer_init (
    "StringMetricValue",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const ArgumentDescriptorType& i)
  {
    e << static_cast< const ::CDM::AbstractDescriptor& > (i);

    // ArgName
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ArgumentDescriptorType::ArgNameType& x (i.ArgName ());
      if (typeid (ArgumentDescriptorType::ArgNameType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ArgName",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ArgName",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // ArgType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ArgumentDescriptorType::ArgTypeType& x (i.ArgType ());
      if (typeid (ArgumentDescriptorType::ArgTypeType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ArgType",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ArgType",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ArgumentDescriptorType >
  _xsd_ArgumentDescriptorType_type_serializer_init (
    "ArgumentDescriptorType",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const SCODescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDeviceComponent& > (i);

    // Operation
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SCODescriptor::OperationConstIterator
           b (i.Operation ().begin ()), n (i.Operation ().end ());
           b != n; ++b)
      {
        if (typeid (SCODescriptor::OperationType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Operation",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Operation",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SCODescriptor >
  _xsd_SCODescriptor_type_serializer_init (
    "SCODescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractOperationDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDescriptor& > (i);

    // ModifiableElement
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AbstractOperationDescriptor::ModifiableElementConstIterator
           b (i.ModifiableElement ().begin ()), n (i.ModifiableElement ().end ());
           b != n; ++b)
      {
        if (typeid (AbstractOperationDescriptor::ModifiableElementType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ModifiableElement",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ModifiableElement",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // OperationTarget
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "OperationTarget",
          e));

      a << i.OperationTarget ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractOperationDescriptor >
  _xsd_AbstractOperationDescriptor_type_serializer_init (
    "AbstractOperationDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const SetValueOperationDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractOperationDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetValueOperationDescriptor >
  _xsd_SetValueOperationDescriptor_type_serializer_init (
    "SetValueOperationDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const SetStringOperationDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractOperationDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetStringOperationDescriptor >
  _xsd_SetStringOperationDescriptor_type_serializer_init (
    "SetStringOperationDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const ActivateOperationDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractOperationDescriptor& > (i);

    // Argument
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ActivateOperationDescriptor::ArgumentConstIterator
           b (i.Argument ().begin ()), n (i.Argument ().end ());
           b != n; ++b)
      {
        if (typeid (ActivateOperationDescriptor::ArgumentType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Argument",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Argument",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // ActivationDuration
    //
    if (i.ActivationDuration ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ActivationDuration",
          e));

      a << *i.ActivationDuration ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ActivateOperationDescriptor >
  _xsd_ActivateOperationDescriptor_type_serializer_init (
    "ActivateOperationDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const NonGenericOperationDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractOperationDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, NonGenericOperationDescriptor >
  _xsd_NonGenericOperationDescriptor_type_serializer_init (
    "NonGenericOperationDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const SetAlertStateOperationDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractOperationDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetAlertStateOperationDescriptor >
  _xsd_SetAlertStateOperationDescriptor_type_serializer_init (
    "SetAlertStateOperationDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const SetRangeOperationDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractOperationDescriptor& > (i);

    // AllowedMaxRange
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const SetRangeOperationDescriptor::AllowedMaxRangeType& x (i.AllowedMaxRange ());
      if (typeid (SetRangeOperationDescriptor::AllowedMaxRangeType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AllowedMaxRange",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "AllowedMaxRange",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetRangeOperationDescriptor >
  _xsd_SetRangeOperationDescriptor_type_serializer_init (
    "SetRangeOperationDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const SetContextOperationDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractOperationDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetContextOperationDescriptor >
  _xsd_SetContextOperationDescriptor_type_serializer_init (
    "SetContextOperationDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const OperatingMode& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const OperatingMode& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const OperatingMode& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OperatingMode >
  _xsd_OperatingMode_type_serializer_init (
    "OperatingMode",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const OperationState& i)
  {
    e << static_cast< const ::CDM::AbstractState& > (i);

    // OperatingMode
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "OperatingMode",
          e));

      a << i.OperatingMode ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OperationState >
  _xsd_OperationState_type_serializer_init (
    "OperationState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const SetValueOperationState& i)
  {
    e << static_cast< const ::CDM::OperationState& > (i);

    // allowedRange
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SetValueOperationState::AllowedRangeConstIterator
           b (i.allowedRange ().begin ()), n (i.allowedRange ().end ());
           b != n; ++b)
      {
        if (typeid (SetValueOperationState::AllowedRangeType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "allowedRange",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "allowedRange",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetValueOperationState >
  _xsd_SetValueOperationState_type_serializer_init (
    "SetValueOperationState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const SetRangeOperationState& i)
  {
    e << static_cast< const ::CDM::OperationState& > (i);

    // allowedRange
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SetRangeOperationState::AllowedRangeConstIterator
           b (i.allowedRange ().begin ()), n (i.allowedRange ().end ());
           b != n; ++b)
      {
        if (typeid (SetRangeOperationState::AllowedRangeType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "allowedRange",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "allowedRange",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SetRangeOperationState >
  _xsd_SetRangeOperationState_type_serializer_init (
    "SetRangeOperationState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const TimeZone& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const TimeZone& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const TimeZone& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TimeZone >
  _xsd_TimeZone_type_serializer_init (
    "TimeZone",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const ClockDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDescriptor& > (i);

    // TimeProtocol
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ClockDescriptor::TimeProtocolConstIterator
           b (i.TimeProtocol ().begin ()), n (i.TimeProtocol ().end ());
           b != n; ++b)
      {
        if (typeid (ClockDescriptor::TimeProtocolType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TimeProtocol",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "TimeProtocol",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // Resolution
    //
    if (i.Resolution ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Resolution",
          e));

      a << *i.Resolution ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ClockDescriptor >
  _xsd_ClockDescriptor_type_serializer_init (
    "ClockDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const ClockState& i)
  {
    e << static_cast< const ::CDM::AbstractState& > (i);

    // ActiveSyncProtocol
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ActiveSyncProtocol ())
      {
        const ClockState::ActiveSyncProtocolType& x (*i.ActiveSyncProtocol ());
        if (typeid (ClockState::ActiveSyncProtocolType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ActiveSyncProtocol",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ActiveSyncProtocol",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // DateAndTime
    //
    if (i.DateAndTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "DateAndTime",
          e));

      a << *i.DateAndTime ();
    }

    // RemoteSync
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "RemoteSync",
          e));

      a << i.RemoteSync ();
    }

    // ReferenceSource
    //
    if (i.ReferenceSource ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ReferenceSource",
          e));

      a << *i.ReferenceSource ();
    }

    // Accuracy
    //
    if (i.Accuracy ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Accuracy",
          e));

      a << ::xml_schema::AsDecimal(*i.Accuracy ());
    }

    // LastSet
    //
    if (i.LastSet ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "LastSet",
          e));

      a << *i.LastSet ();
    }

    // TimeZone
    //
    if (i.TimeZone ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "TimeZone",
          e));

      a << *i.TimeZone ();
    }

    // CriticalUse
    //
    if (i.CriticalUse ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "CriticalUse",
          e));

      a << *i.CriticalUse ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ClockState >
  _xsd_ClockState_type_serializer_init (
    "ClockState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractContextDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractContextDescriptor >
  _xsd_AbstractContextDescriptor_type_serializer_init (
    "AbstractContextDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const LocationContextDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractContextDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LocationContextDescriptor >
  _xsd_LocationContextDescriptor_type_serializer_init (
    "LocationContextDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const EnsembleContextDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractContextDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnsembleContextDescriptor >
  _xsd_EnsembleContextDescriptor_type_serializer_init (
    "EnsembleContextDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const OperatorContextDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractContextDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OperatorContextDescriptor >
  _xsd_OperatorContextDescriptor_type_serializer_init (
    "OperatorContextDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const WorkflowContextDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractContextDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, WorkflowContextDescriptor >
  _xsd_WorkflowContextDescriptor_type_serializer_init (
    "WorkflowContextDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractContextState& i)
  {
    e << static_cast< const ::CDM::AbstractState& > (i);

    // Validator
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AbstractContextState::ValidatorConstIterator
           b (i.Validator ().begin ()), n (i.Validator ().end ());
           b != n; ++b)
      {
        if (typeid (AbstractContextState::ValidatorType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Validator",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Validator",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // ContextAssociation
    //
    if (i.ContextAssociation ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ContextAssociation",
          e));

      a << *i.ContextAssociation ();
    }

    // BindingMDIBVersion
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "BindingMDIBVersion",
          e));

      a << i.BindingMDIBVersion ();
    }

    // UnbindingMDIBVersion
    //
    if (i.UnbindingMDIBVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "UnbindingMDIBVersion",
          e));

      a << *i.UnbindingMDIBVersion ();
    }

    // BindingStartTime
    //
    if (i.BindingStartTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "BindingStartTime",
          e));

      a << *i.BindingStartTime ();
    }

    // BindingEndTime
    //
    if (i.BindingEndTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "BindingEndTime",
          e));

      a << *i.BindingEndTime ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractContextState >
  _xsd_AbstractContextState_type_serializer_init (
    "AbstractContextState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractIdentifiableContextState& i)
  {
    e << static_cast< const ::CDM::AbstractContextState& > (i);

    // Identification
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (AbstractIdentifiableContextState::IdentificationConstIterator
           b (i.Identification ().begin ()), n (i.Identification ().end ());
           b != n; ++b)
      {
        if (typeid (AbstractIdentifiableContextState::IdentificationType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Identification",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Identification",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractIdentifiableContextState >
  _xsd_AbstractIdentifiableContextState_type_serializer_init (
    "AbstractIdentifiableContextState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const LocationContextState& i)
  {
    e << static_cast< const ::CDM::AbstractIdentifiableContextState& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LocationContextState >
  _xsd_LocationContextState_type_serializer_init (
    "LocationContextState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const EnsembleContextState& i)
  {
    e << static_cast< const ::CDM::AbstractIdentifiableContextState& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EnsembleContextState >
  _xsd_EnsembleContextState_type_serializer_init (
    "EnsembleContextState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const WorkflowContextState& i)
  {
    e << static_cast< const ::CDM::AbstractIdentifiableContextState& > (i);

    // OrderDetail
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.OrderDetail ())
      {
        const WorkflowContextState::OrderDetailType& x (*i.OrderDetail ());
        if (typeid (WorkflowContextState::OrderDetailType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OrderDetail",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "OrderDetail",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, WorkflowContextState >
  _xsd_WorkflowContextState_type_serializer_init (
    "WorkflowContextState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const OperatorContextState& i)
  {
    e << static_cast< const ::CDM::AbstractIdentifiableContextState& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OperatorContextState >
  _xsd_OperatorContextState_type_serializer_init (
    "OperatorContextState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const ContextAssociation& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ContextAssociation& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const ContextAssociation& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ContextAssociation >
  _xsd_ContextAssociation_type_serializer_init (
    "ContextAssociation",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const PatientContextDescriptor& i)
  {
    e << static_cast< const ::CDM::AbstractContextDescriptor& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PatientContextDescriptor >
  _xsd_PatientContextDescriptor_type_serializer_init (
    "PatientContextDescriptor",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const BaseDemographics& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // Givenname
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Givenname ())
      {
        const BaseDemographics::GivennameType& x (*i.Givenname ());
        if (typeid (BaseDemographics::GivennameType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Givenname",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Givenname",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // Middlename
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (BaseDemographics::MiddlenameConstIterator
           b (i.Middlename ().begin ()), n (i.Middlename ().end ());
           b != n; ++b)
      {
        if (typeid (BaseDemographics::MiddlenameType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Middlename",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Middlename",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // Familyname
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Familyname ())
      {
        const BaseDemographics::FamilynameType& x (*i.Familyname ());
        if (typeid (BaseDemographics::FamilynameType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Familyname",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Familyname",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // Birthname
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Birthname ())
      {
        const BaseDemographics::BirthnameType& x (*i.Birthname ());
        if (typeid (BaseDemographics::BirthnameType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Birthname",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Birthname",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // Title
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Title ())
      {
        const BaseDemographics::TitleType& x (*i.Title ());
        if (typeid (BaseDemographics::TitleType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Title",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Title",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BaseDemographics >
  _xsd_BaseDemographics_type_serializer_init (
    "BaseDemographics",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const PatientDemographicsCoreData& i)
  {
    e << static_cast< const ::CDM::BaseDemographics& > (i);

    // Sex
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Sex ())
      {
        const PatientDemographicsCoreData::SexType& x (*i.Sex ());
        if (typeid (PatientDemographicsCoreData::SexType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Sex",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Sex",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // PatientType
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.PatientType ())
      {
        const PatientDemographicsCoreData::PatientTypeType& x (*i.PatientType ());
        if (typeid (PatientDemographicsCoreData::PatientTypeType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PatientType",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "PatientType",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // DateOfBirth
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DateOfBirth ())
      {
        const PatientDemographicsCoreData::DateOfBirthType& x (*i.DateOfBirth ());
        if (typeid (PatientDemographicsCoreData::DateOfBirthType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DateOfBirth",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DateOfBirth",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // Height
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Height ())
      {
        const PatientDemographicsCoreData::HeightType& x (*i.Height ());
        if (typeid (PatientDemographicsCoreData::HeightType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Height",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Height",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // Weight
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Weight ())
      {
        const PatientDemographicsCoreData::WeightType& x (*i.Weight ());
        if (typeid (PatientDemographicsCoreData::WeightType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Weight",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Weight",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // Race
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Race ())
      {
        const PatientDemographicsCoreData::RaceType& x (*i.Race ());
        if (typeid (PatientDemographicsCoreData::RaceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Race",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Race",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PatientDemographicsCoreData >
  _xsd_PatientDemographicsCoreData_type_serializer_init (
    "PatientDemographicsCoreData",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const PersonReference& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // Identification
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (PersonReference::IdentificationConstIterator
           b (i.Identification ().begin ()), n (i.Identification ().end ());
           b != n; ++b)
      {
        if (typeid (PersonReference::IdentificationType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Identification",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Identification",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // Name
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (PersonReference::NameConstIterator
           b (i.Name ().begin ()), n (i.Name ().end ());
           b != n; ++b)
      {
        if (typeid (PersonReference::NameType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Name",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Name",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PersonReference >
  _xsd_PersonReference_type_serializer_init (
    "PersonReference",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const PersonParticipation& i)
  {
    e << static_cast< const ::CDM::PersonReference& > (i);

    // Role
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (PersonParticipation::RoleConstIterator
           b (i.Role ().begin ()), n (i.Role ().end ());
           b != n; ++b)
      {
        if (typeid (PersonParticipation::RoleType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Role",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Role",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PersonParticipation >
  _xsd_PersonParticipation_type_serializer_init (
    "PersonParticipation",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const NeonatalPatientDemographicsCoreData& i)
  {
    e << static_cast< const ::CDM::PatientDemographicsCoreData& > (i);

    // Gestational-Age
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Gestational_Age ())
      {
        const NeonatalPatientDemographicsCoreData::Gestational_AgeType& x (*i.Gestational_Age ());
        if (typeid (NeonatalPatientDemographicsCoreData::Gestational_AgeType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Gestational-Age",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Gestational-Age",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // BirthLength
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.BirthLength ())
      {
        const NeonatalPatientDemographicsCoreData::BirthLengthType& x (*i.BirthLength ());
        if (typeid (NeonatalPatientDemographicsCoreData::BirthLengthType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "BirthLength",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "BirthLength",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // BirthWeight
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.BirthWeight ())
      {
        const NeonatalPatientDemographicsCoreData::BirthWeightType& x (*i.BirthWeight ());
        if (typeid (NeonatalPatientDemographicsCoreData::BirthWeightType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "BirthWeight",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "BirthWeight",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // HeadCircumference
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.HeadCircumference ())
      {
        const NeonatalPatientDemographicsCoreData::HeadCircumferenceType& x (*i.HeadCircumference ());
        if (typeid (NeonatalPatientDemographicsCoreData::HeadCircumferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "HeadCircumference",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "HeadCircumference",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // Mother
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Mother ())
      {
        const NeonatalPatientDemographicsCoreData::MotherType& x (*i.Mother ());
        if (typeid (NeonatalPatientDemographicsCoreData::MotherType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Mother",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Mother",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, NeonatalPatientDemographicsCoreData >
  _xsd_NeonatalPatientDemographicsCoreData_type_serializer_init (
    "NeonatalPatientDemographicsCoreData",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const PatientContextState& i)
  {
    e << static_cast< const ::CDM::AbstractIdentifiableContextState& > (i);

    // CoreData
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.CoreData ())
      {
        const PatientContextState::CoreDataType& x (*i.CoreData ());
        if (typeid (PatientContextState::CoreDataType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CoreData",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CoreData",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PatientContextState >
  _xsd_PatientContextState_type_serializer_init (
    "PatientContextState",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const Sex& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Sex& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Sex& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Sex >
  _xsd_Sex_type_serializer_init (
    "Sex",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const PatientType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const PatientType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const PatientType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PatientType >
  _xsd_PatientType_type_serializer_init (
    "PatientType",
    "http://domain-model-uri/15/04");


  void
  MetricCategory_ (::std::ostream& o,
                   const ::CDM::MetricCategory& s,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MetricCategory_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  MetricCategory_ (::std::ostream& o,
                   const ::CDM::MetricCategory& s,
                   ::xml_schema::ErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MetricCategory_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MetricCategory_ (::std::ostream& o,
                   const ::CDM::MetricCategory& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MetricCategory_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MetricCategory_ (::xercesc::XMLFormatTarget& t,
                   const ::CDM::MetricCategory& s,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MetricCategory_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  MetricCategory_ (::xercesc::XMLFormatTarget& t,
                   const ::CDM::MetricCategory& s,
                   ::xml_schema::ErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MetricCategory_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MetricCategory_ (::xercesc::XMLFormatTarget& t,
                   const ::CDM::MetricCategory& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MetricCategory_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MetricCategory_ (::xercesc::DOMDocument& d,
                   const ::CDM::MetricCategory& s,
                   ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (typeid (::CDM::MetricCategory) == typeid (s))
    {
      if (n.name () == "MetricCategory" &&
          n.namespace_ () == "http://domain-model-uri/15/04")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "MetricCategory",
          "http://domain-model-uri/15/04");
      }
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "MetricCategory",
        "http://domain-model-uri/15/04",
        e, n, s);
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  MetricCategory_ (const ::CDM::MetricCategory& s,
                   const ::xml_schema::NamespaceInfomap& m,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

    if (typeid (::CDM::MetricCategory) == typeid (s))
    {
      d = ::xsd::cxx::xml::dom::serialize< char > (
        "MetricCategory",
        "http://domain-model-uri/15/04",
        m, f);
    }
    else
    {
      d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "MetricCategory",
        "http://domain-model-uri/15/04",
        m, s, f);
    }

    ::CDM::MetricCategory_ (*d, s, f);
    return d;
  }

  void
  Availability (::std::ostream& o,
                const ::CDM::MetricAvailability& s,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Availability (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  Availability (::std::ostream& o,
                const ::CDM::MetricAvailability& s,
                ::xml_schema::ErrorHandler& h,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Availability (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Availability (::std::ostream& o,
                const ::CDM::MetricAvailability& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Availability (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Availability (::xercesc::XMLFormatTarget& t,
                const ::CDM::MetricAvailability& s,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Availability (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  Availability (::xercesc::XMLFormatTarget& t,
                const ::CDM::MetricAvailability& s,
                ::xml_schema::ErrorHandler& h,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Availability (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Availability (::xercesc::XMLFormatTarget& t,
                const ::CDM::MetricAvailability& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::NamespaceInfomap& m,
                const ::std::string& e,
                ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::Availability (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Availability (::xercesc::DOMDocument& d,
                const ::CDM::MetricAvailability& s,
                ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (typeid (::CDM::MetricAvailability) == typeid (s))
    {
      if (n.name () == "Availability" &&
          n.namespace_ () == "http://domain-model-uri/15/04")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "Availability",
          "http://domain-model-uri/15/04");
      }
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "Availability",
        "http://domain-model-uri/15/04",
        e, n, s);
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  Availability (const ::CDM::MetricAvailability& s,
                const ::xml_schema::NamespaceInfomap& m,
                ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

    if (typeid (::CDM::MetricAvailability) == typeid (s))
    {
      d = ::xsd::cxx::xml::dom::serialize< char > (
        "Availability",
        "http://domain-model-uri/15/04",
        m, f);
    }
    else
    {
      d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "Availability",
        "http://domain-model-uri/15/04",
        m, s, f);
    }

    ::CDM::Availability (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const ContainmentTree& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // Entry
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ContainmentTree::EntryConstIterator
           b (i.Entry ().begin ()), n (i.Entry ().end ());
           b != n; ++b)
      {
        if (typeid (ContainmentTree::EntryType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Entry",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Entry",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // HandleRef
    //
    if (i.HandleRef ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "HandleRef",
          e));

      a << *i.HandleRef ();
    }

    // ParentHandleRef
    //
    if (i.ParentHandleRef ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ParentHandleRef",
          e));

      a << *i.ParentHandleRef ();
    }

    // EntryType
    //
    if (i.EntryType1 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "EntryType",
          e));

      a << *i.EntryType1 ();
    }

    // ChildrenCount
    //
    if (i.ChildrenCount ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ChildrenCount",
          e));

      a << *i.ChildrenCount ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ContainmentTree >
  _xsd_ContainmentTree_type_serializer_init (
    "ContainmentTree",
    "http://domain-model-uri/15/04");


  void
  MDIBContainmentTree_ (::std::ostream& o,
                        const ::CDM::MDIBContainmentTree& s,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MDIBContainmentTree_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  MDIBContainmentTree_ (::std::ostream& o,
                        const ::CDM::MDIBContainmentTree& s,
                        ::xml_schema::ErrorHandler& h,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MDIBContainmentTree_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MDIBContainmentTree_ (::std::ostream& o,
                        const ::CDM::MDIBContainmentTree& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MDIBContainmentTree_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MDIBContainmentTree_ (::xercesc::XMLFormatTarget& t,
                        const ::CDM::MDIBContainmentTree& s,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MDIBContainmentTree_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  MDIBContainmentTree_ (::xercesc::XMLFormatTarget& t,
                        const ::CDM::MDIBContainmentTree& s,
                        ::xml_schema::ErrorHandler& h,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MDIBContainmentTree_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MDIBContainmentTree_ (::xercesc::XMLFormatTarget& t,
                        const ::CDM::MDIBContainmentTree& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MDIBContainmentTree_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MDIBContainmentTree_ (::xercesc::DOMDocument& d,
                        const ::CDM::MDIBContainmentTree& s,
                        ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "MDIBContainmentTree" &&
        n.namespace_ () == "http://domain-model-uri/15/04")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "MDIBContainmentTree",
        "http://domain-model-uri/15/04");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  MDIBContainmentTree_ (const ::CDM::MDIBContainmentTree& s,
                        const ::xml_schema::NamespaceInfomap& m,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "MDIBContainmentTree",
        "http://domain-model-uri/15/04",
        m, f));

    ::CDM::MDIBContainmentTree_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const ContainmentTreeEntry& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // Type
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Type ())
      {
        const ContainmentTreeEntry::TypeType& x (*i.Type ());
        if (typeid (ContainmentTreeEntry::TypeType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Type",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Type",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // HandleRef
    //
    if (i.HandleRef ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "HandleRef",
          e));

      a << *i.HandleRef ();
    }

    // ParentHandleRef
    //
    if (i.ParentHandleRef ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ParentHandleRef",
          e));

      a << *i.ParentHandleRef ();
    }

    // EntryType
    //
    if (i.EntryType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "EntryType",
          e));

      a << *i.EntryType ();
    }

    // ChildrenCount
    //
    if (i.ChildrenCount ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ChildrenCount",
          e));

      a << *i.ChildrenCount ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ContainmentTreeEntry >
  _xsd_ContainmentTreeEntry_type_serializer_init (
    "ContainmentTreeEntry",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const ClinicalInfo& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // Type
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ClinicalInfo::TypeType& x (i.Type ());
      if (typeid (ClinicalInfo::TypeType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Type",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Type",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // RelatedMeasurement
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ClinicalInfo::RelatedMeasurementConstIterator
           b (i.RelatedMeasurement ().begin ()), n (i.RelatedMeasurement ().end ());
           b != n; ++b)
      {
        if (typeid (ClinicalInfo::RelatedMeasurementType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "RelatedMeasurement",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "RelatedMeasurement",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // MeasuredValue
    //
    if (i.MeasuredValue ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MeasuredValue",
          e));

      a << ::xml_schema::AsDecimal(*i.MeasuredValue ());
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ClinicalInfo >
  _xsd_ClinicalInfo_type_serializer_init (
    "ClinicalInfo",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const Order& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // VisitNumber
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.VisitNumber ())
      {
        const Order::VisitNumberType& x (*i.VisitNumber ());
        if (typeid (Order::VisitNumberType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "VisitNumber",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "VisitNumber",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // PlacerOrderNumber
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const Order::PlacerOrderNumberType& x (i.PlacerOrderNumber ());
      if (typeid (Order::PlacerOrderNumberType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PlacerOrderNumber",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "PlacerOrderNumber",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // FillerOrderNumber
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.FillerOrderNumber ())
      {
        const Order::FillerOrderNumberType& x (*i.FillerOrderNumber ());
        if (typeid (Order::FillerOrderNumberType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "FillerOrderNumber",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "FillerOrderNumber",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // Patient
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const Order::PatientType& x (i.Patient ());
      if (typeid (Order::PatientType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Patient",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Patient",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // ReferringPhysician
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ReferringPhysician ())
      {
        const Order::ReferringPhysicianType& x (*i.ReferringPhysician ());
        if (typeid (Order::ReferringPhysicianType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ReferringPhysician",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ReferringPhysician",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // RequestingPhysician
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.RequestingPhysician ())
      {
        const Order::RequestingPhysicianType& x (*i.RequestingPhysician ());
        if (typeid (Order::RequestingPhysicianType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "RequestingPhysician",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "RequestingPhysician",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // Reason
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (Order::ReasonConstIterator
           b (i.Reason ().begin ()), n (i.Reason ().end ());
           b != n; ++b)
      {
        if (typeid (Order::ReasonType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Reason",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Reason",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // DangerCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (Order::DangerCodeConstIterator
           b (i.DangerCode ().begin ()), n (i.DangerCode ().end ());
           b != n; ++b)
      {
        if (typeid (Order::DangerCodeType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DangerCode",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "DangerCode",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // RelevantClinicalInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (Order::RelevantClinicalInfoConstIterator
           b (i.RelevantClinicalInfo ().begin ()), n (i.RelevantClinicalInfo ().end ());
           b != n; ++b)
      {
        if (typeid (Order::RelevantClinicalInfoType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "RelevantClinicalInfo",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "RelevantClinicalInfo",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // ImagingProcedure
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (Order::ImagingProcedureConstIterator
           b (i.ImagingProcedure ().begin ()), n (i.ImagingProcedure ().end ());
           b != n; ++b)
      {
        if (typeid (Order::ImagingProcedureType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ImagingProcedure",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ImagingProcedure",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // RequestedOrderDetail
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.RequestedOrderDetail ())
      {
        const Order::RequestedOrderDetailType& x (*i.RequestedOrderDetail ());
        if (typeid (Order::RequestedOrderDetailType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "RequestedOrderDetail",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "RequestedOrderDetail",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // PerformedOrderDetail
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.PerformedOrderDetail ())
      {
        const Order::PerformedOrderDetailType& x (*i.PerformedOrderDetail ());
        if (typeid (Order::PerformedOrderDetailType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PerformedOrderDetail",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "PerformedOrderDetail",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Order >
  _xsd_Order_type_serializer_init (
    "Order",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const OrderDetail& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // Start
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Start ())
      {
        const OrderDetail::StartType& x (*i.Start ());
        if (typeid (OrderDetail::StartType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Start",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Start",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // End
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.End ())
      {
        const OrderDetail::EndType& x (*i.End ());
        if (typeid (OrderDetail::EndType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "End",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "End",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // Performer
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (OrderDetail::PerformerConstIterator
           b (i.Performer ().begin ()), n (i.Performer ().end ());
           b != n; ++b)
      {
        if (typeid (OrderDetail::PerformerType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Performer",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Performer",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }

    // Service
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (OrderDetail::ServiceConstIterator
           b (i.Service ().begin ()), n (i.Service ().end ());
           b != n; ++b)
      {
        if (typeid (OrderDetail::ServiceType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Service",
              "http://domain-model-uri/15/04",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Service",
            "http://domain-model-uri/15/04",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OrderDetail >
  _xsd_OrderDetail_type_serializer_init (
    "OrderDetail",
    "http://domain-model-uri/15/04");


  void
  operator<< (::xercesc::DOMElement& e, const ImagingProcedure& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    if (i.Extension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Extension",
          "http://extension-point-uri/15/03",
          e));

      s << *i.Extension ();
    }

    // AccessionIdentifier
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ImagingProcedure::AccessionIdentifierType& x (i.AccessionIdentifier ());
      if (typeid (ImagingProcedure::AccessionIdentifierType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AccessionIdentifier",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "AccessionIdentifier",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // RequestedProcedureID
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ImagingProcedure::RequestedProcedureIDType& x (i.RequestedProcedureID ());
      if (typeid (ImagingProcedure::RequestedProcedureIDType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RequestedProcedureID",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "RequestedProcedureID",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // StudyInstanceUID
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ImagingProcedure::StudyInstanceUIDType& x (i.StudyInstanceUID ());
      if (typeid (ImagingProcedure::StudyInstanceUIDType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "StudyInstanceUID",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "StudyInstanceUID",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // ScheduledProcedureStepID
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ImagingProcedure::ScheduledProcedureStepIDType& x (i.ScheduledProcedureStepID ());
      if (typeid (ImagingProcedure::ScheduledProcedureStepIDType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ScheduledProcedureStepID",
            "http://domain-model-uri/15/04",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ScheduledProcedureStepID",
          "http://domain-model-uri/15/04",
          false, true, e, x);
    }

    // Modality
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Modality ())
      {
        const ImagingProcedure::ModalityType& x (*i.Modality ());
        if (typeid (ImagingProcedure::ModalityType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Modality",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Modality",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }

    // ProtocolCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ProtocolCode ())
      {
        const ImagingProcedure::ProtocolCodeType& x (*i.ProtocolCode ());
        if (typeid (ImagingProcedure::ProtocolCodeType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ProtocolCode",
              "http://domain-model-uri/15/04",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ProtocolCode",
            "http://domain-model-uri/15/04",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ImagingProcedure >
  _xsd_ImagingProcedure_type_serializer_init (
    "ImagingProcedure",
    "http://domain-model-uri/15/04");


  void
  MDIBContainer (::std::ostream& o,
                 const ::CDM::MDIB& s,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MDIBContainer (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  MDIBContainer (::std::ostream& o,
                 const ::CDM::MDIB& s,
                 ::xml_schema::ErrorHandler& h,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MDIBContainer (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MDIBContainer (::std::ostream& o,
                 const ::CDM::MDIB& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MDIBContainer (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MDIBContainer (::xercesc::XMLFormatTarget& t,
                 const ::CDM::MDIB& s,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MDIBContainer (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  MDIBContainer (::xercesc::XMLFormatTarget& t,
                 const ::CDM::MDIB& s,
                 ::xml_schema::ErrorHandler& h,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MDIBContainer (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MDIBContainer (::xercesc::XMLFormatTarget& t,
                 const ::CDM::MDIB& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::CDM::MDIBContainer (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  MDIBContainer (::xercesc::DOMDocument& d,
                 const ::CDM::MDIB& s,
                 ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (typeid (::CDM::MDIB) == typeid (s))
    {
      if (n.name () == "MDIBContainer" &&
          n.namespace_ () == "http://domain-model-uri/15/04")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "MDIBContainer",
          "http://domain-model-uri/15/04");
      }
    }
    else
    {
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "MDIBContainer",
        "http://domain-model-uri/15/04",
        e, n, s);
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  MDIBContainer (const ::CDM::MDIB& s,
                 const ::xml_schema::NamespaceInfomap& m,
                 ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

    if (typeid (::CDM::MDIB) == typeid (s))
    {
      d = ::xsd::cxx::xml::dom::serialize< char > (
        "MDIBContainer",
        "http://domain-model-uri/15/04",
        m, f);
    }
    else
    {
      d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
        "MDIBContainer",
        "http://domain-model-uri/15/04",
        m, s, f);
    }

    ::CDM::MDIBContainer (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const MDIBContainmentTree& i)
  {
    e << static_cast< const ::CDM::ContainmentTree& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

