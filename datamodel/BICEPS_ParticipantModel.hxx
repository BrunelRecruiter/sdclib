// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef BICEPS_PARTICIPANT_MODEL_HXX
#define BICEPS_PARTICIPANT_MODEL_HXX

#include "BICEPS_ParticipantModel-fwd.hxx"

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "ExtensionPoint.hxx"

namespace CDM
{
  class Mdib: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // MdDescription
    //
    typedef ::CDM::MdDescription MdDescriptionType;
    typedef ::xsd::cxx::tree::optional< MdDescriptionType > MdDescriptionOptional;
    typedef ::xsd::cxx::tree::traits< MdDescriptionType, char > MdDescriptionTraits;

    const MdDescriptionOptional&
    MdDescription () const;

    MdDescriptionOptional&
    MdDescription ();

    void
    MdDescription (const MdDescriptionType& x);

    void
    MdDescription (const MdDescriptionOptional& x);

    void
    MdDescription (::std::unique_ptr< MdDescriptionType > p);

    // MdState
    //
    typedef ::CDM::MdState MdStateType;
    typedef ::xsd::cxx::tree::optional< MdStateType > MdStateOptional;
    typedef ::xsd::cxx::tree::traits< MdStateType, char > MdStateTraits;

    const MdStateOptional&
    MdState () const;

    MdStateOptional&
    MdState ();

    void
    MdState (const MdStateType& x);

    void
    MdState (const MdStateOptional& x);

    void
    MdState (::std::unique_ptr< MdStateType > p);

    // MdibVersion
    //
    typedef ::CDM::VersionCounter MdibVersionType;
    typedef ::xsd::cxx::tree::optional< MdibVersionType > MdibVersionOptional;
    typedef ::xsd::cxx::tree::traits< MdibVersionType, char > MdibVersionTraits;

    const MdibVersionOptional&
    MdibVersion () const;

    MdibVersionOptional&
    MdibVersion ();

    void
    MdibVersion (const MdibVersionType& x);

    void
    MdibVersion (const MdibVersionOptional& x);

    void
    MdibVersion (::std::unique_ptr< MdibVersionType > p);

    // SequenceId
    //
    typedef ::xml_schema::Uri SequenceIdType;
    typedef ::xsd::cxx::tree::traits< SequenceIdType, char > SequenceIdTraits;

    const SequenceIdType&
    SequenceId () const;

    SequenceIdType&
    SequenceId ();

    void
    SequenceId (const SequenceIdType& x);

    void
    SequenceId (::std::unique_ptr< SequenceIdType > p);

    // InstanceId
    //
    typedef ::xml_schema::UnsignedLong InstanceIdType;
    typedef ::xsd::cxx::tree::optional< InstanceIdType > InstanceIdOptional;
    typedef ::xsd::cxx::tree::traits< InstanceIdType, char > InstanceIdTraits;

    const InstanceIdOptional&
    InstanceId () const;

    InstanceIdOptional&
    InstanceId ();

    void
    InstanceId (const InstanceIdType& x);

    void
    InstanceId (const InstanceIdOptional& x);

    // Constructors.
    //
    Mdib (const SequenceIdType&);

    Mdib (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    Mdib (const Mdib& x,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    virtual Mdib*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Mdib&
    operator= (const Mdib& x);

    virtual 
    ~Mdib ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    MdDescriptionOptional MdDescription_;
    MdStateOptional MdState_;
    MdibVersionOptional MdibVersion_;
    ::xsd::cxx::tree::one< SequenceIdType > SequenceId_;
    InstanceIdOptional InstanceId_;
  };

  class MdDescription: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Mds
    //
    typedef ::CDM::MdsDescriptor MdsType;
    typedef ::xsd::cxx::tree::sequence< MdsType > MdsSequence;
    typedef MdsSequence::iterator MdsIterator;
    typedef MdsSequence::const_iterator MdsConstIterator;
    typedef ::xsd::cxx::tree::traits< MdsType, char > MdsTraits;

    const MdsSequence&
    Mds () const;

    MdsSequence&
    Mds ();

    void
    Mds (const MdsSequence& s);

    // DescriptionVersion
    //
    typedef ::CDM::VersionCounter DescriptionVersionType;
    typedef ::xsd::cxx::tree::optional< DescriptionVersionType > DescriptionVersionOptional;
    typedef ::xsd::cxx::tree::traits< DescriptionVersionType, char > DescriptionVersionTraits;

    const DescriptionVersionOptional&
    DescriptionVersion () const;

    DescriptionVersionOptional&
    DescriptionVersion ();

    void
    DescriptionVersion (const DescriptionVersionType& x);

    void
    DescriptionVersion (const DescriptionVersionOptional& x);

    void
    DescriptionVersion (::std::unique_ptr< DescriptionVersionType > p);

    // Constructors.
    //
    MdDescription ();

    MdDescription (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    MdDescription (const MdDescription& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual MdDescription*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MdDescription&
    operator= (const MdDescription& x);

    virtual 
    ~MdDescription ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    MdsSequence Mds_;
    DescriptionVersionOptional DescriptionVersion_;
  };

  class MdState: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // State
    //
    typedef ::CDM::AbstractState StateType;
    typedef ::xsd::cxx::tree::sequence< StateType > StateSequence;
    typedef StateSequence::iterator StateIterator;
    typedef StateSequence::const_iterator StateConstIterator;
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    const StateSequence&
    State () const;

    StateSequence&
    State ();

    void
    State (const StateSequence& s);

    // StateVersion
    //
    typedef ::CDM::VersionCounter StateVersionType;
    typedef ::xsd::cxx::tree::optional< StateVersionType > StateVersionOptional;
    typedef ::xsd::cxx::tree::traits< StateVersionType, char > StateVersionTraits;

    const StateVersionOptional&
    StateVersion () const;

    StateVersionOptional&
    StateVersion ();

    void
    StateVersion (const StateVersionType& x);

    void
    StateVersion (const StateVersionOptional& x);

    void
    StateVersion (::std::unique_ptr< StateVersionType > p);

    // Constructors.
    //
    MdState ();

    MdState (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    MdState (const MdState& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    virtual MdState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MdState&
    operator= (const MdState& x);

    virtual 
    ~MdState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    StateSequence State_;
    StateVersionOptional StateVersion_;
  };

  class MeasurementValidity: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Vld,
      Vldated,
      Ong,
      Qst,
      Calib,
      Inv,
      Oflw,
      Uflw,
      NA
    };

    MeasurementValidity (Value v);

    MeasurementValidity (const char* v);

    MeasurementValidity (const ::std::string& v);

    MeasurementValidity (const ::xml_schema::String& v);

    MeasurementValidity (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    MeasurementValidity (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    MeasurementValidity (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    MeasurementValidity (const MeasurementValidity& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual MeasurementValidity*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MeasurementValidity&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_MeasurementValidity_convert ();
    }

    protected:
    Value
    _xsd_MeasurementValidity_convert () const;

    public:
    static const char* const _xsd_MeasurementValidity_literals_[9];
    static const Value _xsd_MeasurementValidity_indexes_[9];
  };

  class Timestamp: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >
  {
    public:
    // Constructors.
    //
    Timestamp (const ::xml_schema::UnsignedLong&);

    Timestamp (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    Timestamp (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    Timestamp (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    Timestamp (const Timestamp& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    virtual Timestamp*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~Timestamp ();
  };

  class VersionCounter: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >
  {
    public:
    // Constructors.
    //
    VersionCounter (const ::xml_schema::UnsignedLong&);

    VersionCounter (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    VersionCounter (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    VersionCounter (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    VersionCounter (const VersionCounter& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual VersionCounter*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~VersionCounter ();
  };

  class ReferencedVersion: public ::CDM::VersionCounter
  {
    public:
    // Constructors.
    //
    ReferencedVersion (const ::xml_schema::UnsignedLong&);

    ReferencedVersion (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    ReferencedVersion (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    ReferencedVersion (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    ReferencedVersion (const ReferencedVersion& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual ReferencedVersion*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~ReferencedVersion ();
  };

  class CodeIdentifier: public ::xml_schema::String
  {
    public:
    // Constructors.
    //
    CodeIdentifier ();

    CodeIdentifier (const char*);

    CodeIdentifier (const ::std::string&);

    CodeIdentifier (const ::xml_schema::String&);

    CodeIdentifier (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    CodeIdentifier (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    CodeIdentifier (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    CodeIdentifier (const CodeIdentifier& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual CodeIdentifier*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~CodeIdentifier ();
  };

  class SymbolicCodeName: public ::xml_schema::String
  {
    public:
    // Constructors.
    //
    SymbolicCodeName ();

    SymbolicCodeName (const char*);

    SymbolicCodeName (const ::std::string&);

    SymbolicCodeName (const ::xml_schema::String&);

    SymbolicCodeName (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    SymbolicCodeName (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    SymbolicCodeName (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    SymbolicCodeName (const SymbolicCodeName& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual SymbolicCodeName*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~SymbolicCodeName ();
  };

  class LocalizedTextRef: public ::xml_schema::String
  {
    public:
    // Constructors.
    //
    LocalizedTextRef ();

    LocalizedTextRef (const char*);

    LocalizedTextRef (const ::std::string&);

    LocalizedTextRef (const ::xml_schema::String&);

    LocalizedTextRef (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    LocalizedTextRef (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    LocalizedTextRef (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    LocalizedTextRef (const LocalizedTextRef& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual LocalizedTextRef*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~LocalizedTextRef ();
  };

  class LocalizedText: public ::xml_schema::String
  {
    public:
    // Ref
    //
    typedef ::CDM::LocalizedTextRef RefType;
    typedef ::xsd::cxx::tree::optional< RefType > RefOptional;
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    const RefOptional&
    Ref () const;

    RefOptional&
    Ref ();

    void
    Ref (const RefType& x);

    void
    Ref (const RefOptional& x);

    void
    Ref (::std::unique_ptr< RefType > p);

    // Lang
    //
    typedef ::xml_schema::Language LangType;
    typedef ::xsd::cxx::tree::optional< LangType > LangOptional;
    typedef ::xsd::cxx::tree::traits< LangType, char > LangTraits;

    const LangOptional&
    Lang () const;

    LangOptional&
    Lang ();

    void
    Lang (const LangType& x);

    void
    Lang (const LangOptional& x);

    void
    Lang (::std::unique_ptr< LangType > p);

    // Version
    //
    typedef ::CDM::ReferencedVersion VersionType;
    typedef ::xsd::cxx::tree::optional< VersionType > VersionOptional;
    typedef ::xsd::cxx::tree::traits< VersionType, char > VersionTraits;

    const VersionOptional&
    Version () const;

    VersionOptional&
    Version ();

    void
    Version (const VersionType& x);

    void
    Version (const VersionOptional& x);

    void
    Version (::std::unique_ptr< VersionType > p);

    // Constructors.
    //
    LocalizedText ();

    LocalizedText (const char*);

    LocalizedText (const ::std::string&);

    LocalizedText (const ::xml_schema::String&);

    LocalizedText (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    LocalizedText (const LocalizedText& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual LocalizedText*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    LocalizedText&
    operator= (const LocalizedText& x);

    virtual 
    ~LocalizedText ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    RefOptional Ref_;
    LangOptional Lang_;
    VersionOptional Version_;
  };

  class CodedValue: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // CodingSystemName
    //
    typedef ::CDM::LocalizedText CodingSystemNameType;
    typedef ::xsd::cxx::tree::sequence< CodingSystemNameType > CodingSystemNameSequence;
    typedef CodingSystemNameSequence::iterator CodingSystemNameIterator;
    typedef CodingSystemNameSequence::const_iterator CodingSystemNameConstIterator;
    typedef ::xsd::cxx::tree::traits< CodingSystemNameType, char > CodingSystemNameTraits;

    const CodingSystemNameSequence&
    CodingSystemName () const;

    CodingSystemNameSequence&
    CodingSystemName ();

    void
    CodingSystemName (const CodingSystemNameSequence& s);

    // ConceptDescription
    //
    typedef ::CDM::LocalizedText ConceptDescriptionType;
    typedef ::xsd::cxx::tree::sequence< ConceptDescriptionType > ConceptDescriptionSequence;
    typedef ConceptDescriptionSequence::iterator ConceptDescriptionIterator;
    typedef ConceptDescriptionSequence::const_iterator ConceptDescriptionConstIterator;
    typedef ::xsd::cxx::tree::traits< ConceptDescriptionType, char > ConceptDescriptionTraits;

    const ConceptDescriptionSequence&
    ConceptDescription () const;

    ConceptDescriptionSequence&
    ConceptDescription ();

    void
    ConceptDescription (const ConceptDescriptionSequence& s);

    // Translation
    //
    typedef ::CDM::CodedValue TranslationType;
    typedef ::xsd::cxx::tree::sequence< TranslationType > TranslationSequence;
    typedef TranslationSequence::iterator TranslationIterator;
    typedef TranslationSequence::const_iterator TranslationConstIterator;
    typedef ::xsd::cxx::tree::traits< TranslationType, char > TranslationTraits;

    const TranslationSequence&
    Translation () const;

    TranslationSequence&
    Translation ();

    void
    Translation (const TranslationSequence& s);

    // Code
    //
    typedef ::CDM::CodeIdentifier CodeType;
    typedef ::xsd::cxx::tree::traits< CodeType, char > CodeTraits;

    const CodeType&
    Code () const;

    CodeType&
    Code ();

    void
    Code (const CodeType& x);

    void
    Code (::std::unique_ptr< CodeType > p);

    // CodingSystem
    //
    typedef ::xml_schema::Uri CodingSystemType;
    typedef ::xsd::cxx::tree::optional< CodingSystemType > CodingSystemOptional;
    typedef ::xsd::cxx::tree::traits< CodingSystemType, char > CodingSystemTraits;

    const CodingSystemOptional&
    CodingSystem () const;

    CodingSystemOptional&
    CodingSystem ();

    void
    CodingSystem (const CodingSystemType& x);

    void
    CodingSystem (const CodingSystemOptional& x);

    void
    CodingSystem (::std::unique_ptr< CodingSystemType > p);

    // CodingSystemVersion
    //
    typedef ::xml_schema::String CodingSystemVersionType;
    typedef ::xsd::cxx::tree::optional< CodingSystemVersionType > CodingSystemVersionOptional;
    typedef ::xsd::cxx::tree::traits< CodingSystemVersionType, char > CodingSystemVersionTraits;

    const CodingSystemVersionOptional&
    CodingSystemVersion () const;

    CodingSystemVersionOptional&
    CodingSystemVersion ();

    void
    CodingSystemVersion (const CodingSystemVersionType& x);

    void
    CodingSystemVersion (const CodingSystemVersionOptional& x);

    void
    CodingSystemVersion (::std::unique_ptr< CodingSystemVersionType > p);

    // SymbolicCodeName
    //
    typedef ::CDM::SymbolicCodeName SymbolicCodeNameType;
    typedef ::xsd::cxx::tree::optional< SymbolicCodeNameType > SymbolicCodeNameOptional;
    typedef ::xsd::cxx::tree::traits< SymbolicCodeNameType, char > SymbolicCodeNameTraits;

    const SymbolicCodeNameOptional&
    SymbolicCodeName () const;

    SymbolicCodeNameOptional&
    SymbolicCodeName ();

    void
    SymbolicCodeName (const SymbolicCodeNameType& x);

    void
    SymbolicCodeName (const SymbolicCodeNameOptional& x);

    void
    SymbolicCodeName (::std::unique_ptr< SymbolicCodeNameType > p);

    // Constructors.
    //
    CodedValue (const CodeType&);

    CodedValue (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    CodedValue (const CodedValue& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual CodedValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CodedValue&
    operator= (const CodedValue& x);

    virtual 
    ~CodedValue ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    CodingSystemNameSequence CodingSystemName_;
    ConceptDescriptionSequence ConceptDescription_;
    TranslationSequence Translation_;
    ::xsd::cxx::tree::one< CodeType > Code_;
    CodingSystemOptional CodingSystem_;
    CodingSystemVersionOptional CodingSystemVersion_;
    SymbolicCodeNameOptional SymbolicCodeName_;
  };

  class InstanceIdentifier: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Type
    //
    typedef ::CDM::CodedValue TypeType;
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeOptional&
    Type () const;

    TypeOptional&
    Type ();

    void
    Type (const TypeType& x);

    void
    Type (const TypeOptional& x);

    void
    Type (::std::unique_ptr< TypeType > p);

    // IdentifierName
    //
    typedef ::CDM::LocalizedText IdentifierNameType;
    typedef ::xsd::cxx::tree::sequence< IdentifierNameType > IdentifierNameSequence;
    typedef IdentifierNameSequence::iterator IdentifierNameIterator;
    typedef IdentifierNameSequence::const_iterator IdentifierNameConstIterator;
    typedef ::xsd::cxx::tree::traits< IdentifierNameType, char > IdentifierNameTraits;

    const IdentifierNameSequence&
    IdentifierName () const;

    IdentifierNameSequence&
    IdentifierName ();

    void
    IdentifierName (const IdentifierNameSequence& s);

    // Root
    //
    typedef ::xml_schema::Uri RootType;
    typedef ::xsd::cxx::tree::traits< RootType, char > RootTraits;

    const RootType&
    Root () const;

    RootType&
    Root ();

    void
    Root (const RootType& x);

    void
    Root (::std::unique_ptr< RootType > p);

    // Extension
    //
    typedef ::xml_schema::String Extension1Type;
    typedef ::xsd::cxx::tree::optional< Extension1Type > Extension1Optional;
    typedef ::xsd::cxx::tree::traits< Extension1Type, char > Extension1Traits;

    const Extension1Optional&
    Extension1 () const;

    Extension1Optional&
    Extension1 ();

    void
    Extension1 (const Extension1Type& x);

    void
    Extension1 (const Extension1Optional& x);

    void
    Extension1 (::std::unique_ptr< Extension1Type > p);

    // Constructors.
    //
    InstanceIdentifier (const RootType&);

    InstanceIdentifier (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    InstanceIdentifier (const InstanceIdentifier& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual InstanceIdentifier*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    InstanceIdentifier&
    operator= (const InstanceIdentifier& x);

    virtual 
    ~InstanceIdentifier ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    TypeOptional Type_;
    IdentifierNameSequence IdentifierName_;
    ::xsd::cxx::tree::one< RootType > Root_;
    Extension1Optional Extension1_;
  };

  class Range: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Lower
    //
    typedef ::xml_schema::Decimal LowerType;
    typedef ::xsd::cxx::tree::optional< LowerType > LowerOptional;
    typedef ::xsd::cxx::tree::traits< LowerType, char, ::xsd::cxx::tree::schema_type::decimal > LowerTraits;

    const LowerOptional&
    Lower () const;

    LowerOptional&
    Lower ();

    void
    Lower (const LowerType& x);

    void
    Lower (const LowerOptional& x);

    // Upper
    //
    typedef ::xml_schema::Decimal UpperType;
    typedef ::xsd::cxx::tree::optional< UpperType > UpperOptional;
    typedef ::xsd::cxx::tree::traits< UpperType, char, ::xsd::cxx::tree::schema_type::decimal > UpperTraits;

    const UpperOptional&
    Upper () const;

    UpperOptional&
    Upper ();

    void
    Upper (const UpperType& x);

    void
    Upper (const UpperOptional& x);

    // StepWidth
    //
    typedef ::xml_schema::Decimal StepWidthType;
    typedef ::xsd::cxx::tree::optional< StepWidthType > StepWidthOptional;
    typedef ::xsd::cxx::tree::traits< StepWidthType, char, ::xsd::cxx::tree::schema_type::decimal > StepWidthTraits;

    const StepWidthOptional&
    StepWidth () const;

    StepWidthOptional&
    StepWidth ();

    void
    StepWidth (const StepWidthType& x);

    void
    StepWidth (const StepWidthOptional& x);

    // RelativeAccuracy
    //
    typedef ::xml_schema::Decimal RelativeAccuracyType;
    typedef ::xsd::cxx::tree::optional< RelativeAccuracyType > RelativeAccuracyOptional;
    typedef ::xsd::cxx::tree::traits< RelativeAccuracyType, char, ::xsd::cxx::tree::schema_type::decimal > RelativeAccuracyTraits;

    const RelativeAccuracyOptional&
    RelativeAccuracy () const;

    RelativeAccuracyOptional&
    RelativeAccuracy ();

    void
    RelativeAccuracy (const RelativeAccuracyType& x);

    void
    RelativeAccuracy (const RelativeAccuracyOptional& x);

    // AbsoluteAccuracy
    //
    typedef ::xml_schema::Decimal AbsoluteAccuracyType;
    typedef ::xsd::cxx::tree::optional< AbsoluteAccuracyType > AbsoluteAccuracyOptional;
    typedef ::xsd::cxx::tree::traits< AbsoluteAccuracyType, char, ::xsd::cxx::tree::schema_type::decimal > AbsoluteAccuracyTraits;

    const AbsoluteAccuracyOptional&
    AbsoluteAccuracy () const;

    AbsoluteAccuracyOptional&
    AbsoluteAccuracy ();

    void
    AbsoluteAccuracy (const AbsoluteAccuracyType& x);

    void
    AbsoluteAccuracy (const AbsoluteAccuracyOptional& x);

    // Constructors.
    //
    Range ();

    Range (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    Range (const Range& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    virtual Range*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Range&
    operator= (const Range& x);

    virtual 
    ~Range ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    LowerOptional Lower_;
    UpperOptional Upper_;
    StepWidthOptional StepWidth_;
    RelativeAccuracyOptional RelativeAccuracy_;
    AbsoluteAccuracyOptional AbsoluteAccuracy_;
  };

  class Measurement: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // MeasurementUnit
    //
    typedef ::CDM::CodedValue MeasurementUnitType;
    typedef ::xsd::cxx::tree::traits< MeasurementUnitType, char > MeasurementUnitTraits;

    const MeasurementUnitType&
    MeasurementUnit () const;

    MeasurementUnitType&
    MeasurementUnit ();

    void
    MeasurementUnit (const MeasurementUnitType& x);

    void
    MeasurementUnit (::std::unique_ptr< MeasurementUnitType > p);

    // MeasuredValue
    //
    typedef ::xml_schema::Decimal MeasuredValueType;
    typedef ::xsd::cxx::tree::traits< MeasuredValueType, char, ::xsd::cxx::tree::schema_type::decimal > MeasuredValueTraits;

    const MeasuredValueType&
    MeasuredValue () const;

    MeasuredValueType&
    MeasuredValue ();

    void
    MeasuredValue (const MeasuredValueType& x);

    // Constructors.
    //
    Measurement (const MeasurementUnitType&,
                 const MeasuredValueType&);

    Measurement (::std::unique_ptr< MeasurementUnitType >,
                 const MeasuredValueType&);

    Measurement (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    Measurement (const Measurement& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual Measurement*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Measurement&
    operator= (const Measurement& x);

    virtual 
    ~Measurement ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< MeasurementUnitType > MeasurementUnit_;
    ::xsd::cxx::tree::one< MeasuredValueType > MeasuredValue_;
  };

  class SafetyClassification: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Inf,
      MedA,
      MedB,
      MedC
    };

    SafetyClassification (Value v);

    SafetyClassification (const char* v);

    SafetyClassification (const ::std::string& v);

    SafetyClassification (const ::xml_schema::String& v);

    SafetyClassification (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    SafetyClassification (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    SafetyClassification (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    SafetyClassification (const SafetyClassification& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual SafetyClassification*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SafetyClassification&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_SafetyClassification_convert ();
    }

    protected:
    Value
    _xsd_SafetyClassification_convert () const;

    public:
    static const char* const _xsd_SafetyClassification_literals_[4];
    static const Value _xsd_SafetyClassification_indexes_[4];
  };

  class ComponentActivation: public ::xml_schema::String
  {
    public:
    enum Value
    {
      On,
      NotRdy,
      StndBy,
      Off,
      Shtdn,
      Fail
    };

    ComponentActivation (Value v);

    ComponentActivation (const char* v);

    ComponentActivation (const ::std::string& v);

    ComponentActivation (const ::xml_schema::String& v);

    ComponentActivation (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    ComponentActivation (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    ComponentActivation (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    ComponentActivation (const ComponentActivation& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual ComponentActivation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ComponentActivation&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_ComponentActivation_convert ();
    }

    protected:
    Value
    _xsd_ComponentActivation_convert () const;

    public:
    static const char* const _xsd_ComponentActivation_literals_[6];
    static const Value _xsd_ComponentActivation_indexes_[6];
  };

  class Handle: public ::xml_schema::String
  {
    public:
    // Constructors.
    //
    Handle ();

    Handle (const char*);

    Handle (const ::std::string&);

    Handle (const ::xml_schema::String&);

    Handle (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    Handle (const ::xercesc::DOMAttr& a,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    Handle (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    Handle (const Handle& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    virtual Handle*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~Handle ();
  };

  class HandleRef: public ::xml_schema::String
  {
    public:
    // Constructors.
    //
    HandleRef ();

    HandleRef (const char*);

    HandleRef (const ::std::string&);

    HandleRef (const ::xml_schema::String&);

    HandleRef (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    HandleRef (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    HandleRef (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    HandleRef (const HandleRef& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    virtual HandleRef*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~HandleRef ();
  };

  class AbstractDescriptor: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Type
    //
    typedef ::CDM::CodedValue TypeType;
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeOptional&
    Type () const;

    TypeOptional&
    Type ();

    void
    Type (const TypeType& x);

    void
    Type (const TypeOptional& x);

    void
    Type (::std::unique_ptr< TypeType > p);

    // Handle
    //
    typedef ::CDM::Handle HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    Handle () const;

    HandleType&
    Handle ();

    void
    Handle (const HandleType& x);

    void
    Handle (::std::unique_ptr< HandleType > p);

    // DescriptorVersion
    //
    typedef ::CDM::VersionCounter DescriptorVersionType;
    typedef ::xsd::cxx::tree::optional< DescriptorVersionType > DescriptorVersionOptional;
    typedef ::xsd::cxx::tree::traits< DescriptorVersionType, char > DescriptorVersionTraits;

    const DescriptorVersionOptional&
    DescriptorVersion () const;

    DescriptorVersionOptional&
    DescriptorVersion ();

    void
    DescriptorVersion (const DescriptorVersionType& x);

    void
    DescriptorVersion (const DescriptorVersionOptional& x);

    void
    DescriptorVersion (::std::unique_ptr< DescriptorVersionType > p);

    // SafetyClassification
    //
    typedef ::CDM::SafetyClassification SafetyClassificationType;
    typedef ::xsd::cxx::tree::optional< SafetyClassificationType > SafetyClassificationOptional;
    typedef ::xsd::cxx::tree::traits< SafetyClassificationType, char > SafetyClassificationTraits;

    const SafetyClassificationOptional&
    SafetyClassification () const;

    SafetyClassificationOptional&
    SafetyClassification ();

    void
    SafetyClassification (const SafetyClassificationType& x);

    void
    SafetyClassification (const SafetyClassificationOptional& x);

    void
    SafetyClassification (::std::unique_ptr< SafetyClassificationType > p);

    // Constructors.
    //
    AbstractDescriptor (const HandleType&);

    AbstractDescriptor (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    AbstractDescriptor (const AbstractDescriptor& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual AbstractDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractDescriptor&
    operator= (const AbstractDescriptor& x);

    virtual 
    ~AbstractDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    TypeOptional Type_;
    ::xsd::cxx::tree::one< HandleType > Handle_;
    DescriptorVersionOptional DescriptorVersion_;
    SafetyClassificationOptional SafetyClassification_;
  };

  class AbstractState: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // StateVersion
    //
    typedef ::CDM::VersionCounter StateVersionType;
    typedef ::xsd::cxx::tree::optional< StateVersionType > StateVersionOptional;
    typedef ::xsd::cxx::tree::traits< StateVersionType, char > StateVersionTraits;

    const StateVersionOptional&
    StateVersion () const;

    StateVersionOptional&
    StateVersion ();

    void
    StateVersion (const StateVersionType& x);

    void
    StateVersion (const StateVersionOptional& x);

    void
    StateVersion (::std::unique_ptr< StateVersionType > p);

    // DescriptorHandle
    //
    typedef ::CDM::HandleRef DescriptorHandleType;
    typedef ::xsd::cxx::tree::traits< DescriptorHandleType, char > DescriptorHandleTraits;

    const DescriptorHandleType&
    DescriptorHandle () const;

    DescriptorHandleType&
    DescriptorHandle ();

    void
    DescriptorHandle (const DescriptorHandleType& x);

    void
    DescriptorHandle (::std::unique_ptr< DescriptorHandleType > p);

    // DescriptorVersion
    //
    typedef ::CDM::ReferencedVersion DescriptorVersionType;
    typedef ::xsd::cxx::tree::optional< DescriptorVersionType > DescriptorVersionOptional;
    typedef ::xsd::cxx::tree::traits< DescriptorVersionType, char > DescriptorVersionTraits;

    const DescriptorVersionOptional&
    DescriptorVersion () const;

    DescriptorVersionOptional&
    DescriptorVersion ();

    void
    DescriptorVersion (const DescriptorVersionType& x);

    void
    DescriptorVersion (const DescriptorVersionOptional& x);

    void
    DescriptorVersion (::std::unique_ptr< DescriptorVersionType > p);

    // Constructors.
    //
    AbstractState (const DescriptorHandleType&);

    AbstractState (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    AbstractState (const AbstractState& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual AbstractState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractState&
    operator= (const AbstractState& x);

    virtual 
    ~AbstractState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    StateVersionOptional StateVersion_;
    ::xsd::cxx::tree::one< DescriptorHandleType > DescriptorHandle_;
    DescriptorVersionOptional DescriptorVersion_;
  };

  class AbstractMultiState: public ::CDM::AbstractState
  {
    public:
    // Category
    //
    typedef ::CDM::CodedValue CategoryType;
    typedef ::xsd::cxx::tree::optional< CategoryType > CategoryOptional;
    typedef ::xsd::cxx::tree::traits< CategoryType, char > CategoryTraits;

    const CategoryOptional&
    Category () const;

    CategoryOptional&
    Category ();

    void
    Category (const CategoryType& x);

    void
    Category (const CategoryOptional& x);

    void
    Category (::std::unique_ptr< CategoryType > p);

    // Handle
    //
    typedef ::CDM::Handle HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    Handle () const;

    HandleType&
    Handle ();

    void
    Handle (const HandleType& x);

    void
    Handle (::std::unique_ptr< HandleType > p);

    // Constructors.
    //
    AbstractMultiState (const DescriptorHandleType&,
                        const HandleType&);

    AbstractMultiState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    AbstractMultiState (const AbstractMultiState& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual AbstractMultiState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractMultiState&
    operator= (const AbstractMultiState& x);

    virtual 
    ~AbstractMultiState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CategoryOptional Category_;
    ::xsd::cxx::tree::one< HandleType > Handle_;
  };

  class AbstractDeviceComponentDescriptor: public ::CDM::AbstractDescriptor
  {
    public:
    // ProductionSpecification
    //
    typedef ::CDM::ProductionSpecification ProductionSpecificationType;
    typedef ::xsd::cxx::tree::sequence< ProductionSpecificationType > ProductionSpecificationSequence;
    typedef ProductionSpecificationSequence::iterator ProductionSpecificationIterator;
    typedef ProductionSpecificationSequence::const_iterator ProductionSpecificationConstIterator;
    typedef ::xsd::cxx::tree::traits< ProductionSpecificationType, char > ProductionSpecificationTraits;

    const ProductionSpecificationSequence&
    ProductionSpecification () const;

    ProductionSpecificationSequence&
    ProductionSpecification ();

    void
    ProductionSpecification (const ProductionSpecificationSequence& s);

    // Constructors.
    //
    AbstractDeviceComponentDescriptor (const HandleType&);

    AbstractDeviceComponentDescriptor (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    AbstractDeviceComponentDescriptor (const AbstractDeviceComponentDescriptor& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    virtual AbstractDeviceComponentDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractDeviceComponentDescriptor&
    operator= (const AbstractDeviceComponentDescriptor& x);

    virtual 
    ~AbstractDeviceComponentDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ProductionSpecificationSequence ProductionSpecification_;
  };

  class AbstractAlertingDeviceComponentDescriptor: public ::CDM::AbstractDeviceComponentDescriptor
  {
    public:
    // AlertSystem
    //
    typedef ::CDM::AlertSystemDescriptor AlertSystemType;
    typedef ::xsd::cxx::tree::optional< AlertSystemType > AlertSystemOptional;
    typedef ::xsd::cxx::tree::traits< AlertSystemType, char > AlertSystemTraits;

    const AlertSystemOptional&
    AlertSystem () const;

    AlertSystemOptional&
    AlertSystem ();

    void
    AlertSystem (const AlertSystemType& x);

    void
    AlertSystem (const AlertSystemOptional& x);

    void
    AlertSystem (::std::unique_ptr< AlertSystemType > p);

    // Constructors.
    //
    AbstractAlertingDeviceComponentDescriptor (const HandleType&);

    AbstractAlertingDeviceComponentDescriptor (const ::xercesc::DOMElement& e,
                                               ::xml_schema::Flags f = 0,
                                               ::xml_schema::Container* c = 0);

    AbstractAlertingDeviceComponentDescriptor (const AbstractAlertingDeviceComponentDescriptor& x,
                                               ::xml_schema::Flags f = 0,
                                               ::xml_schema::Container* c = 0);

    virtual AbstractAlertingDeviceComponentDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractAlertingDeviceComponentDescriptor&
    operator= (const AbstractAlertingDeviceComponentDescriptor& x);

    virtual 
    ~AbstractAlertingDeviceComponentDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AlertSystemOptional AlertSystem_;
  };

  class CalibrationState: public ::xml_schema::String
  {
    public:
    enum Value
    {
      No,
      Req,
      Cal
    };

    CalibrationState (Value v);

    CalibrationState (const char* v);

    CalibrationState (const ::std::string& v);

    CalibrationState (const ::xml_schema::String& v);

    CalibrationState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    CalibrationState (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    CalibrationState (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    CalibrationState (const CalibrationState& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual CalibrationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CalibrationState&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_CalibrationState_convert ();
    }

    protected:
    Value
    _xsd_CalibrationState_convert () const;

    public:
    static const char* const _xsd_CalibrationState_literals_[3];
    static const Value _xsd_CalibrationState_indexes_[3];
  };

  class CalibrationType: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Offset,
      Gain,
      TP,
      Unspec
    };

    CalibrationType (Value v);

    CalibrationType (const char* v);

    CalibrationType (const ::std::string& v);

    CalibrationType (const ::xml_schema::String& v);

    CalibrationType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    CalibrationType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    CalibrationType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    CalibrationType (const CalibrationType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual CalibrationType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CalibrationType&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_CalibrationType_convert ();
    }

    protected:
    Value
    _xsd_CalibrationType_convert () const;

    public:
    static const char* const _xsd_CalibrationType_literals_[4];
    static const Value _xsd_CalibrationType_indexes_[4];
  };

  class CalibrationInfo: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // ComponentCalibrationState
    //
    typedef ::CDM::CalibrationState ComponentCalibrationStateType;
    typedef ::xsd::cxx::tree::optional< ComponentCalibrationStateType > ComponentCalibrationStateOptional;
    typedef ::xsd::cxx::tree::traits< ComponentCalibrationStateType, char > ComponentCalibrationStateTraits;

    const ComponentCalibrationStateOptional&
    ComponentCalibrationState () const;

    ComponentCalibrationStateOptional&
    ComponentCalibrationState ();

    void
    ComponentCalibrationState (const ComponentCalibrationStateType& x);

    void
    ComponentCalibrationState (const ComponentCalibrationStateOptional& x);

    void
    ComponentCalibrationState (::std::unique_ptr< ComponentCalibrationStateType > p);

    // Type
    //
    typedef ::CDM::CalibrationType TypeType;
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeOptional&
    Type () const;

    TypeOptional&
    Type ();

    void
    Type (const TypeType& x);

    void
    Type (const TypeOptional& x);

    void
    Type (::std::unique_ptr< TypeType > p);

    // Time
    //
    typedef ::CDM::Timestamp TimeType;
    typedef ::xsd::cxx::tree::optional< TimeType > TimeOptional;
    typedef ::xsd::cxx::tree::traits< TimeType, char > TimeTraits;

    const TimeOptional&
    Time () const;

    TimeOptional&
    Time ();

    void
    Time (const TimeType& x);

    void
    Time (const TimeOptional& x);

    void
    Time (::std::unique_ptr< TimeType > p);

    // Constructors.
    //
    CalibrationInfo ();

    CalibrationInfo (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    CalibrationInfo (const CalibrationInfo& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual CalibrationInfo*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CalibrationInfo&
    operator= (const CalibrationInfo& x);

    virtual 
    ~CalibrationInfo ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ComponentCalibrationStateOptional ComponentCalibrationState_;
    TypeOptional Type_;
    TimeOptional Time_;
  };

  class AbstractDeviceComponentState: public ::CDM::AbstractState
  {
    public:
    // CalibrationInfo
    //
    typedef ::CDM::CalibrationInfo CalibrationInfoType;
    typedef ::xsd::cxx::tree::optional< CalibrationInfoType > CalibrationInfoOptional;
    typedef ::xsd::cxx::tree::traits< CalibrationInfoType, char > CalibrationInfoTraits;

    const CalibrationInfoOptional&
    CalibrationInfo () const;

    CalibrationInfoOptional&
    CalibrationInfo ();

    void
    CalibrationInfo (const CalibrationInfoType& x);

    void
    CalibrationInfo (const CalibrationInfoOptional& x);

    void
    CalibrationInfo (::std::unique_ptr< CalibrationInfoType > p);

    // NextCalibration
    //
    typedef ::CDM::CalibrationInfo NextCalibrationType;
    typedef ::xsd::cxx::tree::optional< NextCalibrationType > NextCalibrationOptional;
    typedef ::xsd::cxx::tree::traits< NextCalibrationType, char > NextCalibrationTraits;

    const NextCalibrationOptional&
    NextCalibration () const;

    NextCalibrationOptional&
    NextCalibration ();

    void
    NextCalibration (const NextCalibrationType& x);

    void
    NextCalibration (const NextCalibrationOptional& x);

    void
    NextCalibration (::std::unique_ptr< NextCalibrationType > p);

    // ActivationState
    //
    typedef ::CDM::ComponentActivation ActivationStateType;
    typedef ::xsd::cxx::tree::optional< ActivationStateType > ActivationStateOptional;
    typedef ::xsd::cxx::tree::traits< ActivationStateType, char > ActivationStateTraits;

    const ActivationStateOptional&
    ActivationState () const;

    ActivationStateOptional&
    ActivationState ();

    void
    ActivationState (const ActivationStateType& x);

    void
    ActivationState (const ActivationStateOptional& x);

    void
    ActivationState (::std::unique_ptr< ActivationStateType > p);

    // OperatingHours
    //
    typedef ::xml_schema::UnsignedInt OperatingHoursType;
    typedef ::xsd::cxx::tree::optional< OperatingHoursType > OperatingHoursOptional;
    typedef ::xsd::cxx::tree::traits< OperatingHoursType, char > OperatingHoursTraits;

    const OperatingHoursOptional&
    OperatingHours () const;

    OperatingHoursOptional&
    OperatingHours ();

    void
    OperatingHours (const OperatingHoursType& x);

    void
    OperatingHours (const OperatingHoursOptional& x);

    // OperatingCycles
    //
    typedef ::xml_schema::Int OperatingCyclesType;
    typedef ::xsd::cxx::tree::optional< OperatingCyclesType > OperatingCyclesOptional;
    typedef ::xsd::cxx::tree::traits< OperatingCyclesType, char > OperatingCyclesTraits;

    const OperatingCyclesOptional&
    OperatingCycles () const;

    OperatingCyclesOptional&
    OperatingCycles ();

    void
    OperatingCycles (const OperatingCyclesType& x);

    void
    OperatingCycles (const OperatingCyclesOptional& x);

    // Constructors.
    //
    AbstractDeviceComponentState (const DescriptorHandleType&);

    AbstractDeviceComponentState (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    AbstractDeviceComponentState (const AbstractDeviceComponentState& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    virtual AbstractDeviceComponentState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractDeviceComponentState&
    operator= (const AbstractDeviceComponentState& x);

    virtual 
    ~AbstractDeviceComponentState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CalibrationInfoOptional CalibrationInfo_;
    NextCalibrationOptional NextCalibration_;
    ActivationStateOptional ActivationState_;
    OperatingHoursOptional OperatingHours_;
    OperatingCyclesOptional OperatingCycles_;
  };

  class AbstractAlertingDeviceComponentState: public ::CDM::AbstractDeviceComponentState
  {
    public:
    // Constructors.
    //
    AbstractAlertingDeviceComponentState (const DescriptorHandleType&);

    AbstractAlertingDeviceComponentState (const ::xercesc::DOMElement& e,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    AbstractAlertingDeviceComponentState (const AbstractAlertingDeviceComponentState& x,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    virtual AbstractAlertingDeviceComponentState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~AbstractAlertingDeviceComponentState ();
  };

  class MdsDescriptor: public ::CDM::AbstractAlertingDeviceComponentDescriptor
  {
    public:
    // MetaData
    //
    typedef ::CDM::MetaData MetaDataType;
    typedef ::xsd::cxx::tree::optional< MetaDataType > MetaDataOptional;
    typedef ::xsd::cxx::tree::traits< MetaDataType, char > MetaDataTraits;

    const MetaDataOptional&
    MetaData () const;

    MetaDataOptional&
    MetaData ();

    void
    MetaData (const MetaDataType& x);

    void
    MetaData (const MetaDataOptional& x);

    void
    MetaData (::std::unique_ptr< MetaDataType > p);

    // SystemContext
    //
    typedef ::CDM::SystemContextDescriptor SystemContextType;
    typedef ::xsd::cxx::tree::optional< SystemContextType > SystemContextOptional;
    typedef ::xsd::cxx::tree::traits< SystemContextType, char > SystemContextTraits;

    const SystemContextOptional&
    SystemContext () const;

    SystemContextOptional&
    SystemContext ();

    void
    SystemContext (const SystemContextType& x);

    void
    SystemContext (const SystemContextOptional& x);

    void
    SystemContext (::std::unique_ptr< SystemContextType > p);

    // Clock
    //
    typedef ::CDM::ClockDescriptor ClockType;
    typedef ::xsd::cxx::tree::optional< ClockType > ClockOptional;
    typedef ::xsd::cxx::tree::traits< ClockType, char > ClockTraits;

    const ClockOptional&
    Clock () const;

    ClockOptional&
    Clock ();

    void
    Clock (const ClockType& x);

    void
    Clock (const ClockOptional& x);

    void
    Clock (::std::unique_ptr< ClockType > p);

    // Battery
    //
    typedef ::CDM::BatteryDescriptor BatteryType;
    typedef ::xsd::cxx::tree::optional< BatteryType > BatteryOptional;
    typedef ::xsd::cxx::tree::traits< BatteryType, char > BatteryTraits;

    const BatteryOptional&
    Battery () const;

    BatteryOptional&
    Battery ();

    void
    Battery (const BatteryType& x);

    void
    Battery (const BatteryOptional& x);

    void
    Battery (::std::unique_ptr< BatteryType > p);

    // Sco
    //
    typedef ::CDM::ScoDescriptor ScoType;
    typedef ::xsd::cxx::tree::optional< ScoType > ScoOptional;
    typedef ::xsd::cxx::tree::traits< ScoType, char > ScoTraits;

    const ScoOptional&
    Sco () const;

    ScoOptional&
    Sco ();

    void
    Sco (const ScoType& x);

    void
    Sco (const ScoOptional& x);

    void
    Sco (::std::unique_ptr< ScoType > p);

    // Vmd
    //
    typedef ::CDM::VmdDescriptor VmdType;
    typedef ::xsd::cxx::tree::sequence< VmdType > VmdSequence;
    typedef VmdSequence::iterator VmdIterator;
    typedef VmdSequence::const_iterator VmdConstIterator;
    typedef ::xsd::cxx::tree::traits< VmdType, char > VmdTraits;

    const VmdSequence&
    Vmd () const;

    VmdSequence&
    Vmd ();

    void
    Vmd (const VmdSequence& s);

    // Constructors.
    //
    MdsDescriptor (const HandleType&);

    MdsDescriptor (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    MdsDescriptor (const MdsDescriptor& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual MdsDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MdsDescriptor&
    operator= (const MdsDescriptor& x);

    virtual 
    ~MdsDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MetaDataOptional MetaData_;
    SystemContextOptional SystemContext_;
    ClockOptional Clock_;
    BatteryOptional Battery_;
    ScoOptional Sco_;
    VmdSequence Vmd_;
  };

  class MdsOperatingMode: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Nml,
      Dmo,
      Srv,
      Mtn
    };

    MdsOperatingMode (Value v);

    MdsOperatingMode (const char* v);

    MdsOperatingMode (const ::std::string& v);

    MdsOperatingMode (const ::xml_schema::String& v);

    MdsOperatingMode (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    MdsOperatingMode (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    MdsOperatingMode (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    MdsOperatingMode (const MdsOperatingMode& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual MdsOperatingMode*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MdsOperatingMode&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_MdsOperatingMode_convert ();
    }

    protected:
    Value
    _xsd_MdsOperatingMode_convert () const;

    public:
    static const char* const _xsd_MdsOperatingMode_literals_[4];
    static const Value _xsd_MdsOperatingMode_indexes_[4];
  };

  class MdsState: public ::CDM::AbstractAlertingDeviceComponentState
  {
    public:
    // Lang
    //
    typedef ::xml_schema::Language LangType;
    typedef ::xsd::cxx::tree::optional< LangType > LangOptional;
    typedef ::xsd::cxx::tree::traits< LangType, char > LangTraits;

    const LangOptional&
    Lang () const;

    LangOptional&
    Lang ();

    void
    Lang (const LangType& x);

    void
    Lang (const LangOptional& x);

    void
    Lang (::std::unique_ptr< LangType > p);

    // OperatingMode
    //
    typedef ::CDM::MdsOperatingMode OperatingModeType;
    typedef ::xsd::cxx::tree::optional< OperatingModeType > OperatingModeOptional;
    typedef ::xsd::cxx::tree::traits< OperatingModeType, char > OperatingModeTraits;

    const OperatingModeOptional&
    OperatingMode () const;

    OperatingModeOptional&
    OperatingMode ();

    void
    OperatingMode (const OperatingModeType& x);

    void
    OperatingMode (const OperatingModeOptional& x);

    void
    OperatingMode (::std::unique_ptr< OperatingModeType > p);

    // Constructors.
    //
    MdsState (const DescriptorHandleType&);

    MdsState (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    MdsState (const MdsState& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    virtual MdsState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MdsState&
    operator= (const MdsState& x);

    virtual 
    ~MdsState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    LangOptional Lang_;
    OperatingModeOptional OperatingMode_;
  };

  class VmdDescriptor: public ::CDM::AbstractAlertingDeviceComponentDescriptor
  {
    public:
    // Sco
    //
    typedef ::CDM::ScoDescriptor ScoType;
    typedef ::xsd::cxx::tree::optional< ScoType > ScoOptional;
    typedef ::xsd::cxx::tree::traits< ScoType, char > ScoTraits;

    const ScoOptional&
    Sco () const;

    ScoOptional&
    Sco ();

    void
    Sco (const ScoType& x);

    void
    Sco (const ScoOptional& x);

    void
    Sco (::std::unique_ptr< ScoType > p);

    // Channel
    //
    typedef ::CDM::ChannelDescriptor ChannelType;
    typedef ::xsd::cxx::tree::sequence< ChannelType > ChannelSequence;
    typedef ChannelSequence::iterator ChannelIterator;
    typedef ChannelSequence::const_iterator ChannelConstIterator;
    typedef ::xsd::cxx::tree::traits< ChannelType, char > ChannelTraits;

    const ChannelSequence&
    Channel () const;

    ChannelSequence&
    Channel ();

    void
    Channel (const ChannelSequence& s);

    // Constructors.
    //
    VmdDescriptor (const HandleType&);

    VmdDescriptor (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    VmdDescriptor (const VmdDescriptor& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual VmdDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    VmdDescriptor&
    operator= (const VmdDescriptor& x);

    virtual 
    ~VmdDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ScoOptional Sco_;
    ChannelSequence Channel_;
  };

  class VmdState: public ::CDM::AbstractAlertingDeviceComponentState
  {
    public:
    // Constructors.
    //
    VmdState (const DescriptorHandleType&);

    VmdState (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    VmdState (const VmdState& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    virtual VmdState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~VmdState ();
  };

  class ChannelDescriptor: public ::CDM::AbstractAlertingDeviceComponentDescriptor
  {
    public:
    // Metric
    //
    typedef ::CDM::AbstractMetricDescriptor MetricType;
    typedef ::xsd::cxx::tree::sequence< MetricType > MetricSequence;
    typedef MetricSequence::iterator MetricIterator;
    typedef MetricSequence::const_iterator MetricConstIterator;
    typedef ::xsd::cxx::tree::traits< MetricType, char > MetricTraits;

    const MetricSequence&
    Metric () const;

    MetricSequence&
    Metric ();

    void
    Metric (const MetricSequence& s);

    // Constructors.
    //
    ChannelDescriptor (const HandleType&);

    ChannelDescriptor (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    ChannelDescriptor (const ChannelDescriptor& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual ChannelDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ChannelDescriptor&
    operator= (const ChannelDescriptor& x);

    virtual 
    ~ChannelDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MetricSequence Metric_;
  };

  class ChannelState: public ::CDM::AbstractAlertingDeviceComponentState
  {
    public:
    // Constructors.
    //
    ChannelState (const DescriptorHandleType&);

    ChannelState (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    ChannelState (const ChannelState& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual ChannelState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~ChannelState ();
  };

  class AbstractAlertDescriptor: public ::CDM::AbstractDescriptor
  {
    public:
    // Constructors.
    //
    AbstractAlertDescriptor (const HandleType&);

    AbstractAlertDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    AbstractAlertDescriptor (const AbstractAlertDescriptor& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual AbstractAlertDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~AbstractAlertDescriptor ();
  };

  class AbstractAlertState: public ::CDM::AbstractState
  {
    public:
    // ActivationState
    //
    typedef ::CDM::AlertActivation ActivationStateType;
    typedef ::xsd::cxx::tree::traits< ActivationStateType, char > ActivationStateTraits;

    const ActivationStateType&
    ActivationState () const;

    ActivationStateType&
    ActivationState ();

    void
    ActivationState (const ActivationStateType& x);

    void
    ActivationState (::std::unique_ptr< ActivationStateType > p);

    // Constructors.
    //
    AbstractAlertState (const DescriptorHandleType&,
                        const ActivationStateType&);

    AbstractAlertState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    AbstractAlertState (const AbstractAlertState& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual AbstractAlertState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractAlertState&
    operator= (const AbstractAlertState& x);

    virtual 
    ~AbstractAlertState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ActivationStateType > ActivationState_;
  };

  class AlertActivation: public ::xml_schema::String
  {
    public:
    enum Value
    {
      On,
      Off,
      Psd
    };

    AlertActivation (Value v);

    AlertActivation (const char* v);

    AlertActivation (const ::std::string& v);

    AlertActivation (const ::xml_schema::String& v);

    AlertActivation (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    AlertActivation (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    AlertActivation (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    AlertActivation (const AlertActivation& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual AlertActivation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertActivation&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_AlertActivation_convert ();
    }

    protected:
    Value
    _xsd_AlertActivation_convert () const;

    public:
    static const char* const _xsd_AlertActivation_literals_[3];
    static const Value _xsd_AlertActivation_indexes_[3];
  };

  class SystemSignalActivation: public ::xml_schema::Type
  {
    public:
    // Manifestation
    //
    typedef ::CDM::AlertSignalManifestation ManifestationType;
    typedef ::xsd::cxx::tree::traits< ManifestationType, char > ManifestationTraits;

    const ManifestationType&
    Manifestation () const;

    ManifestationType&
    Manifestation ();

    void
    Manifestation (const ManifestationType& x);

    void
    Manifestation (::std::unique_ptr< ManifestationType > p);

    // State
    //
    typedef ::CDM::AlertActivation StateType;
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    const StateType&
    State () const;

    StateType&
    State ();

    void
    State (const StateType& x);

    void
    State (::std::unique_ptr< StateType > p);

    // Constructors.
    //
    SystemSignalActivation (const ManifestationType&,
                            const StateType&);

    SystemSignalActivation (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    SystemSignalActivation (const SystemSignalActivation& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    virtual SystemSignalActivation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SystemSignalActivation&
    operator= (const SystemSignalActivation& x);

    virtual 
    ~SystemSignalActivation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ManifestationType > Manifestation_;
    ::xsd::cxx::tree::one< StateType > State_;
  };

  class AlertSystemDescriptor: public ::CDM::AbstractAlertDescriptor
  {
    public:
    // AlertCondition
    //
    typedef ::CDM::AlertConditionDescriptor AlertConditionType;
    typedef ::xsd::cxx::tree::sequence< AlertConditionType > AlertConditionSequence;
    typedef AlertConditionSequence::iterator AlertConditionIterator;
    typedef AlertConditionSequence::const_iterator AlertConditionConstIterator;
    typedef ::xsd::cxx::tree::traits< AlertConditionType, char > AlertConditionTraits;

    const AlertConditionSequence&
    AlertCondition () const;

    AlertConditionSequence&
    AlertCondition ();

    void
    AlertCondition (const AlertConditionSequence& s);

    // AlertSignal
    //
    typedef ::CDM::AlertSignalDescriptor AlertSignalType;
    typedef ::xsd::cxx::tree::sequence< AlertSignalType > AlertSignalSequence;
    typedef AlertSignalSequence::iterator AlertSignalIterator;
    typedef AlertSignalSequence::const_iterator AlertSignalConstIterator;
    typedef ::xsd::cxx::tree::traits< AlertSignalType, char > AlertSignalTraits;

    const AlertSignalSequence&
    AlertSignal () const;

    AlertSignalSequence&
    AlertSignal ();

    void
    AlertSignal (const AlertSignalSequence& s);

    // MaxPhysiologicalParallelAlarms
    //
    typedef ::xml_schema::UnsignedInt MaxPhysiologicalParallelAlarmsType;
    typedef ::xsd::cxx::tree::optional< MaxPhysiologicalParallelAlarmsType > MaxPhysiologicalParallelAlarmsOptional;
    typedef ::xsd::cxx::tree::traits< MaxPhysiologicalParallelAlarmsType, char > MaxPhysiologicalParallelAlarmsTraits;

    const MaxPhysiologicalParallelAlarmsOptional&
    MaxPhysiologicalParallelAlarms () const;

    MaxPhysiologicalParallelAlarmsOptional&
    MaxPhysiologicalParallelAlarms ();

    void
    MaxPhysiologicalParallelAlarms (const MaxPhysiologicalParallelAlarmsType& x);

    void
    MaxPhysiologicalParallelAlarms (const MaxPhysiologicalParallelAlarmsOptional& x);

    // MaxTechnicalParallelAlarms
    //
    typedef ::xml_schema::UnsignedInt MaxTechnicalParallelAlarmsType;
    typedef ::xsd::cxx::tree::optional< MaxTechnicalParallelAlarmsType > MaxTechnicalParallelAlarmsOptional;
    typedef ::xsd::cxx::tree::traits< MaxTechnicalParallelAlarmsType, char > MaxTechnicalParallelAlarmsTraits;

    const MaxTechnicalParallelAlarmsOptional&
    MaxTechnicalParallelAlarms () const;

    MaxTechnicalParallelAlarmsOptional&
    MaxTechnicalParallelAlarms ();

    void
    MaxTechnicalParallelAlarms (const MaxTechnicalParallelAlarmsType& x);

    void
    MaxTechnicalParallelAlarms (const MaxTechnicalParallelAlarmsOptional& x);

    // SelfCheckPeriod
    //
    typedef ::xml_schema::Duration SelfCheckPeriodType;
    typedef ::xsd::cxx::tree::optional< SelfCheckPeriodType > SelfCheckPeriodOptional;
    typedef ::xsd::cxx::tree::traits< SelfCheckPeriodType, char > SelfCheckPeriodTraits;

    const SelfCheckPeriodOptional&
    SelfCheckPeriod () const;

    SelfCheckPeriodOptional&
    SelfCheckPeriod ();

    void
    SelfCheckPeriod (const SelfCheckPeriodType& x);

    void
    SelfCheckPeriod (const SelfCheckPeriodOptional& x);

    void
    SelfCheckPeriod (::std::unique_ptr< SelfCheckPeriodType > p);

    // Constructors.
    //
    AlertSystemDescriptor (const HandleType&);

    AlertSystemDescriptor (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    AlertSystemDescriptor (const AlertSystemDescriptor& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual AlertSystemDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertSystemDescriptor&
    operator= (const AlertSystemDescriptor& x);

    virtual 
    ~AlertSystemDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AlertConditionSequence AlertCondition_;
    AlertSignalSequence AlertSignal_;
    MaxPhysiologicalParallelAlarmsOptional MaxPhysiologicalParallelAlarms_;
    MaxTechnicalParallelAlarmsOptional MaxTechnicalParallelAlarms_;
    SelfCheckPeriodOptional SelfCheckPeriod_;
  };

  class AlertSystemState: public ::CDM::AbstractAlertState
  {
    public:
    // SystemSignalActivation
    //
    typedef ::CDM::SystemSignalActivation SystemSignalActivationType;
    typedef ::xsd::cxx::tree::sequence< SystemSignalActivationType > SystemSignalActivationSequence;
    typedef SystemSignalActivationSequence::iterator SystemSignalActivationIterator;
    typedef SystemSignalActivationSequence::const_iterator SystemSignalActivationConstIterator;
    typedef ::xsd::cxx::tree::traits< SystemSignalActivationType, char > SystemSignalActivationTraits;

    const SystemSignalActivationSequence&
    SystemSignalActivation () const;

    SystemSignalActivationSequence&
    SystemSignalActivation ();

    void
    SystemSignalActivation (const SystemSignalActivationSequence& s);

    // LastSelfCheck
    //
    typedef ::CDM::Timestamp LastSelfCheckType;
    typedef ::xsd::cxx::tree::optional< LastSelfCheckType > LastSelfCheckOptional;
    typedef ::xsd::cxx::tree::traits< LastSelfCheckType, char > LastSelfCheckTraits;

    const LastSelfCheckOptional&
    LastSelfCheck () const;

    LastSelfCheckOptional&
    LastSelfCheck ();

    void
    LastSelfCheck (const LastSelfCheckType& x);

    void
    LastSelfCheck (const LastSelfCheckOptional& x);

    void
    LastSelfCheck (::std::unique_ptr< LastSelfCheckType > p);

    // SelfCheckCount
    //
    typedef ::xml_schema::Long SelfCheckCountType;
    typedef ::xsd::cxx::tree::optional< SelfCheckCountType > SelfCheckCountOptional;
    typedef ::xsd::cxx::tree::traits< SelfCheckCountType, char > SelfCheckCountTraits;

    const SelfCheckCountOptional&
    SelfCheckCount () const;

    SelfCheckCountOptional&
    SelfCheckCount ();

    void
    SelfCheckCount (const SelfCheckCountType& x);

    void
    SelfCheckCount (const SelfCheckCountOptional& x);

    // PresentPhysiologicalAlarmConditions
    //
    typedef ::CDM::AlertConditionReference PresentPhysiologicalAlarmConditionsType;
    typedef ::xsd::cxx::tree::optional< PresentPhysiologicalAlarmConditionsType > PresentPhysiologicalAlarmConditionsOptional;
    typedef ::xsd::cxx::tree::traits< PresentPhysiologicalAlarmConditionsType, char > PresentPhysiologicalAlarmConditionsTraits;

    const PresentPhysiologicalAlarmConditionsOptional&
    PresentPhysiologicalAlarmConditions () const;

    PresentPhysiologicalAlarmConditionsOptional&
    PresentPhysiologicalAlarmConditions ();

    void
    PresentPhysiologicalAlarmConditions (const PresentPhysiologicalAlarmConditionsType& x);

    void
    PresentPhysiologicalAlarmConditions (const PresentPhysiologicalAlarmConditionsOptional& x);

    void
    PresentPhysiologicalAlarmConditions (::std::unique_ptr< PresentPhysiologicalAlarmConditionsType > p);

    // PresentTechnicalAlarmConditions
    //
    typedef ::CDM::AlertConditionReference PresentTechnicalAlarmConditionsType;
    typedef ::xsd::cxx::tree::optional< PresentTechnicalAlarmConditionsType > PresentTechnicalAlarmConditionsOptional;
    typedef ::xsd::cxx::tree::traits< PresentTechnicalAlarmConditionsType, char > PresentTechnicalAlarmConditionsTraits;

    const PresentTechnicalAlarmConditionsOptional&
    PresentTechnicalAlarmConditions () const;

    PresentTechnicalAlarmConditionsOptional&
    PresentTechnicalAlarmConditions ();

    void
    PresentTechnicalAlarmConditions (const PresentTechnicalAlarmConditionsType& x);

    void
    PresentTechnicalAlarmConditions (const PresentTechnicalAlarmConditionsOptional& x);

    void
    PresentTechnicalAlarmConditions (::std::unique_ptr< PresentTechnicalAlarmConditionsType > p);

    // Constructors.
    //
    AlertSystemState (const DescriptorHandleType&,
                      const ActivationStateType&);

    AlertSystemState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    AlertSystemState (const AlertSystemState& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual AlertSystemState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertSystemState&
    operator= (const AlertSystemState& x);

    virtual 
    ~AlertSystemState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SystemSignalActivationSequence SystemSignalActivation_;
    LastSelfCheckOptional LastSelfCheck_;
    SelfCheckCountOptional SelfCheckCount_;
    PresentPhysiologicalAlarmConditionsOptional PresentPhysiologicalAlarmConditions_;
    PresentTechnicalAlarmConditionsOptional PresentTechnicalAlarmConditions_;
  };

  class CauseInfo: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // RemedyInfo
    //
    typedef ::CDM::RemedyInfo RemedyInfoType;
    typedef ::xsd::cxx::tree::optional< RemedyInfoType > RemedyInfoOptional;
    typedef ::xsd::cxx::tree::traits< RemedyInfoType, char > RemedyInfoTraits;

    const RemedyInfoOptional&
    RemedyInfo () const;

    RemedyInfoOptional&
    RemedyInfo ();

    void
    RemedyInfo (const RemedyInfoType& x);

    void
    RemedyInfo (const RemedyInfoOptional& x);

    void
    RemedyInfo (::std::unique_ptr< RemedyInfoType > p);

    // Description
    //
    typedef ::CDM::LocalizedText DescriptionType;
    typedef ::xsd::cxx::tree::sequence< DescriptionType > DescriptionSequence;
    typedef DescriptionSequence::iterator DescriptionIterator;
    typedef DescriptionSequence::const_iterator DescriptionConstIterator;
    typedef ::xsd::cxx::tree::traits< DescriptionType, char > DescriptionTraits;

    const DescriptionSequence&
    Description () const;

    DescriptionSequence&
    Description ();

    void
    Description (const DescriptionSequence& s);

    // Constructors.
    //
    CauseInfo ();

    CauseInfo (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    CauseInfo (const CauseInfo& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    virtual CauseInfo*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CauseInfo&
    operator= (const CauseInfo& x);

    virtual 
    ~CauseInfo ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    RemedyInfoOptional RemedyInfo_;
    DescriptionSequence Description_;
  };

  class RemedyInfo: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Description
    //
    typedef ::CDM::LocalizedText DescriptionType;
    typedef ::xsd::cxx::tree::sequence< DescriptionType > DescriptionSequence;
    typedef DescriptionSequence::iterator DescriptionIterator;
    typedef DescriptionSequence::const_iterator DescriptionConstIterator;
    typedef ::xsd::cxx::tree::traits< DescriptionType, char > DescriptionTraits;

    const DescriptionSequence&
    Description () const;

    DescriptionSequence&
    Description ();

    void
    Description (const DescriptionSequence& s);

    // Constructors.
    //
    RemedyInfo ();

    RemedyInfo (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    RemedyInfo (const RemedyInfo& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual RemedyInfo*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    RemedyInfo&
    operator= (const RemedyInfo& x);

    virtual 
    ~RemedyInfo ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    DescriptionSequence Description_;
  };

  class AlertConditionKind: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Phy,
      Tec,
      Oth
    };

    AlertConditionKind (Value v);

    AlertConditionKind (const char* v);

    AlertConditionKind (const ::std::string& v);

    AlertConditionKind (const ::xml_schema::String& v);

    AlertConditionKind (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    AlertConditionKind (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    AlertConditionKind (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    AlertConditionKind (const AlertConditionKind& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual AlertConditionKind*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertConditionKind&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_AlertConditionKind_convert ();
    }

    protected:
    Value
    _xsd_AlertConditionKind_convert () const;

    public:
    static const char* const _xsd_AlertConditionKind_literals_[3];
    static const Value _xsd_AlertConditionKind_indexes_[3];
  };

  class AlertConditionPriority: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Lo,
      Me,
      Hi,
      None
    };

    AlertConditionPriority (Value v);

    AlertConditionPriority (const char* v);

    AlertConditionPriority (const ::std::string& v);

    AlertConditionPriority (const ::xml_schema::String& v);

    AlertConditionPriority (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    AlertConditionPriority (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    AlertConditionPriority (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    AlertConditionPriority (const AlertConditionPriority& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    virtual AlertConditionPriority*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertConditionPriority&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_AlertConditionPriority_convert ();
    }

    protected:
    Value
    _xsd_AlertConditionPriority_convert () const;

    public:
    static const char* const _xsd_AlertConditionPriority_literals_[4];
    static const Value _xsd_AlertConditionPriority_indexes_[4];
  };

  class AlertConditionDescriptor: public ::CDM::AbstractAlertDescriptor
  {
    public:
    // Source
    //
    typedef ::CDM::HandleRef SourceType;
    typedef ::xsd::cxx::tree::sequence< SourceType > SourceSequence;
    typedef SourceSequence::iterator SourceIterator;
    typedef SourceSequence::const_iterator SourceConstIterator;
    typedef ::xsd::cxx::tree::traits< SourceType, char > SourceTraits;

    const SourceSequence&
    Source () const;

    SourceSequence&
    Source ();

    void
    Source (const SourceSequence& s);

    // CauseInfo
    //
    typedef ::CDM::CauseInfo CauseInfoType;
    typedef ::xsd::cxx::tree::sequence< CauseInfoType > CauseInfoSequence;
    typedef CauseInfoSequence::iterator CauseInfoIterator;
    typedef CauseInfoSequence::const_iterator CauseInfoConstIterator;
    typedef ::xsd::cxx::tree::traits< CauseInfoType, char > CauseInfoTraits;

    const CauseInfoSequence&
    CauseInfo () const;

    CauseInfoSequence&
    CauseInfo ();

    void
    CauseInfo (const CauseInfoSequence& s);

    // Kind
    //
    typedef ::CDM::AlertConditionKind KindType;
    typedef ::xsd::cxx::tree::traits< KindType, char > KindTraits;

    const KindType&
    Kind () const;

    KindType&
    Kind ();

    void
    Kind (const KindType& x);

    void
    Kind (::std::unique_ptr< KindType > p);

    // Priority
    //
    typedef ::CDM::AlertConditionPriority PriorityType;
    typedef ::xsd::cxx::tree::traits< PriorityType, char > PriorityTraits;

    const PriorityType&
    Priority () const;

    PriorityType&
    Priority ();

    void
    Priority (const PriorityType& x);

    void
    Priority (::std::unique_ptr< PriorityType > p);

    // Constructors.
    //
    AlertConditionDescriptor (const HandleType&,
                              const KindType&,
                              const PriorityType&);

    AlertConditionDescriptor (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    AlertConditionDescriptor (const AlertConditionDescriptor& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    virtual AlertConditionDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertConditionDescriptor&
    operator= (const AlertConditionDescriptor& x);

    virtual 
    ~AlertConditionDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SourceSequence Source_;
    CauseInfoSequence CauseInfo_;
    ::xsd::cxx::tree::one< KindType > Kind_;
    ::xsd::cxx::tree::one< PriorityType > Priority_;
  };

  class AlertConditionReference: public ::xml_schema::SimpleType,
    public ::xsd::cxx::tree::list< ::CDM::HandleRef, char >
  {
    public:
    AlertConditionReference ();

    AlertConditionReference (size_type n, const ::CDM::HandleRef& x);

    template < typename I >
    AlertConditionReference (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (begin, end, this)
    {
    }

    AlertConditionReference (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    AlertConditionReference (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    AlertConditionReference (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    AlertConditionReference (const AlertConditionReference& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual AlertConditionReference*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~AlertConditionReference ();
  };

  class AlertConditionState: public ::CDM::AbstractAlertState
  {
    public:
    // ActualPriority
    //
    typedef ::CDM::AlertConditionPriority ActualPriorityType;
    typedef ::xsd::cxx::tree::optional< ActualPriorityType > ActualPriorityOptional;
    typedef ::xsd::cxx::tree::traits< ActualPriorityType, char > ActualPriorityTraits;

    const ActualPriorityOptional&
    ActualPriority () const;

    ActualPriorityOptional&
    ActualPriority ();

    void
    ActualPriority (const ActualPriorityType& x);

    void
    ActualPriority (const ActualPriorityOptional& x);

    void
    ActualPriority (::std::unique_ptr< ActualPriorityType > p);

    // Rank
    //
    typedef ::xml_schema::Int RankType;
    typedef ::xsd::cxx::tree::optional< RankType > RankOptional;
    typedef ::xsd::cxx::tree::traits< RankType, char > RankTraits;

    const RankOptional&
    Rank () const;

    RankOptional&
    Rank ();

    void
    Rank (const RankType& x);

    void
    Rank (const RankOptional& x);

    // Presence
    //
    typedef ::xml_schema::Boolean PresenceType;
    typedef ::xsd::cxx::tree::traits< PresenceType, char > PresenceTraits;

    const PresenceType&
    Presence () const;

    PresenceType&
    Presence ();

    void
    Presence (const PresenceType& x);

    // DeterminationTime
    //
    typedef ::CDM::Timestamp DeterminationTimeType;
    typedef ::xsd::cxx::tree::optional< DeterminationTimeType > DeterminationTimeOptional;
    typedef ::xsd::cxx::tree::traits< DeterminationTimeType, char > DeterminationTimeTraits;

    const DeterminationTimeOptional&
    DeterminationTime () const;

    DeterminationTimeOptional&
    DeterminationTime ();

    void
    DeterminationTime (const DeterminationTimeType& x);

    void
    DeterminationTime (const DeterminationTimeOptional& x);

    void
    DeterminationTime (::std::unique_ptr< DeterminationTimeType > p);

    // Constructors.
    //
    AlertConditionState (const DescriptorHandleType&,
                         const ActivationStateType&,
                         const PresenceType&);

    AlertConditionState (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    AlertConditionState (const AlertConditionState& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual AlertConditionState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertConditionState&
    operator= (const AlertConditionState& x);

    virtual 
    ~AlertConditionState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ActualPriorityOptional ActualPriority_;
    RankOptional Rank_;
    ::xsd::cxx::tree::one< PresenceType > Presence_;
    DeterminationTimeOptional DeterminationTime_;
  };

  class LimitAlertConditionDescriptor: public ::CDM::AlertConditionDescriptor
  {
    public:
    // MaxLimits
    //
    typedef ::CDM::Range MaxLimitsType;
    typedef ::xsd::cxx::tree::traits< MaxLimitsType, char > MaxLimitsTraits;

    const MaxLimitsType&
    MaxLimits () const;

    MaxLimitsType&
    MaxLimits ();

    void
    MaxLimits (const MaxLimitsType& x);

    void
    MaxLimits (::std::unique_ptr< MaxLimitsType > p);

    // AutoLimitSupported
    //
    typedef ::xml_schema::Boolean AutoLimitSupportedType;
    typedef ::xsd::cxx::tree::optional< AutoLimitSupportedType > AutoLimitSupportedOptional;
    typedef ::xsd::cxx::tree::traits< AutoLimitSupportedType, char > AutoLimitSupportedTraits;

    const AutoLimitSupportedOptional&
    AutoLimitSupported () const;

    AutoLimitSupportedOptional&
    AutoLimitSupported ();

    void
    AutoLimitSupported (const AutoLimitSupportedType& x);

    void
    AutoLimitSupported (const AutoLimitSupportedOptional& x);

    // Constructors.
    //
    LimitAlertConditionDescriptor (const HandleType&,
                                   const KindType&,
                                   const PriorityType&,
                                   const MaxLimitsType&);

    LimitAlertConditionDescriptor (const HandleType&,
                                   const KindType&,
                                   const PriorityType&,
                                   ::std::unique_ptr< MaxLimitsType >);

    LimitAlertConditionDescriptor (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    LimitAlertConditionDescriptor (const LimitAlertConditionDescriptor& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    virtual LimitAlertConditionDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    LimitAlertConditionDescriptor&
    operator= (const LimitAlertConditionDescriptor& x);

    virtual 
    ~LimitAlertConditionDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< MaxLimitsType > MaxLimits_;
    AutoLimitSupportedOptional AutoLimitSupported_;
  };

  class AlertConditionMonitoredLimits: public ::xml_schema::String
  {
    public:
    enum Value
    {
      All,
      LoOff,
      HiOff,
      None
    };

    AlertConditionMonitoredLimits (Value v);

    AlertConditionMonitoredLimits (const char* v);

    AlertConditionMonitoredLimits (const ::std::string& v);

    AlertConditionMonitoredLimits (const ::xml_schema::String& v);

    AlertConditionMonitoredLimits (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    AlertConditionMonitoredLimits (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    AlertConditionMonitoredLimits (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    AlertConditionMonitoredLimits (const AlertConditionMonitoredLimits& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    virtual AlertConditionMonitoredLimits*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertConditionMonitoredLimits&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_AlertConditionMonitoredLimits_convert ();
    }

    protected:
    Value
    _xsd_AlertConditionMonitoredLimits_convert () const;

    public:
    static const char* const _xsd_AlertConditionMonitoredLimits_literals_[4];
    static const Value _xsd_AlertConditionMonitoredLimits_indexes_[4];
  };

  class LimitAlertConditionState: public ::CDM::AlertConditionState
  {
    public:
    // Limits
    //
    typedef ::CDM::Range LimitsType;
    typedef ::xsd::cxx::tree::traits< LimitsType, char > LimitsTraits;

    const LimitsType&
    Limits () const;

    LimitsType&
    Limits ();

    void
    Limits (const LimitsType& x);

    void
    Limits (::std::unique_ptr< LimitsType > p);

    // MonitoredAlertLimits
    //
    typedef ::CDM::AlertConditionMonitoredLimits MonitoredAlertLimitsType;
    typedef ::xsd::cxx::tree::traits< MonitoredAlertLimitsType, char > MonitoredAlertLimitsTraits;

    const MonitoredAlertLimitsType&
    MonitoredAlertLimits () const;

    MonitoredAlertLimitsType&
    MonitoredAlertLimits ();

    void
    MonitoredAlertLimits (const MonitoredAlertLimitsType& x);

    void
    MonitoredAlertLimits (::std::unique_ptr< MonitoredAlertLimitsType > p);

    // AutoLimitActivationState
    //
    typedef ::CDM::AlertActivation AutoLimitActivationStateType;
    typedef ::xsd::cxx::tree::optional< AutoLimitActivationStateType > AutoLimitActivationStateOptional;
    typedef ::xsd::cxx::tree::traits< AutoLimitActivationStateType, char > AutoLimitActivationStateTraits;

    const AutoLimitActivationStateOptional&
    AutoLimitActivationState () const;

    AutoLimitActivationStateOptional&
    AutoLimitActivationState ();

    void
    AutoLimitActivationState (const AutoLimitActivationStateType& x);

    void
    AutoLimitActivationState (const AutoLimitActivationStateOptional& x);

    void
    AutoLimitActivationState (::std::unique_ptr< AutoLimitActivationStateType > p);

    // Constructors.
    //
    LimitAlertConditionState (const DescriptorHandleType&,
                              const ActivationStateType&,
                              const PresenceType&,
                              const LimitsType&,
                              const MonitoredAlertLimitsType&);

    LimitAlertConditionState (const DescriptorHandleType&,
                              const ActivationStateType&,
                              const PresenceType&,
                              ::std::unique_ptr< LimitsType >,
                              const MonitoredAlertLimitsType&);

    LimitAlertConditionState (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    LimitAlertConditionState (const LimitAlertConditionState& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    virtual LimitAlertConditionState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    LimitAlertConditionState&
    operator= (const LimitAlertConditionState& x);

    virtual 
    ~LimitAlertConditionState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< LimitsType > Limits_;
    ::xsd::cxx::tree::one< MonitoredAlertLimitsType > MonitoredAlertLimits_;
    AutoLimitActivationStateOptional AutoLimitActivationState_;
  };

  class AlertSignalManifestation: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Aud,
      Vis,
      Tan,
      Oth
    };

    AlertSignalManifestation (Value v);

    AlertSignalManifestation (const char* v);

    AlertSignalManifestation (const ::std::string& v);

    AlertSignalManifestation (const ::xml_schema::String& v);

    AlertSignalManifestation (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    AlertSignalManifestation (const ::xercesc::DOMAttr& a,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    AlertSignalManifestation (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    AlertSignalManifestation (const AlertSignalManifestation& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    virtual AlertSignalManifestation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertSignalManifestation&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_AlertSignalManifestation_convert ();
    }

    protected:
    Value
    _xsd_AlertSignalManifestation_convert () const;

    public:
    static const char* const _xsd_AlertSignalManifestation_literals_[4];
    static const Value _xsd_AlertSignalManifestation_indexes_[4];
  };

  class AlertSignalDescriptor: public ::CDM::AbstractAlertDescriptor
  {
    public:
    // ConditionSignaled
    //
    typedef ::CDM::HandleRef ConditionSignaledType;
    typedef ::xsd::cxx::tree::traits< ConditionSignaledType, char > ConditionSignaledTraits;

    const ConditionSignaledType&
    ConditionSignaled () const;

    ConditionSignaledType&
    ConditionSignaled ();

    void
    ConditionSignaled (const ConditionSignaledType& x);

    void
    ConditionSignaled (::std::unique_ptr< ConditionSignaledType > p);

    // Manifestation
    //
    typedef ::CDM::AlertSignalManifestation ManifestationType;
    typedef ::xsd::cxx::tree::traits< ManifestationType, char > ManifestationTraits;

    const ManifestationType&
    Manifestation () const;

    ManifestationType&
    Manifestation ();

    void
    Manifestation (const ManifestationType& x);

    void
    Manifestation (::std::unique_ptr< ManifestationType > p);

    // Latching
    //
    typedef ::xml_schema::Boolean LatchingType;
    typedef ::xsd::cxx::tree::traits< LatchingType, char > LatchingTraits;

    const LatchingType&
    Latching () const;

    LatchingType&
    Latching ();

    void
    Latching (const LatchingType& x);

    // DefaultSignalGenerationDelay
    //
    typedef ::xml_schema::Duration DefaultSignalGenerationDelayType;
    typedef ::xsd::cxx::tree::optional< DefaultSignalGenerationDelayType > DefaultSignalGenerationDelayOptional;
    typedef ::xsd::cxx::tree::traits< DefaultSignalGenerationDelayType, char > DefaultSignalGenerationDelayTraits;

    const DefaultSignalGenerationDelayOptional&
    DefaultSignalGenerationDelay () const;

    DefaultSignalGenerationDelayOptional&
    DefaultSignalGenerationDelay ();

    void
    DefaultSignalGenerationDelay (const DefaultSignalGenerationDelayType& x);

    void
    DefaultSignalGenerationDelay (const DefaultSignalGenerationDelayOptional& x);

    void
    DefaultSignalGenerationDelay (::std::unique_ptr< DefaultSignalGenerationDelayType > p);

    // SignalDelegationSupported
    //
    typedef ::xml_schema::Boolean SignalDelegationSupportedType;
    typedef ::xsd::cxx::tree::optional< SignalDelegationSupportedType > SignalDelegationSupportedOptional;
    typedef ::xsd::cxx::tree::traits< SignalDelegationSupportedType, char > SignalDelegationSupportedTraits;

    const SignalDelegationSupportedOptional&
    SignalDelegationSupported () const;

    SignalDelegationSupportedOptional&
    SignalDelegationSupported ();

    void
    SignalDelegationSupported (const SignalDelegationSupportedType& x);

    void
    SignalDelegationSupported (const SignalDelegationSupportedOptional& x);

    // AcknowledgementSupported
    //
    typedef ::xml_schema::Boolean AcknowledgementSupportedType;
    typedef ::xsd::cxx::tree::optional< AcknowledgementSupportedType > AcknowledgementSupportedOptional;
    typedef ::xsd::cxx::tree::traits< AcknowledgementSupportedType, char > AcknowledgementSupportedTraits;

    const AcknowledgementSupportedOptional&
    AcknowledgementSupported () const;

    AcknowledgementSupportedOptional&
    AcknowledgementSupported ();

    void
    AcknowledgementSupported (const AcknowledgementSupportedType& x);

    void
    AcknowledgementSupported (const AcknowledgementSupportedOptional& x);

    // AcknowledgeTimeout
    //
    typedef ::xml_schema::Duration AcknowledgeTimeoutType;
    typedef ::xsd::cxx::tree::optional< AcknowledgeTimeoutType > AcknowledgeTimeoutOptional;
    typedef ::xsd::cxx::tree::traits< AcknowledgeTimeoutType, char > AcknowledgeTimeoutTraits;

    const AcknowledgeTimeoutOptional&
    AcknowledgeTimeout () const;

    AcknowledgeTimeoutOptional&
    AcknowledgeTimeout ();

    void
    AcknowledgeTimeout (const AcknowledgeTimeoutType& x);

    void
    AcknowledgeTimeout (const AcknowledgeTimeoutOptional& x);

    void
    AcknowledgeTimeout (::std::unique_ptr< AcknowledgeTimeoutType > p);

    // Constructors.
    //
    AlertSignalDescriptor (const HandleType&,
                           const ConditionSignaledType&,
                           const ManifestationType&,
                           const LatchingType&);

    AlertSignalDescriptor (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    AlertSignalDescriptor (const AlertSignalDescriptor& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual AlertSignalDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertSignalDescriptor&
    operator= (const AlertSignalDescriptor& x);

    virtual 
    ~AlertSignalDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ConditionSignaledType > ConditionSignaled_;
    ::xsd::cxx::tree::one< ManifestationType > Manifestation_;
    ::xsd::cxx::tree::one< LatchingType > Latching_;
    DefaultSignalGenerationDelayOptional DefaultSignalGenerationDelay_;
    SignalDelegationSupportedOptional SignalDelegationSupported_;
    AcknowledgementSupportedOptional AcknowledgementSupported_;
    AcknowledgeTimeoutOptional AcknowledgeTimeout_;
  };

  class AlertSignalPresence: public ::xml_schema::String
  {
    public:
    enum Value
    {
      On,
      Off,
      Latch,
      Ack
    };

    AlertSignalPresence (Value v);

    AlertSignalPresence (const char* v);

    AlertSignalPresence (const ::std::string& v);

    AlertSignalPresence (const ::xml_schema::String& v);

    AlertSignalPresence (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    AlertSignalPresence (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    AlertSignalPresence (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    AlertSignalPresence (const AlertSignalPresence& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual AlertSignalPresence*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertSignalPresence&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_AlertSignalPresence_convert ();
    }

    protected:
    Value
    _xsd_AlertSignalPresence_convert () const;

    public:
    static const char* const _xsd_AlertSignalPresence_literals_[4];
    static const Value _xsd_AlertSignalPresence_indexes_[4];
  };

  class AlertSignalPrimaryLocation: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Loc,
      Rem
    };

    AlertSignalPrimaryLocation (Value v);

    AlertSignalPrimaryLocation (const char* v);

    AlertSignalPrimaryLocation (const ::std::string& v);

    AlertSignalPrimaryLocation (const ::xml_schema::String& v);

    AlertSignalPrimaryLocation (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    AlertSignalPrimaryLocation (const ::xercesc::DOMAttr& a,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    AlertSignalPrimaryLocation (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    AlertSignalPrimaryLocation (const AlertSignalPrimaryLocation& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    virtual AlertSignalPrimaryLocation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertSignalPrimaryLocation&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_AlertSignalPrimaryLocation_convert ();
    }

    protected:
    Value
    _xsd_AlertSignalPrimaryLocation_convert () const;

    public:
    static const char* const _xsd_AlertSignalPrimaryLocation_literals_[2];
    static const Value _xsd_AlertSignalPrimaryLocation_indexes_[2];
  };

  class AlertSignalState: public ::CDM::AbstractAlertState
  {
    public:
    // Presence
    //
    typedef ::CDM::AlertSignalPresence PresenceType;
    typedef ::xsd::cxx::tree::optional< PresenceType > PresenceOptional;
    typedef ::xsd::cxx::tree::traits< PresenceType, char > PresenceTraits;

    const PresenceOptional&
    Presence () const;

    PresenceOptional&
    Presence ();

    void
    Presence (const PresenceType& x);

    void
    Presence (const PresenceOptional& x);

    void
    Presence (::std::unique_ptr< PresenceType > p);

    // Location
    //
    typedef ::CDM::AlertSignalPrimaryLocation LocationType;
    typedef ::xsd::cxx::tree::optional< LocationType > LocationOptional;
    typedef ::xsd::cxx::tree::traits< LocationType, char > LocationTraits;

    const LocationOptional&
    Location () const;

    LocationOptional&
    Location ();

    void
    Location (const LocationType& x);

    void
    Location (const LocationOptional& x);

    void
    Location (::std::unique_ptr< LocationType > p);

    // Slot
    //
    typedef ::xml_schema::UnsignedInt SlotType;
    typedef ::xsd::cxx::tree::optional< SlotType > SlotOptional;
    typedef ::xsd::cxx::tree::traits< SlotType, char > SlotTraits;

    const SlotOptional&
    Slot () const;

    SlotOptional&
    Slot ();

    void
    Slot (const SlotType& x);

    void
    Slot (const SlotOptional& x);

    // Constructors.
    //
    AlertSignalState (const DescriptorHandleType&,
                      const ActivationStateType&);

    AlertSignalState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    AlertSignalState (const AlertSignalState& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual AlertSignalState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertSignalState&
    operator= (const AlertSignalState& x);

    virtual 
    ~AlertSignalState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    PresenceOptional Presence_;
    LocationOptional Location_;
    SlotOptional Slot_;
  };

  class QualityIndicator: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >
  {
    public:
    // Constructors.
    //
    QualityIndicator (const ::xml_schema::Decimal&);

    QualityIndicator (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    QualityIndicator (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    QualityIndicator (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    QualityIndicator (const QualityIndicator& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual QualityIndicator*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~QualityIndicator ();
  };

  class GenerationMode: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Real,
      Test,
      Demo
    };

    GenerationMode (Value v);

    GenerationMode (const char* v);

    GenerationMode (const ::std::string& v);

    GenerationMode (const ::xml_schema::String& v);

    GenerationMode (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    GenerationMode (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    GenerationMode (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    GenerationMode (const GenerationMode& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual GenerationMode*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    GenerationMode&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_GenerationMode_convert ();
    }

    protected:
    Value
    _xsd_GenerationMode_convert () const;

    public:
    static const char* const _xsd_GenerationMode_literals_[3];
    static const Value _xsd_GenerationMode_indexes_[3];
  };

  class AbstractMetricValue: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // MetricQuality
    //
    typedef ::CDM::MetricQuality MetricQualityType;
    typedef ::xsd::cxx::tree::traits< MetricQualityType, char > MetricQualityTraits;

    const MetricQualityType&
    MetricQuality () const;

    MetricQualityType&
    MetricQuality ();

    void
    MetricQuality (const MetricQualityType& x);

    void
    MetricQuality (::std::unique_ptr< MetricQualityType > p);

    // Annotation
    //
    typedef ::CDM::Annotation AnnotationType;
    typedef ::xsd::cxx::tree::sequence< AnnotationType > AnnotationSequence;
    typedef AnnotationSequence::iterator AnnotationIterator;
    typedef AnnotationSequence::const_iterator AnnotationConstIterator;
    typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

    const AnnotationSequence&
    Annotation () const;

    AnnotationSequence&
    Annotation ();

    void
    Annotation (const AnnotationSequence& s);

    // StartTime
    //
    typedef ::CDM::Timestamp StartTimeType;
    typedef ::xsd::cxx::tree::optional< StartTimeType > StartTimeOptional;
    typedef ::xsd::cxx::tree::traits< StartTimeType, char > StartTimeTraits;

    const StartTimeOptional&
    StartTime () const;

    StartTimeOptional&
    StartTime ();

    void
    StartTime (const StartTimeType& x);

    void
    StartTime (const StartTimeOptional& x);

    void
    StartTime (::std::unique_ptr< StartTimeType > p);

    // StopTime
    //
    typedef ::CDM::Timestamp StopTimeType;
    typedef ::xsd::cxx::tree::optional< StopTimeType > StopTimeOptional;
    typedef ::xsd::cxx::tree::traits< StopTimeType, char > StopTimeTraits;

    const StopTimeOptional&
    StopTime () const;

    StopTimeOptional&
    StopTime ();

    void
    StopTime (const StopTimeType& x);

    void
    StopTime (const StopTimeOptional& x);

    void
    StopTime (::std::unique_ptr< StopTimeType > p);

    // DeterminationTime
    //
    typedef ::CDM::Timestamp DeterminationTimeType;
    typedef ::xsd::cxx::tree::optional< DeterminationTimeType > DeterminationTimeOptional;
    typedef ::xsd::cxx::tree::traits< DeterminationTimeType, char > DeterminationTimeTraits;

    const DeterminationTimeOptional&
    DeterminationTime () const;

    DeterminationTimeOptional&
    DeterminationTime ();

    void
    DeterminationTime (const DeterminationTimeType& x);

    void
    DeterminationTime (const DeterminationTimeOptional& x);

    void
    DeterminationTime (::std::unique_ptr< DeterminationTimeType > p);

    // Constructors.
    //
    AbstractMetricValue (const MetricQualityType&);

    AbstractMetricValue (::std::unique_ptr< MetricQualityType >);

    AbstractMetricValue (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    AbstractMetricValue (const AbstractMetricValue& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual AbstractMetricValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractMetricValue&
    operator= (const AbstractMetricValue& x);

    virtual 
    ~AbstractMetricValue ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< MetricQualityType > MetricQuality_;
    AnnotationSequence Annotation_;
    StartTimeOptional StartTime_;
    StopTimeOptional StopTime_;
    DeterminationTimeOptional DeterminationTime_;
  };

  class NumericMetricValue: public ::CDM::AbstractMetricValue
  {
    public:
    // Value
    //
    typedef ::xml_schema::Decimal ValueType;
    typedef ::xsd::cxx::tree::optional< ValueType > ValueOptional;
    typedef ::xsd::cxx::tree::traits< ValueType, char, ::xsd::cxx::tree::schema_type::decimal > ValueTraits;

    const ValueOptional&
    Value () const;

    ValueOptional&
    Value ();

    void
    Value (const ValueType& x);

    void
    Value (const ValueOptional& x);

    // Constructors.
    //
    NumericMetricValue (const MetricQualityType&);

    NumericMetricValue (::std::unique_ptr< MetricQualityType >);

    NumericMetricValue (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    NumericMetricValue (const NumericMetricValue& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual NumericMetricValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    NumericMetricValue&
    operator= (const NumericMetricValue& x);

    virtual 
    ~NumericMetricValue ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ValueOptional Value_;
  };

  class StringMetricValue: public ::CDM::AbstractMetricValue
  {
    public:
    // Value
    //
    typedef ::xml_schema::String ValueType;
    typedef ::xsd::cxx::tree::optional< ValueType > ValueOptional;
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    const ValueOptional&
    Value () const;

    ValueOptional&
    Value ();

    void
    Value (const ValueType& x);

    void
    Value (const ValueOptional& x);

    void
    Value (::std::unique_ptr< ValueType > p);

    // Constructors.
    //
    StringMetricValue (const MetricQualityType&);

    StringMetricValue (::std::unique_ptr< MetricQualityType >);

    StringMetricValue (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    StringMetricValue (const StringMetricValue& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual StringMetricValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    StringMetricValue&
    operator= (const StringMetricValue& x);

    virtual 
    ~StringMetricValue ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ValueOptional Value_;
  };

  class RealTimeValueType: public ::xml_schema::SimpleType,
    public ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal >
  {
    public:
    RealTimeValueType ();

    RealTimeValueType (size_type n, const ::xml_schema::Decimal& x);

    template < typename I >
    RealTimeValueType (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal > (begin, end, this)
    {
    }

    RealTimeValueType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    RealTimeValueType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    RealTimeValueType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    RealTimeValueType (const RealTimeValueType& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual RealTimeValueType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~RealTimeValueType ();
  };

  class SampleArrayValue: public ::CDM::AbstractMetricValue
  {
    public:
    // ApplyAnnotation
    //
    typedef ::CDM::ApplyAnnotation ApplyAnnotationType;
    typedef ::xsd::cxx::tree::sequence< ApplyAnnotationType > ApplyAnnotationSequence;
    typedef ApplyAnnotationSequence::iterator ApplyAnnotationIterator;
    typedef ApplyAnnotationSequence::const_iterator ApplyAnnotationConstIterator;
    typedef ::xsd::cxx::tree::traits< ApplyAnnotationType, char > ApplyAnnotationTraits;

    const ApplyAnnotationSequence&
    ApplyAnnotation () const;

    ApplyAnnotationSequence&
    ApplyAnnotation ();

    void
    ApplyAnnotation (const ApplyAnnotationSequence& s);

    // Samples
    //
    typedef ::CDM::RealTimeValueType SamplesType;
    typedef ::xsd::cxx::tree::optional< SamplesType > SamplesOptional;
    typedef ::xsd::cxx::tree::traits< SamplesType, char > SamplesTraits;

    const SamplesOptional&
    Samples () const;

    SamplesOptional&
    Samples ();

    void
    Samples (const SamplesType& x);

    void
    Samples (const SamplesOptional& x);

    void
    Samples (::std::unique_ptr< SamplesType > p);

    // Constructors.
    //
    SampleArrayValue (const MetricQualityType&);

    SampleArrayValue (::std::unique_ptr< MetricQualityType >);

    SampleArrayValue (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    SampleArrayValue (const SampleArrayValue& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual SampleArrayValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SampleArrayValue&
    operator= (const SampleArrayValue& x);

    virtual 
    ~SampleArrayValue ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ApplyAnnotationSequence ApplyAnnotation_;
    SamplesOptional Samples_;
  };

  class MetricCategory: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Unspec,
      Msrmt,
      Clc,
      Set,
      Preset,
      Rcmm
    };

    MetricCategory (Value v);

    MetricCategory (const char* v);

    MetricCategory (const ::std::string& v);

    MetricCategory (const ::xml_schema::String& v);

    MetricCategory (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    MetricCategory (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    MetricCategory (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    MetricCategory (const MetricCategory& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual MetricCategory*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MetricCategory&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_MetricCategory_convert ();
    }

    protected:
    Value
    _xsd_MetricCategory_convert () const;

    public:
    static const char* const _xsd_MetricCategory_literals_[6];
    static const Value _xsd_MetricCategory_indexes_[6];
  };

  class DerivationMethod: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Auto,
      Man
    };

    DerivationMethod (Value v);

    DerivationMethod (const char* v);

    DerivationMethod (const ::std::string& v);

    DerivationMethod (const ::xml_schema::String& v);

    DerivationMethod (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    DerivationMethod (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    DerivationMethod (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    DerivationMethod (const DerivationMethod& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual DerivationMethod*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    DerivationMethod&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_DerivationMethod_convert ();
    }

    protected:
    Value
    _xsd_DerivationMethod_convert () const;

    public:
    static const char* const _xsd_DerivationMethod_literals_[2];
    static const Value _xsd_DerivationMethod_indexes_[2];
  };

  class MetricAvailability: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Intr,
      Cont
    };

    MetricAvailability (Value v);

    MetricAvailability (const char* v);

    MetricAvailability (const ::std::string& v);

    MetricAvailability (const ::xml_schema::String& v);

    MetricAvailability (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    MetricAvailability (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    MetricAvailability (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    MetricAvailability (const MetricAvailability& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual MetricAvailability*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MetricAvailability&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_MetricAvailability_convert ();
    }

    protected:
    Value
    _xsd_MetricAvailability_convert () const;

    public:
    static const char* const _xsd_MetricAvailability_literals_[2];
    static const Value _xsd_MetricAvailability_indexes_[2];
  };

  class AbstractMetricDescriptor: public ::CDM::AbstractDescriptor
  {
    public:
    // Unit
    //
    typedef ::CDM::CodedValue UnitType;
    typedef ::xsd::cxx::tree::traits< UnitType, char > UnitTraits;

    const UnitType&
    Unit () const;

    UnitType&
    Unit ();

    void
    Unit (const UnitType& x);

    void
    Unit (::std::unique_ptr< UnitType > p);

    // BodySite
    //
    typedef ::CDM::CodedValue BodySiteType;
    typedef ::xsd::cxx::tree::sequence< BodySiteType > BodySiteSequence;
    typedef BodySiteSequence::iterator BodySiteIterator;
    typedef BodySiteSequence::const_iterator BodySiteConstIterator;
    typedef ::xsd::cxx::tree::traits< BodySiteType, char > BodySiteTraits;

    const BodySiteSequence&
    BodySite () const;

    BodySiteSequence&
    BodySite ();

    void
    BodySite (const BodySiteSequence& s);

    // MetricCategory
    //
    typedef ::CDM::MetricCategory MetricCategoryType;
    typedef ::xsd::cxx::tree::traits< MetricCategoryType, char > MetricCategoryTraits;

    const MetricCategoryType&
    MetricCategory () const;

    MetricCategoryType&
    MetricCategory ();

    void
    MetricCategory (const MetricCategoryType& x);

    void
    MetricCategory (::std::unique_ptr< MetricCategoryType > p);

    // DerivationMethod
    //
    typedef ::CDM::DerivationMethod DerivationMethodType;
    typedef ::xsd::cxx::tree::optional< DerivationMethodType > DerivationMethodOptional;
    typedef ::xsd::cxx::tree::traits< DerivationMethodType, char > DerivationMethodTraits;

    const DerivationMethodOptional&
    DerivationMethod () const;

    DerivationMethodOptional&
    DerivationMethod ();

    void
    DerivationMethod (const DerivationMethodType& x);

    void
    DerivationMethod (const DerivationMethodOptional& x);

    void
    DerivationMethod (::std::unique_ptr< DerivationMethodType > p);

    // MetricAvailability
    //
    typedef ::CDM::MetricAvailability MetricAvailabilityType;
    typedef ::xsd::cxx::tree::traits< MetricAvailabilityType, char > MetricAvailabilityTraits;

    const MetricAvailabilityType&
    MetricAvailability () const;

    MetricAvailabilityType&
    MetricAvailability ();

    void
    MetricAvailability (const MetricAvailabilityType& x);

    void
    MetricAvailability (::std::unique_ptr< MetricAvailabilityType > p);

    // MaxMeasurementTime
    //
    typedef ::xml_schema::Duration MaxMeasurementTimeType;
    typedef ::xsd::cxx::tree::optional< MaxMeasurementTimeType > MaxMeasurementTimeOptional;
    typedef ::xsd::cxx::tree::traits< MaxMeasurementTimeType, char > MaxMeasurementTimeTraits;

    const MaxMeasurementTimeOptional&
    MaxMeasurementTime () const;

    MaxMeasurementTimeOptional&
    MaxMeasurementTime ();

    void
    MaxMeasurementTime (const MaxMeasurementTimeType& x);

    void
    MaxMeasurementTime (const MaxMeasurementTimeOptional& x);

    void
    MaxMeasurementTime (::std::unique_ptr< MaxMeasurementTimeType > p);

    // MaxDelayTime
    //
    typedef ::xml_schema::Duration MaxDelayTimeType;
    typedef ::xsd::cxx::tree::optional< MaxDelayTimeType > MaxDelayTimeOptional;
    typedef ::xsd::cxx::tree::traits< MaxDelayTimeType, char > MaxDelayTimeTraits;

    const MaxDelayTimeOptional&
    MaxDelayTime () const;

    MaxDelayTimeOptional&
    MaxDelayTime ();

    void
    MaxDelayTime (const MaxDelayTimeType& x);

    void
    MaxDelayTime (const MaxDelayTimeOptional& x);

    void
    MaxDelayTime (::std::unique_ptr< MaxDelayTimeType > p);

    // DeterminationPeriod
    //
    typedef ::xml_schema::Duration DeterminationPeriodType;
    typedef ::xsd::cxx::tree::optional< DeterminationPeriodType > DeterminationPeriodOptional;
    typedef ::xsd::cxx::tree::traits< DeterminationPeriodType, char > DeterminationPeriodTraits;

    const DeterminationPeriodOptional&
    DeterminationPeriod () const;

    DeterminationPeriodOptional&
    DeterminationPeriod ();

    void
    DeterminationPeriod (const DeterminationPeriodType& x);

    void
    DeterminationPeriod (const DeterminationPeriodOptional& x);

    void
    DeterminationPeriod (::std::unique_ptr< DeterminationPeriodType > p);

    // LifeTimePeriod
    //
    typedef ::xml_schema::Duration LifeTimePeriodType;
    typedef ::xsd::cxx::tree::optional< LifeTimePeriodType > LifeTimePeriodOptional;
    typedef ::xsd::cxx::tree::traits< LifeTimePeriodType, char > LifeTimePeriodTraits;

    const LifeTimePeriodOptional&
    LifeTimePeriod () const;

    LifeTimePeriodOptional&
    LifeTimePeriod ();

    void
    LifeTimePeriod (const LifeTimePeriodType& x);

    void
    LifeTimePeriod (const LifeTimePeriodOptional& x);

    void
    LifeTimePeriod (::std::unique_ptr< LifeTimePeriodType > p);

    // Constructors.
    //
    AbstractMetricDescriptor (const HandleType&,
                              const UnitType&,
                              const MetricCategoryType&,
                              const MetricAvailabilityType&);

    AbstractMetricDescriptor (const HandleType&,
                              ::std::unique_ptr< UnitType >,
                              const MetricCategoryType&,
                              const MetricAvailabilityType&);

    AbstractMetricDescriptor (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    AbstractMetricDescriptor (const AbstractMetricDescriptor& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    virtual AbstractMetricDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractMetricDescriptor&
    operator= (const AbstractMetricDescriptor& x);

    virtual 
    ~AbstractMetricDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< UnitType > Unit_;
    BodySiteSequence BodySite_;
    ::xsd::cxx::tree::one< MetricCategoryType > MetricCategory_;
    DerivationMethodOptional DerivationMethod_;
    ::xsd::cxx::tree::one< MetricAvailabilityType > MetricAvailability_;
    MaxMeasurementTimeOptional MaxMeasurementTime_;
    MaxDelayTimeOptional MaxDelayTime_;
    DeterminationPeriodOptional DeterminationPeriod_;
    LifeTimePeriodOptional LifeTimePeriod_;
  };

  class AbstractMetricState: public ::CDM::AbstractState
  {
    public:
    // BodySite
    //
    typedef ::CDM::CodedValue BodySiteType;
    typedef ::xsd::cxx::tree::sequence< BodySiteType > BodySiteSequence;
    typedef BodySiteSequence::iterator BodySiteIterator;
    typedef BodySiteSequence::const_iterator BodySiteConstIterator;
    typedef ::xsd::cxx::tree::traits< BodySiteType, char > BodySiteTraits;

    const BodySiteSequence&
    BodySite () const;

    BodySiteSequence&
    BodySite ();

    void
    BodySite (const BodySiteSequence& s);

    // ActivationState
    //
    typedef ::CDM::ComponentActivation ActivationStateType;
    typedef ::xsd::cxx::tree::optional< ActivationStateType > ActivationStateOptional;
    typedef ::xsd::cxx::tree::traits< ActivationStateType, char > ActivationStateTraits;

    const ActivationStateOptional&
    ActivationState () const;

    ActivationStateOptional&
    ActivationState ();

    void
    ActivationState (const ActivationStateType& x);

    void
    ActivationState (const ActivationStateOptional& x);

    void
    ActivationState (::std::unique_ptr< ActivationStateType > p);

    // ActiveDeterminationPeriod
    //
    typedef ::xml_schema::Duration ActiveDeterminationPeriodType;
    typedef ::xsd::cxx::tree::optional< ActiveDeterminationPeriodType > ActiveDeterminationPeriodOptional;
    typedef ::xsd::cxx::tree::traits< ActiveDeterminationPeriodType, char > ActiveDeterminationPeriodTraits;

    const ActiveDeterminationPeriodOptional&
    ActiveDeterminationPeriod () const;

    ActiveDeterminationPeriodOptional&
    ActiveDeterminationPeriod ();

    void
    ActiveDeterminationPeriod (const ActiveDeterminationPeriodType& x);

    void
    ActiveDeterminationPeriod (const ActiveDeterminationPeriodOptional& x);

    void
    ActiveDeterminationPeriod (::std::unique_ptr< ActiveDeterminationPeriodType > p);

    // LifeTimePeriod
    //
    typedef ::xml_schema::Duration LifeTimePeriodType;
    typedef ::xsd::cxx::tree::optional< LifeTimePeriodType > LifeTimePeriodOptional;
    typedef ::xsd::cxx::tree::traits< LifeTimePeriodType, char > LifeTimePeriodTraits;

    const LifeTimePeriodOptional&
    LifeTimePeriod () const;

    LifeTimePeriodOptional&
    LifeTimePeriod ();

    void
    LifeTimePeriod (const LifeTimePeriodType& x);

    void
    LifeTimePeriod (const LifeTimePeriodOptional& x);

    void
    LifeTimePeriod (::std::unique_ptr< LifeTimePeriodType > p);

    // Constructors.
    //
    AbstractMetricState (const DescriptorHandleType&);

    AbstractMetricState (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    AbstractMetricState (const AbstractMetricState& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual AbstractMetricState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractMetricState&
    operator= (const AbstractMetricState& x);

    virtual 
    ~AbstractMetricState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    BodySiteSequence BodySite_;
    ActivationStateOptional ActivationState_;
    ActiveDeterminationPeriodOptional ActiveDeterminationPeriod_;
    LifeTimePeriodOptional LifeTimePeriod_;
  };

  class NumericMetricDescriptor: public ::CDM::AbstractMetricDescriptor
  {
    public:
    // TechnicalRange
    //
    typedef ::CDM::Range TechnicalRangeType;
    typedef ::xsd::cxx::tree::sequence< TechnicalRangeType > TechnicalRangeSequence;
    typedef TechnicalRangeSequence::iterator TechnicalRangeIterator;
    typedef TechnicalRangeSequence::const_iterator TechnicalRangeConstIterator;
    typedef ::xsd::cxx::tree::traits< TechnicalRangeType, char > TechnicalRangeTraits;

    const TechnicalRangeSequence&
    TechnicalRange () const;

    TechnicalRangeSequence&
    TechnicalRange ();

    void
    TechnicalRange (const TechnicalRangeSequence& s);

    // Resolution
    //
    typedef ::xml_schema::Decimal ResolutionType;
    typedef ::xsd::cxx::tree::optional< ResolutionType > ResolutionOptional;
    typedef ::xsd::cxx::tree::traits< ResolutionType, char, ::xsd::cxx::tree::schema_type::decimal > ResolutionTraits;

    const ResolutionOptional&
    Resolution () const;

    ResolutionOptional&
    Resolution ();

    void
    Resolution (const ResolutionType& x);

    void
    Resolution (const ResolutionOptional& x);

    // AveragingPeriod
    //
    typedef ::xml_schema::Duration AveragingPeriodType;
    typedef ::xsd::cxx::tree::optional< AveragingPeriodType > AveragingPeriodOptional;
    typedef ::xsd::cxx::tree::traits< AveragingPeriodType, char > AveragingPeriodTraits;

    const AveragingPeriodOptional&
    AveragingPeriod () const;

    AveragingPeriodOptional&
    AveragingPeriod ();

    void
    AveragingPeriod (const AveragingPeriodType& x);

    void
    AveragingPeriod (const AveragingPeriodOptional& x);

    void
    AveragingPeriod (::std::unique_ptr< AveragingPeriodType > p);

    // Constructors.
    //
    NumericMetricDescriptor (const HandleType&,
                             const UnitType&,
                             const MetricCategoryType&,
                             const MetricAvailabilityType&);

    NumericMetricDescriptor (const HandleType&,
                             ::std::unique_ptr< UnitType >,
                             const MetricCategoryType&,
                             const MetricAvailabilityType&);

    NumericMetricDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    NumericMetricDescriptor (const NumericMetricDescriptor& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual NumericMetricDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    NumericMetricDescriptor&
    operator= (const NumericMetricDescriptor& x);

    virtual 
    ~NumericMetricDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TechnicalRangeSequence TechnicalRange_;
    ResolutionOptional Resolution_;
    AveragingPeriodOptional AveragingPeriod_;
  };

  class NumericMetricState: public ::CDM::AbstractMetricState
  {
    public:
    // MetricValue
    //
    typedef ::CDM::NumericMetricValue MetricValueType;
    typedef ::xsd::cxx::tree::optional< MetricValueType > MetricValueOptional;
    typedef ::xsd::cxx::tree::traits< MetricValueType, char > MetricValueTraits;

    const MetricValueOptional&
    MetricValue () const;

    MetricValueOptional&
    MetricValue ();

    void
    MetricValue (const MetricValueType& x);

    void
    MetricValue (const MetricValueOptional& x);

    void
    MetricValue (::std::unique_ptr< MetricValueType > p);

    // PhysiologicalRange
    //
    typedef ::CDM::Range PhysiologicalRangeType;
    typedef ::xsd::cxx::tree::sequence< PhysiologicalRangeType > PhysiologicalRangeSequence;
    typedef PhysiologicalRangeSequence::iterator PhysiologicalRangeIterator;
    typedef PhysiologicalRangeSequence::const_iterator PhysiologicalRangeConstIterator;
    typedef ::xsd::cxx::tree::traits< PhysiologicalRangeType, char > PhysiologicalRangeTraits;

    const PhysiologicalRangeSequence&
    PhysiologicalRange () const;

    PhysiologicalRangeSequence&
    PhysiologicalRange ();

    void
    PhysiologicalRange (const PhysiologicalRangeSequence& s);

    // ActiveAveragingPeriod
    //
    typedef ::xml_schema::Duration ActiveAveragingPeriodType;
    typedef ::xsd::cxx::tree::optional< ActiveAveragingPeriodType > ActiveAveragingPeriodOptional;
    typedef ::xsd::cxx::tree::traits< ActiveAveragingPeriodType, char > ActiveAveragingPeriodTraits;

    const ActiveAveragingPeriodOptional&
    ActiveAveragingPeriod () const;

    ActiveAveragingPeriodOptional&
    ActiveAveragingPeriod ();

    void
    ActiveAveragingPeriod (const ActiveAveragingPeriodType& x);

    void
    ActiveAveragingPeriod (const ActiveAveragingPeriodOptional& x);

    void
    ActiveAveragingPeriod (::std::unique_ptr< ActiveAveragingPeriodType > p);

    // Constructors.
    //
    NumericMetricState (const DescriptorHandleType&);

    NumericMetricState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    NumericMetricState (const NumericMetricState& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual NumericMetricState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    NumericMetricState&
    operator= (const NumericMetricState& x);

    virtual 
    ~NumericMetricState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MetricValueOptional MetricValue_;
    PhysiologicalRangeSequence PhysiologicalRange_;
    ActiveAveragingPeriodOptional ActiveAveragingPeriod_;
  };

  class StringMetricDescriptor: public ::CDM::AbstractMetricDescriptor
  {
    public:
    // Constructors.
    //
    StringMetricDescriptor (const HandleType&,
                            const UnitType&,
                            const MetricCategoryType&,
                            const MetricAvailabilityType&);

    StringMetricDescriptor (const HandleType&,
                            ::std::unique_ptr< UnitType >,
                            const MetricCategoryType&,
                            const MetricAvailabilityType&);

    StringMetricDescriptor (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    StringMetricDescriptor (const StringMetricDescriptor& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    virtual StringMetricDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~StringMetricDescriptor ();
  };

  class StringMetricState: public ::CDM::AbstractMetricState
  {
    public:
    // MetricValue
    //
    typedef ::CDM::StringMetricValue MetricValueType;
    typedef ::xsd::cxx::tree::optional< MetricValueType > MetricValueOptional;
    typedef ::xsd::cxx::tree::traits< MetricValueType, char > MetricValueTraits;

    const MetricValueOptional&
    MetricValue () const;

    MetricValueOptional&
    MetricValue ();

    void
    MetricValue (const MetricValueType& x);

    void
    MetricValue (const MetricValueOptional& x);

    void
    MetricValue (::std::unique_ptr< MetricValueType > p);

    // Constructors.
    //
    StringMetricState (const DescriptorHandleType&);

    StringMetricState (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    StringMetricState (const StringMetricState& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual StringMetricState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    StringMetricState&
    operator= (const StringMetricState& x);

    virtual 
    ~StringMetricState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MetricValueOptional MetricValue_;
  };

  class EnumStringMetricDescriptor: public ::CDM::StringMetricDescriptor
  {
    public:
    // AllowedValue
    //
    typedef ::CDM::AllowedValue AllowedValueType;
    typedef ::xsd::cxx::tree::sequence< AllowedValueType > AllowedValueSequence;
    typedef AllowedValueSequence::iterator AllowedValueIterator;
    typedef AllowedValueSequence::const_iterator AllowedValueConstIterator;
    typedef ::xsd::cxx::tree::traits< AllowedValueType, char > AllowedValueTraits;

    const AllowedValueSequence&
    AllowedValue () const;

    AllowedValueSequence&
    AllowedValue ();

    void
    AllowedValue (const AllowedValueSequence& s);

    // Constructors.
    //
    EnumStringMetricDescriptor (const HandleType&,
                                const UnitType&,
                                const MetricCategoryType&,
                                const MetricAvailabilityType&);

    EnumStringMetricDescriptor (const HandleType&,
                                ::std::unique_ptr< UnitType >,
                                const MetricCategoryType&,
                                const MetricAvailabilityType&);

    EnumStringMetricDescriptor (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    EnumStringMetricDescriptor (const EnumStringMetricDescriptor& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    virtual EnumStringMetricDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    EnumStringMetricDescriptor&
    operator= (const EnumStringMetricDescriptor& x);

    virtual 
    ~EnumStringMetricDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AllowedValueSequence AllowedValue_;
  };

  class EnumStringMetricState: public ::CDM::StringMetricState
  {
    public:
    // Constructors.
    //
    EnumStringMetricState (const DescriptorHandleType&);

    EnumStringMetricState (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    EnumStringMetricState (const EnumStringMetricState& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual EnumStringMetricState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~EnumStringMetricState ();
  };

  class RealTimeSampleArrayMetricDescriptor: public ::CDM::AbstractMetricDescriptor
  {
    public:
    // TechnicalRange
    //
    typedef ::CDM::Range TechnicalRangeType;
    typedef ::xsd::cxx::tree::sequence< TechnicalRangeType > TechnicalRangeSequence;
    typedef TechnicalRangeSequence::iterator TechnicalRangeIterator;
    typedef TechnicalRangeSequence::const_iterator TechnicalRangeConstIterator;
    typedef ::xsd::cxx::tree::traits< TechnicalRangeType, char > TechnicalRangeTraits;

    const TechnicalRangeSequence&
    TechnicalRange () const;

    TechnicalRangeSequence&
    TechnicalRange ();

    void
    TechnicalRange (const TechnicalRangeSequence& s);

    // Resolution
    //
    typedef ::xml_schema::Decimal ResolutionType;
    typedef ::xsd::cxx::tree::optional< ResolutionType > ResolutionOptional;
    typedef ::xsd::cxx::tree::traits< ResolutionType, char, ::xsd::cxx::tree::schema_type::decimal > ResolutionTraits;

    const ResolutionOptional&
    Resolution () const;

    ResolutionOptional&
    Resolution ();

    void
    Resolution (const ResolutionType& x);

    void
    Resolution (const ResolutionOptional& x);

    // SamplePeriod
    //
    typedef ::xml_schema::Duration SamplePeriodType;
    typedef ::xsd::cxx::tree::traits< SamplePeriodType, char > SamplePeriodTraits;

    const SamplePeriodType&
    SamplePeriod () const;

    SamplePeriodType&
    SamplePeriod ();

    void
    SamplePeriod (const SamplePeriodType& x);

    void
    SamplePeriod (::std::unique_ptr< SamplePeriodType > p);

    // Constructors.
    //
    RealTimeSampleArrayMetricDescriptor (const HandleType&,
                                         const UnitType&,
                                         const MetricCategoryType&,
                                         const MetricAvailabilityType&,
                                         const SamplePeriodType&);

    RealTimeSampleArrayMetricDescriptor (const HandleType&,
                                         ::std::unique_ptr< UnitType >,
                                         const MetricCategoryType&,
                                         const MetricAvailabilityType&,
                                         const SamplePeriodType&);

    RealTimeSampleArrayMetricDescriptor (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    RealTimeSampleArrayMetricDescriptor (const RealTimeSampleArrayMetricDescriptor& x,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    virtual RealTimeSampleArrayMetricDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    RealTimeSampleArrayMetricDescriptor&
    operator= (const RealTimeSampleArrayMetricDescriptor& x);

    virtual 
    ~RealTimeSampleArrayMetricDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TechnicalRangeSequence TechnicalRange_;
    ResolutionOptional Resolution_;
    ::xsd::cxx::tree::one< SamplePeriodType > SamplePeriod_;
  };

  class RealTimeSampleArrayMetricState: public ::CDM::AbstractMetricState
  {
    public:
    // MetricValue
    //
    typedef ::CDM::SampleArrayValue MetricValueType;
    typedef ::xsd::cxx::tree::optional< MetricValueType > MetricValueOptional;
    typedef ::xsd::cxx::tree::traits< MetricValueType, char > MetricValueTraits;

    const MetricValueOptional&
    MetricValue () const;

    MetricValueOptional&
    MetricValue ();

    void
    MetricValue (const MetricValueType& x);

    void
    MetricValue (const MetricValueOptional& x);

    void
    MetricValue (::std::unique_ptr< MetricValueType > p);

    // PhysiologicalRange
    //
    typedef ::CDM::Range PhysiologicalRangeType;
    typedef ::xsd::cxx::tree::sequence< PhysiologicalRangeType > PhysiologicalRangeSequence;
    typedef PhysiologicalRangeSequence::iterator PhysiologicalRangeIterator;
    typedef PhysiologicalRangeSequence::const_iterator PhysiologicalRangeConstIterator;
    typedef ::xsd::cxx::tree::traits< PhysiologicalRangeType, char > PhysiologicalRangeTraits;

    const PhysiologicalRangeSequence&
    PhysiologicalRange () const;

    PhysiologicalRangeSequence&
    PhysiologicalRange ();

    void
    PhysiologicalRange (const PhysiologicalRangeSequence& s);

    // Constructors.
    //
    RealTimeSampleArrayMetricState (const DescriptorHandleType&);

    RealTimeSampleArrayMetricState (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    RealTimeSampleArrayMetricState (const RealTimeSampleArrayMetricState& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    virtual RealTimeSampleArrayMetricState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    RealTimeSampleArrayMetricState&
    operator= (const RealTimeSampleArrayMetricState& x);

    virtual 
    ~RealTimeSampleArrayMetricState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MetricValueOptional MetricValue_;
    PhysiologicalRangeSequence PhysiologicalRange_;
  };

  class DistributionSampleArrayMetricDescriptor: public ::CDM::AbstractMetricDescriptor
  {
    public:
    // TechnicalRange
    //
    typedef ::CDM::Range TechnicalRangeType;
    typedef ::xsd::cxx::tree::sequence< TechnicalRangeType > TechnicalRangeSequence;
    typedef TechnicalRangeSequence::iterator TechnicalRangeIterator;
    typedef TechnicalRangeSequence::const_iterator TechnicalRangeConstIterator;
    typedef ::xsd::cxx::tree::traits< TechnicalRangeType, char > TechnicalRangeTraits;

    const TechnicalRangeSequence&
    TechnicalRange () const;

    TechnicalRangeSequence&
    TechnicalRange ();

    void
    TechnicalRange (const TechnicalRangeSequence& s);

    // DomainUnit
    //
    typedef ::CDM::CodedValue DomainUnitType;
    typedef ::xsd::cxx::tree::traits< DomainUnitType, char > DomainUnitTraits;

    const DomainUnitType&
    DomainUnit () const;

    DomainUnitType&
    DomainUnit ();

    void
    DomainUnit (const DomainUnitType& x);

    void
    DomainUnit (::std::unique_ptr< DomainUnitType > p);

    // DistributionRange
    //
    typedef ::CDM::Range DistributionRangeType;
    typedef ::xsd::cxx::tree::traits< DistributionRangeType, char > DistributionRangeTraits;

    const DistributionRangeType&
    DistributionRange () const;

    DistributionRangeType&
    DistributionRange ();

    void
    DistributionRange (const DistributionRangeType& x);

    void
    DistributionRange (::std::unique_ptr< DistributionRangeType > p);

    // Resolution
    //
    typedef ::xml_schema::Decimal ResolutionType;
    typedef ::xsd::cxx::tree::optional< ResolutionType > ResolutionOptional;
    typedef ::xsd::cxx::tree::traits< ResolutionType, char, ::xsd::cxx::tree::schema_type::decimal > ResolutionTraits;

    const ResolutionOptional&
    Resolution () const;

    ResolutionOptional&
    Resolution ();

    void
    Resolution (const ResolutionType& x);

    void
    Resolution (const ResolutionOptional& x);

    // Constructors.
    //
    DistributionSampleArrayMetricDescriptor (const HandleType&,
                                             const UnitType&,
                                             const MetricCategoryType&,
                                             const MetricAvailabilityType&,
                                             const DomainUnitType&,
                                             const DistributionRangeType&);

    DistributionSampleArrayMetricDescriptor (const HandleType&,
                                             ::std::unique_ptr< UnitType >,
                                             const MetricCategoryType&,
                                             const MetricAvailabilityType&,
                                             ::std::unique_ptr< DomainUnitType >,
                                             ::std::unique_ptr< DistributionRangeType >);

    DistributionSampleArrayMetricDescriptor (const ::xercesc::DOMElement& e,
                                             ::xml_schema::Flags f = 0,
                                             ::xml_schema::Container* c = 0);

    DistributionSampleArrayMetricDescriptor (const DistributionSampleArrayMetricDescriptor& x,
                                             ::xml_schema::Flags f = 0,
                                             ::xml_schema::Container* c = 0);

    virtual DistributionSampleArrayMetricDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    DistributionSampleArrayMetricDescriptor&
    operator= (const DistributionSampleArrayMetricDescriptor& x);

    virtual 
    ~DistributionSampleArrayMetricDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TechnicalRangeSequence TechnicalRange_;
    ::xsd::cxx::tree::one< DomainUnitType > DomainUnit_;
    ::xsd::cxx::tree::one< DistributionRangeType > DistributionRange_;
    ResolutionOptional Resolution_;
  };

  class DistributionSampleArrayMetricState: public ::CDM::AbstractMetricState
  {
    public:
    // MetricValue
    //
    typedef ::CDM::SampleArrayValue MetricValueType;
    typedef ::xsd::cxx::tree::optional< MetricValueType > MetricValueOptional;
    typedef ::xsd::cxx::tree::traits< MetricValueType, char > MetricValueTraits;

    const MetricValueOptional&
    MetricValue () const;

    MetricValueOptional&
    MetricValue ();

    void
    MetricValue (const MetricValueType& x);

    void
    MetricValue (const MetricValueOptional& x);

    void
    MetricValue (::std::unique_ptr< MetricValueType > p);

    // PhysiologicalRange
    //
    typedef ::CDM::Range PhysiologicalRangeType;
    typedef ::xsd::cxx::tree::sequence< PhysiologicalRangeType > PhysiologicalRangeSequence;
    typedef PhysiologicalRangeSequence::iterator PhysiologicalRangeIterator;
    typedef PhysiologicalRangeSequence::const_iterator PhysiologicalRangeConstIterator;
    typedef ::xsd::cxx::tree::traits< PhysiologicalRangeType, char > PhysiologicalRangeTraits;

    const PhysiologicalRangeSequence&
    PhysiologicalRange () const;

    PhysiologicalRangeSequence&
    PhysiologicalRange ();

    void
    PhysiologicalRange (const PhysiologicalRangeSequence& s);

    // Constructors.
    //
    DistributionSampleArrayMetricState (const DescriptorHandleType&);

    DistributionSampleArrayMetricState (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    DistributionSampleArrayMetricState (const DistributionSampleArrayMetricState& x,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    virtual DistributionSampleArrayMetricState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    DistributionSampleArrayMetricState&
    operator= (const DistributionSampleArrayMetricState& x);

    virtual 
    ~DistributionSampleArrayMetricState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MetricValueOptional MetricValue_;
    PhysiologicalRangeSequence PhysiologicalRange_;
  };

  class ScoDescriptor: public ::CDM::AbstractDescriptor
  {
    public:
    // Operation
    //
    typedef ::CDM::AbstractOperationDescriptor OperationType;
    typedef ::xsd::cxx::tree::sequence< OperationType > OperationSequence;
    typedef OperationSequence::iterator OperationIterator;
    typedef OperationSequence::const_iterator OperationConstIterator;
    typedef ::xsd::cxx::tree::traits< OperationType, char > OperationTraits;

    const OperationSequence&
    Operation () const;

    OperationSequence&
    Operation ();

    void
    Operation (const OperationSequence& s);

    // Constructors.
    //
    ScoDescriptor (const HandleType&);

    ScoDescriptor (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    ScoDescriptor (const ScoDescriptor& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual ScoDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ScoDescriptor&
    operator= (const ScoDescriptor& x);

    virtual 
    ~ScoDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    OperationSequence Operation_;
  };

  class ScoState: public ::CDM::AbstractState
  {
    public:
    // Constructors.
    //
    ScoState (const DescriptorHandleType&);

    ScoState (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    ScoState (const ScoState& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    virtual ScoState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~ScoState ();
  };

  class AbstractOperationDescriptor: public ::CDM::AbstractDescriptor
  {
    public:
    // OperationTarget
    //
    typedef ::CDM::HandleRef OperationTargetType;
    typedef ::xsd::cxx::tree::traits< OperationTargetType, char > OperationTargetTraits;

    const OperationTargetType&
    OperationTarget () const;

    OperationTargetType&
    OperationTarget ();

    void
    OperationTarget (const OperationTargetType& x);

    void
    OperationTarget (::std::unique_ptr< OperationTargetType > p);

    // Constructors.
    //
    AbstractOperationDescriptor (const HandleType&,
                                 const OperationTargetType&);

    AbstractOperationDescriptor (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    AbstractOperationDescriptor (const AbstractOperationDescriptor& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    virtual AbstractOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractOperationDescriptor&
    operator= (const AbstractOperationDescriptor& x);

    virtual 
    ~AbstractOperationDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< OperationTargetType > OperationTarget_;
  };

  class AbstractSetStateOperationDescriptor: public ::CDM::AbstractOperationDescriptor
  {
    public:
    // ModifiableElement
    //
    typedef ::xml_schema::String ModifiableElementType;
    typedef ::xsd::cxx::tree::sequence< ModifiableElementType > ModifiableElementSequence;
    typedef ModifiableElementSequence::iterator ModifiableElementIterator;
    typedef ModifiableElementSequence::const_iterator ModifiableElementConstIterator;
    typedef ::xsd::cxx::tree::traits< ModifiableElementType, char > ModifiableElementTraits;

    const ModifiableElementSequence&
    ModifiableElement () const;

    ModifiableElementSequence&
    ModifiableElement ();

    void
    ModifiableElement (const ModifiableElementSequence& s);

    // Constructors.
    //
    AbstractSetStateOperationDescriptor (const HandleType&,
                                         const OperationTargetType&);

    AbstractSetStateOperationDescriptor (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    AbstractSetStateOperationDescriptor (const AbstractSetStateOperationDescriptor& x,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    virtual AbstractSetStateOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractSetStateOperationDescriptor&
    operator= (const AbstractSetStateOperationDescriptor& x);

    virtual 
    ~AbstractSetStateOperationDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ModifiableElementSequence ModifiableElement_;
  };

  class OperatingMode: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Dis,
      En,
      NA
    };

    OperatingMode (Value v);

    OperatingMode (const char* v);

    OperatingMode (const ::std::string& v);

    OperatingMode (const ::xml_schema::String& v);

    OperatingMode (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    OperatingMode (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    OperatingMode (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    OperatingMode (const OperatingMode& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual OperatingMode*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    OperatingMode&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_OperatingMode_convert ();
    }

    protected:
    Value
    _xsd_OperatingMode_convert () const;

    public:
    static const char* const _xsd_OperatingMode_literals_[3];
    static const Value _xsd_OperatingMode_indexes_[3];
  };

  class AbstractOperationState: public ::CDM::AbstractState
  {
    public:
    // OperatingMode
    //
    typedef ::CDM::OperatingMode OperatingModeType;
    typedef ::xsd::cxx::tree::traits< OperatingModeType, char > OperatingModeTraits;

    const OperatingModeType&
    OperatingMode () const;

    OperatingModeType&
    OperatingMode ();

    void
    OperatingMode (const OperatingModeType& x);

    void
    OperatingMode (::std::unique_ptr< OperatingModeType > p);

    // Constructors.
    //
    AbstractOperationState (const DescriptorHandleType&,
                            const OperatingModeType&);

    AbstractOperationState (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    AbstractOperationState (const AbstractOperationState& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    virtual AbstractOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractOperationState&
    operator= (const AbstractOperationState& x);

    virtual 
    ~AbstractOperationState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< OperatingModeType > OperatingMode_;
  };

  class SetValueOperationDescriptor: public ::CDM::AbstractOperationDescriptor
  {
    public:
    // Constructors.
    //
    SetValueOperationDescriptor (const HandleType&,
                                 const OperationTargetType&);

    SetValueOperationDescriptor (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    SetValueOperationDescriptor (const SetValueOperationDescriptor& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    virtual SetValueOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~SetValueOperationDescriptor ();
  };

  class SetValueOperationState: public ::CDM::AbstractOperationState
  {
    public:
    // allowedRange
    //
    typedef ::CDM::Range AllowedRangeType;
    typedef ::xsd::cxx::tree::sequence< AllowedRangeType > AllowedRangeSequence;
    typedef AllowedRangeSequence::iterator AllowedRangeIterator;
    typedef AllowedRangeSequence::const_iterator AllowedRangeConstIterator;
    typedef ::xsd::cxx::tree::traits< AllowedRangeType, char > AllowedRangeTraits;

    const AllowedRangeSequence&
    allowedRange () const;

    AllowedRangeSequence&
    allowedRange ();

    void
    allowedRange (const AllowedRangeSequence& s);

    // Constructors.
    //
    SetValueOperationState (const DescriptorHandleType&,
                            const OperatingModeType&);

    SetValueOperationState (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    SetValueOperationState (const SetValueOperationState& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    virtual SetValueOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SetValueOperationState&
    operator= (const SetValueOperationState& x);

    virtual 
    ~SetValueOperationState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AllowedRangeSequence allowedRange_;
  };

  class SetStringOperationDescriptor: public ::CDM::AbstractOperationDescriptor
  {
    public:
    // MaxLength
    //
    typedef ::xml_schema::UnsignedLong MaxLengthType;
    typedef ::xsd::cxx::tree::optional< MaxLengthType > MaxLengthOptional;
    typedef ::xsd::cxx::tree::traits< MaxLengthType, char > MaxLengthTraits;

    const MaxLengthOptional&
    MaxLength () const;

    MaxLengthOptional&
    MaxLength ();

    void
    MaxLength (const MaxLengthType& x);

    void
    MaxLength (const MaxLengthOptional& x);

    // Constructors.
    //
    SetStringOperationDescriptor (const HandleType&,
                                  const OperationTargetType&);

    SetStringOperationDescriptor (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    SetStringOperationDescriptor (const SetStringOperationDescriptor& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    virtual SetStringOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SetStringOperationDescriptor&
    operator= (const SetStringOperationDescriptor& x);

    virtual 
    ~SetStringOperationDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MaxLengthOptional MaxLength_;
  };

  class SetStringOperationState: public ::CDM::AbstractOperationState
  {
    public:
    // Constructors.
    //
    SetStringOperationState (const DescriptorHandleType&,
                             const OperatingModeType&);

    SetStringOperationState (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    SetStringOperationState (const SetStringOperationState& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual SetStringOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~SetStringOperationState ();
  };

  class ActivateOperationDescriptor: public ::CDM::AbstractSetStateOperationDescriptor
  {
    public:
    // Argument
    //
    typedef ::CDM::Argument ArgumentType;
    typedef ::xsd::cxx::tree::sequence< ArgumentType > ArgumentSequence;
    typedef ArgumentSequence::iterator ArgumentIterator;
    typedef ArgumentSequence::const_iterator ArgumentConstIterator;
    typedef ::xsd::cxx::tree::traits< ArgumentType, char > ArgumentTraits;

    const ArgumentSequence&
    Argument () const;

    ArgumentSequence&
    Argument ();

    void
    Argument (const ArgumentSequence& s);

    // ActivationDuration
    //
    typedef ::xml_schema::Duration ActivationDurationType;
    typedef ::xsd::cxx::tree::optional< ActivationDurationType > ActivationDurationOptional;
    typedef ::xsd::cxx::tree::traits< ActivationDurationType, char > ActivationDurationTraits;

    const ActivationDurationOptional&
    ActivationDuration () const;

    ActivationDurationOptional&
    ActivationDuration ();

    void
    ActivationDuration (const ActivationDurationType& x);

    void
    ActivationDuration (const ActivationDurationOptional& x);

    void
    ActivationDuration (::std::unique_ptr< ActivationDurationType > p);

    // Retriggerable
    //
    typedef ::xml_schema::Boolean RetriggerableType;
    typedef ::xsd::cxx::tree::optional< RetriggerableType > RetriggerableOptional;
    typedef ::xsd::cxx::tree::traits< RetriggerableType, char > RetriggerableTraits;

    const RetriggerableOptional&
    Retriggerable () const;

    RetriggerableOptional&
    Retriggerable ();

    void
    Retriggerable (const RetriggerableType& x);

    void
    Retriggerable (const RetriggerableOptional& x);

    // Constructors.
    //
    ActivateOperationDescriptor (const HandleType&,
                                 const OperationTargetType&);

    ActivateOperationDescriptor (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    ActivateOperationDescriptor (const ActivateOperationDescriptor& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    virtual ActivateOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ActivateOperationDescriptor&
    operator= (const ActivateOperationDescriptor& x);

    virtual 
    ~ActivateOperationDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ArgumentSequence Argument_;
    ActivationDurationOptional ActivationDuration_;
    RetriggerableOptional Retriggerable_;
  };

  class ActivateOperationState: public ::CDM::AbstractOperationState
  {
    public:
    // Constructors.
    //
    ActivateOperationState (const DescriptorHandleType&,
                            const OperatingModeType&);

    ActivateOperationState (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    ActivateOperationState (const ActivateOperationState& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    virtual ActivateOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~ActivateOperationState ();
  };

  class SetContextStateOperationDescriptor: public ::CDM::AbstractSetStateOperationDescriptor
  {
    public:
    // Constructors.
    //
    SetContextStateOperationDescriptor (const HandleType&,
                                        const OperationTargetType&);

    SetContextStateOperationDescriptor (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    SetContextStateOperationDescriptor (const SetContextStateOperationDescriptor& x,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

    virtual SetContextStateOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~SetContextStateOperationDescriptor ();
  };

  class SetContextStateOperationState: public ::CDM::AbstractOperationState
  {
    public:
    // Constructors.
    //
    SetContextStateOperationState (const DescriptorHandleType&,
                                   const OperatingModeType&);

    SetContextStateOperationState (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    SetContextStateOperationState (const SetContextStateOperationState& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    virtual SetContextStateOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~SetContextStateOperationState ();
  };

  class SetMetricStateOperationDescriptor: public ::CDM::AbstractSetStateOperationDescriptor
  {
    public:
    // Constructors.
    //
    SetMetricStateOperationDescriptor (const HandleType&,
                                       const OperationTargetType&);

    SetMetricStateOperationDescriptor (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    SetMetricStateOperationDescriptor (const SetMetricStateOperationDescriptor& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    virtual SetMetricStateOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~SetMetricStateOperationDescriptor ();
  };

  class SetMetricStateOperationState: public ::CDM::AbstractOperationState
  {
    public:
    // Constructors.
    //
    SetMetricStateOperationState (const DescriptorHandleType&,
                                  const OperatingModeType&);

    SetMetricStateOperationState (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    SetMetricStateOperationState (const SetMetricStateOperationState& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    virtual SetMetricStateOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~SetMetricStateOperationState ();
  };

  class SetComponentStateOperationDescriptor: public ::CDM::AbstractSetStateOperationDescriptor
  {
    public:
    // Constructors.
    //
    SetComponentStateOperationDescriptor (const HandleType&,
                                          const OperationTargetType&);

    SetComponentStateOperationDescriptor (const ::xercesc::DOMElement& e,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    SetComponentStateOperationDescriptor (const SetComponentStateOperationDescriptor& x,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    virtual SetComponentStateOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~SetComponentStateOperationDescriptor ();
  };

  class SetComponentStateOperationState: public ::CDM::AbstractOperationState
  {
    public:
    // Constructors.
    //
    SetComponentStateOperationState (const DescriptorHandleType&,
                                     const OperatingModeType&);

    SetComponentStateOperationState (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    SetComponentStateOperationState (const SetComponentStateOperationState& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    virtual SetComponentStateOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~SetComponentStateOperationState ();
  };

  class SetAlertStateOperationDescriptor: public ::CDM::AbstractSetStateOperationDescriptor
  {
    public:
    // Constructors.
    //
    SetAlertStateOperationDescriptor (const HandleType&,
                                      const OperationTargetType&);

    SetAlertStateOperationDescriptor (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    SetAlertStateOperationDescriptor (const SetAlertStateOperationDescriptor& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    virtual SetAlertStateOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~SetAlertStateOperationDescriptor ();
  };

  class SetAlertStateOperationState: public ::CDM::AbstractOperationState
  {
    public:
    // Constructors.
    //
    SetAlertStateOperationState (const DescriptorHandleType&,
                                 const OperatingModeType&);

    SetAlertStateOperationState (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    SetAlertStateOperationState (const SetAlertStateOperationState& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    virtual SetAlertStateOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~SetAlertStateOperationState ();
  };

  class TimeZone: public ::xml_schema::String
  {
    public:
    // Constructors.
    //
    TimeZone ();

    TimeZone (const char*);

    TimeZone (const ::std::string&);

    TimeZone (const ::xml_schema::String&);

    TimeZone (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    TimeZone (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    TimeZone (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    TimeZone (const TimeZone& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    virtual TimeZone*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~TimeZone ();
  };

  class ClockDescriptor: public ::CDM::AbstractDeviceComponentDescriptor
  {
    public:
    // TimeProtocol
    //
    typedef ::CDM::CodedValue TimeProtocolType;
    typedef ::xsd::cxx::tree::sequence< TimeProtocolType > TimeProtocolSequence;
    typedef TimeProtocolSequence::iterator TimeProtocolIterator;
    typedef TimeProtocolSequence::const_iterator TimeProtocolConstIterator;
    typedef ::xsd::cxx::tree::traits< TimeProtocolType, char > TimeProtocolTraits;

    const TimeProtocolSequence&
    TimeProtocol () const;

    TimeProtocolSequence&
    TimeProtocol ();

    void
    TimeProtocol (const TimeProtocolSequence& s);

    // Resolution
    //
    typedef ::xml_schema::Duration ResolutionType;
    typedef ::xsd::cxx::tree::optional< ResolutionType > ResolutionOptional;
    typedef ::xsd::cxx::tree::traits< ResolutionType, char > ResolutionTraits;

    const ResolutionOptional&
    Resolution () const;

    ResolutionOptional&
    Resolution ();

    void
    Resolution (const ResolutionType& x);

    void
    Resolution (const ResolutionOptional& x);

    void
    Resolution (::std::unique_ptr< ResolutionType > p);

    // Constructors.
    //
    ClockDescriptor (const HandleType&);

    ClockDescriptor (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    ClockDescriptor (const ClockDescriptor& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual ClockDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ClockDescriptor&
    operator= (const ClockDescriptor& x);

    virtual 
    ~ClockDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TimeProtocolSequence TimeProtocol_;
    ResolutionOptional Resolution_;
  };

  class ClockState: public ::CDM::AbstractDeviceComponentState
  {
    public:
    // ActiveSyncProtocol
    //
    typedef ::CDM::CodedValue ActiveSyncProtocolType;
    typedef ::xsd::cxx::tree::optional< ActiveSyncProtocolType > ActiveSyncProtocolOptional;
    typedef ::xsd::cxx::tree::traits< ActiveSyncProtocolType, char > ActiveSyncProtocolTraits;

    const ActiveSyncProtocolOptional&
    ActiveSyncProtocol () const;

    ActiveSyncProtocolOptional&
    ActiveSyncProtocol ();

    void
    ActiveSyncProtocol (const ActiveSyncProtocolType& x);

    void
    ActiveSyncProtocol (const ActiveSyncProtocolOptional& x);

    void
    ActiveSyncProtocol (::std::unique_ptr< ActiveSyncProtocolType > p);

    // DateAndTime
    //
    typedef ::CDM::Timestamp DateAndTimeType;
    typedef ::xsd::cxx::tree::optional< DateAndTimeType > DateAndTimeOptional;
    typedef ::xsd::cxx::tree::traits< DateAndTimeType, char > DateAndTimeTraits;

    const DateAndTimeOptional&
    DateAndTime () const;

    DateAndTimeOptional&
    DateAndTime ();

    void
    DateAndTime (const DateAndTimeType& x);

    void
    DateAndTime (const DateAndTimeOptional& x);

    void
    DateAndTime (::std::unique_ptr< DateAndTimeType > p);

    // RemoteSync
    //
    typedef ::xml_schema::Boolean RemoteSyncType;
    typedef ::xsd::cxx::tree::traits< RemoteSyncType, char > RemoteSyncTraits;

    const RemoteSyncType&
    RemoteSync () const;

    RemoteSyncType&
    RemoteSync ();

    void
    RemoteSync (const RemoteSyncType& x);

    // ReferenceSource
    //
    typedef ::xml_schema::String ReferenceSourceType;
    typedef ::xsd::cxx::tree::optional< ReferenceSourceType > ReferenceSourceOptional;
    typedef ::xsd::cxx::tree::traits< ReferenceSourceType, char > ReferenceSourceTraits;

    const ReferenceSourceOptional&
    ReferenceSource () const;

    ReferenceSourceOptional&
    ReferenceSource ();

    void
    ReferenceSource (const ReferenceSourceType& x);

    void
    ReferenceSource (const ReferenceSourceOptional& x);

    void
    ReferenceSource (::std::unique_ptr< ReferenceSourceType > p);

    // Accuracy
    //
    typedef ::xml_schema::Decimal AccuracyType;
    typedef ::xsd::cxx::tree::optional< AccuracyType > AccuracyOptional;
    typedef ::xsd::cxx::tree::traits< AccuracyType, char, ::xsd::cxx::tree::schema_type::decimal > AccuracyTraits;

    const AccuracyOptional&
    Accuracy () const;

    AccuracyOptional&
    Accuracy ();

    void
    Accuracy (const AccuracyType& x);

    void
    Accuracy (const AccuracyOptional& x);

    // LastSet
    //
    typedef ::CDM::Timestamp LastSetType;
    typedef ::xsd::cxx::tree::optional< LastSetType > LastSetOptional;
    typedef ::xsd::cxx::tree::traits< LastSetType, char > LastSetTraits;

    const LastSetOptional&
    LastSet () const;

    LastSetOptional&
    LastSet ();

    void
    LastSet (const LastSetType& x);

    void
    LastSet (const LastSetOptional& x);

    void
    LastSet (::std::unique_ptr< LastSetType > p);

    // TimeZone
    //
    typedef ::CDM::TimeZone TimeZoneType;
    typedef ::xsd::cxx::tree::optional< TimeZoneType > TimeZoneOptional;
    typedef ::xsd::cxx::tree::traits< TimeZoneType, char > TimeZoneTraits;

    const TimeZoneOptional&
    TimeZone () const;

    TimeZoneOptional&
    TimeZone ();

    void
    TimeZone (const TimeZoneType& x);

    void
    TimeZone (const TimeZoneOptional& x);

    void
    TimeZone (::std::unique_ptr< TimeZoneType > p);

    // CriticalUse
    //
    typedef ::xml_schema::Boolean CriticalUseType;
    typedef ::xsd::cxx::tree::optional< CriticalUseType > CriticalUseOptional;
    typedef ::xsd::cxx::tree::traits< CriticalUseType, char > CriticalUseTraits;

    const CriticalUseOptional&
    CriticalUse () const;

    CriticalUseOptional&
    CriticalUse ();

    void
    CriticalUse (const CriticalUseType& x);

    void
    CriticalUse (const CriticalUseOptional& x);

    // Constructors.
    //
    ClockState (const DescriptorHandleType&,
                const RemoteSyncType&);

    ClockState (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    ClockState (const ClockState& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual ClockState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ClockState&
    operator= (const ClockState& x);

    virtual 
    ~ClockState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ActiveSyncProtocolOptional ActiveSyncProtocol_;
    DateAndTimeOptional DateAndTime_;
    ::xsd::cxx::tree::one< RemoteSyncType > RemoteSync_;
    ReferenceSourceOptional ReferenceSource_;
    AccuracyOptional Accuracy_;
    LastSetOptional LastSet_;
    TimeZoneOptional TimeZone_;
    CriticalUseOptional CriticalUse_;
  };

  class BatteryDescriptor: public ::CDM::AbstractDeviceComponentDescriptor
  {
    public:
    // CapacityFullCharge
    //
    typedef ::CDM::Measurement CapacityFullChargeType;
    typedef ::xsd::cxx::tree::optional< CapacityFullChargeType > CapacityFullChargeOptional;
    typedef ::xsd::cxx::tree::traits< CapacityFullChargeType, char > CapacityFullChargeTraits;

    const CapacityFullChargeOptional&
    CapacityFullCharge () const;

    CapacityFullChargeOptional&
    CapacityFullCharge ();

    void
    CapacityFullCharge (const CapacityFullChargeType& x);

    void
    CapacityFullCharge (const CapacityFullChargeOptional& x);

    void
    CapacityFullCharge (::std::unique_ptr< CapacityFullChargeType > p);

    // CapacitySpecified
    //
    typedef ::CDM::Measurement CapacitySpecifiedType;
    typedef ::xsd::cxx::tree::optional< CapacitySpecifiedType > CapacitySpecifiedOptional;
    typedef ::xsd::cxx::tree::traits< CapacitySpecifiedType, char > CapacitySpecifiedTraits;

    const CapacitySpecifiedOptional&
    CapacitySpecified () const;

    CapacitySpecifiedOptional&
    CapacitySpecified ();

    void
    CapacitySpecified (const CapacitySpecifiedType& x);

    void
    CapacitySpecified (const CapacitySpecifiedOptional& x);

    void
    CapacitySpecified (::std::unique_ptr< CapacitySpecifiedType > p);

    // VoltageSpecified
    //
    typedef ::CDM::Measurement VoltageSpecifiedType;
    typedef ::xsd::cxx::tree::optional< VoltageSpecifiedType > VoltageSpecifiedOptional;
    typedef ::xsd::cxx::tree::traits< VoltageSpecifiedType, char > VoltageSpecifiedTraits;

    const VoltageSpecifiedOptional&
    VoltageSpecified () const;

    VoltageSpecifiedOptional&
    VoltageSpecified ();

    void
    VoltageSpecified (const VoltageSpecifiedType& x);

    void
    VoltageSpecified (const VoltageSpecifiedOptional& x);

    void
    VoltageSpecified (::std::unique_ptr< VoltageSpecifiedType > p);

    // Constructors.
    //
    BatteryDescriptor (const HandleType&);

    BatteryDescriptor (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    BatteryDescriptor (const BatteryDescriptor& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual BatteryDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    BatteryDescriptor&
    operator= (const BatteryDescriptor& x);

    virtual 
    ~BatteryDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CapacityFullChargeOptional CapacityFullCharge_;
    CapacitySpecifiedOptional CapacitySpecified_;
    VoltageSpecifiedOptional VoltageSpecified_;
  };

  class BatteryState: public ::CDM::AbstractDeviceComponentState
  {
    public:
    // CapacityRemaining
    //
    typedef ::CDM::Measurement CapacityRemainingType;
    typedef ::xsd::cxx::tree::optional< CapacityRemainingType > CapacityRemainingOptional;
    typedef ::xsd::cxx::tree::traits< CapacityRemainingType, char > CapacityRemainingTraits;

    const CapacityRemainingOptional&
    CapacityRemaining () const;

    CapacityRemainingOptional&
    CapacityRemaining ();

    void
    CapacityRemaining (const CapacityRemainingType& x);

    void
    CapacityRemaining (const CapacityRemainingOptional& x);

    void
    CapacityRemaining (::std::unique_ptr< CapacityRemainingType > p);

    // Voltage
    //
    typedef ::CDM::Measurement VoltageType;
    typedef ::xsd::cxx::tree::optional< VoltageType > VoltageOptional;
    typedef ::xsd::cxx::tree::traits< VoltageType, char > VoltageTraits;

    const VoltageOptional&
    Voltage () const;

    VoltageOptional&
    Voltage ();

    void
    Voltage (const VoltageType& x);

    void
    Voltage (const VoltageOptional& x);

    void
    Voltage (::std::unique_ptr< VoltageType > p);

    // Current
    //
    typedef ::CDM::Measurement CurrentType;
    typedef ::xsd::cxx::tree::optional< CurrentType > CurrentOptional;
    typedef ::xsd::cxx::tree::traits< CurrentType, char > CurrentTraits;

    const CurrentOptional&
    Current () const;

    CurrentOptional&
    Current ();

    void
    Current (const CurrentType& x);

    void
    Current (const CurrentOptional& x);

    void
    Current (::std::unique_ptr< CurrentType > p);

    // Temperature
    //
    typedef ::CDM::Measurement TemperatureType;
    typedef ::xsd::cxx::tree::optional< TemperatureType > TemperatureOptional;
    typedef ::xsd::cxx::tree::traits< TemperatureType, char > TemperatureTraits;

    const TemperatureOptional&
    Temperature () const;

    TemperatureOptional&
    Temperature ();

    void
    Temperature (const TemperatureType& x);

    void
    Temperature (const TemperatureOptional& x);

    void
    Temperature (::std::unique_ptr< TemperatureType > p);

    // RemainingBatteryTime
    //
    typedef ::CDM::Measurement RemainingBatteryTimeType;
    typedef ::xsd::cxx::tree::optional< RemainingBatteryTimeType > RemainingBatteryTimeOptional;
    typedef ::xsd::cxx::tree::traits< RemainingBatteryTimeType, char > RemainingBatteryTimeTraits;

    const RemainingBatteryTimeOptional&
    RemainingBatteryTime () const;

    RemainingBatteryTimeOptional&
    RemainingBatteryTime ();

    void
    RemainingBatteryTime (const RemainingBatteryTimeType& x);

    void
    RemainingBatteryTime (const RemainingBatteryTimeOptional& x);

    void
    RemainingBatteryTime (::std::unique_ptr< RemainingBatteryTimeType > p);

    // ChargeStatus
    //
    typedef ::CDM::ChargeStatus ChargeStatusType;
    typedef ::xsd::cxx::tree::optional< ChargeStatusType > ChargeStatusOptional;
    typedef ::xsd::cxx::tree::traits< ChargeStatusType, char > ChargeStatusTraits;

    const ChargeStatusOptional&
    ChargeStatus () const;

    ChargeStatusOptional&
    ChargeStatus ();

    void
    ChargeStatus (const ChargeStatusType& x);

    void
    ChargeStatus (const ChargeStatusOptional& x);

    void
    ChargeStatus (::std::unique_ptr< ChargeStatusType > p);

    // ChargeCycles
    //
    typedef ::xml_schema::UnsignedInt ChargeCyclesType;
    typedef ::xsd::cxx::tree::optional< ChargeCyclesType > ChargeCyclesOptional;
    typedef ::xsd::cxx::tree::traits< ChargeCyclesType, char > ChargeCyclesTraits;

    const ChargeCyclesOptional&
    ChargeCycles () const;

    ChargeCyclesOptional&
    ChargeCycles ();

    void
    ChargeCycles (const ChargeCyclesType& x);

    void
    ChargeCycles (const ChargeCyclesOptional& x);

    // Constructors.
    //
    BatteryState (const DescriptorHandleType&);

    BatteryState (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    BatteryState (const BatteryState& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual BatteryState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    BatteryState&
    operator= (const BatteryState& x);

    virtual 
    ~BatteryState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CapacityRemainingOptional CapacityRemaining_;
    VoltageOptional Voltage_;
    CurrentOptional Current_;
    TemperatureOptional Temperature_;
    RemainingBatteryTimeOptional RemainingBatteryTime_;
    ChargeStatusOptional ChargeStatus_;
    ChargeCyclesOptional ChargeCycles_;
  };

  class SystemContextDescriptor: public ::CDM::AbstractDescriptor
  {
    public:
    // PatientContext
    //
    typedef ::CDM::PatientContextDescriptor PatientContextType;
    typedef ::xsd::cxx::tree::optional< PatientContextType > PatientContextOptional;
    typedef ::xsd::cxx::tree::traits< PatientContextType, char > PatientContextTraits;

    const PatientContextOptional&
    PatientContext () const;

    PatientContextOptional&
    PatientContext ();

    void
    PatientContext (const PatientContextType& x);

    void
    PatientContext (const PatientContextOptional& x);

    void
    PatientContext (::std::unique_ptr< PatientContextType > p);

    // LocationContext
    //
    typedef ::CDM::LocationContextDescriptor LocationContextType;
    typedef ::xsd::cxx::tree::optional< LocationContextType > LocationContextOptional;
    typedef ::xsd::cxx::tree::traits< LocationContextType, char > LocationContextTraits;

    const LocationContextOptional&
    LocationContext () const;

    LocationContextOptional&
    LocationContext ();

    void
    LocationContext (const LocationContextType& x);

    void
    LocationContext (const LocationContextOptional& x);

    void
    LocationContext (::std::unique_ptr< LocationContextType > p);

    // EnsembleContext
    //
    typedef ::CDM::EnsembleContextDescriptor EnsembleContextType;
    typedef ::xsd::cxx::tree::optional< EnsembleContextType > EnsembleContextOptional;
    typedef ::xsd::cxx::tree::traits< EnsembleContextType, char > EnsembleContextTraits;

    const EnsembleContextOptional&
    EnsembleContext () const;

    EnsembleContextOptional&
    EnsembleContext ();

    void
    EnsembleContext (const EnsembleContextType& x);

    void
    EnsembleContext (const EnsembleContextOptional& x);

    void
    EnsembleContext (::std::unique_ptr< EnsembleContextType > p);

    // OperatorContext
    //
    typedef ::CDM::OperatorContextDescriptor OperatorContextType;
    typedef ::xsd::cxx::tree::optional< OperatorContextType > OperatorContextOptional;
    typedef ::xsd::cxx::tree::traits< OperatorContextType, char > OperatorContextTraits;

    const OperatorContextOptional&
    OperatorContext () const;

    OperatorContextOptional&
    OperatorContext ();

    void
    OperatorContext (const OperatorContextType& x);

    void
    OperatorContext (const OperatorContextOptional& x);

    void
    OperatorContext (::std::unique_ptr< OperatorContextType > p);

    // WorkflowContext
    //
    typedef ::CDM::WorkflowContextDescriptor WorkflowContextType;
    typedef ::xsd::cxx::tree::optional< WorkflowContextType > WorkflowContextOptional;
    typedef ::xsd::cxx::tree::traits< WorkflowContextType, char > WorkflowContextTraits;

    const WorkflowContextOptional&
    WorkflowContext () const;

    WorkflowContextOptional&
    WorkflowContext ();

    void
    WorkflowContext (const WorkflowContextType& x);

    void
    WorkflowContext (const WorkflowContextOptional& x);

    void
    WorkflowContext (::std::unique_ptr< WorkflowContextType > p);

    // MeansContext
    //
    typedef ::CDM::MeansContextDescriptor MeansContextType;
    typedef ::xsd::cxx::tree::optional< MeansContextType > MeansContextOptional;
    typedef ::xsd::cxx::tree::traits< MeansContextType, char > MeansContextTraits;

    const MeansContextOptional&
    MeansContext () const;

    MeansContextOptional&
    MeansContext ();

    void
    MeansContext (const MeansContextType& x);

    void
    MeansContext (const MeansContextOptional& x);

    void
    MeansContext (::std::unique_ptr< MeansContextType > p);

    // Constructors.
    //
    SystemContextDescriptor (const HandleType&);

    SystemContextDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    SystemContextDescriptor (const SystemContextDescriptor& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual SystemContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SystemContextDescriptor&
    operator= (const SystemContextDescriptor& x);

    virtual 
    ~SystemContextDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    PatientContextOptional PatientContext_;
    LocationContextOptional LocationContext_;
    EnsembleContextOptional EnsembleContext_;
    OperatorContextOptional OperatorContext_;
    WorkflowContextOptional WorkflowContext_;
    MeansContextOptional MeansContext_;
  };

  class SystemContextState: public ::CDM::AbstractState
  {
    public:
    // Constructors.
    //
    SystemContextState (const DescriptorHandleType&);

    SystemContextState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    SystemContextState (const SystemContextState& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual SystemContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~SystemContextState ();
  };

  class AbstractContextDescriptor: public ::CDM::AbstractDescriptor
  {
    public:
    // Constructors.
    //
    AbstractContextDescriptor (const HandleType&);

    AbstractContextDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    AbstractContextDescriptor (const AbstractContextDescriptor& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    virtual AbstractContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~AbstractContextDescriptor ();
  };

  class ContextAssociation: public ::xml_schema::String
  {
    public:
    enum Value
    {
      No,
      Pre,
      Assoc,
      Dis
    };

    ContextAssociation (Value v);

    ContextAssociation (const char* v);

    ContextAssociation (const ::std::string& v);

    ContextAssociation (const ::xml_schema::String& v);

    ContextAssociation (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    ContextAssociation (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    ContextAssociation (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    ContextAssociation (const ContextAssociation& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual ContextAssociation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ContextAssociation&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_ContextAssociation_convert ();
    }

    protected:
    Value
    _xsd_ContextAssociation_convert () const;

    public:
    static const char* const _xsd_ContextAssociation_literals_[4];
    static const Value _xsd_ContextAssociation_indexes_[4];
  };

  class AbstractContextState: public ::CDM::AbstractMultiState
  {
    public:
    // Validator
    //
    typedef ::CDM::InstanceIdentifier ValidatorType;
    typedef ::xsd::cxx::tree::sequence< ValidatorType > ValidatorSequence;
    typedef ValidatorSequence::iterator ValidatorIterator;
    typedef ValidatorSequence::const_iterator ValidatorConstIterator;
    typedef ::xsd::cxx::tree::traits< ValidatorType, char > ValidatorTraits;

    const ValidatorSequence&
    Validator () const;

    ValidatorSequence&
    Validator ();

    void
    Validator (const ValidatorSequence& s);

    // Identification
    //
    typedef ::CDM::InstanceIdentifier IdentificationType;
    typedef ::xsd::cxx::tree::sequence< IdentificationType > IdentificationSequence;
    typedef IdentificationSequence::iterator IdentificationIterator;
    typedef IdentificationSequence::const_iterator IdentificationConstIterator;
    typedef ::xsd::cxx::tree::traits< IdentificationType, char > IdentificationTraits;

    const IdentificationSequence&
    Identification () const;

    IdentificationSequence&
    Identification ();

    void
    Identification (const IdentificationSequence& s);

    // ContextAssociation
    //
    typedef ::CDM::ContextAssociation ContextAssociationType;
    typedef ::xsd::cxx::tree::optional< ContextAssociationType > ContextAssociationOptional;
    typedef ::xsd::cxx::tree::traits< ContextAssociationType, char > ContextAssociationTraits;

    const ContextAssociationOptional&
    ContextAssociation () const;

    ContextAssociationOptional&
    ContextAssociation ();

    void
    ContextAssociation (const ContextAssociationType& x);

    void
    ContextAssociation (const ContextAssociationOptional& x);

    void
    ContextAssociation (::std::unique_ptr< ContextAssociationType > p);

    // BindingMdibVersion
    //
    typedef ::CDM::ReferencedVersion BindingMdibVersionType;
    typedef ::xsd::cxx::tree::optional< BindingMdibVersionType > BindingMdibVersionOptional;
    typedef ::xsd::cxx::tree::traits< BindingMdibVersionType, char > BindingMdibVersionTraits;

    const BindingMdibVersionOptional&
    BindingMdibVersion () const;

    BindingMdibVersionOptional&
    BindingMdibVersion ();

    void
    BindingMdibVersion (const BindingMdibVersionType& x);

    void
    BindingMdibVersion (const BindingMdibVersionOptional& x);

    void
    BindingMdibVersion (::std::unique_ptr< BindingMdibVersionType > p);

    // UnbindingMdibVersion
    //
    typedef ::CDM::ReferencedVersion UnbindingMdibVersionType;
    typedef ::xsd::cxx::tree::optional< UnbindingMdibVersionType > UnbindingMdibVersionOptional;
    typedef ::xsd::cxx::tree::traits< UnbindingMdibVersionType, char > UnbindingMdibVersionTraits;

    const UnbindingMdibVersionOptional&
    UnbindingMdibVersion () const;

    UnbindingMdibVersionOptional&
    UnbindingMdibVersion ();

    void
    UnbindingMdibVersion (const UnbindingMdibVersionType& x);

    void
    UnbindingMdibVersion (const UnbindingMdibVersionOptional& x);

    void
    UnbindingMdibVersion (::std::unique_ptr< UnbindingMdibVersionType > p);

    // BindingStartTime
    //
    typedef ::CDM::Timestamp BindingStartTimeType;
    typedef ::xsd::cxx::tree::optional< BindingStartTimeType > BindingStartTimeOptional;
    typedef ::xsd::cxx::tree::traits< BindingStartTimeType, char > BindingStartTimeTraits;

    const BindingStartTimeOptional&
    BindingStartTime () const;

    BindingStartTimeOptional&
    BindingStartTime ();

    void
    BindingStartTime (const BindingStartTimeType& x);

    void
    BindingStartTime (const BindingStartTimeOptional& x);

    void
    BindingStartTime (::std::unique_ptr< BindingStartTimeType > p);

    // BindingEndTime
    //
    typedef ::CDM::Timestamp BindingEndTimeType;
    typedef ::xsd::cxx::tree::optional< BindingEndTimeType > BindingEndTimeOptional;
    typedef ::xsd::cxx::tree::traits< BindingEndTimeType, char > BindingEndTimeTraits;

    const BindingEndTimeOptional&
    BindingEndTime () const;

    BindingEndTimeOptional&
    BindingEndTime ();

    void
    BindingEndTime (const BindingEndTimeType& x);

    void
    BindingEndTime (const BindingEndTimeOptional& x);

    void
    BindingEndTime (::std::unique_ptr< BindingEndTimeType > p);

    // Constructors.
    //
    AbstractContextState (const DescriptorHandleType&,
                          const HandleType&);

    AbstractContextState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    AbstractContextState (const AbstractContextState& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual AbstractContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractContextState&
    operator= (const AbstractContextState& x);

    virtual 
    ~AbstractContextState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ValidatorSequence Validator_;
    IdentificationSequence Identification_;
    ContextAssociationOptional ContextAssociation_;
    BindingMdibVersionOptional BindingMdibVersion_;
    UnbindingMdibVersionOptional UnbindingMdibVersion_;
    BindingStartTimeOptional BindingStartTime_;
    BindingEndTimeOptional BindingEndTime_;
  };

  class BaseDemographics: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Givenname
    //
    typedef ::xml_schema::String GivennameType;
    typedef ::xsd::cxx::tree::optional< GivennameType > GivennameOptional;
    typedef ::xsd::cxx::tree::traits< GivennameType, char > GivennameTraits;

    const GivennameOptional&
    Givenname () const;

    GivennameOptional&
    Givenname ();

    void
    Givenname (const GivennameType& x);

    void
    Givenname (const GivennameOptional& x);

    void
    Givenname (::std::unique_ptr< GivennameType > p);

    // Middlename
    //
    typedef ::xml_schema::String MiddlenameType;
    typedef ::xsd::cxx::tree::sequence< MiddlenameType > MiddlenameSequence;
    typedef MiddlenameSequence::iterator MiddlenameIterator;
    typedef MiddlenameSequence::const_iterator MiddlenameConstIterator;
    typedef ::xsd::cxx::tree::traits< MiddlenameType, char > MiddlenameTraits;

    const MiddlenameSequence&
    Middlename () const;

    MiddlenameSequence&
    Middlename ();

    void
    Middlename (const MiddlenameSequence& s);

    // Familyname
    //
    typedef ::xml_schema::String FamilynameType;
    typedef ::xsd::cxx::tree::optional< FamilynameType > FamilynameOptional;
    typedef ::xsd::cxx::tree::traits< FamilynameType, char > FamilynameTraits;

    const FamilynameOptional&
    Familyname () const;

    FamilynameOptional&
    Familyname ();

    void
    Familyname (const FamilynameType& x);

    void
    Familyname (const FamilynameOptional& x);

    void
    Familyname (::std::unique_ptr< FamilynameType > p);

    // Birthname
    //
    typedef ::xml_schema::String BirthnameType;
    typedef ::xsd::cxx::tree::optional< BirthnameType > BirthnameOptional;
    typedef ::xsd::cxx::tree::traits< BirthnameType, char > BirthnameTraits;

    const BirthnameOptional&
    Birthname () const;

    BirthnameOptional&
    Birthname ();

    void
    Birthname (const BirthnameType& x);

    void
    Birthname (const BirthnameOptional& x);

    void
    Birthname (::std::unique_ptr< BirthnameType > p);

    // Title
    //
    typedef ::xml_schema::String TitleType;
    typedef ::xsd::cxx::tree::optional< TitleType > TitleOptional;
    typedef ::xsd::cxx::tree::traits< TitleType, char > TitleTraits;

    const TitleOptional&
    Title () const;

    TitleOptional&
    Title ();

    void
    Title (const TitleType& x);

    void
    Title (const TitleOptional& x);

    void
    Title (::std::unique_ptr< TitleType > p);

    // Constructors.
    //
    BaseDemographics ();

    BaseDemographics (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    BaseDemographics (const BaseDemographics& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual BaseDemographics*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    BaseDemographics&
    operator= (const BaseDemographics& x);

    virtual 
    ~BaseDemographics ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    GivennameOptional Givenname_;
    MiddlenameSequence Middlename_;
    FamilynameOptional Familyname_;
    BirthnameOptional Birthname_;
    TitleOptional Title_;
  };

  class PersonReference: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Identification
    //
    typedef ::CDM::InstanceIdentifier IdentificationType;
    typedef ::xsd::cxx::tree::sequence< IdentificationType > IdentificationSequence;
    typedef IdentificationSequence::iterator IdentificationIterator;
    typedef IdentificationSequence::const_iterator IdentificationConstIterator;
    typedef ::xsd::cxx::tree::traits< IdentificationType, char > IdentificationTraits;

    const IdentificationSequence&
    Identification () const;

    IdentificationSequence&
    Identification ();

    void
    Identification (const IdentificationSequence& s);

    // Name
    //
    typedef ::CDM::BaseDemographics NameType;
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameOptional&
    Name () const;

    NameOptional&
    Name ();

    void
    Name (const NameType& x);

    void
    Name (const NameOptional& x);

    void
    Name (::std::unique_ptr< NameType > p);

    // Constructors.
    //
    PersonReference ();

    PersonReference (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    PersonReference (const PersonReference& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual PersonReference*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    PersonReference&
    operator= (const PersonReference& x);

    virtual 
    ~PersonReference ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    IdentificationSequence Identification_;
    NameOptional Name_;
  };

  class LocationDetail: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // PoC
    //
    typedef ::xml_schema::String PoCType;
    typedef ::xsd::cxx::tree::optional< PoCType > PoCOptional;
    typedef ::xsd::cxx::tree::traits< PoCType, char > PoCTraits;

    const PoCOptional&
    PoC () const;

    PoCOptional&
    PoC ();

    void
    PoC (const PoCType& x);

    void
    PoC (const PoCOptional& x);

    void
    PoC (::std::unique_ptr< PoCType > p);

    // Room
    //
    typedef ::xml_schema::String RoomType;
    typedef ::xsd::cxx::tree::optional< RoomType > RoomOptional;
    typedef ::xsd::cxx::tree::traits< RoomType, char > RoomTraits;

    const RoomOptional&
    Room () const;

    RoomOptional&
    Room ();

    void
    Room (const RoomType& x);

    void
    Room (const RoomOptional& x);

    void
    Room (::std::unique_ptr< RoomType > p);

    // Bed
    //
    typedef ::xml_schema::String BedType;
    typedef ::xsd::cxx::tree::optional< BedType > BedOptional;
    typedef ::xsd::cxx::tree::traits< BedType, char > BedTraits;

    const BedOptional&
    Bed () const;

    BedOptional&
    Bed ();

    void
    Bed (const BedType& x);

    void
    Bed (const BedOptional& x);

    void
    Bed (::std::unique_ptr< BedType > p);

    // Facility
    //
    typedef ::xml_schema::String FacilityType;
    typedef ::xsd::cxx::tree::optional< FacilityType > FacilityOptional;
    typedef ::xsd::cxx::tree::traits< FacilityType, char > FacilityTraits;

    const FacilityOptional&
    Facility () const;

    FacilityOptional&
    Facility ();

    void
    Facility (const FacilityType& x);

    void
    Facility (const FacilityOptional& x);

    void
    Facility (::std::unique_ptr< FacilityType > p);

    // Building
    //
    typedef ::xml_schema::String BuildingType;
    typedef ::xsd::cxx::tree::optional< BuildingType > BuildingOptional;
    typedef ::xsd::cxx::tree::traits< BuildingType, char > BuildingTraits;

    const BuildingOptional&
    Building () const;

    BuildingOptional&
    Building ();

    void
    Building (const BuildingType& x);

    void
    Building (const BuildingOptional& x);

    void
    Building (::std::unique_ptr< BuildingType > p);

    // Floor
    //
    typedef ::xml_schema::String FloorType;
    typedef ::xsd::cxx::tree::optional< FloorType > FloorOptional;
    typedef ::xsd::cxx::tree::traits< FloorType, char > FloorTraits;

    const FloorOptional&
    Floor () const;

    FloorOptional&
    Floor ();

    void
    Floor (const FloorType& x);

    void
    Floor (const FloorOptional& x);

    void
    Floor (::std::unique_ptr< FloorType > p);

    // Constructors.
    //
    LocationDetail ();

    LocationDetail (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    LocationDetail (const LocationDetail& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual LocationDetail*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    LocationDetail&
    operator= (const LocationDetail& x);

    virtual 
    ~LocationDetail ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    PoCOptional PoC_;
    RoomOptional Room_;
    BedOptional Bed_;
    FacilityOptional Facility_;
    BuildingOptional Building_;
    FloorOptional Floor_;
  };

  class PatientContextDescriptor: public ::CDM::AbstractContextDescriptor
  {
    public:
    // Constructors.
    //
    PatientContextDescriptor (const HandleType&);

    PatientContextDescriptor (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    PatientContextDescriptor (const PatientContextDescriptor& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    virtual PatientContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~PatientContextDescriptor ();
  };

  class Sex: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Unspec,
      M,
      F,
      Unkn
    };

    Sex (Value v);

    Sex (const char* v);

    Sex (const ::std::string& v);

    Sex (const ::xml_schema::String& v);

    Sex (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    Sex (const ::xercesc::DOMAttr& a,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    Sex (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    Sex (const Sex& x,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    virtual Sex*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Sex&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_Sex_convert ();
    }

    protected:
    Value
    _xsd_Sex_convert () const;

    public:
    static const char* const _xsd_Sex_literals_[4];
    static const Value _xsd_Sex_indexes_[4];
  };

  class PatientType: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Unspec,
      Ad,
      Ped,
      Neo
    };

    PatientType (Value v);

    PatientType (const char* v);

    PatientType (const ::std::string& v);

    PatientType (const ::xml_schema::String& v);

    PatientType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    PatientType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    PatientType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    PatientType (const PatientType& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual PatientType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    PatientType&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_PatientType_convert ();
    }

    protected:
    Value
    _xsd_PatientType_convert () const;

    public:
    static const char* const _xsd_PatientType_literals_[4];
    static const Value _xsd_PatientType_indexes_[4];
  };

  class PatientDemographicsCoreData: public ::CDM::BaseDemographics
  {
    public:
    // Sex
    //
    typedef ::CDM::Sex SexType;
    typedef ::xsd::cxx::tree::optional< SexType > SexOptional;
    typedef ::xsd::cxx::tree::traits< SexType, char > SexTraits;

    const SexOptional&
    Sex () const;

    SexOptional&
    Sex ();

    void
    Sex (const SexType& x);

    void
    Sex (const SexOptional& x);

    void
    Sex (::std::unique_ptr< SexType > p);

    // PatientType
    //
    typedef ::CDM::PatientType PatientTypeType;
    typedef ::xsd::cxx::tree::optional< PatientTypeType > PatientTypeOptional;
    typedef ::xsd::cxx::tree::traits< PatientTypeType, char > PatientTypeTraits;

    const PatientTypeOptional&
    PatientType () const;

    PatientTypeOptional&
    PatientType ();

    void
    PatientType (const PatientTypeType& x);

    void
    PatientType (const PatientTypeOptional& x);

    void
    PatientType (::std::unique_ptr< PatientTypeType > p);

    // DateOfBirth
    //
    typedef ::CDM::DateOfBirth DateOfBirthType;
    typedef ::xsd::cxx::tree::optional< DateOfBirthType > DateOfBirthOptional;
    typedef ::xsd::cxx::tree::traits< DateOfBirthType, char > DateOfBirthTraits;

    const DateOfBirthOptional&
    DateOfBirth () const;

    DateOfBirthOptional&
    DateOfBirth ();

    void
    DateOfBirth (const DateOfBirthType& x);

    void
    DateOfBirth (const DateOfBirthOptional& x);

    void
    DateOfBirth (::std::unique_ptr< DateOfBirthType > p);

    // Height
    //
    typedef ::CDM::Measurement HeightType;
    typedef ::xsd::cxx::tree::optional< HeightType > HeightOptional;
    typedef ::xsd::cxx::tree::traits< HeightType, char > HeightTraits;

    const HeightOptional&
    Height () const;

    HeightOptional&
    Height ();

    void
    Height (const HeightType& x);

    void
    Height (const HeightOptional& x);

    void
    Height (::std::unique_ptr< HeightType > p);

    // Weight
    //
    typedef ::CDM::Measurement WeightType;
    typedef ::xsd::cxx::tree::optional< WeightType > WeightOptional;
    typedef ::xsd::cxx::tree::traits< WeightType, char > WeightTraits;

    const WeightOptional&
    Weight () const;

    WeightOptional&
    Weight ();

    void
    Weight (const WeightType& x);

    void
    Weight (const WeightOptional& x);

    void
    Weight (::std::unique_ptr< WeightType > p);

    // Race
    //
    typedef ::CDM::CodedValue RaceType;
    typedef ::xsd::cxx::tree::optional< RaceType > RaceOptional;
    typedef ::xsd::cxx::tree::traits< RaceType, char > RaceTraits;

    const RaceOptional&
    Race () const;

    RaceOptional&
    Race ();

    void
    Race (const RaceType& x);

    void
    Race (const RaceOptional& x);

    void
    Race (::std::unique_ptr< RaceType > p);

    // Constructors.
    //
    PatientDemographicsCoreData ();

    PatientDemographicsCoreData (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    PatientDemographicsCoreData (const PatientDemographicsCoreData& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    virtual PatientDemographicsCoreData*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    PatientDemographicsCoreData&
    operator= (const PatientDemographicsCoreData& x);

    virtual 
    ~PatientDemographicsCoreData ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SexOptional Sex_;
    PatientTypeOptional PatientType_;
    DateOfBirthOptional DateOfBirth_;
    HeightOptional Height_;
    WeightOptional Weight_;
    RaceOptional Race_;
  };

  class NeonatalPatientDemographicsCoreData: public ::CDM::PatientDemographicsCoreData
  {
    public:
    // GestationalAge
    //
    typedef ::CDM::Measurement GestationalAgeType;
    typedef ::xsd::cxx::tree::optional< GestationalAgeType > GestationalAgeOptional;
    typedef ::xsd::cxx::tree::traits< GestationalAgeType, char > GestationalAgeTraits;

    const GestationalAgeOptional&
    GestationalAge () const;

    GestationalAgeOptional&
    GestationalAge ();

    void
    GestationalAge (const GestationalAgeType& x);

    void
    GestationalAge (const GestationalAgeOptional& x);

    void
    GestationalAge (::std::unique_ptr< GestationalAgeType > p);

    // BirthLength
    //
    typedef ::CDM::Measurement BirthLengthType;
    typedef ::xsd::cxx::tree::optional< BirthLengthType > BirthLengthOptional;
    typedef ::xsd::cxx::tree::traits< BirthLengthType, char > BirthLengthTraits;

    const BirthLengthOptional&
    BirthLength () const;

    BirthLengthOptional&
    BirthLength ();

    void
    BirthLength (const BirthLengthType& x);

    void
    BirthLength (const BirthLengthOptional& x);

    void
    BirthLength (::std::unique_ptr< BirthLengthType > p);

    // BirthWeight
    //
    typedef ::CDM::Measurement BirthWeightType;
    typedef ::xsd::cxx::tree::optional< BirthWeightType > BirthWeightOptional;
    typedef ::xsd::cxx::tree::traits< BirthWeightType, char > BirthWeightTraits;

    const BirthWeightOptional&
    BirthWeight () const;

    BirthWeightOptional&
    BirthWeight ();

    void
    BirthWeight (const BirthWeightType& x);

    void
    BirthWeight (const BirthWeightOptional& x);

    void
    BirthWeight (::std::unique_ptr< BirthWeightType > p);

    // HeadCircumference
    //
    typedef ::CDM::Measurement HeadCircumferenceType;
    typedef ::xsd::cxx::tree::optional< HeadCircumferenceType > HeadCircumferenceOptional;
    typedef ::xsd::cxx::tree::traits< HeadCircumferenceType, char > HeadCircumferenceTraits;

    const HeadCircumferenceOptional&
    HeadCircumference () const;

    HeadCircumferenceOptional&
    HeadCircumference ();

    void
    HeadCircumference (const HeadCircumferenceType& x);

    void
    HeadCircumference (const HeadCircumferenceOptional& x);

    void
    HeadCircumference (::std::unique_ptr< HeadCircumferenceType > p);

    // Mother
    //
    typedef ::CDM::PersonReference MotherType;
    typedef ::xsd::cxx::tree::optional< MotherType > MotherOptional;
    typedef ::xsd::cxx::tree::traits< MotherType, char > MotherTraits;

    const MotherOptional&
    Mother () const;

    MotherOptional&
    Mother ();

    void
    Mother (const MotherType& x);

    void
    Mother (const MotherOptional& x);

    void
    Mother (::std::unique_ptr< MotherType > p);

    // Constructors.
    //
    NeonatalPatientDemographicsCoreData ();

    NeonatalPatientDemographicsCoreData (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    NeonatalPatientDemographicsCoreData (const NeonatalPatientDemographicsCoreData& x,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    virtual NeonatalPatientDemographicsCoreData*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    NeonatalPatientDemographicsCoreData&
    operator= (const NeonatalPatientDemographicsCoreData& x);

    virtual 
    ~NeonatalPatientDemographicsCoreData ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    GestationalAgeOptional GestationalAge_;
    BirthLengthOptional BirthLength_;
    BirthWeightOptional BirthWeight_;
    HeadCircumferenceOptional HeadCircumference_;
    MotherOptional Mother_;
  };

  class PatientContextState: public ::CDM::AbstractContextState
  {
    public:
    // CoreData
    //
    typedef ::CDM::PatientDemographicsCoreData CoreDataType;
    typedef ::xsd::cxx::tree::optional< CoreDataType > CoreDataOptional;
    typedef ::xsd::cxx::tree::traits< CoreDataType, char > CoreDataTraits;

    const CoreDataOptional&
    CoreData () const;

    CoreDataOptional&
    CoreData ();

    void
    CoreData (const CoreDataType& x);

    void
    CoreData (const CoreDataOptional& x);

    void
    CoreData (::std::unique_ptr< CoreDataType > p);

    // Constructors.
    //
    PatientContextState (const DescriptorHandleType&,
                         const HandleType&);

    PatientContextState (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    PatientContextState (const PatientContextState& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual PatientContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    PatientContextState&
    operator= (const PatientContextState& x);

    virtual 
    ~PatientContextState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CoreDataOptional CoreData_;
  };

  class LocationContextDescriptor: public ::CDM::AbstractContextDescriptor
  {
    public:
    // Constructors.
    //
    LocationContextDescriptor (const HandleType&);

    LocationContextDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    LocationContextDescriptor (const LocationContextDescriptor& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    virtual LocationContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~LocationContextDescriptor ();
  };

  class LocationContextState: public ::CDM::AbstractContextState
  {
    public:
    // LocationDetail
    //
    typedef ::CDM::LocationDetail LocationDetailType;
    typedef ::xsd::cxx::tree::optional< LocationDetailType > LocationDetailOptional;
    typedef ::xsd::cxx::tree::traits< LocationDetailType, char > LocationDetailTraits;

    const LocationDetailOptional&
    LocationDetail () const;

    LocationDetailOptional&
    LocationDetail ();

    void
    LocationDetail (const LocationDetailType& x);

    void
    LocationDetail (const LocationDetailOptional& x);

    void
    LocationDetail (::std::unique_ptr< LocationDetailType > p);

    // Constructors.
    //
    LocationContextState (const DescriptorHandleType&,
                          const HandleType&);

    LocationContextState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    LocationContextState (const LocationContextState& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual LocationContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    LocationContextState&
    operator= (const LocationContextState& x);

    virtual 
    ~LocationContextState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    LocationDetailOptional LocationDetail_;
  };

  class WorkflowContextDescriptor: public ::CDM::AbstractContextDescriptor
  {
    public:
    // Constructors.
    //
    WorkflowContextDescriptor (const HandleType&);

    WorkflowContextDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    WorkflowContextDescriptor (const WorkflowContextDescriptor& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    virtual WorkflowContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~WorkflowContextDescriptor ();
  };

  class ClinicalInfo: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Type
    //
    typedef ::CDM::CodedValue TypeType;
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeOptional&
    Type () const;

    TypeOptional&
    Type ();

    void
    Type (const TypeType& x);

    void
    Type (const TypeOptional& x);

    void
    Type (::std::unique_ptr< TypeType > p);

    // Description
    //
    typedef ::CDM::LocalizedText DescriptionType;
    typedef ::xsd::cxx::tree::sequence< DescriptionType > DescriptionSequence;
    typedef DescriptionSequence::iterator DescriptionIterator;
    typedef DescriptionSequence::const_iterator DescriptionConstIterator;
    typedef ::xsd::cxx::tree::traits< DescriptionType, char > DescriptionTraits;

    const DescriptionSequence&
    Description () const;

    DescriptionSequence&
    Description ();

    void
    Description (const DescriptionSequence& s);

    // RelatedMeasurement
    //
    typedef ::CDM::RelatedMeasurement RelatedMeasurementType;
    typedef ::xsd::cxx::tree::sequence< RelatedMeasurementType > RelatedMeasurementSequence;
    typedef RelatedMeasurementSequence::iterator RelatedMeasurementIterator;
    typedef RelatedMeasurementSequence::const_iterator RelatedMeasurementConstIterator;
    typedef ::xsd::cxx::tree::traits< RelatedMeasurementType, char > RelatedMeasurementTraits;

    const RelatedMeasurementSequence&
    RelatedMeasurement () const;

    RelatedMeasurementSequence&
    RelatedMeasurement ();

    void
    RelatedMeasurement (const RelatedMeasurementSequence& s);

    // Constructors.
    //
    ClinicalInfo ();

    ClinicalInfo (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    ClinicalInfo (const ClinicalInfo& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual ClinicalInfo*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ClinicalInfo&
    operator= (const ClinicalInfo& x);

    virtual 
    ~ClinicalInfo ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    TypeOptional Type_;
    DescriptionSequence Description_;
    RelatedMeasurementSequence RelatedMeasurement_;
  };

  class ImagingProcedure: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // AccessionIdentifier
    //
    typedef ::CDM::InstanceIdentifier AccessionIdentifierType;
    typedef ::xsd::cxx::tree::traits< AccessionIdentifierType, char > AccessionIdentifierTraits;

    const AccessionIdentifierType&
    AccessionIdentifier () const;

    AccessionIdentifierType&
    AccessionIdentifier ();

    void
    AccessionIdentifier (const AccessionIdentifierType& x);

    void
    AccessionIdentifier (::std::unique_ptr< AccessionIdentifierType > p);

    // RequestedProcedureId
    //
    typedef ::CDM::InstanceIdentifier RequestedProcedureIdType;
    typedef ::xsd::cxx::tree::traits< RequestedProcedureIdType, char > RequestedProcedureIdTraits;

    const RequestedProcedureIdType&
    RequestedProcedureId () const;

    RequestedProcedureIdType&
    RequestedProcedureId ();

    void
    RequestedProcedureId (const RequestedProcedureIdType& x);

    void
    RequestedProcedureId (::std::unique_ptr< RequestedProcedureIdType > p);

    // StudyInstanceUid
    //
    typedef ::CDM::InstanceIdentifier StudyInstanceUidType;
    typedef ::xsd::cxx::tree::traits< StudyInstanceUidType, char > StudyInstanceUidTraits;

    const StudyInstanceUidType&
    StudyInstanceUid () const;

    StudyInstanceUidType&
    StudyInstanceUid ();

    void
    StudyInstanceUid (const StudyInstanceUidType& x);

    void
    StudyInstanceUid (::std::unique_ptr< StudyInstanceUidType > p);

    // ScheduledProcedureStepId
    //
    typedef ::CDM::InstanceIdentifier ScheduledProcedureStepIdType;
    typedef ::xsd::cxx::tree::traits< ScheduledProcedureStepIdType, char > ScheduledProcedureStepIdTraits;

    const ScheduledProcedureStepIdType&
    ScheduledProcedureStepId () const;

    ScheduledProcedureStepIdType&
    ScheduledProcedureStepId ();

    void
    ScheduledProcedureStepId (const ScheduledProcedureStepIdType& x);

    void
    ScheduledProcedureStepId (::std::unique_ptr< ScheduledProcedureStepIdType > p);

    // Modality
    //
    typedef ::CDM::CodedValue ModalityType;
    typedef ::xsd::cxx::tree::optional< ModalityType > ModalityOptional;
    typedef ::xsd::cxx::tree::traits< ModalityType, char > ModalityTraits;

    const ModalityOptional&
    Modality () const;

    ModalityOptional&
    Modality ();

    void
    Modality (const ModalityType& x);

    void
    Modality (const ModalityOptional& x);

    void
    Modality (::std::unique_ptr< ModalityType > p);

    // ProtocolCode
    //
    typedef ::CDM::CodedValue ProtocolCodeType;
    typedef ::xsd::cxx::tree::optional< ProtocolCodeType > ProtocolCodeOptional;
    typedef ::xsd::cxx::tree::traits< ProtocolCodeType, char > ProtocolCodeTraits;

    const ProtocolCodeOptional&
    ProtocolCode () const;

    ProtocolCodeOptional&
    ProtocolCode ();

    void
    ProtocolCode (const ProtocolCodeType& x);

    void
    ProtocolCode (const ProtocolCodeOptional& x);

    void
    ProtocolCode (::std::unique_ptr< ProtocolCodeType > p);

    // Constructors.
    //
    ImagingProcedure (const AccessionIdentifierType&,
                      const RequestedProcedureIdType&,
                      const StudyInstanceUidType&,
                      const ScheduledProcedureStepIdType&);

    ImagingProcedure (::std::unique_ptr< AccessionIdentifierType >,
                      ::std::unique_ptr< RequestedProcedureIdType >,
                      ::std::unique_ptr< StudyInstanceUidType >,
                      ::std::unique_ptr< ScheduledProcedureStepIdType >);

    ImagingProcedure (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    ImagingProcedure (const ImagingProcedure& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual ImagingProcedure*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ImagingProcedure&
    operator= (const ImagingProcedure& x);

    virtual 
    ~ImagingProcedure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< AccessionIdentifierType > AccessionIdentifier_;
    ::xsd::cxx::tree::one< RequestedProcedureIdType > RequestedProcedureId_;
    ::xsd::cxx::tree::one< StudyInstanceUidType > StudyInstanceUid_;
    ::xsd::cxx::tree::one< ScheduledProcedureStepIdType > ScheduledProcedureStepId_;
    ModalityOptional Modality_;
    ProtocolCodeOptional ProtocolCode_;
  };

  class LocationReference: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Identification
    //
    typedef ::CDM::InstanceIdentifier IdentificationType;
    typedef ::xsd::cxx::tree::sequence< IdentificationType > IdentificationSequence;
    typedef IdentificationSequence::iterator IdentificationIterator;
    typedef IdentificationSequence::const_iterator IdentificationConstIterator;
    typedef ::xsd::cxx::tree::traits< IdentificationType, char > IdentificationTraits;

    const IdentificationSequence&
    Identification () const;

    IdentificationSequence&
    Identification ();

    void
    Identification (const IdentificationSequence& s);

    // LocationDetail
    //
    typedef ::CDM::LocationDetail LocationDetailType;
    typedef ::xsd::cxx::tree::optional< LocationDetailType > LocationDetailOptional;
    typedef ::xsd::cxx::tree::traits< LocationDetailType, char > LocationDetailTraits;

    const LocationDetailOptional&
    LocationDetail () const;

    LocationDetailOptional&
    LocationDetail ();

    void
    LocationDetail (const LocationDetailType& x);

    void
    LocationDetail (const LocationDetailOptional& x);

    void
    LocationDetail (::std::unique_ptr< LocationDetailType > p);

    // Constructors.
    //
    LocationReference ();

    LocationReference (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    LocationReference (const LocationReference& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual LocationReference*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    LocationReference&
    operator= (const LocationReference& x);

    virtual 
    ~LocationReference ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    IdentificationSequence Identification_;
    LocationDetailOptional LocationDetail_;
  };

  class OrderDetail: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Start
    //
    typedef ::xml_schema::DateTime StartType;
    typedef ::xsd::cxx::tree::optional< StartType > StartOptional;
    typedef ::xsd::cxx::tree::traits< StartType, char > StartTraits;

    const StartOptional&
    Start () const;

    StartOptional&
    Start ();

    void
    Start (const StartType& x);

    void
    Start (const StartOptional& x);

    void
    Start (::std::unique_ptr< StartType > p);

    // End
    //
    typedef ::xml_schema::DateTime EndType;
    typedef ::xsd::cxx::tree::optional< EndType > EndOptional;
    typedef ::xsd::cxx::tree::traits< EndType, char > EndTraits;

    const EndOptional&
    End () const;

    EndOptional&
    End ();

    void
    End (const EndType& x);

    void
    End (const EndOptional& x);

    void
    End (::std::unique_ptr< EndType > p);

    // Performer
    //
    typedef ::CDM::PersonParticipation PerformerType;
    typedef ::xsd::cxx::tree::sequence< PerformerType > PerformerSequence;
    typedef PerformerSequence::iterator PerformerIterator;
    typedef PerformerSequence::const_iterator PerformerConstIterator;
    typedef ::xsd::cxx::tree::traits< PerformerType, char > PerformerTraits;

    const PerformerSequence&
    Performer () const;

    PerformerSequence&
    Performer ();

    void
    Performer (const PerformerSequence& s);

    // Service
    //
    typedef ::CDM::CodedValue ServiceType;
    typedef ::xsd::cxx::tree::sequence< ServiceType > ServiceSequence;
    typedef ServiceSequence::iterator ServiceIterator;
    typedef ServiceSequence::const_iterator ServiceConstIterator;
    typedef ::xsd::cxx::tree::traits< ServiceType, char > ServiceTraits;

    const ServiceSequence&
    Service () const;

    ServiceSequence&
    Service ();

    void
    Service (const ServiceSequence& s);

    // ImagingProcedure
    //
    typedef ::CDM::ImagingProcedure ImagingProcedureType;
    typedef ::xsd::cxx::tree::sequence< ImagingProcedureType > ImagingProcedureSequence;
    typedef ImagingProcedureSequence::iterator ImagingProcedureIterator;
    typedef ImagingProcedureSequence::const_iterator ImagingProcedureConstIterator;
    typedef ::xsd::cxx::tree::traits< ImagingProcedureType, char > ImagingProcedureTraits;

    const ImagingProcedureSequence&
    ImagingProcedure () const;

    ImagingProcedureSequence&
    ImagingProcedure ();

    void
    ImagingProcedure (const ImagingProcedureSequence& s);

    // Constructors.
    //
    OrderDetail ();

    OrderDetail (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    OrderDetail (const OrderDetail& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual OrderDetail*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    OrderDetail&
    operator= (const OrderDetail& x);

    virtual 
    ~OrderDetail ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    StartOptional Start_;
    EndOptional End_;
    PerformerSequence Performer_;
    ServiceSequence Service_;
    ImagingProcedureSequence ImagingProcedure_;
  };

  class PersonParticipation: public ::CDM::PersonReference
  {
    public:
    // Role
    //
    typedef ::CDM::CodedValue RoleType;
    typedef ::xsd::cxx::tree::sequence< RoleType > RoleSequence;
    typedef RoleSequence::iterator RoleIterator;
    typedef RoleSequence::const_iterator RoleConstIterator;
    typedef ::xsd::cxx::tree::traits< RoleType, char > RoleTraits;

    const RoleSequence&
    Role () const;

    RoleSequence&
    Role ();

    void
    Role (const RoleSequence& s);

    // Constructors.
    //
    PersonParticipation ();

    PersonParticipation (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    PersonParticipation (const PersonParticipation& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual PersonParticipation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    PersonParticipation&
    operator= (const PersonParticipation& x);

    virtual 
    ~PersonParticipation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    RoleSequence Role_;
  };

  class WorkflowContextState: public ::CDM::AbstractContextState
  {
    public:
    // WorkflowDetail
    //
    typedef ::CDM::WorkflowDetail WorkflowDetailType;
    typedef ::xsd::cxx::tree::optional< WorkflowDetailType > WorkflowDetailOptional;
    typedef ::xsd::cxx::tree::traits< WorkflowDetailType, char > WorkflowDetailTraits;

    const WorkflowDetailOptional&
    WorkflowDetail () const;

    WorkflowDetailOptional&
    WorkflowDetail ();

    void
    WorkflowDetail (const WorkflowDetailType& x);

    void
    WorkflowDetail (const WorkflowDetailOptional& x);

    void
    WorkflowDetail (::std::unique_ptr< WorkflowDetailType > p);

    // Constructors.
    //
    WorkflowContextState (const DescriptorHandleType&,
                          const HandleType&);

    WorkflowContextState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    WorkflowContextState (const WorkflowContextState& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual WorkflowContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    WorkflowContextState&
    operator= (const WorkflowContextState& x);

    virtual 
    ~WorkflowContextState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    WorkflowDetailOptional WorkflowDetail_;
  };

  class OperatorContextDescriptor: public ::CDM::AbstractContextDescriptor
  {
    public:
    // Constructors.
    //
    OperatorContextDescriptor (const HandleType&);

    OperatorContextDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    OperatorContextDescriptor (const OperatorContextDescriptor& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    virtual OperatorContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~OperatorContextDescriptor ();
  };

  class OperatorContextState: public ::CDM::AbstractContextState
  {
    public:
    // OperatorDetails
    //
    typedef ::CDM::BaseDemographics OperatorDetailsType;
    typedef ::xsd::cxx::tree::traits< OperatorDetailsType, char > OperatorDetailsTraits;

    const OperatorDetailsType&
    OperatorDetails () const;

    OperatorDetailsType&
    OperatorDetails ();

    void
    OperatorDetails (const OperatorDetailsType& x);

    void
    OperatorDetails (::std::unique_ptr< OperatorDetailsType > p);

    // Constructors.
    //
    OperatorContextState (const DescriptorHandleType&,
                          const HandleType&,
                          const OperatorDetailsType&);

    OperatorContextState (const DescriptorHandleType&,
                          const HandleType&,
                          ::std::unique_ptr< OperatorDetailsType >);

    OperatorContextState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    OperatorContextState (const OperatorContextState& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual OperatorContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    OperatorContextState&
    operator= (const OperatorContextState& x);

    virtual 
    ~OperatorContextState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< OperatorDetailsType > OperatorDetails_;
  };

  class MeansContextDescriptor: public ::CDM::AbstractContextDescriptor
  {
    public:
    // Constructors.
    //
    MeansContextDescriptor (const HandleType&);

    MeansContextDescriptor (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    MeansContextDescriptor (const MeansContextDescriptor& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    virtual MeansContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~MeansContextDescriptor ();
  };

  class MeansContextState: public ::CDM::AbstractContextState
  {
    public:
    // Constructors.
    //
    MeansContextState (const DescriptorHandleType&,
                       const HandleType&);

    MeansContextState (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    MeansContextState (const MeansContextState& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual MeansContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~MeansContextState ();
  };

  class EnsembleContextDescriptor: public ::CDM::AbstractContextDescriptor
  {
    public:
    // Constructors.
    //
    EnsembleContextDescriptor (const HandleType&);

    EnsembleContextDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    EnsembleContextDescriptor (const EnsembleContextDescriptor& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    virtual EnsembleContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~EnsembleContextDescriptor ();
  };

  class EnsembleContextState: public ::CDM::AbstractContextState
  {
    public:
    // Constructors.
    //
    EnsembleContextState (const DescriptorHandleType&,
                          const HandleType&);

    EnsembleContextState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    EnsembleContextState (const EnsembleContextState& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual EnsembleContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~EnsembleContextState ();
  };

  class ContainmentTree: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Entry
    //
    typedef ::CDM::ContainmentTreeEntry EntryType;
    typedef ::xsd::cxx::tree::sequence< EntryType > EntrySequence;
    typedef EntrySequence::iterator EntryIterator;
    typedef EntrySequence::const_iterator EntryConstIterator;
    typedef ::xsd::cxx::tree::traits< EntryType, char > EntryTraits;

    const EntrySequence&
    Entry () const;

    EntrySequence&
    Entry ();

    void
    Entry (const EntrySequence& s);

    // HandleRef
    //
    typedef ::CDM::HandleRef HandleRefType;
    typedef ::xsd::cxx::tree::optional< HandleRefType > HandleRefOptional;
    typedef ::xsd::cxx::tree::traits< HandleRefType, char > HandleRefTraits;

    const HandleRefOptional&
    HandleRef () const;

    HandleRefOptional&
    HandleRef ();

    void
    HandleRef (const HandleRefType& x);

    void
    HandleRef (const HandleRefOptional& x);

    void
    HandleRef (::std::unique_ptr< HandleRefType > p);

    // ParentHandleRef
    //
    typedef ::CDM::HandleRef ParentHandleRefType;
    typedef ::xsd::cxx::tree::optional< ParentHandleRefType > ParentHandleRefOptional;
    typedef ::xsd::cxx::tree::traits< ParentHandleRefType, char > ParentHandleRefTraits;

    const ParentHandleRefOptional&
    ParentHandleRef () const;

    ParentHandleRefOptional&
    ParentHandleRef ();

    void
    ParentHandleRef (const ParentHandleRefType& x);

    void
    ParentHandleRef (const ParentHandleRefOptional& x);

    void
    ParentHandleRef (::std::unique_ptr< ParentHandleRefType > p);

    // EntryType
    //
    typedef ::xml_schema::Qname EntryTypeType;
    typedef ::xsd::cxx::tree::optional< EntryTypeType > EntryTypeOptional;
    typedef ::xsd::cxx::tree::traits< EntryTypeType, char > EntryTypeTraits;

    const EntryTypeOptional&
    EntryType1 () const;

    EntryTypeOptional&
    EntryType1 ();

    void
    EntryType1 (const EntryTypeType& x);

    void
    EntryType1 (const EntryTypeOptional& x);

    void
    EntryType1 (::std::unique_ptr< EntryTypeType > p);

    // ChildrenCount
    //
    typedef ::xml_schema::Int ChildrenCountType;
    typedef ::xsd::cxx::tree::optional< ChildrenCountType > ChildrenCountOptional;
    typedef ::xsd::cxx::tree::traits< ChildrenCountType, char > ChildrenCountTraits;

    const ChildrenCountOptional&
    ChildrenCount () const;

    ChildrenCountOptional&
    ChildrenCount ();

    void
    ChildrenCount (const ChildrenCountType& x);

    void
    ChildrenCount (const ChildrenCountOptional& x);

    // Constructors.
    //
    ContainmentTree ();

    ContainmentTree (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    ContainmentTree (const ContainmentTree& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual ContainmentTree*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ContainmentTree&
    operator= (const ContainmentTree& x);

    virtual 
    ~ContainmentTree ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    EntrySequence Entry_;
    HandleRefOptional HandleRef_;
    ParentHandleRefOptional ParentHandleRef_;
    EntryTypeOptional EntryType_;
    ChildrenCountOptional ChildrenCount_;
  };

  class ContainmentTreeEntry: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Type
    //
    typedef ::CDM::CodedValue TypeType;
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeOptional&
    Type () const;

    TypeOptional&
    Type ();

    void
    Type (const TypeType& x);

    void
    Type (const TypeOptional& x);

    void
    Type (::std::unique_ptr< TypeType > p);

    // HandleRef
    //
    typedef ::CDM::HandleRef HandleRefType;
    typedef ::xsd::cxx::tree::optional< HandleRefType > HandleRefOptional;
    typedef ::xsd::cxx::tree::traits< HandleRefType, char > HandleRefTraits;

    const HandleRefOptional&
    HandleRef () const;

    HandleRefOptional&
    HandleRef ();

    void
    HandleRef (const HandleRefType& x);

    void
    HandleRef (const HandleRefOptional& x);

    void
    HandleRef (::std::unique_ptr< HandleRefType > p);

    // ParentHandleRef
    //
    typedef ::CDM::HandleRef ParentHandleRefType;
    typedef ::xsd::cxx::tree::optional< ParentHandleRefType > ParentHandleRefOptional;
    typedef ::xsd::cxx::tree::traits< ParentHandleRefType, char > ParentHandleRefTraits;

    const ParentHandleRefOptional&
    ParentHandleRef () const;

    ParentHandleRefOptional&
    ParentHandleRef ();

    void
    ParentHandleRef (const ParentHandleRefType& x);

    void
    ParentHandleRef (const ParentHandleRefOptional& x);

    void
    ParentHandleRef (::std::unique_ptr< ParentHandleRefType > p);

    // EntryType
    //
    typedef ::xml_schema::Qname EntryTypeType;
    typedef ::xsd::cxx::tree::optional< EntryTypeType > EntryTypeOptional;
    typedef ::xsd::cxx::tree::traits< EntryTypeType, char > EntryTypeTraits;

    const EntryTypeOptional&
    EntryType () const;

    EntryTypeOptional&
    EntryType ();

    void
    EntryType (const EntryTypeType& x);

    void
    EntryType (const EntryTypeOptional& x);

    void
    EntryType (::std::unique_ptr< EntryTypeType > p);

    // ChildrenCount
    //
    typedef ::xml_schema::Int ChildrenCountType;
    typedef ::xsd::cxx::tree::optional< ChildrenCountType > ChildrenCountOptional;
    typedef ::xsd::cxx::tree::traits< ChildrenCountType, char > ChildrenCountTraits;

    const ChildrenCountOptional&
    ChildrenCount () const;

    ChildrenCountOptional&
    ChildrenCount ();

    void
    ChildrenCount (const ChildrenCountType& x);

    void
    ChildrenCount (const ChildrenCountOptional& x);

    // Constructors.
    //
    ContainmentTreeEntry ();

    ContainmentTreeEntry (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    ContainmentTreeEntry (const ContainmentTreeEntry& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual ContainmentTreeEntry*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ContainmentTreeEntry&
    operator= (const ContainmentTreeEntry& x);

    virtual 
    ~ContainmentTreeEntry ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    TypeOptional Type_;
    HandleRefOptional HandleRef_;
    ParentHandleRefOptional ParentHandleRef_;
    EntryTypeOptional EntryType_;
    ChildrenCountOptional ChildrenCount_;
  };

  class ProductionSpecification: public ::xml_schema::Type
  {
    public:
    // SpecType
    //
    typedef ::CDM::CodedValue SpecTypeType;
    typedef ::xsd::cxx::tree::traits< SpecTypeType, char > SpecTypeTraits;

    const SpecTypeType&
    SpecType () const;

    SpecTypeType&
    SpecType ();

    void
    SpecType (const SpecTypeType& x);

    void
    SpecType (::std::unique_ptr< SpecTypeType > p);

    // ProductionSpec
    //
    typedef ::xml_schema::String ProductionSpecType;
    typedef ::xsd::cxx::tree::traits< ProductionSpecType, char > ProductionSpecTraits;

    const ProductionSpecType&
    ProductionSpec () const;

    ProductionSpecType&
    ProductionSpec ();

    void
    ProductionSpec (const ProductionSpecType& x);

    void
    ProductionSpec (::std::unique_ptr< ProductionSpecType > p);

    // ComponentId
    //
    typedef ::CDM::InstanceIdentifier ComponentIdType;
    typedef ::xsd::cxx::tree::optional< ComponentIdType > ComponentIdOptional;
    typedef ::xsd::cxx::tree::traits< ComponentIdType, char > ComponentIdTraits;

    const ComponentIdOptional&
    ComponentId () const;

    ComponentIdOptional&
    ComponentId ();

    void
    ComponentId (const ComponentIdType& x);

    void
    ComponentId (const ComponentIdOptional& x);

    void
    ComponentId (::std::unique_ptr< ComponentIdType > p);

    // Constructors.
    //
    ProductionSpecification (const SpecTypeType&,
                             const ProductionSpecType&);

    ProductionSpecification (::std::unique_ptr< SpecTypeType >,
                             const ProductionSpecType&);

    ProductionSpecification (::std::unique_ptr< SpecTypeType >,
                             ::std::unique_ptr< ProductionSpecType >);

    ProductionSpecification (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    ProductionSpecification (const ProductionSpecification& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual ProductionSpecification*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ProductionSpecification&
    operator= (const ProductionSpecification& x);

    virtual 
    ~ProductionSpecification ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< SpecTypeType > SpecType_;
    ::xsd::cxx::tree::one< ProductionSpecType > ProductionSpec_;
    ComponentIdOptional ComponentId_;
  };

  class MetaData: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Udi
    //
    typedef ::xml_schema::String UdiType;
    typedef ::xsd::cxx::tree::optional< UdiType > UdiOptional;
    typedef ::xsd::cxx::tree::traits< UdiType, char > UdiTraits;

    const UdiOptional&
    Udi () const;

    UdiOptional&
    Udi ();

    void
    Udi (const UdiType& x);

    void
    Udi (const UdiOptional& x);

    void
    Udi (::std::unique_ptr< UdiType > p);

    // Manufacturer
    //
    typedef ::CDM::LocalizedText ManufacturerType;
    typedef ::xsd::cxx::tree::sequence< ManufacturerType > ManufacturerSequence;
    typedef ManufacturerSequence::iterator ManufacturerIterator;
    typedef ManufacturerSequence::const_iterator ManufacturerConstIterator;
    typedef ::xsd::cxx::tree::traits< ManufacturerType, char > ManufacturerTraits;

    const ManufacturerSequence&
    Manufacturer () const;

    ManufacturerSequence&
    Manufacturer ();

    void
    Manufacturer (const ManufacturerSequence& s);

    // ModelName
    //
    typedef ::CDM::LocalizedText ModelNameType;
    typedef ::xsd::cxx::tree::sequence< ModelNameType > ModelNameSequence;
    typedef ModelNameSequence::iterator ModelNameIterator;
    typedef ModelNameSequence::const_iterator ModelNameConstIterator;
    typedef ::xsd::cxx::tree::traits< ModelNameType, char > ModelNameTraits;

    const ModelNameSequence&
    ModelName () const;

    ModelNameSequence&
    ModelName ();

    void
    ModelName (const ModelNameSequence& s);

    // ModelNumber
    //
    typedef ::xml_schema::String ModelNumberType;
    typedef ::xsd::cxx::tree::optional< ModelNumberType > ModelNumberOptional;
    typedef ::xsd::cxx::tree::traits< ModelNumberType, char > ModelNumberTraits;

    const ModelNumberOptional&
    ModelNumber () const;

    ModelNumberOptional&
    ModelNumber ();

    void
    ModelNumber (const ModelNumberType& x);

    void
    ModelNumber (const ModelNumberOptional& x);

    void
    ModelNumber (::std::unique_ptr< ModelNumberType > p);

    // SerialNumber
    //
    typedef ::xml_schema::String SerialNumberType;
    typedef ::xsd::cxx::tree::sequence< SerialNumberType > SerialNumberSequence;
    typedef SerialNumberSequence::iterator SerialNumberIterator;
    typedef SerialNumberSequence::const_iterator SerialNumberConstIterator;
    typedef ::xsd::cxx::tree::traits< SerialNumberType, char > SerialNumberTraits;

    const SerialNumberSequence&
    SerialNumber () const;

    SerialNumberSequence&
    SerialNumber ();

    void
    SerialNumber (const SerialNumberSequence& s);

    // Constructors.
    //
    MetaData ();

    MetaData (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    MetaData (const MetaData& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    virtual MetaData*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MetaData&
    operator= (const MetaData& x);

    virtual 
    ~MetaData ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    UdiOptional Udi_;
    ManufacturerSequence Manufacturer_;
    ModelNameSequence ModelName_;
    ModelNumberOptional ModelNumber_;
    SerialNumberSequence SerialNumber_;
  };

  class MetricQuality: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Validity
    //
    typedef ::CDM::MeasurementValidity ValidityType;
    typedef ::xsd::cxx::tree::traits< ValidityType, char > ValidityTraits;

    const ValidityType&
    Validity () const;

    ValidityType&
    Validity ();

    void
    Validity (const ValidityType& x);

    void
    Validity (::std::unique_ptr< ValidityType > p);

    // Mode
    //
    typedef ::CDM::GenerationMode ModeType;
    typedef ::xsd::cxx::tree::optional< ModeType > ModeOptional;
    typedef ::xsd::cxx::tree::traits< ModeType, char > ModeTraits;

    const ModeOptional&
    Mode () const;

    ModeOptional&
    Mode ();

    void
    Mode (const ModeType& x);

    void
    Mode (const ModeOptional& x);

    void
    Mode (::std::unique_ptr< ModeType > p);

    // Qi
    //
    typedef ::CDM::QualityIndicator QiType;
    typedef ::xsd::cxx::tree::optional< QiType > QiOptional;
    typedef ::xsd::cxx::tree::traits< QiType, char > QiTraits;

    const QiOptional&
    Qi () const;

    QiOptional&
    Qi ();

    void
    Qi (const QiType& x);

    void
    Qi (const QiOptional& x);

    void
    Qi (::std::unique_ptr< QiType > p);

    // Constructors.
    //
    MetricQuality (const ValidityType&);

    MetricQuality (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    MetricQuality (const MetricQuality& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual MetricQuality*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MetricQuality&
    operator= (const MetricQuality& x);

    virtual 
    ~MetricQuality ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< ValidityType > Validity_;
    ModeOptional Mode_;
    QiOptional Qi_;
  };

  class Annotation: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Type
    //
    typedef ::CDM::CodedValue TypeType;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeType&
    Type () const;

    TypeType&
    Type ();

    void
    Type (const TypeType& x);

    void
    Type (::std::unique_ptr< TypeType > p);

    // Constructors.
    //
    Annotation (const TypeType&);

    Annotation (::std::unique_ptr< TypeType >);

    Annotation (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    Annotation (const Annotation& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual Annotation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Annotation&
    operator= (const Annotation& x);

    virtual 
    ~Annotation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< TypeType > Type_;
  };

  class ApplyAnnotation: public ::xml_schema::Type
  {
    public:
    // AnnotationIndex
    //
    typedef ::xml_schema::UnsignedInt AnnotationIndexType;
    typedef ::xsd::cxx::tree::traits< AnnotationIndexType, char > AnnotationIndexTraits;

    const AnnotationIndexType&
    AnnotationIndex () const;

    AnnotationIndexType&
    AnnotationIndex ();

    void
    AnnotationIndex (const AnnotationIndexType& x);

    // SampleIndex
    //
    typedef ::xml_schema::UnsignedInt SampleIndexType;
    typedef ::xsd::cxx::tree::traits< SampleIndexType, char > SampleIndexTraits;

    const SampleIndexType&
    SampleIndex () const;

    SampleIndexType&
    SampleIndex ();

    void
    SampleIndex (const SampleIndexType& x);

    // Constructors.
    //
    ApplyAnnotation (const AnnotationIndexType&,
                     const SampleIndexType&);

    ApplyAnnotation (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    ApplyAnnotation (const ApplyAnnotation& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual ApplyAnnotation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ApplyAnnotation&
    operator= (const ApplyAnnotation& x);

    virtual 
    ~ApplyAnnotation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< AnnotationIndexType > AnnotationIndex_;
    ::xsd::cxx::tree::one< SampleIndexType > SampleIndex_;
  };

  class AllowedValue: public ::xml_schema::Type
  {
    public:
    // Value
    //
    typedef ::xml_schema::String ValueType;
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    const ValueType&
    Value () const;

    ValueType&
    Value ();

    void
    Value (const ValueType& x);

    void
    Value (::std::unique_ptr< ValueType > p);

    // Type
    //
    typedef ::CDM::CodedValue TypeType;
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeOptional&
    Type () const;

    TypeOptional&
    Type ();

    void
    Type (const TypeType& x);

    void
    Type (const TypeOptional& x);

    void
    Type (::std::unique_ptr< TypeType > p);

    // Constructors.
    //
    AllowedValue (const ValueType&);

    AllowedValue (::std::unique_ptr< ValueType >);

    AllowedValue (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    AllowedValue (const AllowedValue& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual AllowedValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AllowedValue&
    operator= (const AllowedValue& x);

    virtual 
    ~AllowedValue ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ValueType > Value_;
    TypeOptional Type_;
  };

  class Argument: public ::xml_schema::Type
  {
    public:
    // ArgName
    //
    typedef ::CDM::CodedValue ArgNameType;
    typedef ::xsd::cxx::tree::traits< ArgNameType, char > ArgNameTraits;

    const ArgNameType&
    ArgName () const;

    ArgNameType&
    ArgName ();

    void
    ArgName (const ArgNameType& x);

    void
    ArgName (::std::unique_ptr< ArgNameType > p);

    // Arg
    //
    typedef ::xml_schema::Qname ArgType;
    typedef ::xsd::cxx::tree::traits< ArgType, char > ArgTraits;

    const ArgType&
    Arg () const;

    ArgType&
    Arg ();

    void
    Arg (const ArgType& x);

    void
    Arg (::std::unique_ptr< ArgType > p);

    // Constructors.
    //
    Argument (const ArgNameType&,
              const ArgType&);

    Argument (::std::unique_ptr< ArgNameType >,
              const ArgType&);

    Argument (::std::unique_ptr< ArgNameType >,
              ::std::unique_ptr< ArgType >);

    Argument (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    Argument (const Argument& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    virtual Argument*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Argument&
    operator= (const Argument& x);

    virtual 
    ~Argument ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ArgNameType > ArgName_;
    ::xsd::cxx::tree::one< ArgType > Arg_;
  };

  class ChargeStatus: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Ful,
      ChB,
      DisChB,
      DEB
    };

    ChargeStatus (Value v);

    ChargeStatus (const char* v);

    ChargeStatus (const ::std::string& v);

    ChargeStatus (const ::xml_schema::String& v);

    ChargeStatus (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    ChargeStatus (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    ChargeStatus (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    ChargeStatus (const ChargeStatus& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual ChargeStatus*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ChargeStatus&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_ChargeStatus_convert ();
    }

    protected:
    Value
    _xsd_ChargeStatus_convert () const;

    public:
    static const char* const _xsd_ChargeStatus_literals_[4];
    static const Value _xsd_ChargeStatus_indexes_[4];
  };

  class DateOfBirth: public ::xml_schema::String
  {
    public:

    DateOfBirth (const char* v);

    DateOfBirth (const ::std::string& v);

    DateOfBirth (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    DateOfBirth (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    DateOfBirth (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    DateOfBirth (const DateOfBirth& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual DateOfBirth*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;
  };

  class RelatedMeasurement: public ::xml_schema::Type
  {
    public:
    // Value
    //
    typedef ::CDM::Measurement ValueType;
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    const ValueType&
    Value () const;

    ValueType&
    Value ();

    void
    Value (const ValueType& x);

    void
    Value (::std::unique_ptr< ValueType > p);

    // ReferenceRange
    //
    typedef ::CDM::ReferenceRange ReferenceRangeType;
    typedef ::xsd::cxx::tree::sequence< ReferenceRangeType > ReferenceRangeSequence;
    typedef ReferenceRangeSequence::iterator ReferenceRangeIterator;
    typedef ReferenceRangeSequence::const_iterator ReferenceRangeConstIterator;
    typedef ::xsd::cxx::tree::traits< ReferenceRangeType, char > ReferenceRangeTraits;

    const ReferenceRangeSequence&
    ReferenceRange () const;

    ReferenceRangeSequence&
    ReferenceRange ();

    void
    ReferenceRange (const ReferenceRangeSequence& s);

    // Validity
    //
    typedef ::CDM::MeasurementValidity ValidityType;
    typedef ::xsd::cxx::tree::optional< ValidityType > ValidityOptional;
    typedef ::xsd::cxx::tree::traits< ValidityType, char > ValidityTraits;

    const ValidityOptional&
    Validity () const;

    ValidityOptional&
    Validity ();

    void
    Validity (const ValidityType& x);

    void
    Validity (const ValidityOptional& x);

    void
    Validity (::std::unique_ptr< ValidityType > p);

    // Constructors.
    //
    RelatedMeasurement (const ValueType&);

    RelatedMeasurement (::std::unique_ptr< ValueType >);

    RelatedMeasurement (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    RelatedMeasurement (const RelatedMeasurement& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual RelatedMeasurement*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    RelatedMeasurement&
    operator= (const RelatedMeasurement& x);

    virtual 
    ~RelatedMeasurement ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ValueType > Value_;
    ReferenceRangeSequence ReferenceRange_;
    ValidityOptional Validity_;
  };

  class WorkflowDetail: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::ExtensionType ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Patient
    //
    typedef ::CDM::PersonReference PatientType;
    typedef ::xsd::cxx::tree::traits< PatientType, char > PatientTraits;

    const PatientType&
    Patient () const;

    PatientType&
    Patient ();

    void
    Patient (const PatientType& x);

    void
    Patient (::std::unique_ptr< PatientType > p);

    // AssignedLocation
    //
    typedef ::CDM::LocationReference AssignedLocationType;
    typedef ::xsd::cxx::tree::optional< AssignedLocationType > AssignedLocationOptional;
    typedef ::xsd::cxx::tree::traits< AssignedLocationType, char > AssignedLocationTraits;

    const AssignedLocationOptional&
    AssignedLocation () const;

    AssignedLocationOptional&
    AssignedLocation ();

    void
    AssignedLocation (const AssignedLocationType& x);

    void
    AssignedLocation (const AssignedLocationOptional& x);

    void
    AssignedLocation (::std::unique_ptr< AssignedLocationType > p);

    // VisitNumber
    //
    typedef ::CDM::InstanceIdentifier VisitNumberType;
    typedef ::xsd::cxx::tree::optional< VisitNumberType > VisitNumberOptional;
    typedef ::xsd::cxx::tree::traits< VisitNumberType, char > VisitNumberTraits;

    const VisitNumberOptional&
    VisitNumber () const;

    VisitNumberOptional&
    VisitNumber ();

    void
    VisitNumber (const VisitNumberType& x);

    void
    VisitNumber (const VisitNumberOptional& x);

    void
    VisitNumber (::std::unique_ptr< VisitNumberType > p);

    // DangerCode
    //
    typedef ::CDM::CodedValue DangerCodeType;
    typedef ::xsd::cxx::tree::sequence< DangerCodeType > DangerCodeSequence;
    typedef DangerCodeSequence::iterator DangerCodeIterator;
    typedef DangerCodeSequence::const_iterator DangerCodeConstIterator;
    typedef ::xsd::cxx::tree::traits< DangerCodeType, char > DangerCodeTraits;

    const DangerCodeSequence&
    DangerCode () const;

    DangerCodeSequence&
    DangerCode ();

    void
    DangerCode (const DangerCodeSequence& s);

    // RelevantClinicalInfo
    //
    typedef ::CDM::ClinicalInfo RelevantClinicalInfoType;
    typedef ::xsd::cxx::tree::sequence< RelevantClinicalInfoType > RelevantClinicalInfoSequence;
    typedef RelevantClinicalInfoSequence::iterator RelevantClinicalInfoIterator;
    typedef RelevantClinicalInfoSequence::const_iterator RelevantClinicalInfoConstIterator;
    typedef ::xsd::cxx::tree::traits< RelevantClinicalInfoType, char > RelevantClinicalInfoTraits;

    const RelevantClinicalInfoSequence&
    RelevantClinicalInfo () const;

    RelevantClinicalInfoSequence&
    RelevantClinicalInfo ();

    void
    RelevantClinicalInfo (const RelevantClinicalInfoSequence& s);

    // RequestedOrderDetail
    //
    typedef ::CDM::RequestedOrderDetail RequestedOrderDetailType;
    typedef ::xsd::cxx::tree::optional< RequestedOrderDetailType > RequestedOrderDetailOptional;
    typedef ::xsd::cxx::tree::traits< RequestedOrderDetailType, char > RequestedOrderDetailTraits;

    const RequestedOrderDetailOptional&
    RequestedOrderDetail () const;

    RequestedOrderDetailOptional&
    RequestedOrderDetail ();

    void
    RequestedOrderDetail (const RequestedOrderDetailType& x);

    void
    RequestedOrderDetail (const RequestedOrderDetailOptional& x);

    void
    RequestedOrderDetail (::std::unique_ptr< RequestedOrderDetailType > p);

    // PerformedOrderDetail
    //
    typedef ::CDM::PerformedOrderDetail PerformedOrderDetailType;
    typedef ::xsd::cxx::tree::optional< PerformedOrderDetailType > PerformedOrderDetailOptional;
    typedef ::xsd::cxx::tree::traits< PerformedOrderDetailType, char > PerformedOrderDetailTraits;

    const PerformedOrderDetailOptional&
    PerformedOrderDetail () const;

    PerformedOrderDetailOptional&
    PerformedOrderDetail ();

    void
    PerformedOrderDetail (const PerformedOrderDetailType& x);

    void
    PerformedOrderDetail (const PerformedOrderDetailOptional& x);

    void
    PerformedOrderDetail (::std::unique_ptr< PerformedOrderDetailType > p);

    // Constructors.
    //
    WorkflowDetail (const PatientType&);

    WorkflowDetail (::std::unique_ptr< PatientType >);

    WorkflowDetail (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    WorkflowDetail (const WorkflowDetail& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual WorkflowDetail*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    WorkflowDetail&
    operator= (const WorkflowDetail& x);

    virtual 
    ~WorkflowDetail ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< PatientType > Patient_;
    AssignedLocationOptional AssignedLocation_;
    VisitNumberOptional VisitNumber_;
    DangerCodeSequence DangerCode_;
    RelevantClinicalInfoSequence RelevantClinicalInfo_;
    RequestedOrderDetailOptional RequestedOrderDetail_;
    PerformedOrderDetailOptional PerformedOrderDetail_;
  };

  class ReferenceRange: public ::xml_schema::Type
  {
    public:
    // Range
    //
    typedef ::CDM::Range RangeType;
    typedef ::xsd::cxx::tree::traits< RangeType, char > RangeTraits;

    const RangeType&
    Range () const;

    RangeType&
    Range ();

    void
    Range (const RangeType& x);

    void
    Range (::std::unique_ptr< RangeType > p);

    // Meaning
    //
    typedef ::CDM::CodedValue MeaningType;
    typedef ::xsd::cxx::tree::optional< MeaningType > MeaningOptional;
    typedef ::xsd::cxx::tree::traits< MeaningType, char > MeaningTraits;

    const MeaningOptional&
    Meaning () const;

    MeaningOptional&
    Meaning ();

    void
    Meaning (const MeaningType& x);

    void
    Meaning (const MeaningOptional& x);

    void
    Meaning (::std::unique_ptr< MeaningType > p);

    // Constructors.
    //
    ReferenceRange (const RangeType&);

    ReferenceRange (::std::unique_ptr< RangeType >);

    ReferenceRange (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    ReferenceRange (const ReferenceRange& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual ReferenceRange*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ReferenceRange&
    operator= (const ReferenceRange& x);

    virtual 
    ~ReferenceRange ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RangeType > Range_;
    MeaningOptional Meaning_;
  };

  class RequestedOrderDetail: public ::CDM::OrderDetail
  {
    public:
    // ReferringPhysician
    //
    typedef ::CDM::PersonReference ReferringPhysicianType;
    typedef ::xsd::cxx::tree::optional< ReferringPhysicianType > ReferringPhysicianOptional;
    typedef ::xsd::cxx::tree::traits< ReferringPhysicianType, char > ReferringPhysicianTraits;

    const ReferringPhysicianOptional&
    ReferringPhysician () const;

    ReferringPhysicianOptional&
    ReferringPhysician ();

    void
    ReferringPhysician (const ReferringPhysicianType& x);

    void
    ReferringPhysician (const ReferringPhysicianOptional& x);

    void
    ReferringPhysician (::std::unique_ptr< ReferringPhysicianType > p);

    // RequestingPhysician
    //
    typedef ::CDM::PersonReference RequestingPhysicianType;
    typedef ::xsd::cxx::tree::optional< RequestingPhysicianType > RequestingPhysicianOptional;
    typedef ::xsd::cxx::tree::traits< RequestingPhysicianType, char > RequestingPhysicianTraits;

    const RequestingPhysicianOptional&
    RequestingPhysician () const;

    RequestingPhysicianOptional&
    RequestingPhysician ();

    void
    RequestingPhysician (const RequestingPhysicianType& x);

    void
    RequestingPhysician (const RequestingPhysicianOptional& x);

    void
    RequestingPhysician (::std::unique_ptr< RequestingPhysicianType > p);

    // PlacerOrderNumber
    //
    typedef ::CDM::InstanceIdentifier PlacerOrderNumberType;
    typedef ::xsd::cxx::tree::traits< PlacerOrderNumberType, char > PlacerOrderNumberTraits;

    const PlacerOrderNumberType&
    PlacerOrderNumber () const;

    PlacerOrderNumberType&
    PlacerOrderNumber ();

    void
    PlacerOrderNumber (const PlacerOrderNumberType& x);

    void
    PlacerOrderNumber (::std::unique_ptr< PlacerOrderNumberType > p);

    // Constructors.
    //
    RequestedOrderDetail (const PlacerOrderNumberType&);

    RequestedOrderDetail (::std::unique_ptr< PlacerOrderNumberType >);

    RequestedOrderDetail (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    RequestedOrderDetail (const RequestedOrderDetail& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual RequestedOrderDetail*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    RequestedOrderDetail&
    operator= (const RequestedOrderDetail& x);

    virtual 
    ~RequestedOrderDetail ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ReferringPhysicianOptional ReferringPhysician_;
    RequestingPhysicianOptional RequestingPhysician_;
    ::xsd::cxx::tree::one< PlacerOrderNumberType > PlacerOrderNumber_;
  };

  class PerformedOrderDetail: public ::CDM::OrderDetail
  {
    public:
    // FillerOrderNumber
    //
    typedef ::CDM::InstanceIdentifier FillerOrderNumberType;
    typedef ::xsd::cxx::tree::optional< FillerOrderNumberType > FillerOrderNumberOptional;
    typedef ::xsd::cxx::tree::traits< FillerOrderNumberType, char > FillerOrderNumberTraits;

    const FillerOrderNumberOptional&
    FillerOrderNumber () const;

    FillerOrderNumberOptional&
    FillerOrderNumber ();

    void
    FillerOrderNumber (const FillerOrderNumberType& x);

    void
    FillerOrderNumber (const FillerOrderNumberOptional& x);

    void
    FillerOrderNumber (::std::unique_ptr< FillerOrderNumberType > p);

    // ResultingClinicalInfo
    //
    typedef ::CDM::ClinicalInfo ResultingClinicalInfoType;
    typedef ::xsd::cxx::tree::sequence< ResultingClinicalInfoType > ResultingClinicalInfoSequence;
    typedef ResultingClinicalInfoSequence::iterator ResultingClinicalInfoIterator;
    typedef ResultingClinicalInfoSequence::const_iterator ResultingClinicalInfoConstIterator;
    typedef ::xsd::cxx::tree::traits< ResultingClinicalInfoType, char > ResultingClinicalInfoTraits;

    const ResultingClinicalInfoSequence&
    ResultingClinicalInfo () const;

    ResultingClinicalInfoSequence&
    ResultingClinicalInfo ();

    void
    ResultingClinicalInfo (const ResultingClinicalInfoSequence& s);

    // Constructors.
    //
    PerformedOrderDetail ();

    PerformedOrderDetail (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    PerformedOrderDetail (const PerformedOrderDetail& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual PerformedOrderDetail*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    PerformedOrderDetail&
    operator= (const PerformedOrderDetail& x);

    virtual 
    ~PerformedOrderDetail ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    FillerOrderNumberOptional FillerOrderNumber_;
    ResultingClinicalInfoSequence ResultingClinicalInfo_;
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace CDM
{
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace CDM
{
  void
  operator<< (::xercesc::DOMElement&, const Mdib&);

  void
  operator<< (::xercesc::DOMElement&, const MdDescription&);

  void
  operator<< (::xercesc::DOMElement&, const MdState&);

  void
  operator<< (::xercesc::DOMElement&, const MeasurementValidity&);

  void
  operator<< (::xercesc::DOMAttr&, const MeasurementValidity&);

  void
  operator<< (::xml_schema::ListStream&,
              const MeasurementValidity&);

  void
  operator<< (::xercesc::DOMElement&, const Timestamp&);

  void
  operator<< (::xercesc::DOMAttr&, const Timestamp&);

  void
  operator<< (::xml_schema::ListStream&,
              const Timestamp&);

  void
  operator<< (::xercesc::DOMElement&, const VersionCounter&);

  void
  operator<< (::xercesc::DOMAttr&, const VersionCounter&);

  void
  operator<< (::xml_schema::ListStream&,
              const VersionCounter&);

  void
  operator<< (::xercesc::DOMElement&, const ReferencedVersion&);

  void
  operator<< (::xercesc::DOMAttr&, const ReferencedVersion&);

  void
  operator<< (::xml_schema::ListStream&,
              const ReferencedVersion&);

  void
  operator<< (::xercesc::DOMElement&, const CodeIdentifier&);

  void
  operator<< (::xercesc::DOMAttr&, const CodeIdentifier&);

  void
  operator<< (::xml_schema::ListStream&,
              const CodeIdentifier&);

  void
  operator<< (::xercesc::DOMElement&, const SymbolicCodeName&);

  void
  operator<< (::xercesc::DOMAttr&, const SymbolicCodeName&);

  void
  operator<< (::xml_schema::ListStream&,
              const SymbolicCodeName&);

  void
  operator<< (::xercesc::DOMElement&, const LocalizedTextRef&);

  void
  operator<< (::xercesc::DOMAttr&, const LocalizedTextRef&);

  void
  operator<< (::xml_schema::ListStream&,
              const LocalizedTextRef&);

  void
  operator<< (::xercesc::DOMElement&, const LocalizedText&);

  void
  operator<< (::xercesc::DOMElement&, const CodedValue&);

  void
  operator<< (::xercesc::DOMElement&, const InstanceIdentifier&);

  void
  operator<< (::xercesc::DOMElement&, const Range&);

  void
  operator<< (::xercesc::DOMElement&, const Measurement&);

  void
  operator<< (::xercesc::DOMElement&, const SafetyClassification&);

  void
  operator<< (::xercesc::DOMAttr&, const SafetyClassification&);

  void
  operator<< (::xml_schema::ListStream&,
              const SafetyClassification&);

  void
  operator<< (::xercesc::DOMElement&, const ComponentActivation&);

  void
  operator<< (::xercesc::DOMAttr&, const ComponentActivation&);

  void
  operator<< (::xml_schema::ListStream&,
              const ComponentActivation&);

  void
  operator<< (::xercesc::DOMElement&, const Handle&);

  void
  operator<< (::xercesc::DOMAttr&, const Handle&);

  void
  operator<< (::xml_schema::ListStream&,
              const Handle&);

  void
  operator<< (::xercesc::DOMElement&, const HandleRef&);

  void
  operator<< (::xercesc::DOMAttr&, const HandleRef&);

  void
  operator<< (::xml_schema::ListStream&,
              const HandleRef&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractState&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractMultiState&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractDeviceComponentDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractAlertingDeviceComponentDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const CalibrationState&);

  void
  operator<< (::xercesc::DOMAttr&, const CalibrationState&);

  void
  operator<< (::xml_schema::ListStream&,
              const CalibrationState&);

  void
  operator<< (::xercesc::DOMElement&, const CalibrationType&);

  void
  operator<< (::xercesc::DOMAttr&, const CalibrationType&);

  void
  operator<< (::xml_schema::ListStream&,
              const CalibrationType&);

  void
  operator<< (::xercesc::DOMElement&, const CalibrationInfo&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractDeviceComponentState&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractAlertingDeviceComponentState&);

  void
  operator<< (::xercesc::DOMElement&, const MdsDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const MdsOperatingMode&);

  void
  operator<< (::xercesc::DOMAttr&, const MdsOperatingMode&);

  void
  operator<< (::xml_schema::ListStream&,
              const MdsOperatingMode&);

  void
  operator<< (::xercesc::DOMElement&, const MdsState&);

  void
  operator<< (::xercesc::DOMElement&, const VmdDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const VmdState&);

  void
  operator<< (::xercesc::DOMElement&, const ChannelDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const ChannelState&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractAlertDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractAlertState&);

  void
  operator<< (::xercesc::DOMElement&, const AlertActivation&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertActivation&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertActivation&);

  void
  operator<< (::xercesc::DOMElement&, const SystemSignalActivation&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSystemDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSystemState&);

  void
  operator<< (::xercesc::DOMElement&, const CauseInfo&);

  void
  operator<< (::xercesc::DOMElement&, const RemedyInfo&);

  void
  operator<< (::xercesc::DOMElement&, const AlertConditionKind&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertConditionKind&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertConditionKind&);

  void
  operator<< (::xercesc::DOMElement&, const AlertConditionPriority&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertConditionPriority&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertConditionPriority&);

  void
  operator<< (::xercesc::DOMElement&, const AlertConditionDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AlertConditionReference&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertConditionReference&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertConditionReference&);

  void
  operator<< (::xercesc::DOMElement&, const AlertConditionState&);

  void
  operator<< (::xercesc::DOMElement&, const LimitAlertConditionDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AlertConditionMonitoredLimits&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertConditionMonitoredLimits&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertConditionMonitoredLimits&);

  void
  operator<< (::xercesc::DOMElement&, const LimitAlertConditionState&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSignalManifestation&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertSignalManifestation&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertSignalManifestation&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSignalDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSignalPresence&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertSignalPresence&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertSignalPresence&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSignalPrimaryLocation&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertSignalPrimaryLocation&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertSignalPrimaryLocation&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSignalState&);

  void
  operator<< (::xercesc::DOMElement&, const QualityIndicator&);

  void
  operator<< (::xercesc::DOMAttr&, const QualityIndicator&);

  void
  operator<< (::xml_schema::ListStream&,
              const QualityIndicator&);

  void
  operator<< (::xercesc::DOMElement&, const GenerationMode&);

  void
  operator<< (::xercesc::DOMAttr&, const GenerationMode&);

  void
  operator<< (::xml_schema::ListStream&,
              const GenerationMode&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractMetricValue&);

  void
  operator<< (::xercesc::DOMElement&, const NumericMetricValue&);

  void
  operator<< (::xercesc::DOMElement&, const StringMetricValue&);

  void
  operator<< (::xercesc::DOMElement&, const RealTimeValueType&);

  void
  operator<< (::xercesc::DOMAttr&, const RealTimeValueType&);

  void
  operator<< (::xml_schema::ListStream&,
              const RealTimeValueType&);

  void
  operator<< (::xercesc::DOMElement&, const SampleArrayValue&);

  void
  operator<< (::xercesc::DOMElement&, const MetricCategory&);

  void
  operator<< (::xercesc::DOMAttr&, const MetricCategory&);

  void
  operator<< (::xml_schema::ListStream&,
              const MetricCategory&);

  void
  operator<< (::xercesc::DOMElement&, const DerivationMethod&);

  void
  operator<< (::xercesc::DOMAttr&, const DerivationMethod&);

  void
  operator<< (::xml_schema::ListStream&,
              const DerivationMethod&);

  void
  operator<< (::xercesc::DOMElement&, const MetricAvailability&);

  void
  operator<< (::xercesc::DOMAttr&, const MetricAvailability&);

  void
  operator<< (::xml_schema::ListStream&,
              const MetricAvailability&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractMetricDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractMetricState&);

  void
  operator<< (::xercesc::DOMElement&, const NumericMetricDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const NumericMetricState&);

  void
  operator<< (::xercesc::DOMElement&, const StringMetricDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const StringMetricState&);

  void
  operator<< (::xercesc::DOMElement&, const EnumStringMetricDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const EnumStringMetricState&);

  void
  operator<< (::xercesc::DOMElement&, const RealTimeSampleArrayMetricDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const RealTimeSampleArrayMetricState&);

  void
  operator<< (::xercesc::DOMElement&, const DistributionSampleArrayMetricDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const DistributionSampleArrayMetricState&);

  void
  operator<< (::xercesc::DOMElement&, const ScoDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const ScoState&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractSetStateOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const OperatingMode&);

  void
  operator<< (::xercesc::DOMAttr&, const OperatingMode&);

  void
  operator<< (::xml_schema::ListStream&,
              const OperatingMode&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const SetValueOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SetValueOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const SetStringOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SetStringOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const ActivateOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const ActivateOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const SetContextStateOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SetContextStateOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const SetMetricStateOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SetMetricStateOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const SetComponentStateOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SetComponentStateOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const SetAlertStateOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SetAlertStateOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const TimeZone&);

  void
  operator<< (::xercesc::DOMAttr&, const TimeZone&);

  void
  operator<< (::xml_schema::ListStream&,
              const TimeZone&);

  void
  operator<< (::xercesc::DOMElement&, const ClockDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const ClockState&);

  void
  operator<< (::xercesc::DOMElement&, const BatteryDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const BatteryState&);

  void
  operator<< (::xercesc::DOMElement&, const SystemContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SystemContextState&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const ContextAssociation&);

  void
  operator<< (::xercesc::DOMAttr&, const ContextAssociation&);

  void
  operator<< (::xml_schema::ListStream&,
              const ContextAssociation&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractContextState&);

  void
  operator<< (::xercesc::DOMElement&, const BaseDemographics&);

  void
  operator<< (::xercesc::DOMElement&, const PersonReference&);

  void
  operator<< (::xercesc::DOMElement&, const LocationDetail&);

  void
  operator<< (::xercesc::DOMElement&, const PatientContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const Sex&);

  void
  operator<< (::xercesc::DOMAttr&, const Sex&);

  void
  operator<< (::xml_schema::ListStream&,
              const Sex&);

  void
  operator<< (::xercesc::DOMElement&, const PatientType&);

  void
  operator<< (::xercesc::DOMAttr&, const PatientType&);

  void
  operator<< (::xml_schema::ListStream&,
              const PatientType&);

  void
  operator<< (::xercesc::DOMElement&, const PatientDemographicsCoreData&);

  void
  operator<< (::xercesc::DOMElement&, const NeonatalPatientDemographicsCoreData&);

  void
  operator<< (::xercesc::DOMElement&, const PatientContextState&);

  void
  operator<< (::xercesc::DOMElement&, const LocationContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const LocationContextState&);

  void
  operator<< (::xercesc::DOMElement&, const WorkflowContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const ClinicalInfo&);

  void
  operator<< (::xercesc::DOMElement&, const ImagingProcedure&);

  void
  operator<< (::xercesc::DOMElement&, const LocationReference&);

  void
  operator<< (::xercesc::DOMElement&, const OrderDetail&);

  void
  operator<< (::xercesc::DOMElement&, const PersonParticipation&);

  void
  operator<< (::xercesc::DOMElement&, const WorkflowContextState&);

  void
  operator<< (::xercesc::DOMElement&, const OperatorContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const OperatorContextState&);

  void
  operator<< (::xercesc::DOMElement&, const MeansContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const MeansContextState&);

  void
  operator<< (::xercesc::DOMElement&, const EnsembleContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const EnsembleContextState&);

  void
  operator<< (::xercesc::DOMElement&, const ContainmentTree&);

  void
  operator<< (::xercesc::DOMElement&, const ContainmentTreeEntry&);

  void
  operator<< (::xercesc::DOMElement&, const ProductionSpecification&);

  void
  operator<< (::xercesc::DOMElement&, const MetaData&);

  void
  operator<< (::xercesc::DOMElement&, const MetricQuality&);

  void
  operator<< (::xercesc::DOMElement&, const Annotation&);

  void
  operator<< (::xercesc::DOMElement&, const ApplyAnnotation&);

  void
  operator<< (::xercesc::DOMElement&, const AllowedValue&);

  void
  operator<< (::xercesc::DOMElement&, const Argument&);

  void
  operator<< (::xercesc::DOMElement&, const ChargeStatus&);

  void
  operator<< (::xercesc::DOMAttr&, const ChargeStatus&);

  void
  operator<< (::xml_schema::ListStream&,
              const ChargeStatus&);

  void
  operator<< (::xercesc::DOMElement&, const DateOfBirth&);

  void
  operator<< (::xercesc::DOMAttr&, const DateOfBirth&);

  void
  operator<< (::xml_schema::ListStream&,
              const DateOfBirth&);

  void
  operator<< (::xercesc::DOMElement&, const RelatedMeasurement&);

  void
  operator<< (::xercesc::DOMElement&, const WorkflowDetail&);

  void
  operator<< (::xercesc::DOMElement&, const ReferenceRange&);

  void
  operator<< (::xercesc::DOMElement&, const RequestedOrderDetail&);

  void
  operator<< (::xercesc::DOMElement&, const PerformedOrderDetail&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // BICEPS_PARTICIPANT_MODEL_HXX
