// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "BICEPS_MessageModel.hxx"

namespace MDM
{
  // TransactionId
  // 


  // InvocationState
  // 

  InvocationState::
  InvocationState (Value v)
  : ::xml_schema::String (_xsd_InvocationState_literals_[v])
  {
  }

  InvocationState::
  InvocationState (const char* v)
  : ::xml_schema::String (v)
  {
  }

  InvocationState::
  InvocationState (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  InvocationState::
  InvocationState (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  InvocationState::
  InvocationState (const InvocationState& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  InvocationState& InvocationState::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_InvocationState_literals_[v]);

    return *this;
  }


  // InvocationError
  // 

  InvocationError::
  InvocationError (Value v)
  : ::xml_schema::String (_xsd_InvocationError_literals_[v])
  {
  }

  InvocationError::
  InvocationError (const char* v)
  : ::xml_schema::String (v)
  {
  }

  InvocationError::
  InvocationError (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  InvocationError::
  InvocationError (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  InvocationError::
  InvocationError (const InvocationError& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  InvocationError& InvocationError::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_InvocationError_literals_[v]);

    return *this;
  }


  // InvocationInfo
  // 

  const InvocationInfo::ExtensionOptional& InvocationInfo::
  Extension () const
  {
    return this->Extension_;
  }

  InvocationInfo::ExtensionOptional& InvocationInfo::
  Extension ()
  {
    return this->Extension_;
  }

  void InvocationInfo::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void InvocationInfo::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void InvocationInfo::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const InvocationInfo::TransactionIdType& InvocationInfo::
  TransactionId () const
  {
    return this->TransactionId_.get ();
  }

  InvocationInfo::TransactionIdType& InvocationInfo::
  TransactionId ()
  {
    return this->TransactionId_.get ();
  }

  void InvocationInfo::
  TransactionId (const TransactionIdType& x)
  {
    this->TransactionId_.set (x);
  }

  void InvocationInfo::
  TransactionId (::std::unique_ptr< TransactionIdType > x)
  {
    this->TransactionId_.set (std::move (x));
  }

  const InvocationInfo::InvocationStateType& InvocationInfo::
  InvocationState () const
  {
    return this->InvocationState_.get ();
  }

  InvocationInfo::InvocationStateType& InvocationInfo::
  InvocationState ()
  {
    return this->InvocationState_.get ();
  }

  void InvocationInfo::
  InvocationState (const InvocationStateType& x)
  {
    this->InvocationState_.set (x);
  }

  void InvocationInfo::
  InvocationState (::std::unique_ptr< InvocationStateType > x)
  {
    this->InvocationState_.set (std::move (x));
  }

  const InvocationInfo::InvocationErrorOptional& InvocationInfo::
  InvocationError () const
  {
    return this->InvocationError_;
  }

  InvocationInfo::InvocationErrorOptional& InvocationInfo::
  InvocationError ()
  {
    return this->InvocationError_;
  }

  void InvocationInfo::
  InvocationError (const InvocationErrorType& x)
  {
    this->InvocationError_.set (x);
  }

  void InvocationInfo::
  InvocationError (const InvocationErrorOptional& x)
  {
    this->InvocationError_ = x;
  }

  void InvocationInfo::
  InvocationError (::std::unique_ptr< InvocationErrorType > x)
  {
    this->InvocationError_.set (std::move (x));
  }

  const InvocationInfo::InvocationErrorMessageSequence& InvocationInfo::
  InvocationErrorMessage () const
  {
    return this->InvocationErrorMessage_;
  }

  InvocationInfo::InvocationErrorMessageSequence& InvocationInfo::
  InvocationErrorMessage ()
  {
    return this->InvocationErrorMessage_;
  }

  void InvocationInfo::
  InvocationErrorMessage (const InvocationErrorMessageSequence& s)
  {
    this->InvocationErrorMessage_ = s;
  }


  // AbstractGet
  // 

  const AbstractGet::ExtensionOptional& AbstractGet::
  Extension () const
  {
    return this->Extension_;
  }

  AbstractGet::ExtensionOptional& AbstractGet::
  Extension ()
  {
    return this->Extension_;
  }

  void AbstractGet::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractGet::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractGet::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }


  // AbstractGetResponse
  // 

  const AbstractGetResponse::ExtensionOptional& AbstractGetResponse::
  Extension () const
  {
    return this->Extension_;
  }

  AbstractGetResponse::ExtensionOptional& AbstractGetResponse::
  Extension ()
  {
    return this->Extension_;
  }

  void AbstractGetResponse::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractGetResponse::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractGetResponse::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const AbstractGetResponse::MdibVersionOptional& AbstractGetResponse::
  MdibVersion () const
  {
    return this->MdibVersion_;
  }

  AbstractGetResponse::MdibVersionOptional& AbstractGetResponse::
  MdibVersion ()
  {
    return this->MdibVersion_;
  }

  void AbstractGetResponse::
  MdibVersion (const MdibVersionType& x)
  {
    this->MdibVersion_.set (x);
  }

  void AbstractGetResponse::
  MdibVersion (const MdibVersionOptional& x)
  {
    this->MdibVersion_ = x;
  }

  void AbstractGetResponse::
  MdibVersion (::std::unique_ptr< MdibVersionType > x)
  {
    this->MdibVersion_.set (std::move (x));
  }

  const AbstractGetResponse::SequenceIdType& AbstractGetResponse::
  SequenceId () const
  {
    return this->SequenceId_.get ();
  }

  AbstractGetResponse::SequenceIdType& AbstractGetResponse::
  SequenceId ()
  {
    return this->SequenceId_.get ();
  }

  void AbstractGetResponse::
  SequenceId (const SequenceIdType& x)
  {
    this->SequenceId_.set (x);
  }

  void AbstractGetResponse::
  SequenceId (::std::unique_ptr< SequenceIdType > x)
  {
    this->SequenceId_.set (std::move (x));
  }

  const AbstractGetResponse::InstanceIdOptional& AbstractGetResponse::
  InstanceId () const
  {
    return this->InstanceId_;
  }

  AbstractGetResponse::InstanceIdOptional& AbstractGetResponse::
  InstanceId ()
  {
    return this->InstanceId_;
  }

  void AbstractGetResponse::
  InstanceId (const InstanceIdType& x)
  {
    this->InstanceId_.set (x);
  }

  void AbstractGetResponse::
  InstanceId (const InstanceIdOptional& x)
  {
    this->InstanceId_ = x;
  }


  // AbstractReportPart
  // 

  const AbstractReportPart::ExtensionOptional& AbstractReportPart::
  Extension () const
  {
    return this->Extension_;
  }

  AbstractReportPart::ExtensionOptional& AbstractReportPart::
  Extension ()
  {
    return this->Extension_;
  }

  void AbstractReportPart::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractReportPart::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractReportPart::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const AbstractReportPart::SourceMdsOptional& AbstractReportPart::
  SourceMds () const
  {
    return this->SourceMds_;
  }

  AbstractReportPart::SourceMdsOptional& AbstractReportPart::
  SourceMds ()
  {
    return this->SourceMds_;
  }

  void AbstractReportPart::
  SourceMds (const SourceMdsType& x)
  {
    this->SourceMds_.set (x);
  }

  void AbstractReportPart::
  SourceMds (const SourceMdsOptional& x)
  {
    this->SourceMds_ = x;
  }

  void AbstractReportPart::
  SourceMds (::std::unique_ptr< SourceMdsType > x)
  {
    this->SourceMds_.set (std::move (x));
  }


  // AbstractReport
  // 

  const AbstractReport::ExtensionOptional& AbstractReport::
  Extension () const
  {
    return this->Extension_;
  }

  AbstractReport::ExtensionOptional& AbstractReport::
  Extension ()
  {
    return this->Extension_;
  }

  void AbstractReport::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractReport::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractReport::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const AbstractReport::MdibVersionOptional& AbstractReport::
  MdibVersion () const
  {
    return this->MdibVersion_;
  }

  AbstractReport::MdibVersionOptional& AbstractReport::
  MdibVersion ()
  {
    return this->MdibVersion_;
  }

  void AbstractReport::
  MdibVersion (const MdibVersionType& x)
  {
    this->MdibVersion_.set (x);
  }

  void AbstractReport::
  MdibVersion (const MdibVersionOptional& x)
  {
    this->MdibVersion_ = x;
  }

  void AbstractReport::
  MdibVersion (::std::unique_ptr< MdibVersionType > x)
  {
    this->MdibVersion_.set (std::move (x));
  }

  const AbstractReport::SequenceIdType& AbstractReport::
  SequenceId () const
  {
    return this->SequenceId_.get ();
  }

  AbstractReport::SequenceIdType& AbstractReport::
  SequenceId ()
  {
    return this->SequenceId_.get ();
  }

  void AbstractReport::
  SequenceId (const SequenceIdType& x)
  {
    this->SequenceId_.set (x);
  }

  void AbstractReport::
  SequenceId (::std::unique_ptr< SequenceIdType > x)
  {
    this->SequenceId_.set (std::move (x));
  }

  const AbstractReport::InstanceIdOptional& AbstractReport::
  InstanceId () const
  {
    return this->InstanceId_;
  }

  AbstractReport::InstanceIdOptional& AbstractReport::
  InstanceId ()
  {
    return this->InstanceId_;
  }

  void AbstractReport::
  InstanceId (const InstanceIdType& x)
  {
    this->InstanceId_.set (x);
  }

  void AbstractReport::
  InstanceId (const InstanceIdOptional& x)
  {
    this->InstanceId_ = x;
  }


  // AbstractSet
  // 

  const AbstractSet::ExtensionOptional& AbstractSet::
  Extension () const
  {
    return this->Extension_;
  }

  AbstractSet::ExtensionOptional& AbstractSet::
  Extension ()
  {
    return this->Extension_;
  }

  void AbstractSet::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractSet::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractSet::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const AbstractSet::OperationHandleRefType& AbstractSet::
  OperationHandleRef () const
  {
    return this->OperationHandleRef_.get ();
  }

  AbstractSet::OperationHandleRefType& AbstractSet::
  OperationHandleRef ()
  {
    return this->OperationHandleRef_.get ();
  }

  void AbstractSet::
  OperationHandleRef (const OperationHandleRefType& x)
  {
    this->OperationHandleRef_.set (x);
  }

  void AbstractSet::
  OperationHandleRef (::std::unique_ptr< OperationHandleRefType > x)
  {
    this->OperationHandleRef_.set (std::move (x));
  }


  // AbstractSetResponse
  // 

  const AbstractSetResponse::ExtensionOptional& AbstractSetResponse::
  Extension () const
  {
    return this->Extension_;
  }

  AbstractSetResponse::ExtensionOptional& AbstractSetResponse::
  Extension ()
  {
    return this->Extension_;
  }

  void AbstractSetResponse::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void AbstractSetResponse::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void AbstractSetResponse::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const AbstractSetResponse::InvocationInfoType& AbstractSetResponse::
  InvocationInfo () const
  {
    return this->InvocationInfo_.get ();
  }

  AbstractSetResponse::InvocationInfoType& AbstractSetResponse::
  InvocationInfo ()
  {
    return this->InvocationInfo_.get ();
  }

  void AbstractSetResponse::
  InvocationInfo (const InvocationInfoType& x)
  {
    this->InvocationInfo_.set (x);
  }

  void AbstractSetResponse::
  InvocationInfo (::std::unique_ptr< InvocationInfoType > x)
  {
    this->InvocationInfo_.set (std::move (x));
  }

  const AbstractSetResponse::MdibVersionOptional& AbstractSetResponse::
  MdibVersion () const
  {
    return this->MdibVersion_;
  }

  AbstractSetResponse::MdibVersionOptional& AbstractSetResponse::
  MdibVersion ()
  {
    return this->MdibVersion_;
  }

  void AbstractSetResponse::
  MdibVersion (const MdibVersionType& x)
  {
    this->MdibVersion_.set (x);
  }

  void AbstractSetResponse::
  MdibVersion (const MdibVersionOptional& x)
  {
    this->MdibVersion_ = x;
  }

  void AbstractSetResponse::
  MdibVersion (::std::unique_ptr< MdibVersionType > x)
  {
    this->MdibVersion_.set (std::move (x));
  }

  const AbstractSetResponse::SequenceIdType& AbstractSetResponse::
  SequenceId () const
  {
    return this->SequenceId_.get ();
  }

  AbstractSetResponse::SequenceIdType& AbstractSetResponse::
  SequenceId ()
  {
    return this->SequenceId_.get ();
  }

  void AbstractSetResponse::
  SequenceId (const SequenceIdType& x)
  {
    this->SequenceId_.set (x);
  }

  void AbstractSetResponse::
  SequenceId (::std::unique_ptr< SequenceIdType > x)
  {
    this->SequenceId_.set (std::move (x));
  }

  const AbstractSetResponse::InstanceIdOptional& AbstractSetResponse::
  InstanceId () const
  {
    return this->InstanceId_;
  }

  AbstractSetResponse::InstanceIdOptional& AbstractSetResponse::
  InstanceId ()
  {
    return this->InstanceId_;
  }

  void AbstractSetResponse::
  InstanceId (const InstanceIdType& x)
  {
    this->InstanceId_.set (x);
  }

  void AbstractSetResponse::
  InstanceId (const InstanceIdOptional& x)
  {
    this->InstanceId_ = x;
  }


  // AbstractContextReport
  // 

  const AbstractContextReport::ReportPartSequence& AbstractContextReport::
  ReportPart () const
  {
    return this->ReportPart_;
  }

  AbstractContextReport::ReportPartSequence& AbstractContextReport::
  ReportPart ()
  {
    return this->ReportPart_;
  }

  void AbstractContextReport::
  ReportPart (const ReportPartSequence& s)
  {
    this->ReportPart_ = s;
  }


  // VersionFrame
  // 

  const VersionFrame::StartOptional& VersionFrame::
  Start () const
  {
    return this->Start_;
  }

  VersionFrame::StartOptional& VersionFrame::
  Start ()
  {
    return this->Start_;
  }

  void VersionFrame::
  Start (const StartType& x)
  {
    this->Start_.set (x);
  }

  void VersionFrame::
  Start (const StartOptional& x)
  {
    this->Start_ = x;
  }

  void VersionFrame::
  Start (::std::unique_ptr< StartType > x)
  {
    this->Start_.set (std::move (x));
  }

  const VersionFrame::EndOptional& VersionFrame::
  End () const
  {
    return this->End_;
  }

  VersionFrame::EndOptional& VersionFrame::
  End ()
  {
    return this->End_;
  }

  void VersionFrame::
  End (const EndType& x)
  {
    this->End_.set (x);
  }

  void VersionFrame::
  End (const EndOptional& x)
  {
    this->End_ = x;
  }

  void VersionFrame::
  End (::std::unique_ptr< EndType > x)
  {
    this->End_.set (std::move (x));
  }


  // TimeFrame
  // 

  const TimeFrame::StartOptional& TimeFrame::
  Start () const
  {
    return this->Start_;
  }

  TimeFrame::StartOptional& TimeFrame::
  Start ()
  {
    return this->Start_;
  }

  void TimeFrame::
  Start (const StartType& x)
  {
    this->Start_.set (x);
  }

  void TimeFrame::
  Start (const StartOptional& x)
  {
    this->Start_ = x;
  }

  void TimeFrame::
  Start (::std::unique_ptr< StartType > x)
  {
    this->Start_.set (std::move (x));
  }

  const TimeFrame::EndOptional& TimeFrame::
  End () const
  {
    return this->End_;
  }

  TimeFrame::EndOptional& TimeFrame::
  End ()
  {
    return this->End_;
  }

  void TimeFrame::
  End (const EndType& x)
  {
    this->End_.set (x);
  }

  void TimeFrame::
  End (const EndOptional& x)
  {
    this->End_ = x;
  }

  void TimeFrame::
  End (::std::unique_ptr< EndType > x)
  {
    this->End_.set (std::move (x));
  }


  // AbstractMetricReport
  // 

  const AbstractMetricReport::ReportPartSequence& AbstractMetricReport::
  ReportPart () const
  {
    return this->ReportPart_;
  }

  AbstractMetricReport::ReportPartSequence& AbstractMetricReport::
  ReportPart ()
  {
    return this->ReportPart_;
  }

  void AbstractMetricReport::
  ReportPart (const ReportPartSequence& s)
  {
    this->ReportPart_ = s;
  }


  // AbstractComponentReport
  // 

  const AbstractComponentReport::ReportPartSequence& AbstractComponentReport::
  ReportPart () const
  {
    return this->ReportPart_;
  }

  AbstractComponentReport::ReportPartSequence& AbstractComponentReport::
  ReportPart ()
  {
    return this->ReportPart_;
  }

  void AbstractComponentReport::
  ReportPart (const ReportPartSequence& s)
  {
    this->ReportPart_ = s;
  }


  // AbstractAlertReport
  // 

  const AbstractAlertReport::ReportPartSequence& AbstractAlertReport::
  ReportPart () const
  {
    return this->ReportPart_;
  }

  AbstractAlertReport::ReportPartSequence& AbstractAlertReport::
  ReportPart ()
  {
    return this->ReportPart_;
  }

  void AbstractAlertReport::
  ReportPart (const ReportPartSequence& s)
  {
    this->ReportPart_ = s;
  }


  // AbstractOperationalStateReport
  // 

  const AbstractOperationalStateReport::ReportPartSequence& AbstractOperationalStateReport::
  ReportPart () const
  {
    return this->ReportPart_;
  }

  AbstractOperationalStateReport::ReportPartSequence& AbstractOperationalStateReport::
  ReportPart ()
  {
    return this->ReportPart_;
  }

  void AbstractOperationalStateReport::
  ReportPart (const ReportPartSequence& s)
  {
    this->ReportPart_ = s;
  }


  // DescriptionModificationType
  // 

  DescriptionModificationType::
  DescriptionModificationType (Value v)
  : ::xml_schema::String (_xsd_DescriptionModificationType_literals_[v])
  {
  }

  DescriptionModificationType::
  DescriptionModificationType (const char* v)
  : ::xml_schema::String (v)
  {
  }

  DescriptionModificationType::
  DescriptionModificationType (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  DescriptionModificationType::
  DescriptionModificationType (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  DescriptionModificationType::
  DescriptionModificationType (const DescriptionModificationType& v,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  DescriptionModificationType& DescriptionModificationType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_DescriptionModificationType_literals_[v]);

    return *this;
  }


  // RetrievabilityMethod
  // 

  RetrievabilityMethod::
  RetrievabilityMethod (Value v)
  : ::xml_schema::String (_xsd_RetrievabilityMethod_literals_[v])
  {
  }

  RetrievabilityMethod::
  RetrievabilityMethod (const char* v)
  : ::xml_schema::String (v)
  {
  }

  RetrievabilityMethod::
  RetrievabilityMethod (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  RetrievabilityMethod::
  RetrievabilityMethod (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  RetrievabilityMethod::
  RetrievabilityMethod (const RetrievabilityMethod& v,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  RetrievabilityMethod& RetrievabilityMethod::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_RetrievabilityMethod_literals_[v]);

    return *this;
  }


  // RetrievabilityInfo
  // 

  const RetrievabilityInfo::ExtensionOptional& RetrievabilityInfo::
  Extension () const
  {
    return this->Extension_;
  }

  RetrievabilityInfo::ExtensionOptional& RetrievabilityInfo::
  Extension ()
  {
    return this->Extension_;
  }

  void RetrievabilityInfo::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void RetrievabilityInfo::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void RetrievabilityInfo::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const RetrievabilityInfo::MethodType& RetrievabilityInfo::
  Method () const
  {
    return this->Method_.get ();
  }

  RetrievabilityInfo::MethodType& RetrievabilityInfo::
  Method ()
  {
    return this->Method_.get ();
  }

  void RetrievabilityInfo::
  Method (const MethodType& x)
  {
    this->Method_.set (x);
  }

  void RetrievabilityInfo::
  Method (::std::unique_ptr< MethodType > x)
  {
    this->Method_.set (std::move (x));
  }

  const RetrievabilityInfo::UpdatePeriodOptional& RetrievabilityInfo::
  UpdatePeriod () const
  {
    return this->UpdatePeriod_;
  }

  RetrievabilityInfo::UpdatePeriodOptional& RetrievabilityInfo::
  UpdatePeriod ()
  {
    return this->UpdatePeriod_;
  }

  void RetrievabilityInfo::
  UpdatePeriod (const UpdatePeriodType& x)
  {
    this->UpdatePeriod_.set (x);
  }

  void RetrievabilityInfo::
  UpdatePeriod (const UpdatePeriodOptional& x)
  {
    this->UpdatePeriod_ = x;
  }

  void RetrievabilityInfo::
  UpdatePeriod (::std::unique_ptr< UpdatePeriodType > x)
  {
    this->UpdatePeriod_.set (std::move (x));
  }


  // GetMdib
  // 


  // GetMdibResponse
  // 

  const GetMdibResponse::MdibType& GetMdibResponse::
  Mdib () const
  {
    return this->Mdib_.get ();
  }

  GetMdibResponse::MdibType& GetMdibResponse::
  Mdib ()
  {
    return this->Mdib_.get ();
  }

  void GetMdibResponse::
  Mdib (const MdibType& x)
  {
    this->Mdib_.set (x);
  }

  void GetMdibResponse::
  Mdib (::std::unique_ptr< MdibType > x)
  {
    this->Mdib_.set (std::move (x));
  }


  // GetMdDescription
  // 

  const GetMdDescription::HandleRefSequence& GetMdDescription::
  HandleRef () const
  {
    return this->HandleRef_;
  }

  GetMdDescription::HandleRefSequence& GetMdDescription::
  HandleRef ()
  {
    return this->HandleRef_;
  }

  void GetMdDescription::
  HandleRef (const HandleRefSequence& s)
  {
    this->HandleRef_ = s;
  }


  // GetMdDescriptionResponse
  // 

  const GetMdDescriptionResponse::MdDescriptionType& GetMdDescriptionResponse::
  MdDescription () const
  {
    return this->MdDescription_.get ();
  }

  GetMdDescriptionResponse::MdDescriptionType& GetMdDescriptionResponse::
  MdDescription ()
  {
    return this->MdDescription_.get ();
  }

  void GetMdDescriptionResponse::
  MdDescription (const MdDescriptionType& x)
  {
    this->MdDescription_.set (x);
  }

  void GetMdDescriptionResponse::
  MdDescription (::std::unique_ptr< MdDescriptionType > x)
  {
    this->MdDescription_.set (std::move (x));
  }


  // GetMdState
  // 

  const GetMdState::HandleRefSequence& GetMdState::
  HandleRef () const
  {
    return this->HandleRef_;
  }

  GetMdState::HandleRefSequence& GetMdState::
  HandleRef ()
  {
    return this->HandleRef_;
  }

  void GetMdState::
  HandleRef (const HandleRefSequence& s)
  {
    this->HandleRef_ = s;
  }


  // GetMdStateResponse
  // 

  const GetMdStateResponse::MdStateType& GetMdStateResponse::
  MdState () const
  {
    return this->MdState_.get ();
  }

  GetMdStateResponse::MdStateType& GetMdStateResponse::
  MdState ()
  {
    return this->MdState_.get ();
  }

  void GetMdStateResponse::
  MdState (const MdStateType& x)
  {
    this->MdState_.set (x);
  }

  void GetMdStateResponse::
  MdState (::std::unique_ptr< MdStateType > x)
  {
    this->MdState_.set (std::move (x));
  }


  // GetContextStates
  // 

  const GetContextStates::HandleRefSequence& GetContextStates::
  HandleRef () const
  {
    return this->HandleRef_;
  }

  GetContextStates::HandleRefSequence& GetContextStates::
  HandleRef ()
  {
    return this->HandleRef_;
  }

  void GetContextStates::
  HandleRef (const HandleRefSequence& s)
  {
    this->HandleRef_ = s;
  }


  // GetContextStatesResponse
  // 

  const GetContextStatesResponse::ContextStateSequence& GetContextStatesResponse::
  ContextState () const
  {
    return this->ContextState_;
  }

  GetContextStatesResponse::ContextStateSequence& GetContextStatesResponse::
  ContextState ()
  {
    return this->ContextState_;
  }

  void GetContextStatesResponse::
  ContextState (const ContextStateSequence& s)
  {
    this->ContextState_ = s;
  }


  // GetContextStatesByIdentification
  // 

  const GetContextStatesByIdentification::IdentificationSequence& GetContextStatesByIdentification::
  Identification () const
  {
    return this->Identification_;
  }

  GetContextStatesByIdentification::IdentificationSequence& GetContextStatesByIdentification::
  Identification ()
  {
    return this->Identification_;
  }

  void GetContextStatesByIdentification::
  Identification (const IdentificationSequence& s)
  {
    this->Identification_ = s;
  }

  const GetContextStatesByIdentification::ContextTypeOptional& GetContextStatesByIdentification::
  ContextType () const
  {
    return this->ContextType_;
  }

  GetContextStatesByIdentification::ContextTypeOptional& GetContextStatesByIdentification::
  ContextType ()
  {
    return this->ContextType_;
  }

  void GetContextStatesByIdentification::
  ContextType (const ContextTypeType& x)
  {
    this->ContextType_.set (x);
  }

  void GetContextStatesByIdentification::
  ContextType (const ContextTypeOptional& x)
  {
    this->ContextType_ = x;
  }

  void GetContextStatesByIdentification::
  ContextType (::std::unique_ptr< ContextTypeType > x)
  {
    this->ContextType_.set (std::move (x));
  }


  // GetContextStatesByIdentificationResponse
  // 

  const GetContextStatesByIdentificationResponse::ContextStateSequence& GetContextStatesByIdentificationResponse::
  ContextState () const
  {
    return this->ContextState_;
  }

  GetContextStatesByIdentificationResponse::ContextStateSequence& GetContextStatesByIdentificationResponse::
  ContextState ()
  {
    return this->ContextState_;
  }

  void GetContextStatesByIdentificationResponse::
  ContextState (const ContextStateSequence& s)
  {
    this->ContextState_ = s;
  }


  // GetContextStatesByFilter
  // 

  const GetContextStatesByFilter::FilterSequence& GetContextStatesByFilter::
  Filter () const
  {
    return this->Filter_;
  }

  GetContextStatesByFilter::FilterSequence& GetContextStatesByFilter::
  Filter ()
  {
    return this->Filter_;
  }

  void GetContextStatesByFilter::
  Filter (const FilterSequence& s)
  {
    this->Filter_ = s;
  }

  const GetContextStatesByFilter::ContextTypeOptional& GetContextStatesByFilter::
  ContextType () const
  {
    return this->ContextType_;
  }

  GetContextStatesByFilter::ContextTypeOptional& GetContextStatesByFilter::
  ContextType ()
  {
    return this->ContextType_;
  }

  void GetContextStatesByFilter::
  ContextType (const ContextTypeType& x)
  {
    this->ContextType_.set (x);
  }

  void GetContextStatesByFilter::
  ContextType (const ContextTypeOptional& x)
  {
    this->ContextType_ = x;
  }

  void GetContextStatesByFilter::
  ContextType (::std::unique_ptr< ContextTypeType > x)
  {
    this->ContextType_.set (std::move (x));
  }


  // GetContextStatesByFilterResponse
  // 

  const GetContextStatesByFilterResponse::ContextStateSequence& GetContextStatesByFilterResponse::
  ContextState () const
  {
    return this->ContextState_;
  }

  GetContextStatesByFilterResponse::ContextStateSequence& GetContextStatesByFilterResponse::
  ContextState ()
  {
    return this->ContextState_;
  }

  void GetContextStatesByFilterResponse::
  ContextState (const ContextStateSequence& s)
  {
    this->ContextState_ = s;
  }


  // SetContextState
  // 

  const SetContextState::ProposedContextStateSequence& SetContextState::
  ProposedContextState () const
  {
    return this->ProposedContextState_;
  }

  SetContextState::ProposedContextStateSequence& SetContextState::
  ProposedContextState ()
  {
    return this->ProposedContextState_;
  }

  void SetContextState::
  ProposedContextState (const ProposedContextStateSequence& s)
  {
    this->ProposedContextState_ = s;
  }


  // SetContextStateResponse
  // 


  // ReportPart
  // 

  const ReportPart::ContextStateSequence& ReportPart::
  ContextState () const
  {
    return this->ContextState_;
  }

  ReportPart::ContextStateSequence& ReportPart::
  ContextState ()
  {
    return this->ContextState_;
  }

  void ReportPart::
  ContextState (const ContextStateSequence& s)
  {
    this->ContextState_ = s;
  }


  // PeriodicContextReport
  // 


  // EpisodicContextReport
  // 


  // GetLocalizedText
  // 

  const GetLocalizedText::RefSequence& GetLocalizedText::
  Ref () const
  {
    return this->Ref_;
  }

  GetLocalizedText::RefSequence& GetLocalizedText::
  Ref ()
  {
    return this->Ref_;
  }

  void GetLocalizedText::
  Ref (const RefSequence& s)
  {
    this->Ref_ = s;
  }

  const GetLocalizedText::VersionOptional& GetLocalizedText::
  Version () const
  {
    return this->Version_;
  }

  GetLocalizedText::VersionOptional& GetLocalizedText::
  Version ()
  {
    return this->Version_;
  }

  void GetLocalizedText::
  Version (const VersionType& x)
  {
    this->Version_.set (x);
  }

  void GetLocalizedText::
  Version (const VersionOptional& x)
  {
    this->Version_ = x;
  }

  void GetLocalizedText::
  Version (::std::unique_ptr< VersionType > x)
  {
    this->Version_.set (std::move (x));
  }

  const GetLocalizedText::LangSequence& GetLocalizedText::
  Lang () const
  {
    return this->Lang_;
  }

  GetLocalizedText::LangSequence& GetLocalizedText::
  Lang ()
  {
    return this->Lang_;
  }

  void GetLocalizedText::
  Lang (const LangSequence& s)
  {
    this->Lang_ = s;
  }

  const GetLocalizedText::TextWidthSequence& GetLocalizedText::
  TextWidth () const
  {
    return this->TextWidth_;
  }

  GetLocalizedText::TextWidthSequence& GetLocalizedText::
  TextWidth ()
  {
    return this->TextWidth_;
  }

  void GetLocalizedText::
  TextWidth (const TextWidthSequence& s)
  {
    this->TextWidth_ = s;
  }

  const GetLocalizedText::NumberOfLinesSequence& GetLocalizedText::
  NumberOfLines () const
  {
    return this->NumberOfLines_;
  }

  GetLocalizedText::NumberOfLinesSequence& GetLocalizedText::
  NumberOfLines ()
  {
    return this->NumberOfLines_;
  }

  void GetLocalizedText::
  NumberOfLines (const NumberOfLinesSequence& s)
  {
    this->NumberOfLines_ = s;
  }


  // GetLocalizedTextResponse
  // 

  const GetLocalizedTextResponse::TextSequence& GetLocalizedTextResponse::
  Text () const
  {
    return this->Text_;
  }

  GetLocalizedTextResponse::TextSequence& GetLocalizedTextResponse::
  Text ()
  {
    return this->Text_;
  }

  void GetLocalizedTextResponse::
  Text (const TextSequence& s)
  {
    this->Text_ = s;
  }


  // GetSupportedLanguages
  // 


  // GetSupportedLanguagesResponse
  // 

  const GetSupportedLanguagesResponse::LangSequence& GetSupportedLanguagesResponse::
  Lang () const
  {
    return this->Lang_;
  }

  GetSupportedLanguagesResponse::LangSequence& GetSupportedLanguagesResponse::
  Lang ()
  {
    return this->Lang_;
  }

  void GetSupportedLanguagesResponse::
  Lang (const LangSequence& s)
  {
    this->Lang_ = s;
  }


  // GetDescriptorsFromArchive
  // 

  const GetDescriptorsFromArchive::DescriptorRevisionsOptional& GetDescriptorsFromArchive::
  DescriptorRevisions () const
  {
    return this->DescriptorRevisions_;
  }

  GetDescriptorsFromArchive::DescriptorRevisionsOptional& GetDescriptorsFromArchive::
  DescriptorRevisions ()
  {
    return this->DescriptorRevisions_;
  }

  void GetDescriptorsFromArchive::
  DescriptorRevisions (const DescriptorRevisionsType& x)
  {
    this->DescriptorRevisions_.set (x);
  }

  void GetDescriptorsFromArchive::
  DescriptorRevisions (const DescriptorRevisionsOptional& x)
  {
    this->DescriptorRevisions_ = x;
  }

  void GetDescriptorsFromArchive::
  DescriptorRevisions (::std::unique_ptr< DescriptorRevisionsType > x)
  {
    this->DescriptorRevisions_.set (std::move (x));
  }

  const GetDescriptorsFromArchive::TimeFrameOptional& GetDescriptorsFromArchive::
  TimeFrame () const
  {
    return this->TimeFrame_;
  }

  GetDescriptorsFromArchive::TimeFrameOptional& GetDescriptorsFromArchive::
  TimeFrame ()
  {
    return this->TimeFrame_;
  }

  void GetDescriptorsFromArchive::
  TimeFrame (const TimeFrameType& x)
  {
    this->TimeFrame_.set (x);
  }

  void GetDescriptorsFromArchive::
  TimeFrame (const TimeFrameOptional& x)
  {
    this->TimeFrame_ = x;
  }

  void GetDescriptorsFromArchive::
  TimeFrame (::std::unique_ptr< TimeFrameType > x)
  {
    this->TimeFrame_.set (std::move (x));
  }

  const GetDescriptorsFromArchive::HandleSequence& GetDescriptorsFromArchive::
  Handle () const
  {
    return this->Handle_;
  }

  GetDescriptorsFromArchive::HandleSequence& GetDescriptorsFromArchive::
  Handle ()
  {
    return this->Handle_;
  }

  void GetDescriptorsFromArchive::
  Handle (const HandleSequence& s)
  {
    this->Handle_ = s;
  }


  // GetDescriptorsFromArchiveResponse
  // 

  const GetDescriptorsFromArchiveResponse::DescriptorSequence& GetDescriptorsFromArchiveResponse::
  Descriptor () const
  {
    return this->Descriptor_;
  }

  GetDescriptorsFromArchiveResponse::DescriptorSequence& GetDescriptorsFromArchiveResponse::
  Descriptor ()
  {
    return this->Descriptor_;
  }

  void GetDescriptorsFromArchiveResponse::
  Descriptor (const DescriptorSequence& s)
  {
    this->Descriptor_ = s;
  }


  // GetStatesFromArchive
  // 

  const GetStatesFromArchive::StateRevisionsOptional& GetStatesFromArchive::
  StateRevisions () const
  {
    return this->StateRevisions_;
  }

  GetStatesFromArchive::StateRevisionsOptional& GetStatesFromArchive::
  StateRevisions ()
  {
    return this->StateRevisions_;
  }

  void GetStatesFromArchive::
  StateRevisions (const StateRevisionsType& x)
  {
    this->StateRevisions_.set (x);
  }

  void GetStatesFromArchive::
  StateRevisions (const StateRevisionsOptional& x)
  {
    this->StateRevisions_ = x;
  }

  void GetStatesFromArchive::
  StateRevisions (::std::unique_ptr< StateRevisionsType > x)
  {
    this->StateRevisions_.set (std::move (x));
  }

  const GetStatesFromArchive::TimeFrameOptional& GetStatesFromArchive::
  TimeFrame () const
  {
    return this->TimeFrame_;
  }

  GetStatesFromArchive::TimeFrameOptional& GetStatesFromArchive::
  TimeFrame ()
  {
    return this->TimeFrame_;
  }

  void GetStatesFromArchive::
  TimeFrame (const TimeFrameType& x)
  {
    this->TimeFrame_.set (x);
  }

  void GetStatesFromArchive::
  TimeFrame (const TimeFrameOptional& x)
  {
    this->TimeFrame_ = x;
  }

  void GetStatesFromArchive::
  TimeFrame (::std::unique_ptr< TimeFrameType > x)
  {
    this->TimeFrame_.set (std::move (x));
  }

  const GetStatesFromArchive::HandleSequence& GetStatesFromArchive::
  Handle () const
  {
    return this->Handle_;
  }

  GetStatesFromArchive::HandleSequence& GetStatesFromArchive::
  Handle ()
  {
    return this->Handle_;
  }

  void GetStatesFromArchive::
  Handle (const HandleSequence& s)
  {
    this->Handle_ = s;
  }


  // GetStatesFromArchiveResponse
  // 

  const GetStatesFromArchiveResponse::StateSequence& GetStatesFromArchiveResponse::
  State () const
  {
    return this->State_;
  }

  GetStatesFromArchiveResponse::StateSequence& GetStatesFromArchiveResponse::
  State ()
  {
    return this->State_;
  }

  void GetStatesFromArchiveResponse::
  State (const StateSequence& s)
  {
    this->State_ = s;
  }


  // SetValue
  // 

  const SetValue::RequestedNumericValueType& SetValue::
  RequestedNumericValue () const
  {
    return this->RequestedNumericValue_.get ();
  }

  SetValue::RequestedNumericValueType& SetValue::
  RequestedNumericValue ()
  {
    return this->RequestedNumericValue_.get ();
  }

  void SetValue::
  RequestedNumericValue (const RequestedNumericValueType& x)
  {
    this->RequestedNumericValue_.set (x);
  }


  // SetValueResponse
  // 


  // SetString
  // 

  const SetString::RequestedStringValueType& SetString::
  RequestedStringValue () const
  {
    return this->RequestedStringValue_.get ();
  }

  SetString::RequestedStringValueType& SetString::
  RequestedStringValue ()
  {
    return this->RequestedStringValue_.get ();
  }

  void SetString::
  RequestedStringValue (const RequestedStringValueType& x)
  {
    this->RequestedStringValue_.set (x);
  }

  void SetString::
  RequestedStringValue (::std::unique_ptr< RequestedStringValueType > x)
  {
    this->RequestedStringValue_.set (std::move (x));
  }


  // SetStringResponse
  // 


  // Activate
  // 

  const Activate::ArgumentSequence& Activate::
  Argument () const
  {
    return this->Argument_;
  }

  Activate::ArgumentSequence& Activate::
  Argument ()
  {
    return this->Argument_;
  }

  void Activate::
  Argument (const ArgumentSequence& s)
  {
    this->Argument_ = s;
  }


  // ActivateResponse
  // 


  // SetAlertState
  // 

  const SetAlertState::ProposedAlertStateType& SetAlertState::
  ProposedAlertState () const
  {
    return this->ProposedAlertState_.get ();
  }

  SetAlertState::ProposedAlertStateType& SetAlertState::
  ProposedAlertState ()
  {
    return this->ProposedAlertState_.get ();
  }

  void SetAlertState::
  ProposedAlertState (const ProposedAlertStateType& x)
  {
    this->ProposedAlertState_.set (x);
  }

  void SetAlertState::
  ProposedAlertState (::std::unique_ptr< ProposedAlertStateType > x)
  {
    this->ProposedAlertState_.set (std::move (x));
  }


  // SetAlertStateResponse
  // 


  // SetComponentState
  // 

  const SetComponentState::ProposedComponentStateSequence& SetComponentState::
  ProposedComponentState () const
  {
    return this->ProposedComponentState_;
  }

  SetComponentState::ProposedComponentStateSequence& SetComponentState::
  ProposedComponentState ()
  {
    return this->ProposedComponentState_;
  }

  void SetComponentState::
  ProposedComponentState (const ProposedComponentStateSequence& s)
  {
    this->ProposedComponentState_ = s;
  }


  // SetComponentStateResponse
  // 


  // SetMetricState
  // 

  const SetMetricState::ProposedMetricStateSequence& SetMetricState::
  ProposedMetricState () const
  {
    return this->ProposedMetricState_;
  }

  SetMetricState::ProposedMetricStateSequence& SetMetricState::
  ProposedMetricState ()
  {
    return this->ProposedMetricState_;
  }

  void SetMetricState::
  ProposedMetricState (const ProposedMetricStateSequence& s)
  {
    this->ProposedMetricState_ = s;
  }


  // SetMetricStateResponse
  // 


  // OperationInvokedReport
  // 

  const OperationInvokedReport::ReportPartSequence& OperationInvokedReport::
  ReportPart () const
  {
    return this->ReportPart_;
  }

  OperationInvokedReport::ReportPartSequence& OperationInvokedReport::
  ReportPart ()
  {
    return this->ReportPart_;
  }

  void OperationInvokedReport::
  ReportPart (const ReportPartSequence& s)
  {
    this->ReportPart_ = s;
  }


  // GetContainmentTree
  // 

  const GetContainmentTree::HandleRefSequence& GetContainmentTree::
  HandleRef () const
  {
    return this->HandleRef_;
  }

  GetContainmentTree::HandleRefSequence& GetContainmentTree::
  HandleRef ()
  {
    return this->HandleRef_;
  }

  void GetContainmentTree::
  HandleRef (const HandleRefSequence& s)
  {
    this->HandleRef_ = s;
  }


  // GetContainmentTreeResponse
  // 

  const GetContainmentTreeResponse::ContainmentTreeType& GetContainmentTreeResponse::
  ContainmentTree () const
  {
    return this->ContainmentTree_.get ();
  }

  GetContainmentTreeResponse::ContainmentTreeType& GetContainmentTreeResponse::
  ContainmentTree ()
  {
    return this->ContainmentTree_.get ();
  }

  void GetContainmentTreeResponse::
  ContainmentTree (const ContainmentTreeType& x)
  {
    this->ContainmentTree_.set (x);
  }

  void GetContainmentTreeResponse::
  ContainmentTree (::std::unique_ptr< ContainmentTreeType > x)
  {
    this->ContainmentTree_.set (std::move (x));
  }


  // GetDescriptor
  // 

  const GetDescriptor::HandleRefSequence& GetDescriptor::
  HandleRef () const
  {
    return this->HandleRef_;
  }

  GetDescriptor::HandleRefSequence& GetDescriptor::
  HandleRef ()
  {
    return this->HandleRef_;
  }

  void GetDescriptor::
  HandleRef (const HandleRefSequence& s)
  {
    this->HandleRef_ = s;
  }


  // GetDescriptorResponse
  // 

  const GetDescriptorResponse::DescriptorSequence& GetDescriptorResponse::
  Descriptor () const
  {
    return this->Descriptor_;
  }

  GetDescriptorResponse::DescriptorSequence& GetDescriptorResponse::
  Descriptor ()
  {
    return this->Descriptor_;
  }

  void GetDescriptorResponse::
  Descriptor (const DescriptorSequence& s)
  {
    this->Descriptor_ = s;
  }


  // ReportPart1
  // 

  const ReportPart1::MetricStateSequence& ReportPart1::
  MetricState () const
  {
    return this->MetricState_;
  }

  ReportPart1::MetricStateSequence& ReportPart1::
  MetricState ()
  {
    return this->MetricState_;
  }

  void ReportPart1::
  MetricState (const MetricStateSequence& s)
  {
    this->MetricState_ = s;
  }


  // EpisodicMetricReport
  // 


  // PeriodicMetricReport
  // 


  // ReportPart2
  // 

  const ReportPart2::ComponentStateSequence& ReportPart2::
  ComponentState () const
  {
    return this->ComponentState_;
  }

  ReportPart2::ComponentStateSequence& ReportPart2::
  ComponentState ()
  {
    return this->ComponentState_;
  }

  void ReportPart2::
  ComponentState (const ComponentStateSequence& s)
  {
    this->ComponentState_ = s;
  }


  // EpisodicComponentReport
  // 


  // PeriodicComponentReport
  // 


  // ReportPart3
  // 

  const ReportPart3::AlertStateSequence& ReportPart3::
  AlertState () const
  {
    return this->AlertState_;
  }

  ReportPart3::AlertStateSequence& ReportPart3::
  AlertState ()
  {
    return this->AlertState_;
  }

  void ReportPart3::
  AlertState (const AlertStateSequence& s)
  {
    this->AlertState_ = s;
  }


  // EpisodicAlertReport
  // 


  // PeriodicAlertReport
  // 


  // ReportPart4
  // 

  const ReportPart4::OperationStateSequence& ReportPart4::
  OperationState () const
  {
    return this->OperationState_;
  }

  ReportPart4::OperationStateSequence& ReportPart4::
  OperationState ()
  {
    return this->OperationState_;
  }

  void ReportPart4::
  OperationState (const OperationStateSequence& s)
  {
    this->OperationState_ = s;
  }


  // EpisodicOperationalStateReport
  // 


  // PeriodicOperationalStateReport
  // 


  // SystemErrorReport
  // 

  const SystemErrorReport::ReportPartSequence& SystemErrorReport::
  ReportPart () const
  {
    return this->ReportPart_;
  }

  SystemErrorReport::ReportPartSequence& SystemErrorReport::
  ReportPart ()
  {
    return this->ReportPart_;
  }

  void SystemErrorReport::
  ReportPart (const ReportPartSequence& s)
  {
    this->ReportPart_ = s;
  }


  // DescriptionModificationReport
  // 

  const DescriptionModificationReport::ReportPartSequence& DescriptionModificationReport::
  ReportPart () const
  {
    return this->ReportPart_;
  }

  DescriptionModificationReport::ReportPartSequence& DescriptionModificationReport::
  ReportPart ()
  {
    return this->ReportPart_;
  }

  void DescriptionModificationReport::
  ReportPart (const ReportPartSequence& s)
  {
    this->ReportPart_ = s;
  }


  // WaveformStream
  // 

  const WaveformStream::StateSequence& WaveformStream::
  State () const
  {
    return this->State_;
  }

  WaveformStream::StateSequence& WaveformStream::
  State ()
  {
    return this->State_;
  }

  void WaveformStream::
  State (const StateSequence& s)
  {
    this->State_ = s;
  }


  // ObservedValueStream
  // 

  const ObservedValueStream::ValueSequence& ObservedValueStream::
  Value () const
  {
    return this->Value_;
  }

  ObservedValueStream::ValueSequence& ObservedValueStream::
  Value ()
  {
    return this->Value_;
  }

  void ObservedValueStream::
  Value (const ValueSequence& s)
  {
    this->Value_ = s;
  }


  // Retrievability
  // 

  const Retrievability::BySequence& Retrievability::
  By () const
  {
    return this->By_;
  }

  Retrievability::BySequence& Retrievability::
  By ()
  {
    return this->By_;
  }

  void Retrievability::
  By (const BySequence& s)
  {
    this->By_ = s;
  }


  // Argument
  // 

  const Argument::ExtensionOptional& Argument::
  Extension () const
  {
    return this->Extension_;
  }

  Argument::ExtensionOptional& Argument::
  Extension ()
  {
    return this->Extension_;
  }

  void Argument::
  Extension (const ExtensionType& x)
  {
    this->Extension_.set (x);
  }

  void Argument::
  Extension (const ExtensionOptional& x)
  {
    this->Extension_ = x;
  }

  void Argument::
  Extension (::std::unique_ptr< ExtensionType > x)
  {
    this->Extension_.set (std::move (x));
  }

  const Argument::ArgValueType& Argument::
  ArgValue () const
  {
    return this->ArgValue_.get ();
  }

  Argument::ArgValueType& Argument::
  ArgValue ()
  {
    return this->ArgValue_.get ();
  }

  void Argument::
  ArgValue (const ArgValueType& x)
  {
    this->ArgValue_.set (x);
  }

  void Argument::
  ArgValue (::std::unique_ptr< ArgValueType > x)
  {
    this->ArgValue_.set (std::move (x));
  }


  // ReportPart5
  // 

  const ReportPart5::InvocationInfoType& ReportPart5::
  InvocationInfo () const
  {
    return this->InvocationInfo_.get ();
  }

  ReportPart5::InvocationInfoType& ReportPart5::
  InvocationInfo ()
  {
    return this->InvocationInfo_.get ();
  }

  void ReportPart5::
  InvocationInfo (const InvocationInfoType& x)
  {
    this->InvocationInfo_.set (x);
  }

  void ReportPart5::
  InvocationInfo (::std::unique_ptr< InvocationInfoType > x)
  {
    this->InvocationInfo_.set (std::move (x));
  }

  const ReportPart5::InvocationSourceType& ReportPart5::
  InvocationSource () const
  {
    return this->InvocationSource_.get ();
  }

  ReportPart5::InvocationSourceType& ReportPart5::
  InvocationSource ()
  {
    return this->InvocationSource_.get ();
  }

  void ReportPart5::
  InvocationSource (const InvocationSourceType& x)
  {
    this->InvocationSource_.set (x);
  }

  void ReportPart5::
  InvocationSource (::std::unique_ptr< InvocationSourceType > x)
  {
    this->InvocationSource_.set (std::move (x));
  }

  const ReportPart5::OperationHandleRefType& ReportPart5::
  OperationHandleRef () const
  {
    return this->OperationHandleRef_.get ();
  }

  ReportPart5::OperationHandleRefType& ReportPart5::
  OperationHandleRef ()
  {
    return this->OperationHandleRef_.get ();
  }

  void ReportPart5::
  OperationHandleRef (const OperationHandleRefType& x)
  {
    this->OperationHandleRef_.set (x);
  }

  void ReportPart5::
  OperationHandleRef (::std::unique_ptr< OperationHandleRefType > x)
  {
    this->OperationHandleRef_.set (std::move (x));
  }

  const ReportPart5::OperationTargetOptional& ReportPart5::
  OperationTarget () const
  {
    return this->OperationTarget_;
  }

  ReportPart5::OperationTargetOptional& ReportPart5::
  OperationTarget ()
  {
    return this->OperationTarget_;
  }

  void ReportPart5::
  OperationTarget (const OperationTargetType& x)
  {
    this->OperationTarget_.set (x);
  }

  void ReportPart5::
  OperationTarget (const OperationTargetOptional& x)
  {
    this->OperationTarget_ = x;
  }

  void ReportPart5::
  OperationTarget (::std::unique_ptr< OperationTargetType > x)
  {
    this->OperationTarget_.set (std::move (x));
  }


  // ReportPart6
  // 

  const ReportPart6::ErrorCodeType& ReportPart6::
  ErrorCode () const
  {
    return this->ErrorCode_.get ();
  }

  ReportPart6::ErrorCodeType& ReportPart6::
  ErrorCode ()
  {
    return this->ErrorCode_.get ();
  }

  void ReportPart6::
  ErrorCode (const ErrorCodeType& x)
  {
    this->ErrorCode_.set (x);
  }

  void ReportPart6::
  ErrorCode (::std::unique_ptr< ErrorCodeType > x)
  {
    this->ErrorCode_.set (std::move (x));
  }

  const ReportPart6::ErrorInfoOptional& ReportPart6::
  ErrorInfo () const
  {
    return this->ErrorInfo_;
  }

  ReportPart6::ErrorInfoOptional& ReportPart6::
  ErrorInfo ()
  {
    return this->ErrorInfo_;
  }

  void ReportPart6::
  ErrorInfo (const ErrorInfoType& x)
  {
    this->ErrorInfo_.set (x);
  }

  void ReportPart6::
  ErrorInfo (const ErrorInfoOptional& x)
  {
    this->ErrorInfo_ = x;
  }

  void ReportPart6::
  ErrorInfo (::std::unique_ptr< ErrorInfoType > x)
  {
    this->ErrorInfo_.set (std::move (x));
  }


  // ReportPart7
  // 

  const ReportPart7::DescriptorSequence& ReportPart7::
  Descriptor () const
  {
    return this->Descriptor_;
  }

  ReportPart7::DescriptorSequence& ReportPart7::
  Descriptor ()
  {
    return this->Descriptor_;
  }

  void ReportPart7::
  Descriptor (const DescriptorSequence& s)
  {
    this->Descriptor_ = s;
  }

  const ReportPart7::StateSequence& ReportPart7::
  State () const
  {
    return this->State_;
  }

  ReportPart7::StateSequence& ReportPart7::
  State ()
  {
    return this->State_;
  }

  void ReportPart7::
  State (const StateSequence& s)
  {
    this->State_ = s;
  }

  const ReportPart7::ParentDescriptorOptional& ReportPart7::
  ParentDescriptor () const
  {
    return this->ParentDescriptor_;
  }

  ReportPart7::ParentDescriptorOptional& ReportPart7::
  ParentDescriptor ()
  {
    return this->ParentDescriptor_;
  }

  void ReportPart7::
  ParentDescriptor (const ParentDescriptorType& x)
  {
    this->ParentDescriptor_.set (x);
  }

  void ReportPart7::
  ParentDescriptor (const ParentDescriptorOptional& x)
  {
    this->ParentDescriptor_ = x;
  }

  void ReportPart7::
  ParentDescriptor (::std::unique_ptr< ParentDescriptorType > x)
  {
    this->ParentDescriptor_.set (std::move (x));
  }

  const ReportPart7::ModificationTypeOptional& ReportPart7::
  ModificationType () const
  {
    return this->ModificationType_;
  }

  ReportPart7::ModificationTypeOptional& ReportPart7::
  ModificationType ()
  {
    return this->ModificationType_;
  }

  void ReportPart7::
  ModificationType (const ModificationTypeType& x)
  {
    this->ModificationType_.set (x);
  }

  void ReportPart7::
  ModificationType (const ModificationTypeOptional& x)
  {
    this->ModificationType_ = x;
  }

  void ReportPart7::
  ModificationType (::std::unique_ptr< ModificationTypeType > x)
  {
    this->ModificationType_.set (std::move (x));
  }


  // Value
  // 

  const Value::Value1Optional& Value::
  Value1 () const
  {
    return this->Value1_;
  }

  Value::Value1Optional& Value::
  Value1 ()
  {
    return this->Value1_;
  }

  void Value::
  Value1 (const Value1Type& x)
  {
    this->Value1_.set (x);
  }

  void Value::
  Value1 (const Value1Optional& x)
  {
    this->Value1_ = x;
  }

  void Value::
  Value1 (::std::unique_ptr< Value1Type > x)
  {
    this->Value1_.set (std::move (x));
  }

  const Value::MetricType& Value::
  Metric () const
  {
    return this->Metric_.get ();
  }

  Value::MetricType& Value::
  Metric ()
  {
    return this->Metric_.get ();
  }

  void Value::
  Metric (const MetricType& x)
  {
    this->Metric_.set (x);
  }

  void Value::
  Metric (::std::unique_ptr< MetricType > x)
  {
    this->Metric_.set (std::move (x));
  }

  const Value::StateVersionOptional& Value::
  StateVersion () const
  {
    return this->StateVersion_;
  }

  Value::StateVersionOptional& Value::
  StateVersion ()
  {
    return this->StateVersion_;
  }

  void Value::
  StateVersion (const StateVersionType& x)
  {
    this->StateVersion_.set (x);
  }

  void Value::
  StateVersion (const StateVersionOptional& x)
  {
    this->StateVersion_ = x;
  }

  void Value::
  StateVersion (::std::unique_ptr< StateVersionType > x)
  {
    this->StateVersion_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace MDM
{
  // TransactionId
  //

  TransactionId::
  TransactionId (const ::xml_schema::UnsignedInt& _xsd_UnsignedInt_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType > (_xsd_UnsignedInt_base)
  {
  }

  TransactionId::
  TransactionId (const TransactionId& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  TransactionId::
  TransactionId (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  TransactionId::
  TransactionId (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  TransactionId::
  TransactionId (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  TransactionId* TransactionId::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TransactionId (*this, f, c);
  }

  TransactionId::
  ~TransactionId ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, TransactionId >
  _xsd_TransactionId_type_factory_init (
    "TransactionId",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // InvocationState
  //

  InvocationState::
  InvocationState (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_InvocationState_convert ();
  }

  InvocationState::
  InvocationState (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_InvocationState_convert ();
  }

  InvocationState::
  InvocationState (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_InvocationState_convert ();
  }

  InvocationState* InvocationState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InvocationState (*this, f, c);
  }

  InvocationState::Value InvocationState::
  _xsd_InvocationState_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_InvocationState_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_InvocationState_indexes_,
                      _xsd_InvocationState_indexes_ + 7,
                      *this,
                      c));

    if (i == _xsd_InvocationState_indexes_ + 7 || _xsd_InvocationState_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const InvocationState::
  _xsd_InvocationState_literals_[7] =
  {
    "Wait",
    "Start",
    "Cnclld",
    "CnclldMan",
    "Fin",
    "FinMod",
    "Fail"
  };

  const InvocationState::Value InvocationState::
  _xsd_InvocationState_indexes_[7] =
  {
    ::MDM::InvocationState::Cnclld,
    ::MDM::InvocationState::CnclldMan,
    ::MDM::InvocationState::Fail,
    ::MDM::InvocationState::Fin,
    ::MDM::InvocationState::FinMod,
    ::MDM::InvocationState::Start,
    ::MDM::InvocationState::Wait
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, InvocationState >
  _xsd_InvocationState_type_factory_init (
    "InvocationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // InvocationError
  //

  InvocationError::
  InvocationError (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_InvocationError_convert ();
  }

  InvocationError::
  InvocationError (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_InvocationError_convert ();
  }

  InvocationError::
  InvocationError (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_InvocationError_convert ();
  }

  InvocationError* InvocationError::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InvocationError (*this, f, c);
  }

  InvocationError::Value InvocationError::
  _xsd_InvocationError_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_InvocationError_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_InvocationError_indexes_,
                      _xsd_InvocationError_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_InvocationError_indexes_ + 4 || _xsd_InvocationError_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const InvocationError::
  _xsd_InvocationError_literals_[4] =
  {
    "Unspec",
    "Unkn",
    "Inv",
    "Oth"
  };

  const InvocationError::Value InvocationError::
  _xsd_InvocationError_indexes_[4] =
  {
    ::MDM::InvocationError::Inv,
    ::MDM::InvocationError::Oth,
    ::MDM::InvocationError::Unkn,
    ::MDM::InvocationError::Unspec
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, InvocationError >
  _xsd_InvocationError_type_factory_init (
    "InvocationError",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // InvocationInfo
  //

  InvocationInfo::
  InvocationInfo (const TransactionIdType& TransactionId,
                  const InvocationStateType& InvocationState)
  : ::xml_schema::Type (),
    Extension_ (this),
    TransactionId_ (TransactionId, this),
    InvocationState_ (InvocationState, this),
    InvocationError_ (this),
    InvocationErrorMessage_ (this)
  {
  }

  InvocationInfo::
  InvocationInfo (::std::unique_ptr< TransactionIdType > TransactionId,
                  ::std::unique_ptr< InvocationStateType > InvocationState)
  : ::xml_schema::Type (),
    Extension_ (this),
    TransactionId_ (std::move (TransactionId), this),
    InvocationState_ (std::move (InvocationState), this),
    InvocationError_ (this),
    InvocationErrorMessage_ (this)
  {
  }

  InvocationInfo::
  InvocationInfo (const InvocationInfo& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    TransactionId_ (x.TransactionId_, f, this),
    InvocationState_ (x.InvocationState_, f, this),
    InvocationError_ (x.InvocationError_, f, this),
    InvocationErrorMessage_ (x.InvocationErrorMessage_, f, this)
  {
  }

  InvocationInfo::
  InvocationInfo (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    TransactionId_ (this),
    InvocationState_ (this),
    InvocationError_ (this),
    InvocationErrorMessage_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void InvocationInfo::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // TransactionId
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TransactionId",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< TransactionIdType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!TransactionId_.present ())
          {
            ::std::unique_ptr< TransactionIdType > r (
              dynamic_cast< TransactionIdType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->TransactionId_.set (::std::move (r));
            continue;
          }
        }
      }

      // InvocationState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "InvocationState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< InvocationStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!InvocationState_.present ())
          {
            ::std::unique_ptr< InvocationStateType > r (
              dynamic_cast< InvocationStateType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->InvocationState_.set (::std::move (r));
            continue;
          }
        }
      }

      // InvocationError
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "InvocationError",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< InvocationErrorType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->InvocationError_)
          {
            ::std::unique_ptr< InvocationErrorType > r (
              dynamic_cast< InvocationErrorType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->InvocationError_.set (::std::move (r));
            continue;
          }
        }
      }

      // InvocationErrorMessage
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "InvocationErrorMessage",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< InvocationErrorMessageType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< InvocationErrorMessageType > r (
            dynamic_cast< InvocationErrorMessageType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->InvocationErrorMessage_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!TransactionId_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TransactionId",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }

    if (!InvocationState_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "InvocationState",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  InvocationInfo* InvocationInfo::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InvocationInfo (*this, f, c);
  }

  InvocationInfo& InvocationInfo::
  operator= (const InvocationInfo& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->TransactionId_ = x.TransactionId_;
      this->InvocationState_ = x.InvocationState_;
      this->InvocationError_ = x.InvocationError_;
      this->InvocationErrorMessage_ = x.InvocationErrorMessage_;
    }

    return *this;
  }

  InvocationInfo::
  ~InvocationInfo ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, InvocationInfo >
  _xsd_InvocationInfo_type_factory_init (
    "InvocationInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractGet
  //

  AbstractGet::
  AbstractGet ()
  : ::xml_schema::Type (),
    Extension_ (this)
  {
  }

  AbstractGet::
  AbstractGet (const AbstractGet& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this)
  {
  }

  AbstractGet::
  AbstractGet (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AbstractGet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  AbstractGet* AbstractGet::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractGet (*this, f, c);
  }

  AbstractGet& AbstractGet::
  operator= (const AbstractGet& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
    }

    return *this;
  }

  AbstractGet::
  ~AbstractGet ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractGet >
  _xsd_AbstractGet_type_factory_init (
    "AbstractGet",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractGetResponse
  //

  AbstractGetResponse::
  AbstractGetResponse (const SequenceIdType& SequenceId)
  : ::xml_schema::Type (),
    Extension_ (this),
    MdibVersion_ (this),
    SequenceId_ (SequenceId, this),
    InstanceId_ (this)
  {
  }

  AbstractGetResponse::
  AbstractGetResponse (const AbstractGetResponse& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    MdibVersion_ (x.MdibVersion_, f, this),
    SequenceId_ (x.SequenceId_, f, this),
    InstanceId_ (x.InstanceId_, f, this)
  {
  }

  AbstractGetResponse::
  AbstractGetResponse (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    MdibVersion_ (this),
    SequenceId_ (this),
    InstanceId_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractGetResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MdibVersion" && n.namespace_ ().empty ())
      {
        this->MdibVersion_.set (MdibVersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "SequenceId" && n.namespace_ ().empty ())
      {
        this->SequenceId_.set (SequenceIdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "InstanceId" && n.namespace_ ().empty ())
      {
        this->InstanceId_.set (InstanceIdTraits::create (i, f, this));
        continue;
      }
    }

    if (!SequenceId_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "SequenceId",
        "");
    }
  }

  AbstractGetResponse* AbstractGetResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractGetResponse (*this, f, c);
  }

  AbstractGetResponse& AbstractGetResponse::
  operator= (const AbstractGetResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->MdibVersion_ = x.MdibVersion_;
      this->SequenceId_ = x.SequenceId_;
      this->InstanceId_ = x.InstanceId_;
    }

    return *this;
  }

  AbstractGetResponse::
  ~AbstractGetResponse ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractGetResponse >
  _xsd_AbstractGetResponse_type_factory_init (
    "AbstractGetResponse",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractReportPart
  //

  AbstractReportPart::
  AbstractReportPart ()
  : ::xml_schema::Type (),
    Extension_ (this),
    SourceMds_ (this)
  {
  }

  AbstractReportPart::
  AbstractReportPart (const AbstractReportPart& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    SourceMds_ (x.SourceMds_, f, this)
  {
  }

  AbstractReportPart::
  AbstractReportPart (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    SourceMds_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AbstractReportPart::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // SourceMds
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "SourceMds",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< SourceMdsType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->SourceMds_)
          {
            ::std::unique_ptr< SourceMdsType > r (
              dynamic_cast< SourceMdsType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->SourceMds_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }
  }

  AbstractReportPart* AbstractReportPart::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractReportPart (*this, f, c);
  }

  AbstractReportPart& AbstractReportPart::
  operator= (const AbstractReportPart& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->SourceMds_ = x.SourceMds_;
    }

    return *this;
  }

  AbstractReportPart::
  ~AbstractReportPart ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractReportPart >
  _xsd_AbstractReportPart_type_factory_init (
    "AbstractReportPart",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractReport
  //

  AbstractReport::
  AbstractReport (const SequenceIdType& SequenceId)
  : ::xml_schema::Type (),
    Extension_ (this),
    MdibVersion_ (this),
    SequenceId_ (SequenceId, this),
    InstanceId_ (this)
  {
  }

  AbstractReport::
  AbstractReport (const AbstractReport& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    MdibVersion_ (x.MdibVersion_, f, this),
    SequenceId_ (x.SequenceId_, f, this),
    InstanceId_ (x.InstanceId_, f, this)
  {
  }

  AbstractReport::
  AbstractReport (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    MdibVersion_ (this),
    SequenceId_ (this),
    InstanceId_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MdibVersion" && n.namespace_ ().empty ())
      {
        this->MdibVersion_.set (MdibVersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "SequenceId" && n.namespace_ ().empty ())
      {
        this->SequenceId_.set (SequenceIdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "InstanceId" && n.namespace_ ().empty ())
      {
        this->InstanceId_.set (InstanceIdTraits::create (i, f, this));
        continue;
      }
    }

    if (!SequenceId_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "SequenceId",
        "");
    }
  }

  AbstractReport* AbstractReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractReport (*this, f, c);
  }

  AbstractReport& AbstractReport::
  operator= (const AbstractReport& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->MdibVersion_ = x.MdibVersion_;
      this->SequenceId_ = x.SequenceId_;
      this->InstanceId_ = x.InstanceId_;
    }

    return *this;
  }

  AbstractReport::
  ~AbstractReport ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractReport >
  _xsd_AbstractReport_type_factory_init (
    "AbstractReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractSet
  //

  AbstractSet::
  AbstractSet (const OperationHandleRefType& OperationHandleRef)
  : ::xml_schema::Type (),
    Extension_ (this),
    OperationHandleRef_ (OperationHandleRef, this)
  {
  }

  AbstractSet::
  AbstractSet (::std::unique_ptr< OperationHandleRefType > OperationHandleRef)
  : ::xml_schema::Type (),
    Extension_ (this),
    OperationHandleRef_ (std::move (OperationHandleRef), this)
  {
  }

  AbstractSet::
  AbstractSet (const AbstractSet& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    OperationHandleRef_ (x.OperationHandleRef_, f, this)
  {
  }

  AbstractSet::
  AbstractSet (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    OperationHandleRef_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AbstractSet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // OperationHandleRef
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OperationHandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< OperationHandleRefType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!OperationHandleRef_.present ())
          {
            ::std::unique_ptr< OperationHandleRefType > r (
              dynamic_cast< OperationHandleRefType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->OperationHandleRef_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!OperationHandleRef_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "OperationHandleRef",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  AbstractSet* AbstractSet::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractSet (*this, f, c);
  }

  AbstractSet& AbstractSet::
  operator= (const AbstractSet& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->OperationHandleRef_ = x.OperationHandleRef_;
    }

    return *this;
  }

  AbstractSet::
  ~AbstractSet ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractSet >
  _xsd_AbstractSet_type_factory_init (
    "AbstractSet",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractSetResponse
  //

  AbstractSetResponse::
  AbstractSetResponse (const InvocationInfoType& InvocationInfo,
                       const SequenceIdType& SequenceId)
  : ::xml_schema::Type (),
    Extension_ (this),
    InvocationInfo_ (InvocationInfo, this),
    MdibVersion_ (this),
    SequenceId_ (SequenceId, this),
    InstanceId_ (this)
  {
  }

  AbstractSetResponse::
  AbstractSetResponse (::std::unique_ptr< InvocationInfoType > InvocationInfo,
                       const SequenceIdType& SequenceId)
  : ::xml_schema::Type (),
    Extension_ (this),
    InvocationInfo_ (std::move (InvocationInfo), this),
    MdibVersion_ (this),
    SequenceId_ (SequenceId, this),
    InstanceId_ (this)
  {
  }

  AbstractSetResponse::
  AbstractSetResponse (const AbstractSetResponse& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    InvocationInfo_ (x.InvocationInfo_, f, this),
    MdibVersion_ (x.MdibVersion_, f, this),
    SequenceId_ (x.SequenceId_, f, this),
    InstanceId_ (x.InstanceId_, f, this)
  {
  }

  AbstractSetResponse::
  AbstractSetResponse (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    InvocationInfo_ (this),
    MdibVersion_ (this),
    SequenceId_ (this),
    InstanceId_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractSetResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // InvocationInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "InvocationInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< InvocationInfoType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!InvocationInfo_.present ())
          {
            ::std::unique_ptr< InvocationInfoType > r (
              dynamic_cast< InvocationInfoType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->InvocationInfo_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!InvocationInfo_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "InvocationInfo",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "MdibVersion" && n.namespace_ ().empty ())
      {
        this->MdibVersion_.set (MdibVersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "SequenceId" && n.namespace_ ().empty ())
      {
        this->SequenceId_.set (SequenceIdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "InstanceId" && n.namespace_ ().empty ())
      {
        this->InstanceId_.set (InstanceIdTraits::create (i, f, this));
        continue;
      }
    }

    if (!SequenceId_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "SequenceId",
        "");
    }
  }

  AbstractSetResponse* AbstractSetResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractSetResponse (*this, f, c);
  }

  AbstractSetResponse& AbstractSetResponse::
  operator= (const AbstractSetResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->InvocationInfo_ = x.InvocationInfo_;
      this->MdibVersion_ = x.MdibVersion_;
      this->SequenceId_ = x.SequenceId_;
      this->InstanceId_ = x.InstanceId_;
    }

    return *this;
  }

  AbstractSetResponse::
  ~AbstractSetResponse ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractSetResponse >
  _xsd_AbstractSetResponse_type_factory_init (
    "AbstractSetResponse",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractContextReport
  //

  AbstractContextReport::
  AbstractContextReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    ReportPart_ (this)
  {
  }

  AbstractContextReport::
  AbstractContextReport (const AbstractContextReport& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    ReportPart_ (x.ReportPart_, f, this)
  {
  }

  AbstractContextReport::
  AbstractContextReport (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    ReportPart_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractContextReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReportPart
      //
      if (n.name () == "ReportPart" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ReportPartType > r (
          ReportPartTraits::create (i, f, this));

        this->ReportPart_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AbstractContextReport* AbstractContextReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractContextReport (*this, f, c);
  }

  AbstractContextReport& AbstractContextReport::
  operator= (const AbstractContextReport& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->ReportPart_ = x.ReportPart_;
    }

    return *this;
  }

  AbstractContextReport::
  ~AbstractContextReport ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractContextReport >
  _xsd_AbstractContextReport_type_factory_init (
    "AbstractContextReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // VersionFrame
  //

  VersionFrame::
  VersionFrame ()
  : ::xml_schema::Type (),
    Start_ (this),
    End_ (this)
  {
  }

  VersionFrame::
  VersionFrame (const VersionFrame& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Start_ (x.Start_, f, this),
    End_ (x.End_, f, this)
  {
  }

  VersionFrame::
  VersionFrame (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Start_ (this),
    End_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void VersionFrame::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Start" && n.namespace_ ().empty ())
      {
        this->Start_.set (StartTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "End" && n.namespace_ ().empty ())
      {
        this->End_.set (EndTraits::create (i, f, this));
        continue;
      }
    }
  }

  VersionFrame* VersionFrame::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VersionFrame (*this, f, c);
  }

  VersionFrame& VersionFrame::
  operator= (const VersionFrame& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Start_ = x.Start_;
      this->End_ = x.End_;
    }

    return *this;
  }

  VersionFrame::
  ~VersionFrame ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, VersionFrame >
  _xsd_VersionFrame_type_factory_init (
    "VersionFrame",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // TimeFrame
  //

  TimeFrame::
  TimeFrame ()
  : ::xml_schema::Type (),
    Start_ (this),
    End_ (this)
  {
  }

  TimeFrame::
  TimeFrame (const TimeFrame& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Start_ (x.Start_, f, this),
    End_ (x.End_, f, this)
  {
  }

  TimeFrame::
  TimeFrame (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Start_ (this),
    End_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void TimeFrame::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Start" && n.namespace_ ().empty ())
      {
        this->Start_.set (StartTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "End" && n.namespace_ ().empty ())
      {
        this->End_.set (EndTraits::create (i, f, this));
        continue;
      }
    }
  }

  TimeFrame* TimeFrame::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimeFrame (*this, f, c);
  }

  TimeFrame& TimeFrame::
  operator= (const TimeFrame& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Start_ = x.Start_;
      this->End_ = x.End_;
    }

    return *this;
  }

  TimeFrame::
  ~TimeFrame ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, TimeFrame >
  _xsd_TimeFrame_type_factory_init (
    "TimeFrame",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractMetricReport
  //

  AbstractMetricReport::
  AbstractMetricReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    ReportPart_ (this)
  {
  }

  AbstractMetricReport::
  AbstractMetricReport (const AbstractMetricReport& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    ReportPart_ (x.ReportPart_, f, this)
  {
  }

  AbstractMetricReport::
  AbstractMetricReport (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    ReportPart_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractMetricReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReportPart
      //
      if (n.name () == "ReportPart" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ReportPartType > r (
          ReportPartTraits::create (i, f, this));

        this->ReportPart_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AbstractMetricReport* AbstractMetricReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractMetricReport (*this, f, c);
  }

  AbstractMetricReport& AbstractMetricReport::
  operator= (const AbstractMetricReport& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->ReportPart_ = x.ReportPart_;
    }

    return *this;
  }

  AbstractMetricReport::
  ~AbstractMetricReport ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractMetricReport >
  _xsd_AbstractMetricReport_type_factory_init (
    "AbstractMetricReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractComponentReport
  //

  AbstractComponentReport::
  AbstractComponentReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    ReportPart_ (this)
  {
  }

  AbstractComponentReport::
  AbstractComponentReport (const AbstractComponentReport& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    ReportPart_ (x.ReportPart_, f, this)
  {
  }

  AbstractComponentReport::
  AbstractComponentReport (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    ReportPart_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractComponentReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReportPart
      //
      if (n.name () == "ReportPart" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ReportPartType > r (
          ReportPartTraits::create (i, f, this));

        this->ReportPart_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AbstractComponentReport* AbstractComponentReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractComponentReport (*this, f, c);
  }

  AbstractComponentReport& AbstractComponentReport::
  operator= (const AbstractComponentReport& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->ReportPart_ = x.ReportPart_;
    }

    return *this;
  }

  AbstractComponentReport::
  ~AbstractComponentReport ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractComponentReport >
  _xsd_AbstractComponentReport_type_factory_init (
    "AbstractComponentReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractAlertReport
  //

  AbstractAlertReport::
  AbstractAlertReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    ReportPart_ (this)
  {
  }

  AbstractAlertReport::
  AbstractAlertReport (const AbstractAlertReport& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    ReportPart_ (x.ReportPart_, f, this)
  {
  }

  AbstractAlertReport::
  AbstractAlertReport (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    ReportPart_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractAlertReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReportPart
      //
      if (n.name () == "ReportPart" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ReportPartType > r (
          ReportPartTraits::create (i, f, this));

        this->ReportPart_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AbstractAlertReport* AbstractAlertReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractAlertReport (*this, f, c);
  }

  AbstractAlertReport& AbstractAlertReport::
  operator= (const AbstractAlertReport& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->ReportPart_ = x.ReportPart_;
    }

    return *this;
  }

  AbstractAlertReport::
  ~AbstractAlertReport ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractAlertReport >
  _xsd_AbstractAlertReport_type_factory_init (
    "AbstractAlertReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // AbstractOperationalStateReport
  //

  AbstractOperationalStateReport::
  AbstractOperationalStateReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    ReportPart_ (this)
  {
  }

  AbstractOperationalStateReport::
  AbstractOperationalStateReport (const AbstractOperationalStateReport& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    ReportPart_ (x.ReportPart_, f, this)
  {
  }

  AbstractOperationalStateReport::
  AbstractOperationalStateReport (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    ReportPart_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AbstractOperationalStateReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReportPart
      //
      if (n.name () == "ReportPart" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ReportPartType > r (
          ReportPartTraits::create (i, f, this));

        this->ReportPart_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AbstractOperationalStateReport* AbstractOperationalStateReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AbstractOperationalStateReport (*this, f, c);
  }

  AbstractOperationalStateReport& AbstractOperationalStateReport::
  operator= (const AbstractOperationalStateReport& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->ReportPart_ = x.ReportPart_;
    }

    return *this;
  }

  AbstractOperationalStateReport::
  ~AbstractOperationalStateReport ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AbstractOperationalStateReport >
  _xsd_AbstractOperationalStateReport_type_factory_init (
    "AbstractOperationalStateReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // DescriptionModificationType
  //

  DescriptionModificationType::
  DescriptionModificationType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_DescriptionModificationType_convert ();
  }

  DescriptionModificationType::
  DescriptionModificationType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_DescriptionModificationType_convert ();
  }

  DescriptionModificationType::
  DescriptionModificationType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_DescriptionModificationType_convert ();
  }

  DescriptionModificationType* DescriptionModificationType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DescriptionModificationType (*this, f, c);
  }

  DescriptionModificationType::Value DescriptionModificationType::
  _xsd_DescriptionModificationType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_DescriptionModificationType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_DescriptionModificationType_indexes_,
                      _xsd_DescriptionModificationType_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_DescriptionModificationType_indexes_ + 3 || _xsd_DescriptionModificationType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const DescriptionModificationType::
  _xsd_DescriptionModificationType_literals_[3] =
  {
    "Crt",
    "Upt",
    "Del"
  };

  const DescriptionModificationType::Value DescriptionModificationType::
  _xsd_DescriptionModificationType_indexes_[3] =
  {
    ::MDM::DescriptionModificationType::Crt,
    ::MDM::DescriptionModificationType::Del,
    ::MDM::DescriptionModificationType::Upt
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, DescriptionModificationType >
  _xsd_DescriptionModificationType_type_factory_init (
    "DescriptionModificationType",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // RetrievabilityMethod
  //

  RetrievabilityMethod::
  RetrievabilityMethod (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_RetrievabilityMethod_convert ();
  }

  RetrievabilityMethod::
  RetrievabilityMethod (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_RetrievabilityMethod_convert ();
  }

  RetrievabilityMethod::
  RetrievabilityMethod (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_RetrievabilityMethod_convert ();
  }

  RetrievabilityMethod* RetrievabilityMethod::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RetrievabilityMethod (*this, f, c);
  }

  RetrievabilityMethod::Value RetrievabilityMethod::
  _xsd_RetrievabilityMethod_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RetrievabilityMethod_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_RetrievabilityMethod_indexes_,
                      _xsd_RetrievabilityMethod_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_RetrievabilityMethod_indexes_ + 4 || _xsd_RetrievabilityMethod_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const RetrievabilityMethod::
  _xsd_RetrievabilityMethod_literals_[4] =
  {
    "Get",
    "Per",
    "Ep",
    "Strm"
  };

  const RetrievabilityMethod::Value RetrievabilityMethod::
  _xsd_RetrievabilityMethod_indexes_[4] =
  {
    ::MDM::RetrievabilityMethod::Ep,
    ::MDM::RetrievabilityMethod::Get,
    ::MDM::RetrievabilityMethod::Per,
    ::MDM::RetrievabilityMethod::Strm
  };

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RetrievabilityMethod >
  _xsd_RetrievabilityMethod_type_factory_init (
    "RetrievabilityMethod",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // RetrievabilityInfo
  //

  RetrievabilityInfo::
  RetrievabilityInfo (const MethodType& Method)
  : ::xml_schema::Type (),
    Extension_ (this),
    Method_ (Method, this),
    UpdatePeriod_ (this)
  {
  }

  RetrievabilityInfo::
  RetrievabilityInfo (const RetrievabilityInfo& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    Method_ (x.Method_, f, this),
    UpdatePeriod_ (x.UpdatePeriod_, f, this)
  {
  }

  RetrievabilityInfo::
  RetrievabilityInfo (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    Method_ (this),
    UpdatePeriod_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void RetrievabilityInfo::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Method" && n.namespace_ ().empty ())
      {
        this->Method_.set (MethodTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "UpdatePeriod" && n.namespace_ ().empty ())
      {
        this->UpdatePeriod_.set (UpdatePeriodTraits::create (i, f, this));
        continue;
      }
    }

    if (!Method_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Method",
        "");
    }
  }

  RetrievabilityInfo* RetrievabilityInfo::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RetrievabilityInfo (*this, f, c);
  }

  RetrievabilityInfo& RetrievabilityInfo::
  operator= (const RetrievabilityInfo& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->Method_ = x.Method_;
      this->UpdatePeriod_ = x.UpdatePeriod_;
    }

    return *this;
  }

  RetrievabilityInfo::
  ~RetrievabilityInfo ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RetrievabilityInfo >
  _xsd_RetrievabilityInfo_type_factory_init (
    "RetrievabilityInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");

  // GetMdib
  //

  GetMdib::
  GetMdib ()
  : ::MDM::AbstractGet ()
  {
  }

  GetMdib::
  GetMdib (const GetMdib& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c)
  {
  }

  GetMdib::
  GetMdib (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f, c)
  {
  }

  GetMdib* GetMdib::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetMdib (*this, f, c);
  }

  GetMdib::
  ~GetMdib ()
  {
  }

  // GetMdibResponse
  //

  GetMdibResponse::
  GetMdibResponse (const SequenceIdType& SequenceId,
                   const MdibType& Mdib)
  : ::MDM::AbstractGetResponse (SequenceId),
    Mdib_ (Mdib, this)
  {
  }

  GetMdibResponse::
  GetMdibResponse (const SequenceIdType& SequenceId,
                   ::std::unique_ptr< MdibType > Mdib)
  : ::MDM::AbstractGetResponse (SequenceId),
    Mdib_ (std::move (Mdib), this)
  {
  }

  GetMdibResponse::
  GetMdibResponse (const GetMdibResponse& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    Mdib_ (x.Mdib_, f, this)
  {
  }

  GetMdibResponse::
  GetMdibResponse (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    Mdib_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetMdibResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Mdib
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Mdib",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< MdibType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!Mdib_.present ())
          {
            ::std::unique_ptr< MdibType > r (
              dynamic_cast< MdibType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Mdib_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!Mdib_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Mdib",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  GetMdibResponse* GetMdibResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetMdibResponse (*this, f, c);
  }

  GetMdibResponse& GetMdibResponse::
  operator= (const GetMdibResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->Mdib_ = x.Mdib_;
    }

    return *this;
  }

  GetMdibResponse::
  ~GetMdibResponse ()
  {
  }

  // GetMdDescription
  //

  GetMdDescription::
  GetMdDescription ()
  : ::MDM::AbstractGet (),
    HandleRef_ (this)
  {
  }

  GetMdDescription::
  GetMdDescription (const GetMdDescription& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    HandleRef_ (x.HandleRef_, f, this)
  {
  }

  GetMdDescription::
  GetMdDescription (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    HandleRef_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GetMdDescription::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HandleRef
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< HandleRefType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< HandleRefType > r (
            dynamic_cast< HandleRefType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->HandleRef_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetMdDescription* GetMdDescription::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetMdDescription (*this, f, c);
  }

  GetMdDescription& GetMdDescription::
  operator= (const GetMdDescription& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->HandleRef_ = x.HandleRef_;
    }

    return *this;
  }

  GetMdDescription::
  ~GetMdDescription ()
  {
  }

  // GetMdDescriptionResponse
  //

  GetMdDescriptionResponse::
  GetMdDescriptionResponse (const SequenceIdType& SequenceId,
                            const MdDescriptionType& MdDescription)
  : ::MDM::AbstractGetResponse (SequenceId),
    MdDescription_ (MdDescription, this)
  {
  }

  GetMdDescriptionResponse::
  GetMdDescriptionResponse (const SequenceIdType& SequenceId,
                            ::std::unique_ptr< MdDescriptionType > MdDescription)
  : ::MDM::AbstractGetResponse (SequenceId),
    MdDescription_ (std::move (MdDescription), this)
  {
  }

  GetMdDescriptionResponse::
  GetMdDescriptionResponse (const GetMdDescriptionResponse& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    MdDescription_ (x.MdDescription_, f, this)
  {
  }

  GetMdDescriptionResponse::
  GetMdDescriptionResponse (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    MdDescription_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetMdDescriptionResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MdDescription
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MdDescription",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< MdDescriptionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MdDescription_.present ())
          {
            ::std::unique_ptr< MdDescriptionType > r (
              dynamic_cast< MdDescriptionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MdDescription_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!MdDescription_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MdDescription",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  GetMdDescriptionResponse* GetMdDescriptionResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetMdDescriptionResponse (*this, f, c);
  }

  GetMdDescriptionResponse& GetMdDescriptionResponse::
  operator= (const GetMdDescriptionResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->MdDescription_ = x.MdDescription_;
    }

    return *this;
  }

  GetMdDescriptionResponse::
  ~GetMdDescriptionResponse ()
  {
  }

  // GetMdState
  //

  GetMdState::
  GetMdState ()
  : ::MDM::AbstractGet (),
    HandleRef_ (this)
  {
  }

  GetMdState::
  GetMdState (const GetMdState& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    HandleRef_ (x.HandleRef_, f, this)
  {
  }

  GetMdState::
  GetMdState (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    HandleRef_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GetMdState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HandleRef
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< HandleRefType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< HandleRefType > r (
            dynamic_cast< HandleRefType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->HandleRef_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetMdState* GetMdState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetMdState (*this, f, c);
  }

  GetMdState& GetMdState::
  operator= (const GetMdState& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->HandleRef_ = x.HandleRef_;
    }

    return *this;
  }

  GetMdState::
  ~GetMdState ()
  {
  }

  // GetMdStateResponse
  //

  GetMdStateResponse::
  GetMdStateResponse (const SequenceIdType& SequenceId,
                      const MdStateType& MdState)
  : ::MDM::AbstractGetResponse (SequenceId),
    MdState_ (MdState, this)
  {
  }

  GetMdStateResponse::
  GetMdStateResponse (const SequenceIdType& SequenceId,
                      ::std::unique_ptr< MdStateType > MdState)
  : ::MDM::AbstractGetResponse (SequenceId),
    MdState_ (std::move (MdState), this)
  {
  }

  GetMdStateResponse::
  GetMdStateResponse (const GetMdStateResponse& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    MdState_ (x.MdState_, f, this)
  {
  }

  GetMdStateResponse::
  GetMdStateResponse (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    MdState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetMdStateResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MdState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MdState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< MdStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!MdState_.present ())
          {
            ::std::unique_ptr< MdStateType > r (
              dynamic_cast< MdStateType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MdState_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!MdState_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MdState",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  GetMdStateResponse* GetMdStateResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetMdStateResponse (*this, f, c);
  }

  GetMdStateResponse& GetMdStateResponse::
  operator= (const GetMdStateResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->MdState_ = x.MdState_;
    }

    return *this;
  }

  GetMdStateResponse::
  ~GetMdStateResponse ()
  {
  }

  // GetContextStates
  //

  GetContextStates::
  GetContextStates ()
  : ::MDM::AbstractGet (),
    HandleRef_ (this)
  {
  }

  GetContextStates::
  GetContextStates (const GetContextStates& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    HandleRef_ (x.HandleRef_, f, this)
  {
  }

  GetContextStates::
  GetContextStates (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    HandleRef_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GetContextStates::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HandleRef
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< HandleRefType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< HandleRefType > r (
            dynamic_cast< HandleRefType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->HandleRef_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetContextStates* GetContextStates::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetContextStates (*this, f, c);
  }

  GetContextStates& GetContextStates::
  operator= (const GetContextStates& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->HandleRef_ = x.HandleRef_;
    }

    return *this;
  }

  GetContextStates::
  ~GetContextStates ()
  {
  }

  // GetContextStatesResponse
  //

  GetContextStatesResponse::
  GetContextStatesResponse (const SequenceIdType& SequenceId)
  : ::MDM::AbstractGetResponse (SequenceId),
    ContextState_ (this)
  {
  }

  GetContextStatesResponse::
  GetContextStatesResponse (const GetContextStatesResponse& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    ContextState_ (x.ContextState_, f, this)
  {
  }

  GetContextStatesResponse::
  GetContextStatesResponse (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    ContextState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetContextStatesResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ContextState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ContextStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ContextStateType > r (
            dynamic_cast< ContextStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ContextState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetContextStatesResponse* GetContextStatesResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetContextStatesResponse (*this, f, c);
  }

  GetContextStatesResponse& GetContextStatesResponse::
  operator= (const GetContextStatesResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->ContextState_ = x.ContextState_;
    }

    return *this;
  }

  GetContextStatesResponse::
  ~GetContextStatesResponse ()
  {
  }

  // GetContextStatesByIdentification
  //

  GetContextStatesByIdentification::
  GetContextStatesByIdentification ()
  : ::MDM::AbstractGet (),
    Identification_ (this),
    ContextType_ (this)
  {
  }

  GetContextStatesByIdentification::
  GetContextStatesByIdentification (const GetContextStatesByIdentification& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    Identification_ (x.Identification_, f, this),
    ContextType_ (x.ContextType_, f, this)
  {
  }

  GetContextStatesByIdentification::
  GetContextStatesByIdentification (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    Identification_ (this),
    ContextType_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetContextStatesByIdentification::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Identification
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Identification",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< IdentificationType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< IdentificationType > r (
            dynamic_cast< IdentificationType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Identification_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ContextType" && n.namespace_ ().empty ())
      {
        this->ContextType_.set (ContextTypeTraits::create (i, f, this));
        continue;
      }
    }
  }

  GetContextStatesByIdentification* GetContextStatesByIdentification::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetContextStatesByIdentification (*this, f, c);
  }

  GetContextStatesByIdentification& GetContextStatesByIdentification::
  operator= (const GetContextStatesByIdentification& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->Identification_ = x.Identification_;
      this->ContextType_ = x.ContextType_;
    }

    return *this;
  }

  GetContextStatesByIdentification::
  ~GetContextStatesByIdentification ()
  {
  }

  // GetContextStatesByIdentificationResponse
  //

  GetContextStatesByIdentificationResponse::
  GetContextStatesByIdentificationResponse (const SequenceIdType& SequenceId)
  : ::MDM::AbstractGetResponse (SequenceId),
    ContextState_ (this)
  {
  }

  GetContextStatesByIdentificationResponse::
  GetContextStatesByIdentificationResponse (const GetContextStatesByIdentificationResponse& x,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    ContextState_ (x.ContextState_, f, this)
  {
  }

  GetContextStatesByIdentificationResponse::
  GetContextStatesByIdentificationResponse (const ::xercesc::DOMElement& e,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    ContextState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetContextStatesByIdentificationResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ContextState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ContextStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ContextStateType > r (
            dynamic_cast< ContextStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ContextState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetContextStatesByIdentificationResponse* GetContextStatesByIdentificationResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetContextStatesByIdentificationResponse (*this, f, c);
  }

  GetContextStatesByIdentificationResponse& GetContextStatesByIdentificationResponse::
  operator= (const GetContextStatesByIdentificationResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->ContextState_ = x.ContextState_;
    }

    return *this;
  }

  GetContextStatesByIdentificationResponse::
  ~GetContextStatesByIdentificationResponse ()
  {
  }

  // GetContextStatesByFilter
  //

  GetContextStatesByFilter::
  GetContextStatesByFilter ()
  : ::MDM::AbstractGet (),
    Filter_ (this),
    ContextType_ (this)
  {
  }

  GetContextStatesByFilter::
  GetContextStatesByFilter (const GetContextStatesByFilter& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    Filter_ (x.Filter_, f, this),
    ContextType_ (x.ContextType_, f, this)
  {
  }

  GetContextStatesByFilter::
  GetContextStatesByFilter (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    Filter_ (this),
    ContextType_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetContextStatesByFilter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Filter
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Filter",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< FilterType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< FilterType > r (
            dynamic_cast< FilterType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Filter_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ContextType" && n.namespace_ ().empty ())
      {
        this->ContextType_.set (ContextTypeTraits::create (i, f, this));
        continue;
      }
    }
  }

  GetContextStatesByFilter* GetContextStatesByFilter::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetContextStatesByFilter (*this, f, c);
  }

  GetContextStatesByFilter& GetContextStatesByFilter::
  operator= (const GetContextStatesByFilter& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->Filter_ = x.Filter_;
      this->ContextType_ = x.ContextType_;
    }

    return *this;
  }

  GetContextStatesByFilter::
  ~GetContextStatesByFilter ()
  {
  }

  // GetContextStatesByFilterResponse
  //

  GetContextStatesByFilterResponse::
  GetContextStatesByFilterResponse (const SequenceIdType& SequenceId)
  : ::MDM::AbstractGetResponse (SequenceId),
    ContextState_ (this)
  {
  }

  GetContextStatesByFilterResponse::
  GetContextStatesByFilterResponse (const GetContextStatesByFilterResponse& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    ContextState_ (x.ContextState_, f, this)
  {
  }

  GetContextStatesByFilterResponse::
  GetContextStatesByFilterResponse (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    ContextState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetContextStatesByFilterResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ContextState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ContextStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ContextStateType > r (
            dynamic_cast< ContextStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ContextState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetContextStatesByFilterResponse* GetContextStatesByFilterResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetContextStatesByFilterResponse (*this, f, c);
  }

  GetContextStatesByFilterResponse& GetContextStatesByFilterResponse::
  operator= (const GetContextStatesByFilterResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->ContextState_ = x.ContextState_;
    }

    return *this;
  }

  GetContextStatesByFilterResponse::
  ~GetContextStatesByFilterResponse ()
  {
  }

  // SetContextState
  //

  SetContextState::
  SetContextState (const OperationHandleRefType& OperationHandleRef)
  : ::MDM::AbstractSet (OperationHandleRef),
    ProposedContextState_ (this)
  {
  }

  SetContextState::
  SetContextState (::std::unique_ptr< OperationHandleRefType > OperationHandleRef)
  : ::MDM::AbstractSet (std::move (OperationHandleRef)),
    ProposedContextState_ (this)
  {
  }

  SetContextState::
  SetContextState (const SetContextState& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::MDM::AbstractSet (x, f, c),
    ProposedContextState_ (x.ProposedContextState_, f, this)
  {
  }

  SetContextState::
  SetContextState (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::MDM::AbstractSet (e, f | ::xml_schema::Flags::base, c),
    ProposedContextState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SetContextState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractSet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ProposedContextState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ProposedContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ProposedContextStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ProposedContextStateType > r (
            dynamic_cast< ProposedContextStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ProposedContextState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SetContextState* SetContextState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetContextState (*this, f, c);
  }

  SetContextState& SetContextState::
  operator= (const SetContextState& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractSet& > (*this) = x;
      this->ProposedContextState_ = x.ProposedContextState_;
    }

    return *this;
  }

  SetContextState::
  ~SetContextState ()
  {
  }

  // SetContextStateResponse
  //

  SetContextStateResponse::
  SetContextStateResponse (const InvocationInfoType& InvocationInfo,
                           const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (InvocationInfo,
                                SequenceId)
  {
  }

  SetContextStateResponse::
  SetContextStateResponse (::std::unique_ptr< InvocationInfoType > InvocationInfo,
                           const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (std::move (InvocationInfo),
                                SequenceId)
  {
  }

  SetContextStateResponse::
  SetContextStateResponse (const SetContextStateResponse& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (x, f, c)
  {
  }

  SetContextStateResponse::
  SetContextStateResponse (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (e, f, c)
  {
  }

  SetContextStateResponse* SetContextStateResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetContextStateResponse (*this, f, c);
  }

  SetContextStateResponse::
  ~SetContextStateResponse ()
  {
  }

  // ReportPart
  //

  ReportPart::
  ReportPart ()
  : ::MDM::AbstractReportPart (),
    ContextState_ (this)
  {
  }

  ReportPart::
  ReportPart (const ReportPart& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (x, f, c),
    ContextState_ (x.ContextState_, f, this)
  {
  }

  ReportPart::
  ReportPart (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (e, f | ::xml_schema::Flags::base, c),
    ContextState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ReportPart::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReportPart::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ContextState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ContextStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ContextStateType > r (
            dynamic_cast< ContextStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ContextState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ReportPart* ReportPart::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReportPart (*this, f, c);
  }

  ReportPart& ReportPart::
  operator= (const ReportPart& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReportPart& > (*this) = x;
      this->ContextState_ = x.ContextState_;
    }

    return *this;
  }

  ReportPart::
  ~ReportPart ()
  {
  }

  // PeriodicContextReport
  //

  PeriodicContextReport::
  PeriodicContextReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractContextReport (SequenceId)
  {
  }

  PeriodicContextReport::
  PeriodicContextReport (const PeriodicContextReport& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractContextReport (x, f, c)
  {
  }

  PeriodicContextReport::
  PeriodicContextReport (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractContextReport (e, f, c)
  {
  }

  PeriodicContextReport* PeriodicContextReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PeriodicContextReport (*this, f, c);
  }

  PeriodicContextReport::
  ~PeriodicContextReport ()
  {
  }

  // EpisodicContextReport
  //

  EpisodicContextReport::
  EpisodicContextReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractContextReport (SequenceId)
  {
  }

  EpisodicContextReport::
  EpisodicContextReport (const EpisodicContextReport& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractContextReport (x, f, c)
  {
  }

  EpisodicContextReport::
  EpisodicContextReport (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractContextReport (e, f, c)
  {
  }

  EpisodicContextReport* EpisodicContextReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EpisodicContextReport (*this, f, c);
  }

  EpisodicContextReport::
  ~EpisodicContextReport ()
  {
  }

  // GetLocalizedText
  //

  GetLocalizedText::
  GetLocalizedText ()
  : ::MDM::AbstractGet (),
    Ref_ (this),
    Version_ (this),
    Lang_ (this),
    TextWidth_ (this),
    NumberOfLines_ (this)
  {
  }

  GetLocalizedText::
  GetLocalizedText (const GetLocalizedText& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    Ref_ (x.Ref_, f, this),
    Version_ (x.Version_, f, this),
    Lang_ (x.Lang_, f, this),
    TextWidth_ (x.TextWidth_, f, this),
    NumberOfLines_ (x.NumberOfLines_, f, this)
  {
  }

  GetLocalizedText::
  GetLocalizedText (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    Ref_ (this),
    Version_ (this),
    Lang_ (this),
    TextWidth_ (this),
    NumberOfLines_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GetLocalizedText::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Ref
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Ref",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< RefType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< RefType > r (
            dynamic_cast< RefType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Ref_.push_back (::std::move (r));
          continue;
        }
      }

      // Version
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Version",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< VersionType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Version_)
          {
            ::std::unique_ptr< VersionType > r (
              dynamic_cast< VersionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Version_.set (::std::move (r));
            continue;
          }
        }
      }

      // Lang
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Lang",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< LangType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< LangType > r (
            dynamic_cast< LangType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Lang_.push_back (::std::move (r));
          continue;
        }
      }

      // TextWidth
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TextWidth",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< TextWidthType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< TextWidthType > r (
            dynamic_cast< TextWidthType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TextWidth_.push_back (::std::move (r));
          continue;
        }
      }

      // NumberOfLines
      //
      if (n.name () == "NumberOfLines" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        this->NumberOfLines_.push_back (NumberOfLinesTraits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  GetLocalizedText* GetLocalizedText::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetLocalizedText (*this, f, c);
  }

  GetLocalizedText& GetLocalizedText::
  operator= (const GetLocalizedText& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->Ref_ = x.Ref_;
      this->Version_ = x.Version_;
      this->Lang_ = x.Lang_;
      this->TextWidth_ = x.TextWidth_;
      this->NumberOfLines_ = x.NumberOfLines_;
    }

    return *this;
  }

  GetLocalizedText::
  ~GetLocalizedText ()
  {
  }

  // GetLocalizedTextResponse
  //

  GetLocalizedTextResponse::
  GetLocalizedTextResponse (const SequenceIdType& SequenceId)
  : ::MDM::AbstractGetResponse (SequenceId),
    Text_ (this)
  {
  }

  GetLocalizedTextResponse::
  GetLocalizedTextResponse (const GetLocalizedTextResponse& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    Text_ (x.Text_, f, this)
  {
  }

  GetLocalizedTextResponse::
  GetLocalizedTextResponse (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    Text_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetLocalizedTextResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Text
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Text",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< TextType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< TextType > r (
            dynamic_cast< TextType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Text_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetLocalizedTextResponse* GetLocalizedTextResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetLocalizedTextResponse (*this, f, c);
  }

  GetLocalizedTextResponse& GetLocalizedTextResponse::
  operator= (const GetLocalizedTextResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->Text_ = x.Text_;
    }

    return *this;
  }

  GetLocalizedTextResponse::
  ~GetLocalizedTextResponse ()
  {
  }

  // GetSupportedLanguages
  //

  GetSupportedLanguages::
  GetSupportedLanguages ()
  : ::MDM::AbstractGet ()
  {
  }

  GetSupportedLanguages::
  GetSupportedLanguages (const GetSupportedLanguages& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c)
  {
  }

  GetSupportedLanguages::
  GetSupportedLanguages (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f, c)
  {
  }

  GetSupportedLanguages* GetSupportedLanguages::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetSupportedLanguages (*this, f, c);
  }

  GetSupportedLanguages::
  ~GetSupportedLanguages ()
  {
  }

  // GetSupportedLanguagesResponse
  //

  GetSupportedLanguagesResponse::
  GetSupportedLanguagesResponse (const SequenceIdType& SequenceId)
  : ::MDM::AbstractGetResponse (SequenceId),
    Lang_ (this)
  {
  }

  GetSupportedLanguagesResponse::
  GetSupportedLanguagesResponse (const GetSupportedLanguagesResponse& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    Lang_ (x.Lang_, f, this)
  {
  }

  GetSupportedLanguagesResponse::
  GetSupportedLanguagesResponse (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    Lang_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetSupportedLanguagesResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Lang
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Lang",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< LangType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< LangType > r (
            dynamic_cast< LangType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Lang_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetSupportedLanguagesResponse* GetSupportedLanguagesResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetSupportedLanguagesResponse (*this, f, c);
  }

  GetSupportedLanguagesResponse& GetSupportedLanguagesResponse::
  operator= (const GetSupportedLanguagesResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->Lang_ = x.Lang_;
    }

    return *this;
  }

  GetSupportedLanguagesResponse::
  ~GetSupportedLanguagesResponse ()
  {
  }

  // GetDescriptorsFromArchive
  //

  GetDescriptorsFromArchive::
  GetDescriptorsFromArchive ()
  : ::MDM::AbstractGet (),
    DescriptorRevisions_ (this),
    TimeFrame_ (this),
    Handle_ (this)
  {
  }

  GetDescriptorsFromArchive::
  GetDescriptorsFromArchive (const GetDescriptorsFromArchive& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    DescriptorRevisions_ (x.DescriptorRevisions_, f, this),
    TimeFrame_ (x.TimeFrame_, f, this),
    Handle_ (x.Handle_, f, this)
  {
  }

  GetDescriptorsFromArchive::
  GetDescriptorsFromArchive (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    DescriptorRevisions_ (this),
    TimeFrame_ (this),
    Handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GetDescriptorsFromArchive::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DescriptorRevisions
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "DescriptorRevisions",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< DescriptorRevisionsType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->DescriptorRevisions_)
          {
            ::std::unique_ptr< DescriptorRevisionsType > r (
              dynamic_cast< DescriptorRevisionsType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DescriptorRevisions_.set (::std::move (r));
            continue;
          }
        }
      }

      // TimeFrame
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TimeFrame",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< TimeFrameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->TimeFrame_)
          {
            ::std::unique_ptr< TimeFrameType > r (
              dynamic_cast< TimeFrameType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->TimeFrame_.set (::std::move (r));
            continue;
          }
        }
      }

      // Handle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Handle",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< HandleType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< HandleType > r (
            dynamic_cast< HandleType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Handle_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetDescriptorsFromArchive* GetDescriptorsFromArchive::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetDescriptorsFromArchive (*this, f, c);
  }

  GetDescriptorsFromArchive& GetDescriptorsFromArchive::
  operator= (const GetDescriptorsFromArchive& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->DescriptorRevisions_ = x.DescriptorRevisions_;
      this->TimeFrame_ = x.TimeFrame_;
      this->Handle_ = x.Handle_;
    }

    return *this;
  }

  GetDescriptorsFromArchive::
  ~GetDescriptorsFromArchive ()
  {
  }

  // GetDescriptorsFromArchiveResponse
  //

  GetDescriptorsFromArchiveResponse::
  GetDescriptorsFromArchiveResponse (const SequenceIdType& SequenceId)
  : ::MDM::AbstractGetResponse (SequenceId),
    Descriptor_ (this)
  {
  }

  GetDescriptorsFromArchiveResponse::
  GetDescriptorsFromArchiveResponse (const GetDescriptorsFromArchiveResponse& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    Descriptor_ (x.Descriptor_, f, this)
  {
  }

  GetDescriptorsFromArchiveResponse::
  GetDescriptorsFromArchiveResponse (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    Descriptor_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetDescriptorsFromArchiveResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Descriptor
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Descriptor",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< DescriptorType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< DescriptorType > r (
            dynamic_cast< DescriptorType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Descriptor_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetDescriptorsFromArchiveResponse* GetDescriptorsFromArchiveResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetDescriptorsFromArchiveResponse (*this, f, c);
  }

  GetDescriptorsFromArchiveResponse& GetDescriptorsFromArchiveResponse::
  operator= (const GetDescriptorsFromArchiveResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->Descriptor_ = x.Descriptor_;
    }

    return *this;
  }

  GetDescriptorsFromArchiveResponse::
  ~GetDescriptorsFromArchiveResponse ()
  {
  }

  // GetStatesFromArchive
  //

  GetStatesFromArchive::
  GetStatesFromArchive ()
  : ::MDM::AbstractGet (),
    StateRevisions_ (this),
    TimeFrame_ (this),
    Handle_ (this)
  {
  }

  GetStatesFromArchive::
  GetStatesFromArchive (const GetStatesFromArchive& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    StateRevisions_ (x.StateRevisions_, f, this),
    TimeFrame_ (x.TimeFrame_, f, this),
    Handle_ (x.Handle_, f, this)
  {
  }

  GetStatesFromArchive::
  GetStatesFromArchive (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    StateRevisions_ (this),
    TimeFrame_ (this),
    Handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GetStatesFromArchive::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // StateRevisions
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "StateRevisions",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< StateRevisionsType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->StateRevisions_)
          {
            ::std::unique_ptr< StateRevisionsType > r (
              dynamic_cast< StateRevisionsType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->StateRevisions_.set (::std::move (r));
            continue;
          }
        }
      }

      // TimeFrame
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "TimeFrame",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< TimeFrameType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->TimeFrame_)
          {
            ::std::unique_ptr< TimeFrameType > r (
              dynamic_cast< TimeFrameType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->TimeFrame_.set (::std::move (r));
            continue;
          }
        }
      }

      // Handle
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Handle",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< HandleType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< HandleType > r (
            dynamic_cast< HandleType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Handle_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetStatesFromArchive* GetStatesFromArchive::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetStatesFromArchive (*this, f, c);
  }

  GetStatesFromArchive& GetStatesFromArchive::
  operator= (const GetStatesFromArchive& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->StateRevisions_ = x.StateRevisions_;
      this->TimeFrame_ = x.TimeFrame_;
      this->Handle_ = x.Handle_;
    }

    return *this;
  }

  GetStatesFromArchive::
  ~GetStatesFromArchive ()
  {
  }

  // GetStatesFromArchiveResponse
  //

  GetStatesFromArchiveResponse::
  GetStatesFromArchiveResponse (const SequenceIdType& SequenceId)
  : ::MDM::AbstractGetResponse (SequenceId),
    State_ (this)
  {
  }

  GetStatesFromArchiveResponse::
  GetStatesFromArchiveResponse (const GetStatesFromArchiveResponse& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    State_ (x.State_, f, this)
  {
  }

  GetStatesFromArchiveResponse::
  GetStatesFromArchiveResponse (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    State_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetStatesFromArchiveResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // State
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "State",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< StateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< StateType > r (
            dynamic_cast< StateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->State_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetStatesFromArchiveResponse* GetStatesFromArchiveResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetStatesFromArchiveResponse (*this, f, c);
  }

  GetStatesFromArchiveResponse& GetStatesFromArchiveResponse::
  operator= (const GetStatesFromArchiveResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->State_ = x.State_;
    }

    return *this;
  }

  GetStatesFromArchiveResponse::
  ~GetStatesFromArchiveResponse ()
  {
  }

  // SetValue
  //

  SetValue::
  SetValue (const OperationHandleRefType& OperationHandleRef,
            const RequestedNumericValueType& RequestedNumericValue)
  : ::MDM::AbstractSet (OperationHandleRef),
    RequestedNumericValue_ (RequestedNumericValue, this)
  {
  }

  SetValue::
  SetValue (::std::unique_ptr< OperationHandleRefType > OperationHandleRef,
            const RequestedNumericValueType& RequestedNumericValue)
  : ::MDM::AbstractSet (std::move (OperationHandleRef)),
    RequestedNumericValue_ (RequestedNumericValue, this)
  {
  }

  SetValue::
  SetValue (const SetValue& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::MDM::AbstractSet (x, f, c),
    RequestedNumericValue_ (x.RequestedNumericValue_, f, this)
  {
  }

  SetValue::
  SetValue (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::MDM::AbstractSet (e, f | ::xml_schema::Flags::base, c),
    RequestedNumericValue_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SetValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractSet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // RequestedNumericValue
      //
      if (n.name () == "RequestedNumericValue" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        if (!RequestedNumericValue_.present ())
        {
          this->RequestedNumericValue_.set (RequestedNumericValueTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!RequestedNumericValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "RequestedNumericValue",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  SetValue* SetValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetValue (*this, f, c);
  }

  SetValue& SetValue::
  operator= (const SetValue& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractSet& > (*this) = x;
      this->RequestedNumericValue_ = x.RequestedNumericValue_;
    }

    return *this;
  }

  SetValue::
  ~SetValue ()
  {
  }

  // SetValueResponse
  //

  SetValueResponse::
  SetValueResponse (const InvocationInfoType& InvocationInfo,
                    const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (InvocationInfo,
                                SequenceId)
  {
  }

  SetValueResponse::
  SetValueResponse (::std::unique_ptr< InvocationInfoType > InvocationInfo,
                    const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (std::move (InvocationInfo),
                                SequenceId)
  {
  }

  SetValueResponse::
  SetValueResponse (const SetValueResponse& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (x, f, c)
  {
  }

  SetValueResponse::
  SetValueResponse (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (e, f, c)
  {
  }

  SetValueResponse* SetValueResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetValueResponse (*this, f, c);
  }

  SetValueResponse::
  ~SetValueResponse ()
  {
  }

  // SetString
  //

  SetString::
  SetString (const OperationHandleRefType& OperationHandleRef,
             const RequestedStringValueType& RequestedStringValue)
  : ::MDM::AbstractSet (OperationHandleRef),
    RequestedStringValue_ (RequestedStringValue, this)
  {
  }

  SetString::
  SetString (::std::unique_ptr< OperationHandleRefType > OperationHandleRef,
             ::std::unique_ptr< RequestedStringValueType > RequestedStringValue)
  : ::MDM::AbstractSet (std::move (OperationHandleRef)),
    RequestedStringValue_ (std::move (RequestedStringValue), this)
  {
  }

  SetString::
  SetString (const SetString& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::MDM::AbstractSet (x, f, c),
    RequestedStringValue_ (x.RequestedStringValue_, f, this)
  {
  }

  SetString::
  SetString (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::MDM::AbstractSet (e, f | ::xml_schema::Flags::base, c),
    RequestedStringValue_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SetString::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractSet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // RequestedStringValue
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "RequestedStringValue",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< RequestedStringValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!RequestedStringValue_.present ())
          {
            ::std::unique_ptr< RequestedStringValueType > r (
              dynamic_cast< RequestedStringValueType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->RequestedStringValue_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!RequestedStringValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "RequestedStringValue",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  SetString* SetString::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetString (*this, f, c);
  }

  SetString& SetString::
  operator= (const SetString& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractSet& > (*this) = x;
      this->RequestedStringValue_ = x.RequestedStringValue_;
    }

    return *this;
  }

  SetString::
  ~SetString ()
  {
  }

  // SetStringResponse
  //

  SetStringResponse::
  SetStringResponse (const InvocationInfoType& InvocationInfo,
                     const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (InvocationInfo,
                                SequenceId)
  {
  }

  SetStringResponse::
  SetStringResponse (::std::unique_ptr< InvocationInfoType > InvocationInfo,
                     const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (std::move (InvocationInfo),
                                SequenceId)
  {
  }

  SetStringResponse::
  SetStringResponse (const SetStringResponse& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (x, f, c)
  {
  }

  SetStringResponse::
  SetStringResponse (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (e, f, c)
  {
  }

  SetStringResponse* SetStringResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetStringResponse (*this, f, c);
  }

  SetStringResponse::
  ~SetStringResponse ()
  {
  }

  // Activate
  //

  Activate::
  Activate (const OperationHandleRefType& OperationHandleRef)
  : ::MDM::AbstractSet (OperationHandleRef),
    Argument_ (this)
  {
  }

  Activate::
  Activate (::std::unique_ptr< OperationHandleRefType > OperationHandleRef)
  : ::MDM::AbstractSet (std::move (OperationHandleRef)),
    Argument_ (this)
  {
  }

  Activate::
  Activate (const Activate& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::MDM::AbstractSet (x, f, c),
    Argument_ (x.Argument_, f, this)
  {
  }

  Activate::
  Activate (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::MDM::AbstractSet (e, f | ::xml_schema::Flags::base, c),
    Argument_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Activate::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractSet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Argument
      //
      if (n.name () == "Argument" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ArgumentType > r (
          ArgumentTraits::create (i, f, this));

        this->Argument_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Activate* Activate::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Activate (*this, f, c);
  }

  Activate& Activate::
  operator= (const Activate& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractSet& > (*this) = x;
      this->Argument_ = x.Argument_;
    }

    return *this;
  }

  Activate::
  ~Activate ()
  {
  }

  // ActivateResponse
  //

  ActivateResponse::
  ActivateResponse (const InvocationInfoType& InvocationInfo,
                    const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (InvocationInfo,
                                SequenceId)
  {
  }

  ActivateResponse::
  ActivateResponse (::std::unique_ptr< InvocationInfoType > InvocationInfo,
                    const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (std::move (InvocationInfo),
                                SequenceId)
  {
  }

  ActivateResponse::
  ActivateResponse (const ActivateResponse& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (x, f, c)
  {
  }

  ActivateResponse::
  ActivateResponse (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (e, f, c)
  {
  }

  ActivateResponse* ActivateResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ActivateResponse (*this, f, c);
  }

  ActivateResponse::
  ~ActivateResponse ()
  {
  }

  // SetAlertState
  //

  SetAlertState::
  SetAlertState (const OperationHandleRefType& OperationHandleRef,
                 const ProposedAlertStateType& ProposedAlertState)
  : ::MDM::AbstractSet (OperationHandleRef),
    ProposedAlertState_ (ProposedAlertState, this)
  {
  }

  SetAlertState::
  SetAlertState (const OperationHandleRefType& OperationHandleRef,
                 ::std::unique_ptr< ProposedAlertStateType > ProposedAlertState)
  : ::MDM::AbstractSet (OperationHandleRef),
    ProposedAlertState_ (std::move (ProposedAlertState), this)
  {
  }

  SetAlertState::
  SetAlertState (::std::unique_ptr< OperationHandleRefType > OperationHandleRef,
                 ::std::unique_ptr< ProposedAlertStateType > ProposedAlertState)
  : ::MDM::AbstractSet (std::move (OperationHandleRef)),
    ProposedAlertState_ (std::move (ProposedAlertState), this)
  {
  }

  SetAlertState::
  SetAlertState (const SetAlertState& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::MDM::AbstractSet (x, f, c),
    ProposedAlertState_ (x.ProposedAlertState_, f, this)
  {
  }

  SetAlertState::
  SetAlertState (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::MDM::AbstractSet (e, f | ::xml_schema::Flags::base, c),
    ProposedAlertState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SetAlertState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractSet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ProposedAlertState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ProposedAlertState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ProposedAlertStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ProposedAlertState_.present ())
          {
            ::std::unique_ptr< ProposedAlertStateType > r (
              dynamic_cast< ProposedAlertStateType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ProposedAlertState_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ProposedAlertState_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ProposedAlertState",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  SetAlertState* SetAlertState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetAlertState (*this, f, c);
  }

  SetAlertState& SetAlertState::
  operator= (const SetAlertState& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractSet& > (*this) = x;
      this->ProposedAlertState_ = x.ProposedAlertState_;
    }

    return *this;
  }

  SetAlertState::
  ~SetAlertState ()
  {
  }

  // SetAlertStateResponse
  //

  SetAlertStateResponse::
  SetAlertStateResponse (const InvocationInfoType& InvocationInfo,
                         const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (InvocationInfo,
                                SequenceId)
  {
  }

  SetAlertStateResponse::
  SetAlertStateResponse (::std::unique_ptr< InvocationInfoType > InvocationInfo,
                         const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (std::move (InvocationInfo),
                                SequenceId)
  {
  }

  SetAlertStateResponse::
  SetAlertStateResponse (const SetAlertStateResponse& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (x, f, c)
  {
  }

  SetAlertStateResponse::
  SetAlertStateResponse (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (e, f, c)
  {
  }

  SetAlertStateResponse* SetAlertStateResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetAlertStateResponse (*this, f, c);
  }

  SetAlertStateResponse::
  ~SetAlertStateResponse ()
  {
  }

  // SetComponentState
  //

  SetComponentState::
  SetComponentState (const OperationHandleRefType& OperationHandleRef)
  : ::MDM::AbstractSet (OperationHandleRef),
    ProposedComponentState_ (this)
  {
  }

  SetComponentState::
  SetComponentState (::std::unique_ptr< OperationHandleRefType > OperationHandleRef)
  : ::MDM::AbstractSet (std::move (OperationHandleRef)),
    ProposedComponentState_ (this)
  {
  }

  SetComponentState::
  SetComponentState (const SetComponentState& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::MDM::AbstractSet (x, f, c),
    ProposedComponentState_ (x.ProposedComponentState_, f, this)
  {
  }

  SetComponentState::
  SetComponentState (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::MDM::AbstractSet (e, f | ::xml_schema::Flags::base, c),
    ProposedComponentState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SetComponentState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractSet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ProposedComponentState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ProposedComponentState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ProposedComponentStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ProposedComponentStateType > r (
            dynamic_cast< ProposedComponentStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ProposedComponentState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SetComponentState* SetComponentState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetComponentState (*this, f, c);
  }

  SetComponentState& SetComponentState::
  operator= (const SetComponentState& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractSet& > (*this) = x;
      this->ProposedComponentState_ = x.ProposedComponentState_;
    }

    return *this;
  }

  SetComponentState::
  ~SetComponentState ()
  {
  }

  // SetComponentStateResponse
  //

  SetComponentStateResponse::
  SetComponentStateResponse (const InvocationInfoType& InvocationInfo,
                             const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (InvocationInfo,
                                SequenceId)
  {
  }

  SetComponentStateResponse::
  SetComponentStateResponse (::std::unique_ptr< InvocationInfoType > InvocationInfo,
                             const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (std::move (InvocationInfo),
                                SequenceId)
  {
  }

  SetComponentStateResponse::
  SetComponentStateResponse (const SetComponentStateResponse& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (x, f, c)
  {
  }

  SetComponentStateResponse::
  SetComponentStateResponse (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (e, f, c)
  {
  }

  SetComponentStateResponse* SetComponentStateResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetComponentStateResponse (*this, f, c);
  }

  SetComponentStateResponse::
  ~SetComponentStateResponse ()
  {
  }

  // SetMetricState
  //

  SetMetricState::
  SetMetricState (const OperationHandleRefType& OperationHandleRef)
  : ::MDM::AbstractSet (OperationHandleRef),
    ProposedMetricState_ (this)
  {
  }

  SetMetricState::
  SetMetricState (::std::unique_ptr< OperationHandleRefType > OperationHandleRef)
  : ::MDM::AbstractSet (std::move (OperationHandleRef)),
    ProposedMetricState_ (this)
  {
  }

  SetMetricState::
  SetMetricState (const SetMetricState& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::MDM::AbstractSet (x, f, c),
    ProposedMetricState_ (x.ProposedMetricState_, f, this)
  {
  }

  SetMetricState::
  SetMetricState (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::MDM::AbstractSet (e, f | ::xml_schema::Flags::base, c),
    ProposedMetricState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SetMetricState::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractSet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ProposedMetricState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ProposedMetricState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ProposedMetricStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ProposedMetricStateType > r (
            dynamic_cast< ProposedMetricStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ProposedMetricState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SetMetricState* SetMetricState::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetMetricState (*this, f, c);
  }

  SetMetricState& SetMetricState::
  operator= (const SetMetricState& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractSet& > (*this) = x;
      this->ProposedMetricState_ = x.ProposedMetricState_;
    }

    return *this;
  }

  SetMetricState::
  ~SetMetricState ()
  {
  }

  // SetMetricStateResponse
  //

  SetMetricStateResponse::
  SetMetricStateResponse (const InvocationInfoType& InvocationInfo,
                          const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (InvocationInfo,
                                SequenceId)
  {
  }

  SetMetricStateResponse::
  SetMetricStateResponse (::std::unique_ptr< InvocationInfoType > InvocationInfo,
                          const SequenceIdType& SequenceId)
  : ::MDM::AbstractSetResponse (std::move (InvocationInfo),
                                SequenceId)
  {
  }

  SetMetricStateResponse::
  SetMetricStateResponse (const SetMetricStateResponse& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (x, f, c)
  {
  }

  SetMetricStateResponse::
  SetMetricStateResponse (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::MDM::AbstractSetResponse (e, f, c)
  {
  }

  SetMetricStateResponse* SetMetricStateResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SetMetricStateResponse (*this, f, c);
  }

  SetMetricStateResponse::
  ~SetMetricStateResponse ()
  {
  }

  // OperationInvokedReport
  //

  OperationInvokedReport::
  OperationInvokedReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    ReportPart_ (this)
  {
  }

  OperationInvokedReport::
  OperationInvokedReport (const OperationInvokedReport& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    ReportPart_ (x.ReportPart_, f, this)
  {
  }

  OperationInvokedReport::
  OperationInvokedReport (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    ReportPart_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void OperationInvokedReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReportPart
      //
      if (n.name () == "ReportPart" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ReportPartType > r (
          ReportPartTraits::create (i, f, this));

        this->ReportPart_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  OperationInvokedReport* OperationInvokedReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OperationInvokedReport (*this, f, c);
  }

  OperationInvokedReport& OperationInvokedReport::
  operator= (const OperationInvokedReport& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->ReportPart_ = x.ReportPart_;
    }

    return *this;
  }

  OperationInvokedReport::
  ~OperationInvokedReport ()
  {
  }

  // GetContainmentTree
  //

  GetContainmentTree::
  GetContainmentTree ()
  : ::MDM::AbstractGet (),
    HandleRef_ (this)
  {
  }

  GetContainmentTree::
  GetContainmentTree (const GetContainmentTree& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    HandleRef_ (x.HandleRef_, f, this)
  {
  }

  GetContainmentTree::
  GetContainmentTree (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    HandleRef_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GetContainmentTree::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HandleRef
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< HandleRefType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< HandleRefType > r (
            dynamic_cast< HandleRefType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->HandleRef_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetContainmentTree* GetContainmentTree::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetContainmentTree (*this, f, c);
  }

  GetContainmentTree& GetContainmentTree::
  operator= (const GetContainmentTree& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->HandleRef_ = x.HandleRef_;
    }

    return *this;
  }

  GetContainmentTree::
  ~GetContainmentTree ()
  {
  }

  // GetContainmentTreeResponse
  //

  GetContainmentTreeResponse::
  GetContainmentTreeResponse (const SequenceIdType& SequenceId,
                              const ContainmentTreeType& ContainmentTree)
  : ::MDM::AbstractGetResponse (SequenceId),
    ContainmentTree_ (ContainmentTree, this)
  {
  }

  GetContainmentTreeResponse::
  GetContainmentTreeResponse (const SequenceIdType& SequenceId,
                              ::std::unique_ptr< ContainmentTreeType > ContainmentTree)
  : ::MDM::AbstractGetResponse (SequenceId),
    ContainmentTree_ (std::move (ContainmentTree), this)
  {
  }

  GetContainmentTreeResponse::
  GetContainmentTreeResponse (const GetContainmentTreeResponse& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    ContainmentTree_ (x.ContainmentTree_, f, this)
  {
  }

  GetContainmentTreeResponse::
  GetContainmentTreeResponse (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    ContainmentTree_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetContainmentTreeResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ContainmentTree
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ContainmentTree",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ContainmentTreeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ContainmentTree_.present ())
          {
            ::std::unique_ptr< ContainmentTreeType > r (
              dynamic_cast< ContainmentTreeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ContainmentTree_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ContainmentTree_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ContainmentTree",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  GetContainmentTreeResponse* GetContainmentTreeResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetContainmentTreeResponse (*this, f, c);
  }

  GetContainmentTreeResponse& GetContainmentTreeResponse::
  operator= (const GetContainmentTreeResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->ContainmentTree_ = x.ContainmentTree_;
    }

    return *this;
  }

  GetContainmentTreeResponse::
  ~GetContainmentTreeResponse ()
  {
  }

  // GetDescriptor
  //

  GetDescriptor::
  GetDescriptor ()
  : ::MDM::AbstractGet (),
    HandleRef_ (this)
  {
  }

  GetDescriptor::
  GetDescriptor (const GetDescriptor& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::MDM::AbstractGet (x, f, c),
    HandleRef_ (x.HandleRef_, f, this)
  {
  }

  GetDescriptor::
  GetDescriptor (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::MDM::AbstractGet (e, f | ::xml_schema::Flags::base, c),
    HandleRef_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GetDescriptor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGet::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HandleRef
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< HandleRefType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< HandleRefType > r (
            dynamic_cast< HandleRefType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->HandleRef_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetDescriptor* GetDescriptor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetDescriptor (*this, f, c);
  }

  GetDescriptor& GetDescriptor::
  operator= (const GetDescriptor& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGet& > (*this) = x;
      this->HandleRef_ = x.HandleRef_;
    }

    return *this;
  }

  GetDescriptor::
  ~GetDescriptor ()
  {
  }

  // GetDescriptorResponse
  //

  GetDescriptorResponse::
  GetDescriptorResponse (const SequenceIdType& SequenceId)
  : ::MDM::AbstractGetResponse (SequenceId),
    Descriptor_ (this)
  {
  }

  GetDescriptorResponse::
  GetDescriptorResponse (const GetDescriptorResponse& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (x, f, c),
    Descriptor_ (x.Descriptor_, f, this)
  {
  }

  GetDescriptorResponse::
  GetDescriptorResponse (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::MDM::AbstractGetResponse (e, f | ::xml_schema::Flags::base, c),
    Descriptor_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GetDescriptorResponse::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractGetResponse::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Descriptor
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Descriptor",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< DescriptorType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< DescriptorType > r (
            dynamic_cast< DescriptorType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Descriptor_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  GetDescriptorResponse* GetDescriptorResponse::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GetDescriptorResponse (*this, f, c);
  }

  GetDescriptorResponse& GetDescriptorResponse::
  operator= (const GetDescriptorResponse& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractGetResponse& > (*this) = x;
      this->Descriptor_ = x.Descriptor_;
    }

    return *this;
  }

  GetDescriptorResponse::
  ~GetDescriptorResponse ()
  {
  }

  // ReportPart1
  //

  ReportPart1::
  ReportPart1 ()
  : ::MDM::AbstractReportPart (),
    MetricState_ (this)
  {
  }

  ReportPart1::
  ReportPart1 (const ReportPart1& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (x, f, c),
    MetricState_ (x.MetricState_, f, this)
  {
  }

  ReportPart1::
  ReportPart1 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (e, f | ::xml_schema::Flags::base, c),
    MetricState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ReportPart1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReportPart::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MetricState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "MetricState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< MetricStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< MetricStateType > r (
            dynamic_cast< MetricStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->MetricState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ReportPart1* ReportPart1::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReportPart1 (*this, f, c);
  }

  ReportPart1& ReportPart1::
  operator= (const ReportPart1& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReportPart& > (*this) = x;
      this->MetricState_ = x.MetricState_;
    }

    return *this;
  }

  ReportPart1::
  ~ReportPart1 ()
  {
  }

  // EpisodicMetricReport
  //

  EpisodicMetricReport::
  EpisodicMetricReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractMetricReport (SequenceId)
  {
  }

  EpisodicMetricReport::
  EpisodicMetricReport (const EpisodicMetricReport& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::MDM::AbstractMetricReport (x, f, c)
  {
  }

  EpisodicMetricReport::
  EpisodicMetricReport (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::MDM::AbstractMetricReport (e, f, c)
  {
  }

  EpisodicMetricReport* EpisodicMetricReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EpisodicMetricReport (*this, f, c);
  }

  EpisodicMetricReport::
  ~EpisodicMetricReport ()
  {
  }

  // PeriodicMetricReport
  //

  PeriodicMetricReport::
  PeriodicMetricReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractMetricReport (SequenceId)
  {
  }

  PeriodicMetricReport::
  PeriodicMetricReport (const PeriodicMetricReport& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::MDM::AbstractMetricReport (x, f, c)
  {
  }

  PeriodicMetricReport::
  PeriodicMetricReport (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::MDM::AbstractMetricReport (e, f, c)
  {
  }

  PeriodicMetricReport* PeriodicMetricReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PeriodicMetricReport (*this, f, c);
  }

  PeriodicMetricReport::
  ~PeriodicMetricReport ()
  {
  }

  // ReportPart2
  //

  ReportPart2::
  ReportPart2 ()
  : ::MDM::AbstractReportPart (),
    ComponentState_ (this)
  {
  }

  ReportPart2::
  ReportPart2 (const ReportPart2& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (x, f, c),
    ComponentState_ (x.ComponentState_, f, this)
  {
  }

  ReportPart2::
  ReportPart2 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (e, f | ::xml_schema::Flags::base, c),
    ComponentState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ReportPart2::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReportPart::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ComponentState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ComponentState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ComponentStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ComponentStateType > r (
            dynamic_cast< ComponentStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ComponentState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ReportPart2* ReportPart2::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReportPart2 (*this, f, c);
  }

  ReportPart2& ReportPart2::
  operator= (const ReportPart2& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReportPart& > (*this) = x;
      this->ComponentState_ = x.ComponentState_;
    }

    return *this;
  }

  ReportPart2::
  ~ReportPart2 ()
  {
  }

  // EpisodicComponentReport
  //

  EpisodicComponentReport::
  EpisodicComponentReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractComponentReport (SequenceId)
  {
  }

  EpisodicComponentReport::
  EpisodicComponentReport (const EpisodicComponentReport& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::MDM::AbstractComponentReport (x, f, c)
  {
  }

  EpisodicComponentReport::
  EpisodicComponentReport (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::MDM::AbstractComponentReport (e, f, c)
  {
  }

  EpisodicComponentReport* EpisodicComponentReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EpisodicComponentReport (*this, f, c);
  }

  EpisodicComponentReport::
  ~EpisodicComponentReport ()
  {
  }

  // PeriodicComponentReport
  //

  PeriodicComponentReport::
  PeriodicComponentReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractComponentReport (SequenceId)
  {
  }

  PeriodicComponentReport::
  PeriodicComponentReport (const PeriodicComponentReport& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::MDM::AbstractComponentReport (x, f, c)
  {
  }

  PeriodicComponentReport::
  PeriodicComponentReport (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::MDM::AbstractComponentReport (e, f, c)
  {
  }

  PeriodicComponentReport* PeriodicComponentReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PeriodicComponentReport (*this, f, c);
  }

  PeriodicComponentReport::
  ~PeriodicComponentReport ()
  {
  }

  // ReportPart3
  //

  ReportPart3::
  ReportPart3 ()
  : ::MDM::AbstractReportPart (),
    AlertState_ (this)
  {
  }

  ReportPart3::
  ReportPart3 (const ReportPart3& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (x, f, c),
    AlertState_ (x.AlertState_, f, this)
  {
  }

  ReportPart3::
  ReportPart3 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (e, f | ::xml_schema::Flags::base, c),
    AlertState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ReportPart3::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReportPart::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AlertState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "AlertState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< AlertStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< AlertStateType > r (
            dynamic_cast< AlertStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->AlertState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ReportPart3* ReportPart3::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReportPart3 (*this, f, c);
  }

  ReportPart3& ReportPart3::
  operator= (const ReportPart3& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReportPart& > (*this) = x;
      this->AlertState_ = x.AlertState_;
    }

    return *this;
  }

  ReportPart3::
  ~ReportPart3 ()
  {
  }

  // EpisodicAlertReport
  //

  EpisodicAlertReport::
  EpisodicAlertReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractAlertReport (SequenceId)
  {
  }

  EpisodicAlertReport::
  EpisodicAlertReport (const EpisodicAlertReport& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::MDM::AbstractAlertReport (x, f, c)
  {
  }

  EpisodicAlertReport::
  EpisodicAlertReport (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::MDM::AbstractAlertReport (e, f, c)
  {
  }

  EpisodicAlertReport* EpisodicAlertReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EpisodicAlertReport (*this, f, c);
  }

  EpisodicAlertReport::
  ~EpisodicAlertReport ()
  {
  }

  // PeriodicAlertReport
  //

  PeriodicAlertReport::
  PeriodicAlertReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractAlertReport (SequenceId)
  {
  }

  PeriodicAlertReport::
  PeriodicAlertReport (const PeriodicAlertReport& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::MDM::AbstractAlertReport (x, f, c)
  {
  }

  PeriodicAlertReport::
  PeriodicAlertReport (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::MDM::AbstractAlertReport (e, f, c)
  {
  }

  PeriodicAlertReport* PeriodicAlertReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PeriodicAlertReport (*this, f, c);
  }

  PeriodicAlertReport::
  ~PeriodicAlertReport ()
  {
  }

  // ReportPart4
  //

  ReportPart4::
  ReportPart4 ()
  : ::MDM::AbstractReportPart (),
    OperationState_ (this)
  {
  }

  ReportPart4::
  ReportPart4 (const ReportPart4& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (x, f, c),
    OperationState_ (x.OperationState_, f, this)
  {
  }

  ReportPart4::
  ReportPart4 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (e, f | ::xml_schema::Flags::base, c),
    OperationState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ReportPart4::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReportPart::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OperationState
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "OperationState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< OperationStateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< OperationStateType > r (
            dynamic_cast< OperationStateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->OperationState_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ReportPart4* ReportPart4::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReportPart4 (*this, f, c);
  }

  ReportPart4& ReportPart4::
  operator= (const ReportPart4& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReportPart& > (*this) = x;
      this->OperationState_ = x.OperationState_;
    }

    return *this;
  }

  ReportPart4::
  ~ReportPart4 ()
  {
  }

  // EpisodicOperationalStateReport
  //

  EpisodicOperationalStateReport::
  EpisodicOperationalStateReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractOperationalStateReport (SequenceId)
  {
  }

  EpisodicOperationalStateReport::
  EpisodicOperationalStateReport (const EpisodicOperationalStateReport& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::MDM::AbstractOperationalStateReport (x, f, c)
  {
  }

  EpisodicOperationalStateReport::
  EpisodicOperationalStateReport (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::MDM::AbstractOperationalStateReport (e, f, c)
  {
  }

  EpisodicOperationalStateReport* EpisodicOperationalStateReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EpisodicOperationalStateReport (*this, f, c);
  }

  EpisodicOperationalStateReport::
  ~EpisodicOperationalStateReport ()
  {
  }

  // PeriodicOperationalStateReport
  //

  PeriodicOperationalStateReport::
  PeriodicOperationalStateReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractOperationalStateReport (SequenceId)
  {
  }

  PeriodicOperationalStateReport::
  PeriodicOperationalStateReport (const PeriodicOperationalStateReport& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::MDM::AbstractOperationalStateReport (x, f, c)
  {
  }

  PeriodicOperationalStateReport::
  PeriodicOperationalStateReport (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::MDM::AbstractOperationalStateReport (e, f, c)
  {
  }

  PeriodicOperationalStateReport* PeriodicOperationalStateReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PeriodicOperationalStateReport (*this, f, c);
  }

  PeriodicOperationalStateReport::
  ~PeriodicOperationalStateReport ()
  {
  }

  // SystemErrorReport
  //

  SystemErrorReport::
  SystemErrorReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    ReportPart_ (this)
  {
  }

  SystemErrorReport::
  SystemErrorReport (const SystemErrorReport& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    ReportPart_ (x.ReportPart_, f, this)
  {
  }

  SystemErrorReport::
  SystemErrorReport (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    ReportPart_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SystemErrorReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReportPart
      //
      if (n.name () == "ReportPart" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ReportPartType > r (
          ReportPartTraits::create (i, f, this));

        this->ReportPart_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  SystemErrorReport* SystemErrorReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SystemErrorReport (*this, f, c);
  }

  SystemErrorReport& SystemErrorReport::
  operator= (const SystemErrorReport& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->ReportPart_ = x.ReportPart_;
    }

    return *this;
  }

  SystemErrorReport::
  ~SystemErrorReport ()
  {
  }

  // DescriptionModificationReport
  //

  DescriptionModificationReport::
  DescriptionModificationReport (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    ReportPart_ (this)
  {
  }

  DescriptionModificationReport::
  DescriptionModificationReport (const DescriptionModificationReport& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    ReportPart_ (x.ReportPart_, f, this)
  {
  }

  DescriptionModificationReport::
  DescriptionModificationReport (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    ReportPart_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DescriptionModificationReport::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReportPart
      //
      if (n.name () == "ReportPart" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ReportPartType > r (
          ReportPartTraits::create (i, f, this));

        this->ReportPart_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  DescriptionModificationReport* DescriptionModificationReport::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DescriptionModificationReport (*this, f, c);
  }

  DescriptionModificationReport& DescriptionModificationReport::
  operator= (const DescriptionModificationReport& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->ReportPart_ = x.ReportPart_;
    }

    return *this;
  }

  DescriptionModificationReport::
  ~DescriptionModificationReport ()
  {
  }

  // WaveformStream
  //

  WaveformStream::
  WaveformStream (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    State_ (this)
  {
  }

  WaveformStream::
  WaveformStream (const WaveformStream& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    State_ (x.State_, f, this)
  {
  }

  WaveformStream::
  WaveformStream (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    State_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void WaveformStream::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // State
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "State",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< StateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< StateType > r (
            dynamic_cast< StateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->State_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  WaveformStream* WaveformStream::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class WaveformStream (*this, f, c);
  }

  WaveformStream& WaveformStream::
  operator= (const WaveformStream& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->State_ = x.State_;
    }

    return *this;
  }

  WaveformStream::
  ~WaveformStream ()
  {
  }

  // ObservedValueStream
  //

  ObservedValueStream::
  ObservedValueStream (const SequenceIdType& SequenceId)
  : ::MDM::AbstractReport (SequenceId),
    Value_ (this)
  {
  }

  ObservedValueStream::
  ObservedValueStream (const ObservedValueStream& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::MDM::AbstractReport (x, f, c),
    Value_ (x.Value_, f, this)
  {
  }

  ObservedValueStream::
  ObservedValueStream (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::MDM::AbstractReport (e, f | ::xml_schema::Flags::base, c),
    Value_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ObservedValueStream::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReport::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Value
      //
      if (n.name () == "Value" && n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
      {
        ::std::unique_ptr< ValueType > r (
          ValueTraits::create (i, f, this));

        this->Value_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ObservedValueStream* ObservedValueStream::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ObservedValueStream (*this, f, c);
  }

  ObservedValueStream& ObservedValueStream::
  operator= (const ObservedValueStream& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReport& > (*this) = x;
      this->Value_ = x.Value_;
    }

    return *this;
  }

  ObservedValueStream::
  ~ObservedValueStream ()
  {
  }

  // Retrievability
  //

  Retrievability::
  Retrievability ()
  : ::xml_schema::Type (),
    By_ (this)
  {
  }

  Retrievability::
  Retrievability (const Retrievability& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    By_ (x.By_, f, this)
  {
  }

  Retrievability::
  Retrievability (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    By_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Retrievability::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // By
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "By",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ByType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ByType > r (
            dynamic_cast< ByType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->By_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Retrievability* Retrievability::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Retrievability (*this, f, c);
  }

  Retrievability& Retrievability::
  operator= (const Retrievability& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->By_ = x.By_;
    }

    return *this;
  }

  Retrievability::
  ~Retrievability ()
  {
  }

  // Argument
  //

  Argument::
  Argument (const ArgValueType& ArgValue)
  : ::xml_schema::Type (),
    Extension_ (this),
    ArgValue_ (ArgValue, this)
  {
  }

  Argument::
  Argument (::std::unique_ptr< ArgValueType > ArgValue)
  : ::xml_schema::Type (),
    Extension_ (this),
    ArgValue_ (std::move (ArgValue), this)
  {
  }

  Argument::
  Argument (const Argument& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Extension_ (x.Extension_, f, this),
    ArgValue_ (x.ArgValue_, f, this)
  {
  }

  Argument::
  Argument (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Extension_ (this),
    ArgValue_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Argument::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Extension
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            &::xsd::cxx::tree::factory_impl< ExtensionType >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Extension_)
          {
            ::std::unique_ptr< ExtensionType > r (
              dynamic_cast< ExtensionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Extension_.set (::std::move (r));
            continue;
          }
        }
      }

      // ArgValue
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ArgValue",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ArgValueType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ArgValue_.present ())
          {
            ::std::unique_ptr< ArgValueType > r (
              dynamic_cast< ArgValueType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ArgValue_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ArgValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ArgValue",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  Argument* Argument::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Argument (*this, f, c);
  }

  Argument& Argument::
  operator= (const Argument& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Extension_ = x.Extension_;
      this->ArgValue_ = x.ArgValue_;
    }

    return *this;
  }

  Argument::
  ~Argument ()
  {
  }

  // ReportPart5
  //

  ReportPart5::
  ReportPart5 (const InvocationInfoType& InvocationInfo,
               const InvocationSourceType& InvocationSource,
               const OperationHandleRefType& OperationHandleRef)
  : ::MDM::AbstractReportPart (),
    InvocationInfo_ (InvocationInfo, this),
    InvocationSource_ (InvocationSource, this),
    OperationHandleRef_ (OperationHandleRef, this),
    OperationTarget_ (this)
  {
  }

  ReportPart5::
  ReportPart5 (::std::unique_ptr< InvocationInfoType > InvocationInfo,
               ::std::unique_ptr< InvocationSourceType > InvocationSource,
               const OperationHandleRefType& OperationHandleRef)
  : ::MDM::AbstractReportPart (),
    InvocationInfo_ (std::move (InvocationInfo), this),
    InvocationSource_ (std::move (InvocationSource), this),
    OperationHandleRef_ (OperationHandleRef, this),
    OperationTarget_ (this)
  {
  }

  ReportPart5::
  ReportPart5 (const ReportPart5& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (x, f, c),
    InvocationInfo_ (x.InvocationInfo_, f, this),
    InvocationSource_ (x.InvocationSource_, f, this),
    OperationHandleRef_ (x.OperationHandleRef_, f, this),
    OperationTarget_ (x.OperationTarget_, f, this)
  {
  }

  ReportPart5::
  ReportPart5 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (e, f | ::xml_schema::Flags::base, c),
    InvocationInfo_ (this),
    InvocationSource_ (this),
    OperationHandleRef_ (this),
    OperationTarget_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ReportPart5::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReportPart::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // InvocationInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "InvocationInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< InvocationInfoType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!InvocationInfo_.present ())
          {
            ::std::unique_ptr< InvocationInfoType > r (
              dynamic_cast< InvocationInfoType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->InvocationInfo_.set (::std::move (r));
            continue;
          }
        }
      }

      // InvocationSource
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "InvocationSource",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< InvocationSourceType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!InvocationSource_.present ())
          {
            ::std::unique_ptr< InvocationSourceType > r (
              dynamic_cast< InvocationSourceType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->InvocationSource_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!InvocationInfo_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "InvocationInfo",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }

    if (!InvocationSource_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "InvocationSource",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "OperationHandleRef" && n.namespace_ ().empty ())
      {
        this->OperationHandleRef_.set (OperationHandleRefTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "OperationTarget" && n.namespace_ ().empty ())
      {
        this->OperationTarget_.set (OperationTargetTraits::create (i, f, this));
        continue;
      }
    }

    if (!OperationHandleRef_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "OperationHandleRef",
        "");
    }
  }

  ReportPart5* ReportPart5::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReportPart5 (*this, f, c);
  }

  ReportPart5& ReportPart5::
  operator= (const ReportPart5& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReportPart& > (*this) = x;
      this->InvocationInfo_ = x.InvocationInfo_;
      this->InvocationSource_ = x.InvocationSource_;
      this->OperationHandleRef_ = x.OperationHandleRef_;
      this->OperationTarget_ = x.OperationTarget_;
    }

    return *this;
  }

  ReportPart5::
  ~ReportPart5 ()
  {
  }

  // ReportPart6
  //

  ReportPart6::
  ReportPart6 (const ErrorCodeType& ErrorCode)
  : ::MDM::AbstractReportPart (),
    ErrorCode_ (ErrorCode, this),
    ErrorInfo_ (this)
  {
  }

  ReportPart6::
  ReportPart6 (::std::unique_ptr< ErrorCodeType > ErrorCode)
  : ::MDM::AbstractReportPart (),
    ErrorCode_ (std::move (ErrorCode), this),
    ErrorInfo_ (this)
  {
  }

  ReportPart6::
  ReportPart6 (const ReportPart6& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (x, f, c),
    ErrorCode_ (x.ErrorCode_, f, this),
    ErrorInfo_ (x.ErrorInfo_, f, this)
  {
  }

  ReportPart6::
  ReportPart6 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (e, f | ::xml_schema::Flags::base, c),
    ErrorCode_ (this),
    ErrorInfo_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ReportPart6::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReportPart::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ErrorCode
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ErrorCode",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ErrorCodeType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!ErrorCode_.present ())
          {
            ::std::unique_ptr< ErrorCodeType > r (
              dynamic_cast< ErrorCodeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ErrorCode_.set (::std::move (r));
            continue;
          }
        }
      }

      // ErrorInfo
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "ErrorInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< ErrorInfoType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->ErrorInfo_)
          {
            ::std::unique_ptr< ErrorInfoType > r (
              dynamic_cast< ErrorInfoType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ErrorInfo_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    if (!ErrorCode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ErrorCode",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ReportPart6* ReportPart6::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReportPart6 (*this, f, c);
  }

  ReportPart6& ReportPart6::
  operator= (const ReportPart6& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReportPart& > (*this) = x;
      this->ErrorCode_ = x.ErrorCode_;
      this->ErrorInfo_ = x.ErrorInfo_;
    }

    return *this;
  }

  ReportPart6::
  ~ReportPart6 ()
  {
  }

  // ReportPart7
  //

  ReportPart7::
  ReportPart7 ()
  : ::MDM::AbstractReportPart (),
    Descriptor_ (this),
    State_ (this),
    ParentDescriptor_ (this),
    ModificationType_ (this)
  {
  }

  ReportPart7::
  ReportPart7 (const ReportPart7& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (x, f, c),
    Descriptor_ (x.Descriptor_, f, this),
    State_ (x.State_, f, this),
    ParentDescriptor_ (x.ParentDescriptor_, f, this),
    ModificationType_ (x.ModificationType_, f, this)
  {
  }

  ReportPart7::
  ReportPart7 (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::MDM::AbstractReportPart (e, f | ::xml_schema::Flags::base, c),
    Descriptor_ (this),
    State_ (this),
    ParentDescriptor_ (this),
    ModificationType_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ReportPart7::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::MDM::AbstractReportPart::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Descriptor
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Descriptor",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< DescriptorType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< DescriptorType > r (
            dynamic_cast< DescriptorType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Descriptor_.push_back (::std::move (r));
          continue;
        }
      }

      // State
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "State",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< StateType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< StateType > r (
            dynamic_cast< StateType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->State_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ParentDescriptor" && n.namespace_ ().empty ())
      {
        this->ParentDescriptor_.set (ParentDescriptorTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "ModificationType" && n.namespace_ ().empty ())
      {
        this->ModificationType_.set (ModificationTypeTraits::create (i, f, this));
        continue;
      }
    }
  }

  ReportPart7* ReportPart7::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReportPart7 (*this, f, c);
  }

  ReportPart7& ReportPart7::
  operator= (const ReportPart7& x)
  {
    if (this != &x)
    {
      static_cast< ::MDM::AbstractReportPart& > (*this) = x;
      this->Descriptor_ = x.Descriptor_;
      this->State_ = x.State_;
      this->ParentDescriptor_ = x.ParentDescriptor_;
      this->ModificationType_ = x.ModificationType_;
    }

    return *this;
  }

  ReportPart7::
  ~ReportPart7 ()
  {
  }

  // Value
  //

  Value::
  Value (const MetricType& Metric)
  : ::xml_schema::Type (),
    Value1_ (this),
    Metric_ (Metric, this),
    StateVersion_ (this)
  {
  }

  Value::
  Value (const Value& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Value1_ (x.Value1_, f, this),
    Metric_ (x.Metric_, f, this),
    StateVersion_ (x.StateVersion_, f, this)
  {
  }

  Value::
  Value (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Value1_ (this),
    Metric_ (this),
    StateVersion_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Value::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Value
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Value",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            &::xsd::cxx::tree::factory_impl< Value1Type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->Value1_)
          {
            ::std::unique_ptr< Value1Type > r (
              dynamic_cast< Value1Type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Value1_.set (::std::move (r));
            continue;
          }
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Metric" && n.namespace_ ().empty ())
      {
        this->Metric_.set (MetricTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "StateVersion" && n.namespace_ ().empty ())
      {
        this->StateVersion_.set (StateVersionTraits::create (i, f, this));
        continue;
      }
    }

    if (!Metric_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Metric",
        "");
    }
  }

  Value* Value::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Value (*this, f, c);
  }

  Value& Value::
  operator= (const Value& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Value1_ = x.Value1_;
      this->Metric_ = x.Metric_;
      this->StateVersion_ = x.StateVersion_;
    }

    return *this;
  }

  Value::
  ~Value ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace MDM
{
  ::std::unique_ptr< ::MDM::GetMdib >
  GetMdib_ (const ::std::string& u,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetMdib > (
      ::MDM::GetMdib_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdib >
  GetMdib_ (const ::std::string& u,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdib > (
      ::MDM::GetMdib_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdib >
  GetMdib_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdib > (
      ::MDM::GetMdib_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdib >
  GetMdib_ (::std::istream& is,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdib_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdib >
  GetMdib_ (::std::istream& is,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdib_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdib >
  GetMdib_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdib_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdib >
  GetMdib_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdib_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdib >
  GetMdib_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdib_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdib >
  GetMdib_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdib_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdib >
  GetMdib_ (::xercesc::InputSource& i,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetMdib > (
      ::MDM::GetMdib_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdib >
  GetMdib_ (::xercesc::InputSource& i,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdib > (
      ::MDM::GetMdib_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdib >
  GetMdib_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdib > (
      ::MDM::GetMdib_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdib >
  GetMdib_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetMdib > (
        ::MDM::GetMdib_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetMdib" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetMdib > r (
        ::xsd::cxx::tree::traits< ::MDM::GetMdib, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetMdib",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetMdib >
  GetMdib_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetMdib" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetMdib > r (
        ::xsd::cxx::tree::traits< ::MDM::GetMdib, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetMdib",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetMdibResponse >
  GetMdibResponse_ (const ::std::string& u,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetMdibResponse > (
      ::MDM::GetMdibResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdibResponse >
  GetMdibResponse_ (const ::std::string& u,
                    ::xml_schema::ErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdibResponse > (
      ::MDM::GetMdibResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdibResponse >
  GetMdibResponse_ (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdibResponse > (
      ::MDM::GetMdibResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdibResponse >
  GetMdibResponse_ (::std::istream& is,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdibResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdibResponse >
  GetMdibResponse_ (::std::istream& is,
                    ::xml_schema::ErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdibResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdibResponse >
  GetMdibResponse_ (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdibResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdibResponse >
  GetMdibResponse_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdibResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdibResponse >
  GetMdibResponse_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::ErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdibResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdibResponse >
  GetMdibResponse_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdibResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdibResponse >
  GetMdibResponse_ (::xercesc::InputSource& i,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetMdibResponse > (
      ::MDM::GetMdibResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdibResponse >
  GetMdibResponse_ (::xercesc::InputSource& i,
                    ::xml_schema::ErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdibResponse > (
      ::MDM::GetMdibResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdibResponse >
  GetMdibResponse_ (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdibResponse > (
      ::MDM::GetMdibResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdibResponse >
  GetMdibResponse_ (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetMdibResponse > (
        ::MDM::GetMdibResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetMdibResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetMdibResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetMdibResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetMdibResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetMdibResponse >
  GetMdibResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetMdibResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetMdibResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetMdibResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetMdibResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetMdDescription >
  GetMdDescription_ (const ::std::string& u,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetMdDescription > (
      ::MDM::GetMdDescription_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdDescription >
  GetMdDescription_ (const ::std::string& u,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdDescription > (
      ::MDM::GetMdDescription_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdDescription >
  GetMdDescription_ (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdDescription > (
      ::MDM::GetMdDescription_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdDescription >
  GetMdDescription_ (::std::istream& is,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdDescription_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdDescription >
  GetMdDescription_ (::std::istream& is,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdDescription_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdDescription >
  GetMdDescription_ (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdDescription_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdDescription >
  GetMdDescription_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdDescription_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdDescription >
  GetMdDescription_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdDescription_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdDescription >
  GetMdDescription_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdDescription_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdDescription >
  GetMdDescription_ (::xercesc::InputSource& i,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetMdDescription > (
      ::MDM::GetMdDescription_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdDescription >
  GetMdDescription_ (::xercesc::InputSource& i,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdDescription > (
      ::MDM::GetMdDescription_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdDescription >
  GetMdDescription_ (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdDescription > (
      ::MDM::GetMdDescription_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdDescription >
  GetMdDescription_ (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetMdDescription > (
        ::MDM::GetMdDescription_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetMdDescription" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetMdDescription > r (
        ::xsd::cxx::tree::traits< ::MDM::GetMdDescription, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetMdDescription",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetMdDescription >
  GetMdDescription_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetMdDescription" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetMdDescription > r (
        ::xsd::cxx::tree::traits< ::MDM::GetMdDescription, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetMdDescription",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetMdDescriptionResponse >
  GetMdDescriptionResponse_ (const ::std::string& u,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetMdDescriptionResponse > (
      ::MDM::GetMdDescriptionResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdDescriptionResponse >
  GetMdDescriptionResponse_ (const ::std::string& u,
                             ::xml_schema::ErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdDescriptionResponse > (
      ::MDM::GetMdDescriptionResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdDescriptionResponse >
  GetMdDescriptionResponse_ (const ::std::string& u,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdDescriptionResponse > (
      ::MDM::GetMdDescriptionResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdDescriptionResponse >
  GetMdDescriptionResponse_ (::std::istream& is,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdDescriptionResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdDescriptionResponse >
  GetMdDescriptionResponse_ (::std::istream& is,
                             ::xml_schema::ErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdDescriptionResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdDescriptionResponse >
  GetMdDescriptionResponse_ (::std::istream& is,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdDescriptionResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdDescriptionResponse >
  GetMdDescriptionResponse_ (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdDescriptionResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdDescriptionResponse >
  GetMdDescriptionResponse_ (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::ErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdDescriptionResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdDescriptionResponse >
  GetMdDescriptionResponse_ (::std::istream& is,
                             const ::std::string& sid,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdDescriptionResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdDescriptionResponse >
  GetMdDescriptionResponse_ (::xercesc::InputSource& i,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetMdDescriptionResponse > (
      ::MDM::GetMdDescriptionResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdDescriptionResponse >
  GetMdDescriptionResponse_ (::xercesc::InputSource& i,
                             ::xml_schema::ErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdDescriptionResponse > (
      ::MDM::GetMdDescriptionResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdDescriptionResponse >
  GetMdDescriptionResponse_ (::xercesc::InputSource& i,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdDescriptionResponse > (
      ::MDM::GetMdDescriptionResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdDescriptionResponse >
  GetMdDescriptionResponse_ (const ::xercesc::DOMDocument& doc,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetMdDescriptionResponse > (
        ::MDM::GetMdDescriptionResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetMdDescriptionResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetMdDescriptionResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetMdDescriptionResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetMdDescriptionResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetMdDescriptionResponse >
  GetMdDescriptionResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetMdDescriptionResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetMdDescriptionResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetMdDescriptionResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetMdDescriptionResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetMdState >
  GetMdState_ (const ::std::string& u,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetMdState > (
      ::MDM::GetMdState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdState >
  GetMdState_ (const ::std::string& u,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdState > (
      ::MDM::GetMdState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdState >
  GetMdState_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdState > (
      ::MDM::GetMdState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdState >
  GetMdState_ (::std::istream& is,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdState_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdState >
  GetMdState_ (::std::istream& is,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdState >
  GetMdState_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdState >
  GetMdState_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdState_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdState >
  GetMdState_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdState >
  GetMdState_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdState >
  GetMdState_ (::xercesc::InputSource& i,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetMdState > (
      ::MDM::GetMdState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdState >
  GetMdState_ (::xercesc::InputSource& i,
               ::xml_schema::ErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdState > (
      ::MDM::GetMdState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdState >
  GetMdState_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdState > (
      ::MDM::GetMdState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdState >
  GetMdState_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetMdState > (
        ::MDM::GetMdState_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetMdState" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetMdState > r (
        ::xsd::cxx::tree::traits< ::MDM::GetMdState, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetMdState",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetMdState >
  GetMdState_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::Flags f,
               const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetMdState" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetMdState > r (
        ::xsd::cxx::tree::traits< ::MDM::GetMdState, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetMdState",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetMdStateResponse >
  GetMdStateResponse_ (const ::std::string& u,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetMdStateResponse > (
      ::MDM::GetMdStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdStateResponse >
  GetMdStateResponse_ (const ::std::string& u,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdStateResponse > (
      ::MDM::GetMdStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdStateResponse >
  GetMdStateResponse_ (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdStateResponse > (
      ::MDM::GetMdStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdStateResponse >
  GetMdStateResponse_ (::std::istream& is,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdStateResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdStateResponse >
  GetMdStateResponse_ (::std::istream& is,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdStateResponse >
  GetMdStateResponse_ (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetMdStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdStateResponse >
  GetMdStateResponse_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdStateResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdStateResponse >
  GetMdStateResponse_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdStateResponse >
  GetMdStateResponse_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetMdStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetMdStateResponse >
  GetMdStateResponse_ (::xercesc::InputSource& i,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetMdStateResponse > (
      ::MDM::GetMdStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdStateResponse >
  GetMdStateResponse_ (::xercesc::InputSource& i,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdStateResponse > (
      ::MDM::GetMdStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdStateResponse >
  GetMdStateResponse_ (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetMdStateResponse > (
      ::MDM::GetMdStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetMdStateResponse >
  GetMdStateResponse_ (const ::xercesc::DOMDocument& doc,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetMdStateResponse > (
        ::MDM::GetMdStateResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetMdStateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetMdStateResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetMdStateResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetMdStateResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetMdStateResponse >
  GetMdStateResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetMdStateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetMdStateResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetMdStateResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetMdStateResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetContextStates >
  GetContextStates_ (const ::std::string& u,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetContextStates > (
      ::MDM::GetContextStates_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStates >
  GetContextStates_ (const ::std::string& u,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStates > (
      ::MDM::GetContextStates_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStates >
  GetContextStates_ (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStates > (
      ::MDM::GetContextStates_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStates >
  GetContextStates_ (::std::istream& is,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStates_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStates >
  GetContextStates_ (::std::istream& is,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStates_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStates >
  GetContextStates_ (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStates_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStates >
  GetContextStates_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStates_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStates >
  GetContextStates_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStates_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStates >
  GetContextStates_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStates_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStates >
  GetContextStates_ (::xercesc::InputSource& i,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetContextStates > (
      ::MDM::GetContextStates_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStates >
  GetContextStates_ (::xercesc::InputSource& i,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStates > (
      ::MDM::GetContextStates_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStates >
  GetContextStates_ (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStates > (
      ::MDM::GetContextStates_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStates >
  GetContextStates_ (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetContextStates > (
        ::MDM::GetContextStates_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetContextStates" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetContextStates > r (
        ::xsd::cxx::tree::traits< ::MDM::GetContextStates, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetContextStates",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetContextStates >
  GetContextStates_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetContextStates" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetContextStates > r (
        ::xsd::cxx::tree::traits< ::MDM::GetContextStates, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetContextStates",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetContextStatesResponse >
  GetContextStatesResponse_ (const ::std::string& u,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesResponse > (
      ::MDM::GetContextStatesResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesResponse >
  GetContextStatesResponse_ (const ::std::string& u,
                             ::xml_schema::ErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesResponse > (
      ::MDM::GetContextStatesResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesResponse >
  GetContextStatesResponse_ (const ::std::string& u,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesResponse > (
      ::MDM::GetContextStatesResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesResponse >
  GetContextStatesResponse_ (::std::istream& is,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStatesResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesResponse >
  GetContextStatesResponse_ (::std::istream& is,
                             ::xml_schema::ErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStatesResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesResponse >
  GetContextStatesResponse_ (::std::istream& is,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStatesResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesResponse >
  GetContextStatesResponse_ (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStatesResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesResponse >
  GetContextStatesResponse_ (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::ErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStatesResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesResponse >
  GetContextStatesResponse_ (::std::istream& is,
                             const ::std::string& sid,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStatesResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesResponse >
  GetContextStatesResponse_ (::xercesc::InputSource& i,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesResponse > (
      ::MDM::GetContextStatesResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesResponse >
  GetContextStatesResponse_ (::xercesc::InputSource& i,
                             ::xml_schema::ErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesResponse > (
      ::MDM::GetContextStatesResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesResponse >
  GetContextStatesResponse_ (::xercesc::InputSource& i,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesResponse > (
      ::MDM::GetContextStatesResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesResponse >
  GetContextStatesResponse_ (const ::xercesc::DOMDocument& doc,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetContextStatesResponse > (
        ::MDM::GetContextStatesResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetContextStatesResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetContextStatesResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetContextStatesResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetContextStatesResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetContextStatesResponse >
  GetContextStatesResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetContextStatesResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetContextStatesResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetContextStatesResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetContextStatesResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentification >
  GetContextStatesByIdentification_ (const ::std::string& u,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByIdentification > (
      ::MDM::GetContextStatesByIdentification_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentification >
  GetContextStatesByIdentification_ (const ::std::string& u,
                                     ::xml_schema::ErrorHandler& h,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByIdentification > (
      ::MDM::GetContextStatesByIdentification_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentification >
  GetContextStatesByIdentification_ (const ::std::string& u,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByIdentification > (
      ::MDM::GetContextStatesByIdentification_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentification >
  GetContextStatesByIdentification_ (::std::istream& is,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStatesByIdentification_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentification >
  GetContextStatesByIdentification_ (::std::istream& is,
                                     ::xml_schema::ErrorHandler& h,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStatesByIdentification_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentification >
  GetContextStatesByIdentification_ (::std::istream& is,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStatesByIdentification_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentification >
  GetContextStatesByIdentification_ (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStatesByIdentification_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentification >
  GetContextStatesByIdentification_ (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::ErrorHandler& h,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStatesByIdentification_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentification >
  GetContextStatesByIdentification_ (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStatesByIdentification_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentification >
  GetContextStatesByIdentification_ (::xercesc::InputSource& i,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByIdentification > (
      ::MDM::GetContextStatesByIdentification_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentification >
  GetContextStatesByIdentification_ (::xercesc::InputSource& i,
                                     ::xml_schema::ErrorHandler& h,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByIdentification > (
      ::MDM::GetContextStatesByIdentification_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentification >
  GetContextStatesByIdentification_ (::xercesc::InputSource& i,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByIdentification > (
      ::MDM::GetContextStatesByIdentification_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentification >
  GetContextStatesByIdentification_ (const ::xercesc::DOMDocument& doc,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetContextStatesByIdentification > (
        ::MDM::GetContextStatesByIdentification_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetContextStatesByIdentification" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetContextStatesByIdentification > r (
        ::xsd::cxx::tree::traits< ::MDM::GetContextStatesByIdentification, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetContextStatesByIdentification",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentification >
  GetContextStatesByIdentification_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetContextStatesByIdentification" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetContextStatesByIdentification > r (
        ::xsd::cxx::tree::traits< ::MDM::GetContextStatesByIdentification, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetContextStatesByIdentification",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse >
  GetContextStatesByIdentificationResponse_ (const ::std::string& u,
                                             ::xml_schema::Flags f,
                                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse > (
      ::MDM::GetContextStatesByIdentificationResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse >
  GetContextStatesByIdentificationResponse_ (const ::std::string& u,
                                             ::xml_schema::ErrorHandler& h,
                                             ::xml_schema::Flags f,
                                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse > (
      ::MDM::GetContextStatesByIdentificationResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse >
  GetContextStatesByIdentificationResponse_ (const ::std::string& u,
                                             ::xercesc::DOMErrorHandler& h,
                                             ::xml_schema::Flags f,
                                             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse > (
      ::MDM::GetContextStatesByIdentificationResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse >
  GetContextStatesByIdentificationResponse_ (::std::istream& is,
                                             ::xml_schema::Flags f,
                                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStatesByIdentificationResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse >
  GetContextStatesByIdentificationResponse_ (::std::istream& is,
                                             ::xml_schema::ErrorHandler& h,
                                             ::xml_schema::Flags f,
                                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStatesByIdentificationResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse >
  GetContextStatesByIdentificationResponse_ (::std::istream& is,
                                             ::xercesc::DOMErrorHandler& h,
                                             ::xml_schema::Flags f,
                                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStatesByIdentificationResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse >
  GetContextStatesByIdentificationResponse_ (::std::istream& is,
                                             const ::std::string& sid,
                                             ::xml_schema::Flags f,
                                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStatesByIdentificationResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse >
  GetContextStatesByIdentificationResponse_ (::std::istream& is,
                                             const ::std::string& sid,
                                             ::xml_schema::ErrorHandler& h,
                                             ::xml_schema::Flags f,
                                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStatesByIdentificationResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse >
  GetContextStatesByIdentificationResponse_ (::std::istream& is,
                                             const ::std::string& sid,
                                             ::xercesc::DOMErrorHandler& h,
                                             ::xml_schema::Flags f,
                                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStatesByIdentificationResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse >
  GetContextStatesByIdentificationResponse_ (::xercesc::InputSource& i,
                                             ::xml_schema::Flags f,
                                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse > (
      ::MDM::GetContextStatesByIdentificationResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse >
  GetContextStatesByIdentificationResponse_ (::xercesc::InputSource& i,
                                             ::xml_schema::ErrorHandler& h,
                                             ::xml_schema::Flags f,
                                             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse > (
      ::MDM::GetContextStatesByIdentificationResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse >
  GetContextStatesByIdentificationResponse_ (::xercesc::InputSource& i,
                                             ::xercesc::DOMErrorHandler& h,
                                             ::xml_schema::Flags f,
                                             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse > (
      ::MDM::GetContextStatesByIdentificationResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse >
  GetContextStatesByIdentificationResponse_ (const ::xercesc::DOMDocument& doc,
                                             ::xml_schema::Flags f,
                                             const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse > (
        ::MDM::GetContextStatesByIdentificationResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetContextStatesByIdentificationResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetContextStatesByIdentificationResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetContextStatesByIdentificationResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse >
  GetContextStatesByIdentificationResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                                             ::xml_schema::Flags f,
                                             const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetContextStatesByIdentificationResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetContextStatesByIdentificationResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetContextStatesByIdentificationResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetContextStatesByIdentificationResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilter >
  GetContextStatesByFilter_ (const ::std::string& u,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByFilter > (
      ::MDM::GetContextStatesByFilter_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilter >
  GetContextStatesByFilter_ (const ::std::string& u,
                             ::xml_schema::ErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByFilter > (
      ::MDM::GetContextStatesByFilter_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilter >
  GetContextStatesByFilter_ (const ::std::string& u,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByFilter > (
      ::MDM::GetContextStatesByFilter_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilter >
  GetContextStatesByFilter_ (::std::istream& is,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStatesByFilter_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilter >
  GetContextStatesByFilter_ (::std::istream& is,
                             ::xml_schema::ErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStatesByFilter_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilter >
  GetContextStatesByFilter_ (::std::istream& is,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStatesByFilter_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilter >
  GetContextStatesByFilter_ (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStatesByFilter_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilter >
  GetContextStatesByFilter_ (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::ErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStatesByFilter_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilter >
  GetContextStatesByFilter_ (::std::istream& is,
                             const ::std::string& sid,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStatesByFilter_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilter >
  GetContextStatesByFilter_ (::xercesc::InputSource& i,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByFilter > (
      ::MDM::GetContextStatesByFilter_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilter >
  GetContextStatesByFilter_ (::xercesc::InputSource& i,
                             ::xml_schema::ErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByFilter > (
      ::MDM::GetContextStatesByFilter_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilter >
  GetContextStatesByFilter_ (::xercesc::InputSource& i,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByFilter > (
      ::MDM::GetContextStatesByFilter_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilter >
  GetContextStatesByFilter_ (const ::xercesc::DOMDocument& doc,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetContextStatesByFilter > (
        ::MDM::GetContextStatesByFilter_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetContextStatesByFilter" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetContextStatesByFilter > r (
        ::xsd::cxx::tree::traits< ::MDM::GetContextStatesByFilter, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetContextStatesByFilter",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilter >
  GetContextStatesByFilter_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetContextStatesByFilter" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetContextStatesByFilter > r (
        ::xsd::cxx::tree::traits< ::MDM::GetContextStatesByFilter, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetContextStatesByFilter",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse >
  GetContextStatesByFilterResponse_ (const ::std::string& u,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse > (
      ::MDM::GetContextStatesByFilterResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse >
  GetContextStatesByFilterResponse_ (const ::std::string& u,
                                     ::xml_schema::ErrorHandler& h,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse > (
      ::MDM::GetContextStatesByFilterResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse >
  GetContextStatesByFilterResponse_ (const ::std::string& u,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse > (
      ::MDM::GetContextStatesByFilterResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse >
  GetContextStatesByFilterResponse_ (::std::istream& is,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStatesByFilterResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse >
  GetContextStatesByFilterResponse_ (::std::istream& is,
                                     ::xml_schema::ErrorHandler& h,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStatesByFilterResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse >
  GetContextStatesByFilterResponse_ (::std::istream& is,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContextStatesByFilterResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse >
  GetContextStatesByFilterResponse_ (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStatesByFilterResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse >
  GetContextStatesByFilterResponse_ (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::ErrorHandler& h,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStatesByFilterResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse >
  GetContextStatesByFilterResponse_ (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContextStatesByFilterResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse >
  GetContextStatesByFilterResponse_ (::xercesc::InputSource& i,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse > (
      ::MDM::GetContextStatesByFilterResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse >
  GetContextStatesByFilterResponse_ (::xercesc::InputSource& i,
                                     ::xml_schema::ErrorHandler& h,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse > (
      ::MDM::GetContextStatesByFilterResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse >
  GetContextStatesByFilterResponse_ (::xercesc::InputSource& i,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse > (
      ::MDM::GetContextStatesByFilterResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse >
  GetContextStatesByFilterResponse_ (const ::xercesc::DOMDocument& doc,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse > (
        ::MDM::GetContextStatesByFilterResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetContextStatesByFilterResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetContextStatesByFilterResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetContextStatesByFilterResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse >
  GetContextStatesByFilterResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                                     ::xml_schema::Flags f,
                                     const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetContextStatesByFilterResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetContextStatesByFilterResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetContextStatesByFilterResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetContextStatesByFilterResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetContextState >
  SetContextState_ (const ::std::string& u,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetContextState > (
      ::MDM::SetContextState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetContextState >
  SetContextState_ (const ::std::string& u,
                    ::xml_schema::ErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetContextState > (
      ::MDM::SetContextState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetContextState >
  SetContextState_ (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetContextState > (
      ::MDM::SetContextState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetContextState >
  SetContextState_ (::std::istream& is,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetContextState_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetContextState >
  SetContextState_ (::std::istream& is,
                    ::xml_schema::ErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetContextState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetContextState >
  SetContextState_ (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetContextState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetContextState >
  SetContextState_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetContextState_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetContextState >
  SetContextState_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::ErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetContextState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetContextState >
  SetContextState_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetContextState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetContextState >
  SetContextState_ (::xercesc::InputSource& i,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetContextState > (
      ::MDM::SetContextState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetContextState >
  SetContextState_ (::xercesc::InputSource& i,
                    ::xml_schema::ErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetContextState > (
      ::MDM::SetContextState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetContextState >
  SetContextState_ (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetContextState > (
      ::MDM::SetContextState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetContextState >
  SetContextState_ (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::SetContextState > (
        ::MDM::SetContextState_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetContextState" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetContextState > r (
        ::xsd::cxx::tree::traits< ::MDM::SetContextState, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetContextState",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetContextState >
  SetContextState_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SetContextState" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetContextState > r (
        ::xsd::cxx::tree::traits< ::MDM::SetContextState, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetContextState",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetContextStateResponse >
  SetContextStateResponse_ (const ::std::string& u,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetContextStateResponse > (
      ::MDM::SetContextStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetContextStateResponse >
  SetContextStateResponse_ (const ::std::string& u,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetContextStateResponse > (
      ::MDM::SetContextStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetContextStateResponse >
  SetContextStateResponse_ (const ::std::string& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetContextStateResponse > (
      ::MDM::SetContextStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetContextStateResponse >
  SetContextStateResponse_ (::std::istream& is,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetContextStateResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetContextStateResponse >
  SetContextStateResponse_ (::std::istream& is,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetContextStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetContextStateResponse >
  SetContextStateResponse_ (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetContextStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetContextStateResponse >
  SetContextStateResponse_ (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetContextStateResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetContextStateResponse >
  SetContextStateResponse_ (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetContextStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetContextStateResponse >
  SetContextStateResponse_ (::std::istream& is,
                            const ::std::string& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetContextStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetContextStateResponse >
  SetContextStateResponse_ (::xercesc::InputSource& i,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetContextStateResponse > (
      ::MDM::SetContextStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetContextStateResponse >
  SetContextStateResponse_ (::xercesc::InputSource& i,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetContextStateResponse > (
      ::MDM::SetContextStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetContextStateResponse >
  SetContextStateResponse_ (::xercesc::InputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetContextStateResponse > (
      ::MDM::SetContextStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetContextStateResponse >
  SetContextStateResponse_ (const ::xercesc::DOMDocument& doc,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::SetContextStateResponse > (
        ::MDM::SetContextStateResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetContextStateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetContextStateResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::SetContextStateResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetContextStateResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetContextStateResponse >
  SetContextStateResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SetContextStateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetContextStateResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::SetContextStateResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetContextStateResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::PeriodicContextReport >
  PeriodicContextReport_ (const ::std::string& u,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::PeriodicContextReport > (
      ::MDM::PeriodicContextReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicContextReport >
  PeriodicContextReport_ (const ::std::string& u,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicContextReport > (
      ::MDM::PeriodicContextReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicContextReport >
  PeriodicContextReport_ (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicContextReport > (
      ::MDM::PeriodicContextReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicContextReport >
  PeriodicContextReport_ (::std::istream& is,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::PeriodicContextReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicContextReport >
  PeriodicContextReport_ (::std::istream& is,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::PeriodicContextReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicContextReport >
  PeriodicContextReport_ (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::PeriodicContextReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicContextReport >
  PeriodicContextReport_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::PeriodicContextReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicContextReport >
  PeriodicContextReport_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::PeriodicContextReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicContextReport >
  PeriodicContextReport_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::PeriodicContextReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicContextReport >
  PeriodicContextReport_ (::xercesc::InputSource& i,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::PeriodicContextReport > (
      ::MDM::PeriodicContextReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicContextReport >
  PeriodicContextReport_ (::xercesc::InputSource& i,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicContextReport > (
      ::MDM::PeriodicContextReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicContextReport >
  PeriodicContextReport_ (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicContextReport > (
      ::MDM::PeriodicContextReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicContextReport >
  PeriodicContextReport_ (const ::xercesc::DOMDocument& doc,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::PeriodicContextReport > (
        ::MDM::PeriodicContextReport_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "PeriodicContextReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::PeriodicContextReport > r (
        ::xsd::cxx::tree::traits< ::MDM::PeriodicContextReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PeriodicContextReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::PeriodicContextReport >
  PeriodicContextReport_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "PeriodicContextReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::PeriodicContextReport > r (
        ::xsd::cxx::tree::traits< ::MDM::PeriodicContextReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PeriodicContextReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::EpisodicContextReport >
  EpisodicContextReport_ (const ::std::string& u,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::EpisodicContextReport > (
      ::MDM::EpisodicContextReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicContextReport >
  EpisodicContextReport_ (const ::std::string& u,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicContextReport > (
      ::MDM::EpisodicContextReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicContextReport >
  EpisodicContextReport_ (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicContextReport > (
      ::MDM::EpisodicContextReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicContextReport >
  EpisodicContextReport_ (::std::istream& is,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::EpisodicContextReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicContextReport >
  EpisodicContextReport_ (::std::istream& is,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::EpisodicContextReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicContextReport >
  EpisodicContextReport_ (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::EpisodicContextReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicContextReport >
  EpisodicContextReport_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::EpisodicContextReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicContextReport >
  EpisodicContextReport_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::EpisodicContextReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicContextReport >
  EpisodicContextReport_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::EpisodicContextReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicContextReport >
  EpisodicContextReport_ (::xercesc::InputSource& i,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::EpisodicContextReport > (
      ::MDM::EpisodicContextReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicContextReport >
  EpisodicContextReport_ (::xercesc::InputSource& i,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicContextReport > (
      ::MDM::EpisodicContextReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicContextReport >
  EpisodicContextReport_ (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicContextReport > (
      ::MDM::EpisodicContextReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicContextReport >
  EpisodicContextReport_ (const ::xercesc::DOMDocument& doc,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::EpisodicContextReport > (
        ::MDM::EpisodicContextReport_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EpisodicContextReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::EpisodicContextReport > r (
        ::xsd::cxx::tree::traits< ::MDM::EpisodicContextReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EpisodicContextReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::EpisodicContextReport >
  EpisodicContextReport_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EpisodicContextReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::EpisodicContextReport > r (
        ::xsd::cxx::tree::traits< ::MDM::EpisodicContextReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EpisodicContextReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetLocalizedText >
  GetLocalizedText_ (const ::std::string& u,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetLocalizedText > (
      ::MDM::GetLocalizedText_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetLocalizedText >
  GetLocalizedText_ (const ::std::string& u,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetLocalizedText > (
      ::MDM::GetLocalizedText_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetLocalizedText >
  GetLocalizedText_ (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetLocalizedText > (
      ::MDM::GetLocalizedText_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetLocalizedText >
  GetLocalizedText_ (::std::istream& is,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetLocalizedText_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetLocalizedText >
  GetLocalizedText_ (::std::istream& is,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetLocalizedText_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetLocalizedText >
  GetLocalizedText_ (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetLocalizedText_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetLocalizedText >
  GetLocalizedText_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetLocalizedText_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetLocalizedText >
  GetLocalizedText_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetLocalizedText_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetLocalizedText >
  GetLocalizedText_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetLocalizedText_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetLocalizedText >
  GetLocalizedText_ (::xercesc::InputSource& i,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetLocalizedText > (
      ::MDM::GetLocalizedText_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetLocalizedText >
  GetLocalizedText_ (::xercesc::InputSource& i,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetLocalizedText > (
      ::MDM::GetLocalizedText_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetLocalizedText >
  GetLocalizedText_ (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetLocalizedText > (
      ::MDM::GetLocalizedText_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetLocalizedText >
  GetLocalizedText_ (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetLocalizedText > (
        ::MDM::GetLocalizedText_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetLocalizedText" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetLocalizedText > r (
        ::xsd::cxx::tree::traits< ::MDM::GetLocalizedText, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetLocalizedText",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetLocalizedText >
  GetLocalizedText_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetLocalizedText" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetLocalizedText > r (
        ::xsd::cxx::tree::traits< ::MDM::GetLocalizedText, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetLocalizedText",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetLocalizedTextResponse >
  GetLocalizedTextResponse_ (const ::std::string& u,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetLocalizedTextResponse > (
      ::MDM::GetLocalizedTextResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetLocalizedTextResponse >
  GetLocalizedTextResponse_ (const ::std::string& u,
                             ::xml_schema::ErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetLocalizedTextResponse > (
      ::MDM::GetLocalizedTextResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetLocalizedTextResponse >
  GetLocalizedTextResponse_ (const ::std::string& u,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetLocalizedTextResponse > (
      ::MDM::GetLocalizedTextResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetLocalizedTextResponse >
  GetLocalizedTextResponse_ (::std::istream& is,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetLocalizedTextResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetLocalizedTextResponse >
  GetLocalizedTextResponse_ (::std::istream& is,
                             ::xml_schema::ErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetLocalizedTextResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetLocalizedTextResponse >
  GetLocalizedTextResponse_ (::std::istream& is,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetLocalizedTextResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetLocalizedTextResponse >
  GetLocalizedTextResponse_ (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetLocalizedTextResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetLocalizedTextResponse >
  GetLocalizedTextResponse_ (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::ErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetLocalizedTextResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetLocalizedTextResponse >
  GetLocalizedTextResponse_ (::std::istream& is,
                             const ::std::string& sid,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetLocalizedTextResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetLocalizedTextResponse >
  GetLocalizedTextResponse_ (::xercesc::InputSource& i,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetLocalizedTextResponse > (
      ::MDM::GetLocalizedTextResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetLocalizedTextResponse >
  GetLocalizedTextResponse_ (::xercesc::InputSource& i,
                             ::xml_schema::ErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetLocalizedTextResponse > (
      ::MDM::GetLocalizedTextResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetLocalizedTextResponse >
  GetLocalizedTextResponse_ (::xercesc::InputSource& i,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetLocalizedTextResponse > (
      ::MDM::GetLocalizedTextResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetLocalizedTextResponse >
  GetLocalizedTextResponse_ (const ::xercesc::DOMDocument& doc,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetLocalizedTextResponse > (
        ::MDM::GetLocalizedTextResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetLocalizedTextResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetLocalizedTextResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetLocalizedTextResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetLocalizedTextResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetLocalizedTextResponse >
  GetLocalizedTextResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                             ::xml_schema::Flags f,
                             const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetLocalizedTextResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetLocalizedTextResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetLocalizedTextResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetLocalizedTextResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguages >
  GetSupportedLanguages_ (const ::std::string& u,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetSupportedLanguages > (
      ::MDM::GetSupportedLanguages_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguages >
  GetSupportedLanguages_ (const ::std::string& u,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetSupportedLanguages > (
      ::MDM::GetSupportedLanguages_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguages >
  GetSupportedLanguages_ (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetSupportedLanguages > (
      ::MDM::GetSupportedLanguages_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguages >
  GetSupportedLanguages_ (::std::istream& is,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetSupportedLanguages_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguages >
  GetSupportedLanguages_ (::std::istream& is,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetSupportedLanguages_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguages >
  GetSupportedLanguages_ (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetSupportedLanguages_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguages >
  GetSupportedLanguages_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetSupportedLanguages_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguages >
  GetSupportedLanguages_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetSupportedLanguages_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguages >
  GetSupportedLanguages_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetSupportedLanguages_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguages >
  GetSupportedLanguages_ (::xercesc::InputSource& i,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetSupportedLanguages > (
      ::MDM::GetSupportedLanguages_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguages >
  GetSupportedLanguages_ (::xercesc::InputSource& i,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetSupportedLanguages > (
      ::MDM::GetSupportedLanguages_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguages >
  GetSupportedLanguages_ (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetSupportedLanguages > (
      ::MDM::GetSupportedLanguages_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguages >
  GetSupportedLanguages_ (const ::xercesc::DOMDocument& doc,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetSupportedLanguages > (
        ::MDM::GetSupportedLanguages_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetSupportedLanguages" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetSupportedLanguages > r (
        ::xsd::cxx::tree::traits< ::MDM::GetSupportedLanguages, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetSupportedLanguages",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguages >
  GetSupportedLanguages_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetSupportedLanguages" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetSupportedLanguages > r (
        ::xsd::cxx::tree::traits< ::MDM::GetSupportedLanguages, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetSupportedLanguages",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse >
  GetSupportedLanguagesResponse_ (const ::std::string& u,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse > (
      ::MDM::GetSupportedLanguagesResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse >
  GetSupportedLanguagesResponse_ (const ::std::string& u,
                                  ::xml_schema::ErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse > (
      ::MDM::GetSupportedLanguagesResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse >
  GetSupportedLanguagesResponse_ (const ::std::string& u,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse > (
      ::MDM::GetSupportedLanguagesResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse >
  GetSupportedLanguagesResponse_ (::std::istream& is,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetSupportedLanguagesResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse >
  GetSupportedLanguagesResponse_ (::std::istream& is,
                                  ::xml_schema::ErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetSupportedLanguagesResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse >
  GetSupportedLanguagesResponse_ (::std::istream& is,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetSupportedLanguagesResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse >
  GetSupportedLanguagesResponse_ (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetSupportedLanguagesResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse >
  GetSupportedLanguagesResponse_ (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::ErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetSupportedLanguagesResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse >
  GetSupportedLanguagesResponse_ (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetSupportedLanguagesResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse >
  GetSupportedLanguagesResponse_ (::xercesc::InputSource& i,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse > (
      ::MDM::GetSupportedLanguagesResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse >
  GetSupportedLanguagesResponse_ (::xercesc::InputSource& i,
                                  ::xml_schema::ErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse > (
      ::MDM::GetSupportedLanguagesResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse >
  GetSupportedLanguagesResponse_ (::xercesc::InputSource& i,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse > (
      ::MDM::GetSupportedLanguagesResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse >
  GetSupportedLanguagesResponse_ (const ::xercesc::DOMDocument& doc,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse > (
        ::MDM::GetSupportedLanguagesResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetSupportedLanguagesResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetSupportedLanguagesResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetSupportedLanguagesResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse >
  GetSupportedLanguagesResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetSupportedLanguagesResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetSupportedLanguagesResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetSupportedLanguagesResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetSupportedLanguagesResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive >
  GetDescriptorsFromArchive_ (const ::std::string& u,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive > (
      ::MDM::GetDescriptorsFromArchive_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive >
  GetDescriptorsFromArchive_ (const ::std::string& u,
                              ::xml_schema::ErrorHandler& h,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive > (
      ::MDM::GetDescriptorsFromArchive_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive >
  GetDescriptorsFromArchive_ (const ::std::string& u,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive > (
      ::MDM::GetDescriptorsFromArchive_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive >
  GetDescriptorsFromArchive_ (::std::istream& is,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetDescriptorsFromArchive_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive >
  GetDescriptorsFromArchive_ (::std::istream& is,
                              ::xml_schema::ErrorHandler& h,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetDescriptorsFromArchive_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive >
  GetDescriptorsFromArchive_ (::std::istream& is,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetDescriptorsFromArchive_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive >
  GetDescriptorsFromArchive_ (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetDescriptorsFromArchive_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive >
  GetDescriptorsFromArchive_ (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::ErrorHandler& h,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetDescriptorsFromArchive_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive >
  GetDescriptorsFromArchive_ (::std::istream& is,
                              const ::std::string& sid,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetDescriptorsFromArchive_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive >
  GetDescriptorsFromArchive_ (::xercesc::InputSource& i,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive > (
      ::MDM::GetDescriptorsFromArchive_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive >
  GetDescriptorsFromArchive_ (::xercesc::InputSource& i,
                              ::xml_schema::ErrorHandler& h,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive > (
      ::MDM::GetDescriptorsFromArchive_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive >
  GetDescriptorsFromArchive_ (::xercesc::InputSource& i,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive > (
      ::MDM::GetDescriptorsFromArchive_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive >
  GetDescriptorsFromArchive_ (const ::xercesc::DOMDocument& doc,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive > (
        ::MDM::GetDescriptorsFromArchive_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetDescriptorsFromArchive" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive > r (
        ::xsd::cxx::tree::traits< ::MDM::GetDescriptorsFromArchive, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetDescriptorsFromArchive",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive >
  GetDescriptorsFromArchive_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetDescriptorsFromArchive" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetDescriptorsFromArchive > r (
        ::xsd::cxx::tree::traits< ::MDM::GetDescriptorsFromArchive, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetDescriptorsFromArchive",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse >
  GetDescriptorsFromArchiveResponse_ (const ::std::string& u,
                                      ::xml_schema::Flags f,
                                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse > (
      ::MDM::GetDescriptorsFromArchiveResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse >
  GetDescriptorsFromArchiveResponse_ (const ::std::string& u,
                                      ::xml_schema::ErrorHandler& h,
                                      ::xml_schema::Flags f,
                                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse > (
      ::MDM::GetDescriptorsFromArchiveResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse >
  GetDescriptorsFromArchiveResponse_ (const ::std::string& u,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::Flags f,
                                      const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse > (
      ::MDM::GetDescriptorsFromArchiveResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse >
  GetDescriptorsFromArchiveResponse_ (::std::istream& is,
                                      ::xml_schema::Flags f,
                                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetDescriptorsFromArchiveResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse >
  GetDescriptorsFromArchiveResponse_ (::std::istream& is,
                                      ::xml_schema::ErrorHandler& h,
                                      ::xml_schema::Flags f,
                                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetDescriptorsFromArchiveResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse >
  GetDescriptorsFromArchiveResponse_ (::std::istream& is,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::Flags f,
                                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetDescriptorsFromArchiveResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse >
  GetDescriptorsFromArchiveResponse_ (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::Flags f,
                                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetDescriptorsFromArchiveResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse >
  GetDescriptorsFromArchiveResponse_ (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::ErrorHandler& h,
                                      ::xml_schema::Flags f,
                                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetDescriptorsFromArchiveResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse >
  GetDescriptorsFromArchiveResponse_ (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::Flags f,
                                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetDescriptorsFromArchiveResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse >
  GetDescriptorsFromArchiveResponse_ (::xercesc::InputSource& i,
                                      ::xml_schema::Flags f,
                                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse > (
      ::MDM::GetDescriptorsFromArchiveResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse >
  GetDescriptorsFromArchiveResponse_ (::xercesc::InputSource& i,
                                      ::xml_schema::ErrorHandler& h,
                                      ::xml_schema::Flags f,
                                      const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse > (
      ::MDM::GetDescriptorsFromArchiveResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse >
  GetDescriptorsFromArchiveResponse_ (::xercesc::InputSource& i,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::Flags f,
                                      const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse > (
      ::MDM::GetDescriptorsFromArchiveResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse >
  GetDescriptorsFromArchiveResponse_ (const ::xercesc::DOMDocument& doc,
                                      ::xml_schema::Flags f,
                                      const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse > (
        ::MDM::GetDescriptorsFromArchiveResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetDescriptorsFromArchiveResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetDescriptorsFromArchiveResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetDescriptorsFromArchiveResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse >
  GetDescriptorsFromArchiveResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                                      ::xml_schema::Flags f,
                                      const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetDescriptorsFromArchiveResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetDescriptorsFromArchiveResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetDescriptorsFromArchiveResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetDescriptorsFromArchiveResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchive >
  GetStatesFromArchive_ (const ::std::string& u,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetStatesFromArchive > (
      ::MDM::GetStatesFromArchive_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchive >
  GetStatesFromArchive_ (const ::std::string& u,
                         ::xml_schema::ErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetStatesFromArchive > (
      ::MDM::GetStatesFromArchive_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchive >
  GetStatesFromArchive_ (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetStatesFromArchive > (
      ::MDM::GetStatesFromArchive_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchive >
  GetStatesFromArchive_ (::std::istream& is,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetStatesFromArchive_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchive >
  GetStatesFromArchive_ (::std::istream& is,
                         ::xml_schema::ErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetStatesFromArchive_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchive >
  GetStatesFromArchive_ (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetStatesFromArchive_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchive >
  GetStatesFromArchive_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetStatesFromArchive_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchive >
  GetStatesFromArchive_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::ErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetStatesFromArchive_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchive >
  GetStatesFromArchive_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetStatesFromArchive_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchive >
  GetStatesFromArchive_ (::xercesc::InputSource& i,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetStatesFromArchive > (
      ::MDM::GetStatesFromArchive_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchive >
  GetStatesFromArchive_ (::xercesc::InputSource& i,
                         ::xml_schema::ErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetStatesFromArchive > (
      ::MDM::GetStatesFromArchive_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchive >
  GetStatesFromArchive_ (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetStatesFromArchive > (
      ::MDM::GetStatesFromArchive_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchive >
  GetStatesFromArchive_ (const ::xercesc::DOMDocument& doc,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetStatesFromArchive > (
        ::MDM::GetStatesFromArchive_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetStatesFromArchive" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetStatesFromArchive > r (
        ::xsd::cxx::tree::traits< ::MDM::GetStatesFromArchive, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetStatesFromArchive",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchive >
  GetStatesFromArchive_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetStatesFromArchive" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetStatesFromArchive > r (
        ::xsd::cxx::tree::traits< ::MDM::GetStatesFromArchive, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetStatesFromArchive",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse >
  GetStatesFromArchiveResponse_ (const ::std::string& u,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse > (
      ::MDM::GetStatesFromArchiveResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse >
  GetStatesFromArchiveResponse_ (const ::std::string& u,
                                 ::xml_schema::ErrorHandler& h,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse > (
      ::MDM::GetStatesFromArchiveResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse >
  GetStatesFromArchiveResponse_ (const ::std::string& u,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse > (
      ::MDM::GetStatesFromArchiveResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse >
  GetStatesFromArchiveResponse_ (::std::istream& is,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetStatesFromArchiveResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse >
  GetStatesFromArchiveResponse_ (::std::istream& is,
                                 ::xml_schema::ErrorHandler& h,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetStatesFromArchiveResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse >
  GetStatesFromArchiveResponse_ (::std::istream& is,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetStatesFromArchiveResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse >
  GetStatesFromArchiveResponse_ (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetStatesFromArchiveResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse >
  GetStatesFromArchiveResponse_ (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::ErrorHandler& h,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetStatesFromArchiveResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse >
  GetStatesFromArchiveResponse_ (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetStatesFromArchiveResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse >
  GetStatesFromArchiveResponse_ (::xercesc::InputSource& i,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse > (
      ::MDM::GetStatesFromArchiveResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse >
  GetStatesFromArchiveResponse_ (::xercesc::InputSource& i,
                                 ::xml_schema::ErrorHandler& h,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse > (
      ::MDM::GetStatesFromArchiveResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse >
  GetStatesFromArchiveResponse_ (::xercesc::InputSource& i,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse > (
      ::MDM::GetStatesFromArchiveResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse >
  GetStatesFromArchiveResponse_ (const ::xercesc::DOMDocument& doc,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse > (
        ::MDM::GetStatesFromArchiveResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetStatesFromArchiveResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetStatesFromArchiveResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetStatesFromArchiveResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse >
  GetStatesFromArchiveResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                                 ::xml_schema::Flags f,
                                 const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetStatesFromArchiveResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetStatesFromArchiveResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetStatesFromArchiveResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetStatesFromArchiveResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetValue >
  SetValue_ (const ::std::string& u,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetValue > (
      ::MDM::SetValue_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetValue >
  SetValue_ (const ::std::string& u,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetValue > (
      ::MDM::SetValue_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetValue >
  SetValue_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetValue > (
      ::MDM::SetValue_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetValue >
  SetValue_ (::std::istream& is,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetValue_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetValue >
  SetValue_ (::std::istream& is,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetValue_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetValue >
  SetValue_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetValue_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetValue >
  SetValue_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetValue_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetValue >
  SetValue_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetValue_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetValue >
  SetValue_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetValue_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetValue >
  SetValue_ (::xercesc::InputSource& i,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetValue > (
      ::MDM::SetValue_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetValue >
  SetValue_ (::xercesc::InputSource& i,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetValue > (
      ::MDM::SetValue_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetValue >
  SetValue_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetValue > (
      ::MDM::SetValue_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetValue >
  SetValue_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::SetValue > (
        ::MDM::SetValue_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetValue" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetValue > r (
        ::xsd::cxx::tree::traits< ::MDM::SetValue, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetValue",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetValue >
  SetValue_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SetValue" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetValue > r (
        ::xsd::cxx::tree::traits< ::MDM::SetValue, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetValue",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetValueResponse >
  SetValueResponse_ (const ::std::string& u,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetValueResponse > (
      ::MDM::SetValueResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetValueResponse >
  SetValueResponse_ (const ::std::string& u,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetValueResponse > (
      ::MDM::SetValueResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetValueResponse >
  SetValueResponse_ (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetValueResponse > (
      ::MDM::SetValueResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetValueResponse >
  SetValueResponse_ (::std::istream& is,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetValueResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetValueResponse >
  SetValueResponse_ (::std::istream& is,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetValueResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetValueResponse >
  SetValueResponse_ (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetValueResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetValueResponse >
  SetValueResponse_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetValueResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetValueResponse >
  SetValueResponse_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetValueResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetValueResponse >
  SetValueResponse_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetValueResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetValueResponse >
  SetValueResponse_ (::xercesc::InputSource& i,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetValueResponse > (
      ::MDM::SetValueResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetValueResponse >
  SetValueResponse_ (::xercesc::InputSource& i,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetValueResponse > (
      ::MDM::SetValueResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetValueResponse >
  SetValueResponse_ (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetValueResponse > (
      ::MDM::SetValueResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetValueResponse >
  SetValueResponse_ (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::SetValueResponse > (
        ::MDM::SetValueResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetValueResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetValueResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::SetValueResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetValueResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetValueResponse >
  SetValueResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SetValueResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetValueResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::SetValueResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetValueResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetString >
  SetString_ (const ::std::string& u,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetString > (
      ::MDM::SetString_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetString >
  SetString_ (const ::std::string& u,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetString > (
      ::MDM::SetString_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetString >
  SetString_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetString > (
      ::MDM::SetString_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetString >
  SetString_ (::std::istream& is,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetString_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetString >
  SetString_ (::std::istream& is,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetString_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetString >
  SetString_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetString_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetString >
  SetString_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetString_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetString >
  SetString_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetString_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetString >
  SetString_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetString_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetString >
  SetString_ (::xercesc::InputSource& i,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetString > (
      ::MDM::SetString_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetString >
  SetString_ (::xercesc::InputSource& i,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetString > (
      ::MDM::SetString_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetString >
  SetString_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetString > (
      ::MDM::SetString_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetString >
  SetString_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::SetString > (
        ::MDM::SetString_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetString" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetString > r (
        ::xsd::cxx::tree::traits< ::MDM::SetString, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetString",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetString >
  SetString_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SetString" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetString > r (
        ::xsd::cxx::tree::traits< ::MDM::SetString, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetString",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetStringResponse >
  SetStringResponse_ (const ::std::string& u,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetStringResponse > (
      ::MDM::SetStringResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetStringResponse >
  SetStringResponse_ (const ::std::string& u,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetStringResponse > (
      ::MDM::SetStringResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetStringResponse >
  SetStringResponse_ (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetStringResponse > (
      ::MDM::SetStringResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetStringResponse >
  SetStringResponse_ (::std::istream& is,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetStringResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetStringResponse >
  SetStringResponse_ (::std::istream& is,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetStringResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetStringResponse >
  SetStringResponse_ (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetStringResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetStringResponse >
  SetStringResponse_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetStringResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetStringResponse >
  SetStringResponse_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetStringResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetStringResponse >
  SetStringResponse_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetStringResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetStringResponse >
  SetStringResponse_ (::xercesc::InputSource& i,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetStringResponse > (
      ::MDM::SetStringResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetStringResponse >
  SetStringResponse_ (::xercesc::InputSource& i,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetStringResponse > (
      ::MDM::SetStringResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetStringResponse >
  SetStringResponse_ (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetStringResponse > (
      ::MDM::SetStringResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetStringResponse >
  SetStringResponse_ (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::SetStringResponse > (
        ::MDM::SetStringResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetStringResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetStringResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::SetStringResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetStringResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetStringResponse >
  SetStringResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SetStringResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetStringResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::SetStringResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetStringResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::Activate >
  Activate_ (const ::std::string& u,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::Activate > (
      ::MDM::Activate_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::Activate >
  Activate_ (const ::std::string& u,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::Activate > (
      ::MDM::Activate_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::Activate >
  Activate_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::Activate > (
      ::MDM::Activate_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::Activate >
  Activate_ (::std::istream& is,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::Activate_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::Activate >
  Activate_ (::std::istream& is,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::Activate_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::Activate >
  Activate_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::Activate_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::Activate >
  Activate_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::Activate_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::Activate >
  Activate_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::Activate_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::Activate >
  Activate_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::Activate_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::Activate >
  Activate_ (::xercesc::InputSource& i,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::Activate > (
      ::MDM::Activate_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::Activate >
  Activate_ (::xercesc::InputSource& i,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::Activate > (
      ::MDM::Activate_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::Activate >
  Activate_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::Activate > (
      ::MDM::Activate_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::Activate >
  Activate_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::Activate > (
        ::MDM::Activate_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Activate" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::Activate > r (
        ::xsd::cxx::tree::traits< ::MDM::Activate, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Activate",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::Activate >
  Activate_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Activate" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::Activate > r (
        ::xsd::cxx::tree::traits< ::MDM::Activate, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Activate",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::ActivateResponse >
  ActivateResponse_ (const ::std::string& u,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::ActivateResponse > (
      ::MDM::ActivateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::ActivateResponse >
  ActivateResponse_ (const ::std::string& u,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::ActivateResponse > (
      ::MDM::ActivateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::ActivateResponse >
  ActivateResponse_ (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::ActivateResponse > (
      ::MDM::ActivateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::ActivateResponse >
  ActivateResponse_ (::std::istream& is,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::ActivateResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::ActivateResponse >
  ActivateResponse_ (::std::istream& is,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::ActivateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::ActivateResponse >
  ActivateResponse_ (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::ActivateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::ActivateResponse >
  ActivateResponse_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::ActivateResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::ActivateResponse >
  ActivateResponse_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::ActivateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::ActivateResponse >
  ActivateResponse_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::ActivateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::ActivateResponse >
  ActivateResponse_ (::xercesc::InputSource& i,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::ActivateResponse > (
      ::MDM::ActivateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::ActivateResponse >
  ActivateResponse_ (::xercesc::InputSource& i,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::ActivateResponse > (
      ::MDM::ActivateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::ActivateResponse >
  ActivateResponse_ (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::ActivateResponse > (
      ::MDM::ActivateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::ActivateResponse >
  ActivateResponse_ (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::ActivateResponse > (
        ::MDM::ActivateResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ActivateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::ActivateResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::ActivateResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ActivateResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::ActivateResponse >
  ActivateResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ActivateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::ActivateResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::ActivateResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ActivateResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetAlertState >
  SetAlertState_ (const ::std::string& u,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetAlertState > (
      ::MDM::SetAlertState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetAlertState >
  SetAlertState_ (const ::std::string& u,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetAlertState > (
      ::MDM::SetAlertState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetAlertState >
  SetAlertState_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetAlertState > (
      ::MDM::SetAlertState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetAlertState >
  SetAlertState_ (::std::istream& is,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetAlertState_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetAlertState >
  SetAlertState_ (::std::istream& is,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetAlertState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetAlertState >
  SetAlertState_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetAlertState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetAlertState >
  SetAlertState_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetAlertState_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetAlertState >
  SetAlertState_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetAlertState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetAlertState >
  SetAlertState_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetAlertState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetAlertState >
  SetAlertState_ (::xercesc::InputSource& i,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetAlertState > (
      ::MDM::SetAlertState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetAlertState >
  SetAlertState_ (::xercesc::InputSource& i,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetAlertState > (
      ::MDM::SetAlertState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetAlertState >
  SetAlertState_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetAlertState > (
      ::MDM::SetAlertState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetAlertState >
  SetAlertState_ (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::SetAlertState > (
        ::MDM::SetAlertState_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetAlertState" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetAlertState > r (
        ::xsd::cxx::tree::traits< ::MDM::SetAlertState, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetAlertState",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetAlertState >
  SetAlertState_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SetAlertState" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetAlertState > r (
        ::xsd::cxx::tree::traits< ::MDM::SetAlertState, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetAlertState",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetAlertStateResponse >
  SetAlertStateResponse_ (const ::std::string& u,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetAlertStateResponse > (
      ::MDM::SetAlertStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetAlertStateResponse >
  SetAlertStateResponse_ (const ::std::string& u,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetAlertStateResponse > (
      ::MDM::SetAlertStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetAlertStateResponse >
  SetAlertStateResponse_ (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetAlertStateResponse > (
      ::MDM::SetAlertStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetAlertStateResponse >
  SetAlertStateResponse_ (::std::istream& is,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetAlertStateResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetAlertStateResponse >
  SetAlertStateResponse_ (::std::istream& is,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetAlertStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetAlertStateResponse >
  SetAlertStateResponse_ (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetAlertStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetAlertStateResponse >
  SetAlertStateResponse_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetAlertStateResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetAlertStateResponse >
  SetAlertStateResponse_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetAlertStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetAlertStateResponse >
  SetAlertStateResponse_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetAlertStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetAlertStateResponse >
  SetAlertStateResponse_ (::xercesc::InputSource& i,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetAlertStateResponse > (
      ::MDM::SetAlertStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetAlertStateResponse >
  SetAlertStateResponse_ (::xercesc::InputSource& i,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetAlertStateResponse > (
      ::MDM::SetAlertStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetAlertStateResponse >
  SetAlertStateResponse_ (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetAlertStateResponse > (
      ::MDM::SetAlertStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetAlertStateResponse >
  SetAlertStateResponse_ (const ::xercesc::DOMDocument& doc,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::SetAlertStateResponse > (
        ::MDM::SetAlertStateResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetAlertStateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetAlertStateResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::SetAlertStateResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetAlertStateResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetAlertStateResponse >
  SetAlertStateResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SetAlertStateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetAlertStateResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::SetAlertStateResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetAlertStateResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetComponentState >
  SetComponentState_ (const ::std::string& u,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetComponentState > (
      ::MDM::SetComponentState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetComponentState >
  SetComponentState_ (const ::std::string& u,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetComponentState > (
      ::MDM::SetComponentState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetComponentState >
  SetComponentState_ (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetComponentState > (
      ::MDM::SetComponentState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetComponentState >
  SetComponentState_ (::std::istream& is,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetComponentState_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetComponentState >
  SetComponentState_ (::std::istream& is,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetComponentState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetComponentState >
  SetComponentState_ (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetComponentState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetComponentState >
  SetComponentState_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetComponentState_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetComponentState >
  SetComponentState_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetComponentState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetComponentState >
  SetComponentState_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetComponentState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetComponentState >
  SetComponentState_ (::xercesc::InputSource& i,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetComponentState > (
      ::MDM::SetComponentState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetComponentState >
  SetComponentState_ (::xercesc::InputSource& i,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetComponentState > (
      ::MDM::SetComponentState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetComponentState >
  SetComponentState_ (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetComponentState > (
      ::MDM::SetComponentState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetComponentState >
  SetComponentState_ (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::SetComponentState > (
        ::MDM::SetComponentState_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetComponentState" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetComponentState > r (
        ::xsd::cxx::tree::traits< ::MDM::SetComponentState, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetComponentState",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetComponentState >
  SetComponentState_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SetComponentState" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetComponentState > r (
        ::xsd::cxx::tree::traits< ::MDM::SetComponentState, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetComponentState",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetComponentStateResponse >
  SetComponentStateResponse_ (const ::std::string& u,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetComponentStateResponse > (
      ::MDM::SetComponentStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetComponentStateResponse >
  SetComponentStateResponse_ (const ::std::string& u,
                              ::xml_schema::ErrorHandler& h,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetComponentStateResponse > (
      ::MDM::SetComponentStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetComponentStateResponse >
  SetComponentStateResponse_ (const ::std::string& u,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetComponentStateResponse > (
      ::MDM::SetComponentStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetComponentStateResponse >
  SetComponentStateResponse_ (::std::istream& is,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetComponentStateResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetComponentStateResponse >
  SetComponentStateResponse_ (::std::istream& is,
                              ::xml_schema::ErrorHandler& h,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetComponentStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetComponentStateResponse >
  SetComponentStateResponse_ (::std::istream& is,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetComponentStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetComponentStateResponse >
  SetComponentStateResponse_ (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetComponentStateResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetComponentStateResponse >
  SetComponentStateResponse_ (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::ErrorHandler& h,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetComponentStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetComponentStateResponse >
  SetComponentStateResponse_ (::std::istream& is,
                              const ::std::string& sid,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetComponentStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetComponentStateResponse >
  SetComponentStateResponse_ (::xercesc::InputSource& i,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetComponentStateResponse > (
      ::MDM::SetComponentStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetComponentStateResponse >
  SetComponentStateResponse_ (::xercesc::InputSource& i,
                              ::xml_schema::ErrorHandler& h,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetComponentStateResponse > (
      ::MDM::SetComponentStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetComponentStateResponse >
  SetComponentStateResponse_ (::xercesc::InputSource& i,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetComponentStateResponse > (
      ::MDM::SetComponentStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetComponentStateResponse >
  SetComponentStateResponse_ (const ::xercesc::DOMDocument& doc,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::SetComponentStateResponse > (
        ::MDM::SetComponentStateResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetComponentStateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetComponentStateResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::SetComponentStateResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetComponentStateResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetComponentStateResponse >
  SetComponentStateResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                              ::xml_schema::Flags f,
                              const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SetComponentStateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetComponentStateResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::SetComponentStateResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetComponentStateResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetMetricState >
  SetMetricState_ (const ::std::string& u,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetMetricState > (
      ::MDM::SetMetricState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetMetricState >
  SetMetricState_ (const ::std::string& u,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetMetricState > (
      ::MDM::SetMetricState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetMetricState >
  SetMetricState_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetMetricState > (
      ::MDM::SetMetricState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetMetricState >
  SetMetricState_ (::std::istream& is,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetMetricState_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetMetricState >
  SetMetricState_ (::std::istream& is,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetMetricState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetMetricState >
  SetMetricState_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetMetricState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetMetricState >
  SetMetricState_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetMetricState_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetMetricState >
  SetMetricState_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetMetricState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetMetricState >
  SetMetricState_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetMetricState_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetMetricState >
  SetMetricState_ (::xercesc::InputSource& i,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetMetricState > (
      ::MDM::SetMetricState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetMetricState >
  SetMetricState_ (::xercesc::InputSource& i,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetMetricState > (
      ::MDM::SetMetricState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetMetricState >
  SetMetricState_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetMetricState > (
      ::MDM::SetMetricState_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetMetricState >
  SetMetricState_ (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::SetMetricState > (
        ::MDM::SetMetricState_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetMetricState" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetMetricState > r (
        ::xsd::cxx::tree::traits< ::MDM::SetMetricState, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetMetricState",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetMetricState >
  SetMetricState_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SetMetricState" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetMetricState > r (
        ::xsd::cxx::tree::traits< ::MDM::SetMetricState, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetMetricState",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetMetricStateResponse >
  SetMetricStateResponse_ (const ::std::string& u,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetMetricStateResponse > (
      ::MDM::SetMetricStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetMetricStateResponse >
  SetMetricStateResponse_ (const ::std::string& u,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetMetricStateResponse > (
      ::MDM::SetMetricStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetMetricStateResponse >
  SetMetricStateResponse_ (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetMetricStateResponse > (
      ::MDM::SetMetricStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetMetricStateResponse >
  SetMetricStateResponse_ (::std::istream& is,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetMetricStateResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetMetricStateResponse >
  SetMetricStateResponse_ (::std::istream& is,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetMetricStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetMetricStateResponse >
  SetMetricStateResponse_ (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SetMetricStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetMetricStateResponse >
  SetMetricStateResponse_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetMetricStateResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SetMetricStateResponse >
  SetMetricStateResponse_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetMetricStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetMetricStateResponse >
  SetMetricStateResponse_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SetMetricStateResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SetMetricStateResponse >
  SetMetricStateResponse_ (::xercesc::InputSource& i,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SetMetricStateResponse > (
      ::MDM::SetMetricStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetMetricStateResponse >
  SetMetricStateResponse_ (::xercesc::InputSource& i,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetMetricStateResponse > (
      ::MDM::SetMetricStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetMetricStateResponse >
  SetMetricStateResponse_ (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SetMetricStateResponse > (
      ::MDM::SetMetricStateResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SetMetricStateResponse >
  SetMetricStateResponse_ (const ::xercesc::DOMDocument& doc,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::SetMetricStateResponse > (
        ::MDM::SetMetricStateResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetMetricStateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetMetricStateResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::SetMetricStateResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetMetricStateResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SetMetricStateResponse >
  SetMetricStateResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SetMetricStateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SetMetricStateResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::SetMetricStateResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SetMetricStateResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::OperationInvokedReport >
  OperationInvokedReport_ (const ::std::string& u,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::OperationInvokedReport > (
      ::MDM::OperationInvokedReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::OperationInvokedReport >
  OperationInvokedReport_ (const ::std::string& u,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::OperationInvokedReport > (
      ::MDM::OperationInvokedReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::OperationInvokedReport >
  OperationInvokedReport_ (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::OperationInvokedReport > (
      ::MDM::OperationInvokedReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::OperationInvokedReport >
  OperationInvokedReport_ (::std::istream& is,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::OperationInvokedReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::OperationInvokedReport >
  OperationInvokedReport_ (::std::istream& is,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::OperationInvokedReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::OperationInvokedReport >
  OperationInvokedReport_ (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::OperationInvokedReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::OperationInvokedReport >
  OperationInvokedReport_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::OperationInvokedReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::OperationInvokedReport >
  OperationInvokedReport_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::OperationInvokedReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::OperationInvokedReport >
  OperationInvokedReport_ (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::OperationInvokedReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::OperationInvokedReport >
  OperationInvokedReport_ (::xercesc::InputSource& i,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::OperationInvokedReport > (
      ::MDM::OperationInvokedReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::OperationInvokedReport >
  OperationInvokedReport_ (::xercesc::InputSource& i,
                           ::xml_schema::ErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::OperationInvokedReport > (
      ::MDM::OperationInvokedReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::OperationInvokedReport >
  OperationInvokedReport_ (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::OperationInvokedReport > (
      ::MDM::OperationInvokedReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::OperationInvokedReport >
  OperationInvokedReport_ (const ::xercesc::DOMDocument& doc,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::OperationInvokedReport > (
        ::MDM::OperationInvokedReport_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "OperationInvokedReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::OperationInvokedReport > r (
        ::xsd::cxx::tree::traits< ::MDM::OperationInvokedReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "OperationInvokedReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::OperationInvokedReport >
  OperationInvokedReport_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                           ::xml_schema::Flags f,
                           const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "OperationInvokedReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::OperationInvokedReport > r (
        ::xsd::cxx::tree::traits< ::MDM::OperationInvokedReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "OperationInvokedReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetContainmentTree >
  GetContainmentTree_ (const ::std::string& u,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetContainmentTree > (
      ::MDM::GetContainmentTree_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContainmentTree >
  GetContainmentTree_ (const ::std::string& u,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContainmentTree > (
      ::MDM::GetContainmentTree_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContainmentTree >
  GetContainmentTree_ (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContainmentTree > (
      ::MDM::GetContainmentTree_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContainmentTree >
  GetContainmentTree_ (::std::istream& is,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContainmentTree_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContainmentTree >
  GetContainmentTree_ (::std::istream& is,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContainmentTree_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContainmentTree >
  GetContainmentTree_ (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContainmentTree_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContainmentTree >
  GetContainmentTree_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContainmentTree_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContainmentTree >
  GetContainmentTree_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContainmentTree_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContainmentTree >
  GetContainmentTree_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContainmentTree_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContainmentTree >
  GetContainmentTree_ (::xercesc::InputSource& i,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetContainmentTree > (
      ::MDM::GetContainmentTree_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContainmentTree >
  GetContainmentTree_ (::xercesc::InputSource& i,
                       ::xml_schema::ErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContainmentTree > (
      ::MDM::GetContainmentTree_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContainmentTree >
  GetContainmentTree_ (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContainmentTree > (
      ::MDM::GetContainmentTree_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContainmentTree >
  GetContainmentTree_ (const ::xercesc::DOMDocument& doc,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetContainmentTree > (
        ::MDM::GetContainmentTree_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetContainmentTree" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetContainmentTree > r (
        ::xsd::cxx::tree::traits< ::MDM::GetContainmentTree, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetContainmentTree",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetContainmentTree >
  GetContainmentTree_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                       ::xml_schema::Flags f,
                       const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetContainmentTree" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetContainmentTree > r (
        ::xsd::cxx::tree::traits< ::MDM::GetContainmentTree, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetContainmentTree",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetContainmentTreeResponse >
  GetContainmentTreeResponse_ (const ::std::string& u,
                               ::xml_schema::Flags f,
                               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetContainmentTreeResponse > (
      ::MDM::GetContainmentTreeResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContainmentTreeResponse >
  GetContainmentTreeResponse_ (const ::std::string& u,
                               ::xml_schema::ErrorHandler& h,
                               ::xml_schema::Flags f,
                               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContainmentTreeResponse > (
      ::MDM::GetContainmentTreeResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContainmentTreeResponse >
  GetContainmentTreeResponse_ (const ::std::string& u,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::Flags f,
                               const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContainmentTreeResponse > (
      ::MDM::GetContainmentTreeResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContainmentTreeResponse >
  GetContainmentTreeResponse_ (::std::istream& is,
                               ::xml_schema::Flags f,
                               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContainmentTreeResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContainmentTreeResponse >
  GetContainmentTreeResponse_ (::std::istream& is,
                               ::xml_schema::ErrorHandler& h,
                               ::xml_schema::Flags f,
                               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContainmentTreeResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContainmentTreeResponse >
  GetContainmentTreeResponse_ (::std::istream& is,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::Flags f,
                               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetContainmentTreeResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContainmentTreeResponse >
  GetContainmentTreeResponse_ (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::Flags f,
                               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContainmentTreeResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContainmentTreeResponse >
  GetContainmentTreeResponse_ (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::ErrorHandler& h,
                               ::xml_schema::Flags f,
                               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContainmentTreeResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContainmentTreeResponse >
  GetContainmentTreeResponse_ (::std::istream& is,
                               const ::std::string& sid,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::Flags f,
                               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetContainmentTreeResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetContainmentTreeResponse >
  GetContainmentTreeResponse_ (::xercesc::InputSource& i,
                               ::xml_schema::Flags f,
                               const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetContainmentTreeResponse > (
      ::MDM::GetContainmentTreeResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContainmentTreeResponse >
  GetContainmentTreeResponse_ (::xercesc::InputSource& i,
                               ::xml_schema::ErrorHandler& h,
                               ::xml_schema::Flags f,
                               const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContainmentTreeResponse > (
      ::MDM::GetContainmentTreeResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContainmentTreeResponse >
  GetContainmentTreeResponse_ (::xercesc::InputSource& i,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::Flags f,
                               const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetContainmentTreeResponse > (
      ::MDM::GetContainmentTreeResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetContainmentTreeResponse >
  GetContainmentTreeResponse_ (const ::xercesc::DOMDocument& doc,
                               ::xml_schema::Flags f,
                               const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetContainmentTreeResponse > (
        ::MDM::GetContainmentTreeResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetContainmentTreeResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetContainmentTreeResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetContainmentTreeResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetContainmentTreeResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetContainmentTreeResponse >
  GetContainmentTreeResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                               ::xml_schema::Flags f,
                               const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetContainmentTreeResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetContainmentTreeResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetContainmentTreeResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetContainmentTreeResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetDescriptor >
  GetDescriptor_ (const ::std::string& u,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetDescriptor > (
      ::MDM::GetDescriptor_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptor >
  GetDescriptor_ (const ::std::string& u,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetDescriptor > (
      ::MDM::GetDescriptor_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptor >
  GetDescriptor_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetDescriptor > (
      ::MDM::GetDescriptor_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptor >
  GetDescriptor_ (::std::istream& is,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetDescriptor_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptor >
  GetDescriptor_ (::std::istream& is,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetDescriptor_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptor >
  GetDescriptor_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetDescriptor_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptor >
  GetDescriptor_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetDescriptor_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptor >
  GetDescriptor_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetDescriptor_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptor >
  GetDescriptor_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetDescriptor_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptor >
  GetDescriptor_ (::xercesc::InputSource& i,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetDescriptor > (
      ::MDM::GetDescriptor_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptor >
  GetDescriptor_ (::xercesc::InputSource& i,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetDescriptor > (
      ::MDM::GetDescriptor_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptor >
  GetDescriptor_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetDescriptor > (
      ::MDM::GetDescriptor_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptor >
  GetDescriptor_ (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetDescriptor > (
        ::MDM::GetDescriptor_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetDescriptor" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetDescriptor > r (
        ::xsd::cxx::tree::traits< ::MDM::GetDescriptor, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetDescriptor",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetDescriptor >
  GetDescriptor_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetDescriptor" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetDescriptor > r (
        ::xsd::cxx::tree::traits< ::MDM::GetDescriptor, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetDescriptor",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetDescriptorResponse >
  GetDescriptorResponse_ (const ::std::string& u,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorResponse > (
      ::MDM::GetDescriptorResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorResponse >
  GetDescriptorResponse_ (const ::std::string& u,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorResponse > (
      ::MDM::GetDescriptorResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorResponse >
  GetDescriptorResponse_ (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorResponse > (
      ::MDM::GetDescriptorResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorResponse >
  GetDescriptorResponse_ (::std::istream& is,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetDescriptorResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorResponse >
  GetDescriptorResponse_ (::std::istream& is,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetDescriptorResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorResponse >
  GetDescriptorResponse_ (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::GetDescriptorResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorResponse >
  GetDescriptorResponse_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetDescriptorResponse_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorResponse >
  GetDescriptorResponse_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetDescriptorResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorResponse >
  GetDescriptorResponse_ (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::GetDescriptorResponse_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::GetDescriptorResponse >
  GetDescriptorResponse_ (::xercesc::InputSource& i,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorResponse > (
      ::MDM::GetDescriptorResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorResponse >
  GetDescriptorResponse_ (::xercesc::InputSource& i,
                          ::xml_schema::ErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorResponse > (
      ::MDM::GetDescriptorResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorResponse >
  GetDescriptorResponse_ (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::GetDescriptorResponse > (
      ::MDM::GetDescriptorResponse_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::GetDescriptorResponse >
  GetDescriptorResponse_ (const ::xercesc::DOMDocument& doc,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::GetDescriptorResponse > (
        ::MDM::GetDescriptorResponse_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetDescriptorResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetDescriptorResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetDescriptorResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetDescriptorResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::GetDescriptorResponse >
  GetDescriptorResponse_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                          ::xml_schema::Flags f,
                          const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GetDescriptorResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::GetDescriptorResponse > r (
        ::xsd::cxx::tree::traits< ::MDM::GetDescriptorResponse, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GetDescriptorResponse",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::EpisodicMetricReport >
  EpisodicMetricReport_ (const ::std::string& u,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::EpisodicMetricReport > (
      ::MDM::EpisodicMetricReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicMetricReport >
  EpisodicMetricReport_ (const ::std::string& u,
                         ::xml_schema::ErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicMetricReport > (
      ::MDM::EpisodicMetricReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicMetricReport >
  EpisodicMetricReport_ (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicMetricReport > (
      ::MDM::EpisodicMetricReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicMetricReport >
  EpisodicMetricReport_ (::std::istream& is,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::EpisodicMetricReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicMetricReport >
  EpisodicMetricReport_ (::std::istream& is,
                         ::xml_schema::ErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::EpisodicMetricReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicMetricReport >
  EpisodicMetricReport_ (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::EpisodicMetricReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicMetricReport >
  EpisodicMetricReport_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::EpisodicMetricReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicMetricReport >
  EpisodicMetricReport_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::ErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::EpisodicMetricReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicMetricReport >
  EpisodicMetricReport_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::EpisodicMetricReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicMetricReport >
  EpisodicMetricReport_ (::xercesc::InputSource& i,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::EpisodicMetricReport > (
      ::MDM::EpisodicMetricReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicMetricReport >
  EpisodicMetricReport_ (::xercesc::InputSource& i,
                         ::xml_schema::ErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicMetricReport > (
      ::MDM::EpisodicMetricReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicMetricReport >
  EpisodicMetricReport_ (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicMetricReport > (
      ::MDM::EpisodicMetricReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicMetricReport >
  EpisodicMetricReport_ (const ::xercesc::DOMDocument& doc,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::EpisodicMetricReport > (
        ::MDM::EpisodicMetricReport_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EpisodicMetricReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::EpisodicMetricReport > r (
        ::xsd::cxx::tree::traits< ::MDM::EpisodicMetricReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EpisodicMetricReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::EpisodicMetricReport >
  EpisodicMetricReport_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EpisodicMetricReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::EpisodicMetricReport > r (
        ::xsd::cxx::tree::traits< ::MDM::EpisodicMetricReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EpisodicMetricReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::PeriodicMetricReport >
  PeriodicMetricReport_ (const ::std::string& u,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::PeriodicMetricReport > (
      ::MDM::PeriodicMetricReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicMetricReport >
  PeriodicMetricReport_ (const ::std::string& u,
                         ::xml_schema::ErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicMetricReport > (
      ::MDM::PeriodicMetricReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicMetricReport >
  PeriodicMetricReport_ (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicMetricReport > (
      ::MDM::PeriodicMetricReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicMetricReport >
  PeriodicMetricReport_ (::std::istream& is,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::PeriodicMetricReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicMetricReport >
  PeriodicMetricReport_ (::std::istream& is,
                         ::xml_schema::ErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::PeriodicMetricReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicMetricReport >
  PeriodicMetricReport_ (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::PeriodicMetricReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicMetricReport >
  PeriodicMetricReport_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::PeriodicMetricReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicMetricReport >
  PeriodicMetricReport_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::ErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::PeriodicMetricReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicMetricReport >
  PeriodicMetricReport_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::PeriodicMetricReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicMetricReport >
  PeriodicMetricReport_ (::xercesc::InputSource& i,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::PeriodicMetricReport > (
      ::MDM::PeriodicMetricReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicMetricReport >
  PeriodicMetricReport_ (::xercesc::InputSource& i,
                         ::xml_schema::ErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicMetricReport > (
      ::MDM::PeriodicMetricReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicMetricReport >
  PeriodicMetricReport_ (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicMetricReport > (
      ::MDM::PeriodicMetricReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicMetricReport >
  PeriodicMetricReport_ (const ::xercesc::DOMDocument& doc,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::PeriodicMetricReport > (
        ::MDM::PeriodicMetricReport_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "PeriodicMetricReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::PeriodicMetricReport > r (
        ::xsd::cxx::tree::traits< ::MDM::PeriodicMetricReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PeriodicMetricReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::PeriodicMetricReport >
  PeriodicMetricReport_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                         ::xml_schema::Flags f,
                         const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "PeriodicMetricReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::PeriodicMetricReport > r (
        ::xsd::cxx::tree::traits< ::MDM::PeriodicMetricReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PeriodicMetricReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::EpisodicComponentReport >
  EpisodicComponentReport_ (const ::std::string& u,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::EpisodicComponentReport > (
      ::MDM::EpisodicComponentReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicComponentReport >
  EpisodicComponentReport_ (const ::std::string& u,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicComponentReport > (
      ::MDM::EpisodicComponentReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicComponentReport >
  EpisodicComponentReport_ (const ::std::string& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicComponentReport > (
      ::MDM::EpisodicComponentReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicComponentReport >
  EpisodicComponentReport_ (::std::istream& is,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::EpisodicComponentReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicComponentReport >
  EpisodicComponentReport_ (::std::istream& is,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::EpisodicComponentReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicComponentReport >
  EpisodicComponentReport_ (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::EpisodicComponentReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicComponentReport >
  EpisodicComponentReport_ (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::EpisodicComponentReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicComponentReport >
  EpisodicComponentReport_ (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::EpisodicComponentReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicComponentReport >
  EpisodicComponentReport_ (::std::istream& is,
                            const ::std::string& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::EpisodicComponentReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicComponentReport >
  EpisodicComponentReport_ (::xercesc::InputSource& i,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::EpisodicComponentReport > (
      ::MDM::EpisodicComponentReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicComponentReport >
  EpisodicComponentReport_ (::xercesc::InputSource& i,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicComponentReport > (
      ::MDM::EpisodicComponentReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicComponentReport >
  EpisodicComponentReport_ (::xercesc::InputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicComponentReport > (
      ::MDM::EpisodicComponentReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicComponentReport >
  EpisodicComponentReport_ (const ::xercesc::DOMDocument& doc,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::EpisodicComponentReport > (
        ::MDM::EpisodicComponentReport_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EpisodicComponentReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::EpisodicComponentReport > r (
        ::xsd::cxx::tree::traits< ::MDM::EpisodicComponentReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EpisodicComponentReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::EpisodicComponentReport >
  EpisodicComponentReport_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EpisodicComponentReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::EpisodicComponentReport > r (
        ::xsd::cxx::tree::traits< ::MDM::EpisodicComponentReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EpisodicComponentReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::PeriodicComponentReport >
  PeriodicComponentReport_ (const ::std::string& u,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::PeriodicComponentReport > (
      ::MDM::PeriodicComponentReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicComponentReport >
  PeriodicComponentReport_ (const ::std::string& u,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicComponentReport > (
      ::MDM::PeriodicComponentReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicComponentReport >
  PeriodicComponentReport_ (const ::std::string& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicComponentReport > (
      ::MDM::PeriodicComponentReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicComponentReport >
  PeriodicComponentReport_ (::std::istream& is,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::PeriodicComponentReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicComponentReport >
  PeriodicComponentReport_ (::std::istream& is,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::PeriodicComponentReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicComponentReport >
  PeriodicComponentReport_ (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::PeriodicComponentReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicComponentReport >
  PeriodicComponentReport_ (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::PeriodicComponentReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicComponentReport >
  PeriodicComponentReport_ (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::PeriodicComponentReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicComponentReport >
  PeriodicComponentReport_ (::std::istream& is,
                            const ::std::string& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::PeriodicComponentReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicComponentReport >
  PeriodicComponentReport_ (::xercesc::InputSource& i,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::PeriodicComponentReport > (
      ::MDM::PeriodicComponentReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicComponentReport >
  PeriodicComponentReport_ (::xercesc::InputSource& i,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicComponentReport > (
      ::MDM::PeriodicComponentReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicComponentReport >
  PeriodicComponentReport_ (::xercesc::InputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicComponentReport > (
      ::MDM::PeriodicComponentReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicComponentReport >
  PeriodicComponentReport_ (const ::xercesc::DOMDocument& doc,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::PeriodicComponentReport > (
        ::MDM::PeriodicComponentReport_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "PeriodicComponentReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::PeriodicComponentReport > r (
        ::xsd::cxx::tree::traits< ::MDM::PeriodicComponentReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PeriodicComponentReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::PeriodicComponentReport >
  PeriodicComponentReport_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "PeriodicComponentReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::PeriodicComponentReport > r (
        ::xsd::cxx::tree::traits< ::MDM::PeriodicComponentReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PeriodicComponentReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::EpisodicAlertReport >
  EpisodicAlertReport_ (const ::std::string& u,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::EpisodicAlertReport > (
      ::MDM::EpisodicAlertReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicAlertReport >
  EpisodicAlertReport_ (const ::std::string& u,
                        ::xml_schema::ErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicAlertReport > (
      ::MDM::EpisodicAlertReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicAlertReport >
  EpisodicAlertReport_ (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicAlertReport > (
      ::MDM::EpisodicAlertReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicAlertReport >
  EpisodicAlertReport_ (::std::istream& is,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::EpisodicAlertReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicAlertReport >
  EpisodicAlertReport_ (::std::istream& is,
                        ::xml_schema::ErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::EpisodicAlertReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicAlertReport >
  EpisodicAlertReport_ (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::EpisodicAlertReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicAlertReport >
  EpisodicAlertReport_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::EpisodicAlertReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicAlertReport >
  EpisodicAlertReport_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::ErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::EpisodicAlertReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicAlertReport >
  EpisodicAlertReport_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::EpisodicAlertReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicAlertReport >
  EpisodicAlertReport_ (::xercesc::InputSource& i,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::EpisodicAlertReport > (
      ::MDM::EpisodicAlertReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicAlertReport >
  EpisodicAlertReport_ (::xercesc::InputSource& i,
                        ::xml_schema::ErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicAlertReport > (
      ::MDM::EpisodicAlertReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicAlertReport >
  EpisodicAlertReport_ (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicAlertReport > (
      ::MDM::EpisodicAlertReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicAlertReport >
  EpisodicAlertReport_ (const ::xercesc::DOMDocument& doc,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::EpisodicAlertReport > (
        ::MDM::EpisodicAlertReport_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EpisodicAlertReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::EpisodicAlertReport > r (
        ::xsd::cxx::tree::traits< ::MDM::EpisodicAlertReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EpisodicAlertReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::EpisodicAlertReport >
  EpisodicAlertReport_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EpisodicAlertReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::EpisodicAlertReport > r (
        ::xsd::cxx::tree::traits< ::MDM::EpisodicAlertReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EpisodicAlertReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::PeriodicAlertReport >
  PeriodicAlertReport_ (const ::std::string& u,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::PeriodicAlertReport > (
      ::MDM::PeriodicAlertReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicAlertReport >
  PeriodicAlertReport_ (const ::std::string& u,
                        ::xml_schema::ErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicAlertReport > (
      ::MDM::PeriodicAlertReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicAlertReport >
  PeriodicAlertReport_ (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicAlertReport > (
      ::MDM::PeriodicAlertReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicAlertReport >
  PeriodicAlertReport_ (::std::istream& is,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::PeriodicAlertReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicAlertReport >
  PeriodicAlertReport_ (::std::istream& is,
                        ::xml_schema::ErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::PeriodicAlertReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicAlertReport >
  PeriodicAlertReport_ (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::PeriodicAlertReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicAlertReport >
  PeriodicAlertReport_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::PeriodicAlertReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicAlertReport >
  PeriodicAlertReport_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::ErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::PeriodicAlertReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicAlertReport >
  PeriodicAlertReport_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::PeriodicAlertReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicAlertReport >
  PeriodicAlertReport_ (::xercesc::InputSource& i,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::PeriodicAlertReport > (
      ::MDM::PeriodicAlertReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicAlertReport >
  PeriodicAlertReport_ (::xercesc::InputSource& i,
                        ::xml_schema::ErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicAlertReport > (
      ::MDM::PeriodicAlertReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicAlertReport >
  PeriodicAlertReport_ (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicAlertReport > (
      ::MDM::PeriodicAlertReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicAlertReport >
  PeriodicAlertReport_ (const ::xercesc::DOMDocument& doc,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::PeriodicAlertReport > (
        ::MDM::PeriodicAlertReport_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "PeriodicAlertReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::PeriodicAlertReport > r (
        ::xsd::cxx::tree::traits< ::MDM::PeriodicAlertReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PeriodicAlertReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::PeriodicAlertReport >
  PeriodicAlertReport_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "PeriodicAlertReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::PeriodicAlertReport > r (
        ::xsd::cxx::tree::traits< ::MDM::PeriodicAlertReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PeriodicAlertReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport >
  EpisodicOperationalStateReport_ (const ::std::string& u,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport > (
      ::MDM::EpisodicOperationalStateReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport >
  EpisodicOperationalStateReport_ (const ::std::string& u,
                                   ::xml_schema::ErrorHandler& h,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport > (
      ::MDM::EpisodicOperationalStateReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport >
  EpisodicOperationalStateReport_ (const ::std::string& u,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport > (
      ::MDM::EpisodicOperationalStateReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport >
  EpisodicOperationalStateReport_ (::std::istream& is,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::EpisodicOperationalStateReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport >
  EpisodicOperationalStateReport_ (::std::istream& is,
                                   ::xml_schema::ErrorHandler& h,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::EpisodicOperationalStateReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport >
  EpisodicOperationalStateReport_ (::std::istream& is,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::EpisodicOperationalStateReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport >
  EpisodicOperationalStateReport_ (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::EpisodicOperationalStateReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport >
  EpisodicOperationalStateReport_ (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::ErrorHandler& h,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::EpisodicOperationalStateReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport >
  EpisodicOperationalStateReport_ (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::EpisodicOperationalStateReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport >
  EpisodicOperationalStateReport_ (::xercesc::InputSource& i,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport > (
      ::MDM::EpisodicOperationalStateReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport >
  EpisodicOperationalStateReport_ (::xercesc::InputSource& i,
                                   ::xml_schema::ErrorHandler& h,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport > (
      ::MDM::EpisodicOperationalStateReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport >
  EpisodicOperationalStateReport_ (::xercesc::InputSource& i,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport > (
      ::MDM::EpisodicOperationalStateReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport >
  EpisodicOperationalStateReport_ (const ::xercesc::DOMDocument& doc,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport > (
        ::MDM::EpisodicOperationalStateReport_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EpisodicOperationalStateReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport > r (
        ::xsd::cxx::tree::traits< ::MDM::EpisodicOperationalStateReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EpisodicOperationalStateReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport >
  EpisodicOperationalStateReport_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EpisodicOperationalStateReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::EpisodicOperationalStateReport > r (
        ::xsd::cxx::tree::traits< ::MDM::EpisodicOperationalStateReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EpisodicOperationalStateReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport >
  PeriodicOperationalStateReport_ (const ::std::string& u,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport > (
      ::MDM::PeriodicOperationalStateReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport >
  PeriodicOperationalStateReport_ (const ::std::string& u,
                                   ::xml_schema::ErrorHandler& h,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport > (
      ::MDM::PeriodicOperationalStateReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport >
  PeriodicOperationalStateReport_ (const ::std::string& u,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport > (
      ::MDM::PeriodicOperationalStateReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport >
  PeriodicOperationalStateReport_ (::std::istream& is,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::PeriodicOperationalStateReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport >
  PeriodicOperationalStateReport_ (::std::istream& is,
                                   ::xml_schema::ErrorHandler& h,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::PeriodicOperationalStateReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport >
  PeriodicOperationalStateReport_ (::std::istream& is,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::PeriodicOperationalStateReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport >
  PeriodicOperationalStateReport_ (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::PeriodicOperationalStateReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport >
  PeriodicOperationalStateReport_ (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::ErrorHandler& h,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::PeriodicOperationalStateReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport >
  PeriodicOperationalStateReport_ (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::PeriodicOperationalStateReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport >
  PeriodicOperationalStateReport_ (::xercesc::InputSource& i,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport > (
      ::MDM::PeriodicOperationalStateReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport >
  PeriodicOperationalStateReport_ (::xercesc::InputSource& i,
                                   ::xml_schema::ErrorHandler& h,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport > (
      ::MDM::PeriodicOperationalStateReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport >
  PeriodicOperationalStateReport_ (::xercesc::InputSource& i,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport > (
      ::MDM::PeriodicOperationalStateReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport >
  PeriodicOperationalStateReport_ (const ::xercesc::DOMDocument& doc,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport > (
        ::MDM::PeriodicOperationalStateReport_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "PeriodicOperationalStateReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport > r (
        ::xsd::cxx::tree::traits< ::MDM::PeriodicOperationalStateReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PeriodicOperationalStateReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport >
  PeriodicOperationalStateReport_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                                   ::xml_schema::Flags f,
                                   const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "PeriodicOperationalStateReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::PeriodicOperationalStateReport > r (
        ::xsd::cxx::tree::traits< ::MDM::PeriodicOperationalStateReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PeriodicOperationalStateReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SystemErrorReport >
  SystemErrorReport_ (const ::std::string& u,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SystemErrorReport > (
      ::MDM::SystemErrorReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SystemErrorReport >
  SystemErrorReport_ (const ::std::string& u,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SystemErrorReport > (
      ::MDM::SystemErrorReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SystemErrorReport >
  SystemErrorReport_ (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SystemErrorReport > (
      ::MDM::SystemErrorReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SystemErrorReport >
  SystemErrorReport_ (::std::istream& is,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SystemErrorReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SystemErrorReport >
  SystemErrorReport_ (::std::istream& is,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SystemErrorReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SystemErrorReport >
  SystemErrorReport_ (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::SystemErrorReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SystemErrorReport >
  SystemErrorReport_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SystemErrorReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::SystemErrorReport >
  SystemErrorReport_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SystemErrorReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SystemErrorReport >
  SystemErrorReport_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::SystemErrorReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::SystemErrorReport >
  SystemErrorReport_ (::xercesc::InputSource& i,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::SystemErrorReport > (
      ::MDM::SystemErrorReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SystemErrorReport >
  SystemErrorReport_ (::xercesc::InputSource& i,
                      ::xml_schema::ErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SystemErrorReport > (
      ::MDM::SystemErrorReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SystemErrorReport >
  SystemErrorReport_ (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::SystemErrorReport > (
      ::MDM::SystemErrorReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::SystemErrorReport >
  SystemErrorReport_ (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::SystemErrorReport > (
        ::MDM::SystemErrorReport_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SystemErrorReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SystemErrorReport > r (
        ::xsd::cxx::tree::traits< ::MDM::SystemErrorReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SystemErrorReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::SystemErrorReport >
  SystemErrorReport_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::Flags f,
                      const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "SystemErrorReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::SystemErrorReport > r (
        ::xsd::cxx::tree::traits< ::MDM::SystemErrorReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "SystemErrorReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::DescriptionModificationReport >
  DescriptionModificationReport_ (const ::std::string& u,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::DescriptionModificationReport > (
      ::MDM::DescriptionModificationReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::DescriptionModificationReport >
  DescriptionModificationReport_ (const ::std::string& u,
                                  ::xml_schema::ErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::DescriptionModificationReport > (
      ::MDM::DescriptionModificationReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::DescriptionModificationReport >
  DescriptionModificationReport_ (const ::std::string& u,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::DescriptionModificationReport > (
      ::MDM::DescriptionModificationReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::DescriptionModificationReport >
  DescriptionModificationReport_ (::std::istream& is,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::DescriptionModificationReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::DescriptionModificationReport >
  DescriptionModificationReport_ (::std::istream& is,
                                  ::xml_schema::ErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::DescriptionModificationReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::DescriptionModificationReport >
  DescriptionModificationReport_ (::std::istream& is,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::DescriptionModificationReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::DescriptionModificationReport >
  DescriptionModificationReport_ (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::DescriptionModificationReport_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::DescriptionModificationReport >
  DescriptionModificationReport_ (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::ErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::DescriptionModificationReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::DescriptionModificationReport >
  DescriptionModificationReport_ (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::DescriptionModificationReport_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::DescriptionModificationReport >
  DescriptionModificationReport_ (::xercesc::InputSource& i,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::DescriptionModificationReport > (
      ::MDM::DescriptionModificationReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::DescriptionModificationReport >
  DescriptionModificationReport_ (::xercesc::InputSource& i,
                                  ::xml_schema::ErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::DescriptionModificationReport > (
      ::MDM::DescriptionModificationReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::DescriptionModificationReport >
  DescriptionModificationReport_ (::xercesc::InputSource& i,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::DescriptionModificationReport > (
      ::MDM::DescriptionModificationReport_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::DescriptionModificationReport >
  DescriptionModificationReport_ (const ::xercesc::DOMDocument& doc,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::DescriptionModificationReport > (
        ::MDM::DescriptionModificationReport_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DescriptionModificationReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::DescriptionModificationReport > r (
        ::xsd::cxx::tree::traits< ::MDM::DescriptionModificationReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DescriptionModificationReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::DescriptionModificationReport >
  DescriptionModificationReport_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DescriptionModificationReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::DescriptionModificationReport > r (
        ::xsd::cxx::tree::traits< ::MDM::DescriptionModificationReport, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DescriptionModificationReport",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::WaveformStream >
  WaveformStream_ (const ::std::string& u,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::WaveformStream > (
      ::MDM::WaveformStream_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::WaveformStream >
  WaveformStream_ (const ::std::string& u,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::WaveformStream > (
      ::MDM::WaveformStream_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::WaveformStream >
  WaveformStream_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::WaveformStream > (
      ::MDM::WaveformStream_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::WaveformStream >
  WaveformStream_ (::std::istream& is,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::WaveformStream_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::WaveformStream >
  WaveformStream_ (::std::istream& is,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::WaveformStream_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::WaveformStream >
  WaveformStream_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::WaveformStream_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::WaveformStream >
  WaveformStream_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::WaveformStream_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::WaveformStream >
  WaveformStream_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::WaveformStream_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::WaveformStream >
  WaveformStream_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::WaveformStream_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::WaveformStream >
  WaveformStream_ (::xercesc::InputSource& i,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::WaveformStream > (
      ::MDM::WaveformStream_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::WaveformStream >
  WaveformStream_ (::xercesc::InputSource& i,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::WaveformStream > (
      ::MDM::WaveformStream_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::WaveformStream >
  WaveformStream_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::WaveformStream > (
      ::MDM::WaveformStream_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::WaveformStream >
  WaveformStream_ (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::WaveformStream > (
        ::MDM::WaveformStream_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "WaveformStream" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::WaveformStream > r (
        ::xsd::cxx::tree::traits< ::MDM::WaveformStream, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "WaveformStream",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::WaveformStream >
  WaveformStream_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "WaveformStream" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::WaveformStream > r (
        ::xsd::cxx::tree::traits< ::MDM::WaveformStream, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "WaveformStream",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::ObservedValueStream >
  ObservedValueStream_ (const ::std::string& u,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::ObservedValueStream > (
      ::MDM::ObservedValueStream_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::ObservedValueStream >
  ObservedValueStream_ (const ::std::string& u,
                        ::xml_schema::ErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::ObservedValueStream > (
      ::MDM::ObservedValueStream_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::ObservedValueStream >
  ObservedValueStream_ (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::ObservedValueStream > (
      ::MDM::ObservedValueStream_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::ObservedValueStream >
  ObservedValueStream_ (::std::istream& is,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::ObservedValueStream_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::ObservedValueStream >
  ObservedValueStream_ (::std::istream& is,
                        ::xml_schema::ErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::ObservedValueStream_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::ObservedValueStream >
  ObservedValueStream_ (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::ObservedValueStream_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::ObservedValueStream >
  ObservedValueStream_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::ObservedValueStream_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::ObservedValueStream >
  ObservedValueStream_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::ErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::ObservedValueStream_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::ObservedValueStream >
  ObservedValueStream_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::ObservedValueStream_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::ObservedValueStream >
  ObservedValueStream_ (::xercesc::InputSource& i,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::ObservedValueStream > (
      ::MDM::ObservedValueStream_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::ObservedValueStream >
  ObservedValueStream_ (::xercesc::InputSource& i,
                        ::xml_schema::ErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::ObservedValueStream > (
      ::MDM::ObservedValueStream_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::ObservedValueStream >
  ObservedValueStream_ (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::ObservedValueStream > (
      ::MDM::ObservedValueStream_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::ObservedValueStream >
  ObservedValueStream_ (const ::xercesc::DOMDocument& doc,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::ObservedValueStream > (
        ::MDM::ObservedValueStream_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ObservedValueStream" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::ObservedValueStream > r (
        ::xsd::cxx::tree::traits< ::MDM::ObservedValueStream, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ObservedValueStream",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::ObservedValueStream >
  ObservedValueStream_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::Flags f,
                        const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ObservedValueStream" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::ObservedValueStream > r (
        ::xsd::cxx::tree::traits< ::MDM::ObservedValueStream, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ObservedValueStream",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::Retrievability >
  Retrievability_ (const ::std::string& u,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::Retrievability > (
      ::MDM::Retrievability_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::Retrievability >
  Retrievability_ (const ::std::string& u,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::Retrievability > (
      ::MDM::Retrievability_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::Retrievability >
  Retrievability_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::Retrievability > (
      ::MDM::Retrievability_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::Retrievability >
  Retrievability_ (::std::istream& is,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::Retrievability_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::Retrievability >
  Retrievability_ (::std::istream& is,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::Retrievability_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::Retrievability >
  Retrievability_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::MDM::Retrievability_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::Retrievability >
  Retrievability_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::Retrievability_ (isrc, f, p);
  }

  ::std::unique_ptr< ::MDM::Retrievability >
  Retrievability_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::Retrievability_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::Retrievability >
  Retrievability_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::MDM::Retrievability_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::MDM::Retrievability >
  Retrievability_ (::xercesc::InputSource& i,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::MDM::Retrievability > (
      ::MDM::Retrievability_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::Retrievability >
  Retrievability_ (::xercesc::InputSource& i,
                   ::xml_schema::ErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::Retrievability > (
      ::MDM::Retrievability_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::Retrievability >
  Retrievability_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::MDM::Retrievability > (
      ::MDM::Retrievability_ (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::MDM::Retrievability >
  Retrievability_ (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::MDM::Retrievability > (
        ::MDM::Retrievability_ (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Retrievability" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::Retrievability > r (
        ::xsd::cxx::tree::traits< ::MDM::Retrievability, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Retrievability",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }

  ::std::unique_ptr< ::MDM::Retrievability >
  Retrievability_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::Flags f,
                   const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "Retrievability" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      ::std::unique_ptr< ::MDM::Retrievability > r (
        ::xsd::cxx::tree::traits< ::MDM::Retrievability, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Retrievability",
      "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace MDM
{
  void
  operator<< (::xercesc::DOMElement& e, const TransactionId& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const TransactionId& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const TransactionId& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TransactionId >
  _xsd_TransactionId_type_serializer_init (
    "TransactionId",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const InvocationState& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const InvocationState& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const InvocationState& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, InvocationState >
  _xsd_InvocationState_type_serializer_init (
    "InvocationState",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const InvocationError& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const InvocationError& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const InvocationError& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, InvocationError >
  _xsd_InvocationError_type_serializer_init (
    "InvocationError",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const InvocationInfo& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const InvocationInfo::ExtensionType& x (*i.Extension ());
        if (typeid (InvocationInfo::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // TransactionId
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const InvocationInfo::TransactionIdType& x (i.TransactionId ());
      if (typeid (InvocationInfo::TransactionIdType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TransactionId",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "TransactionId",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }

    // InvocationState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const InvocationInfo::InvocationStateType& x (i.InvocationState ());
      if (typeid (InvocationInfo::InvocationStateType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InvocationState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "InvocationState",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }

    // InvocationError
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.InvocationError ())
      {
        const InvocationInfo::InvocationErrorType& x (*i.InvocationError ());
        if (typeid (InvocationInfo::InvocationErrorType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "InvocationError",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "InvocationError",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }

    // InvocationErrorMessage
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (InvocationInfo::InvocationErrorMessageConstIterator
           b (i.InvocationErrorMessage ().begin ()), n (i.InvocationErrorMessage ().end ());
           b != n; ++b)
      {
        if (typeid (InvocationInfo::InvocationErrorMessageType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "InvocationErrorMessage",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "InvocationErrorMessage",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, InvocationInfo >
  _xsd_InvocationInfo_type_serializer_init (
    "InvocationInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractGet& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const AbstractGet::ExtensionType& x (*i.Extension ());
        if (typeid (AbstractGet::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractGet >
  _xsd_AbstractGet_type_serializer_init (
    "AbstractGet",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractGetResponse& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const AbstractGetResponse::ExtensionType& x (*i.Extension ());
        if (typeid (AbstractGetResponse::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // MdibVersion
    //
    if (i.MdibVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MdibVersion",
          e));

      a << *i.MdibVersion ();
    }

    // SequenceId
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "SequenceId",
          e));

      a << i.SequenceId ();
    }

    // InstanceId
    //
    if (i.InstanceId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "InstanceId",
          e));

      a << *i.InstanceId ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractGetResponse >
  _xsd_AbstractGetResponse_type_serializer_init (
    "AbstractGetResponse",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractReportPart& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const AbstractReportPart::ExtensionType& x (*i.Extension ());
        if (typeid (AbstractReportPart::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // SourceMds
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.SourceMds ())
      {
        const AbstractReportPart::SourceMdsType& x (*i.SourceMds ());
        if (typeid (AbstractReportPart::SourceMdsType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SourceMds",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "SourceMds",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractReportPart >
  _xsd_AbstractReportPart_type_serializer_init (
    "AbstractReportPart",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractReport& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const AbstractReport::ExtensionType& x (*i.Extension ());
        if (typeid (AbstractReport::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // MdibVersion
    //
    if (i.MdibVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MdibVersion",
          e));

      a << *i.MdibVersion ();
    }

    // SequenceId
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "SequenceId",
          e));

      a << i.SequenceId ();
    }

    // InstanceId
    //
    if (i.InstanceId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "InstanceId",
          e));

      a << *i.InstanceId ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractReport >
  _xsd_AbstractReport_type_serializer_init (
    "AbstractReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractSet& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const AbstractSet::ExtensionType& x (*i.Extension ());
        if (typeid (AbstractSet::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // OperationHandleRef
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AbstractSet::OperationHandleRefType& x (i.OperationHandleRef ());
      if (typeid (AbstractSet::OperationHandleRefType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OperationHandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "OperationHandleRef",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractSet >
  _xsd_AbstractSet_type_serializer_init (
    "AbstractSet",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const AbstractSetResponse& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const AbstractSetResponse::ExtensionType& x (*i.Extension ());
        if (typeid (AbstractSetResponse::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // InvocationInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const AbstractSetResponse::InvocationInfoType& x (i.InvocationInfo ());
      if (typeid (AbstractSetResponse::InvocationInfoType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InvocationInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "InvocationInfo",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }

    // MdibVersion
    //
    if (i.MdibVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MdibVersion",
          e));

      a << *i.MdibVersion ();
    }

    // SequenceId
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "SequenceId",
          e));

      a << i.SequenceId ();
    }

    // InstanceId
    //
    if (i.InstanceId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "InstanceId",
          e));

      a << *i.InstanceId ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractSetResponse >
  _xsd_AbstractSetResponse_type_serializer_init (
    "AbstractSetResponse",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  GetMdib_ (::std::ostream& o,
            const ::MDM::GetMdib& s,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdib_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetMdib_ (::std::ostream& o,
            const ::MDM::GetMdib& s,
            ::xml_schema::ErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdib_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdib_ (::std::ostream& o,
            const ::MDM::GetMdib& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdib_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdib_ (::xercesc::XMLFormatTarget& t,
            const ::MDM::GetMdib& s,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdib_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetMdib_ (::xercesc::XMLFormatTarget& t,
            const ::MDM::GetMdib& s,
            ::xml_schema::ErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdib_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdib_ (::xercesc::XMLFormatTarget& t,
            const ::MDM::GetMdib& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdib_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdib_ (::xercesc::DOMDocument& d,
            const ::MDM::GetMdib& s,
            ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetMdib" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetMdib",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetMdib_ (const ::MDM::GetMdib& s,
            const ::xml_schema::NamespaceInfomap& m,
            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetMdib",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetMdib_ (*d, s, f);
    return d;
  }

  void
  GetMdibResponse_ (::std::ostream& o,
                    const ::MDM::GetMdibResponse& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdibResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetMdibResponse_ (::std::ostream& o,
                    const ::MDM::GetMdibResponse& s,
                    ::xml_schema::ErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdibResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdibResponse_ (::std::ostream& o,
                    const ::MDM::GetMdibResponse& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdibResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdibResponse_ (::xercesc::XMLFormatTarget& t,
                    const ::MDM::GetMdibResponse& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdibResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetMdibResponse_ (::xercesc::XMLFormatTarget& t,
                    const ::MDM::GetMdibResponse& s,
                    ::xml_schema::ErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdibResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdibResponse_ (::xercesc::XMLFormatTarget& t,
                    const ::MDM::GetMdibResponse& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdibResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdibResponse_ (::xercesc::DOMDocument& d,
                    const ::MDM::GetMdibResponse& s,
                    ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetMdibResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetMdibResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetMdibResponse_ (const ::MDM::GetMdibResponse& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetMdibResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetMdibResponse_ (*d, s, f);
    return d;
  }

  void
  GetMdDescription_ (::std::ostream& o,
                     const ::MDM::GetMdDescription& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdDescription_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetMdDescription_ (::std::ostream& o,
                     const ::MDM::GetMdDescription& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdDescription_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdDescription_ (::std::ostream& o,
                     const ::MDM::GetMdDescription& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdDescription_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdDescription_ (::xercesc::XMLFormatTarget& t,
                     const ::MDM::GetMdDescription& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdDescription_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetMdDescription_ (::xercesc::XMLFormatTarget& t,
                     const ::MDM::GetMdDescription& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdDescription_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdDescription_ (::xercesc::XMLFormatTarget& t,
                     const ::MDM::GetMdDescription& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdDescription_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdDescription_ (::xercesc::DOMDocument& d,
                     const ::MDM::GetMdDescription& s,
                     ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetMdDescription" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetMdDescription",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetMdDescription_ (const ::MDM::GetMdDescription& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetMdDescription",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetMdDescription_ (*d, s, f);
    return d;
  }

  void
  GetMdDescriptionResponse_ (::std::ostream& o,
                             const ::MDM::GetMdDescriptionResponse& s,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdDescriptionResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetMdDescriptionResponse_ (::std::ostream& o,
                             const ::MDM::GetMdDescriptionResponse& s,
                             ::xml_schema::ErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdDescriptionResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdDescriptionResponse_ (::std::ostream& o,
                             const ::MDM::GetMdDescriptionResponse& s,
                             ::xercesc::DOMErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdDescriptionResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdDescriptionResponse_ (::xercesc::XMLFormatTarget& t,
                             const ::MDM::GetMdDescriptionResponse& s,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdDescriptionResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetMdDescriptionResponse_ (::xercesc::XMLFormatTarget& t,
                             const ::MDM::GetMdDescriptionResponse& s,
                             ::xml_schema::ErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdDescriptionResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdDescriptionResponse_ (::xercesc::XMLFormatTarget& t,
                             const ::MDM::GetMdDescriptionResponse& s,
                             ::xercesc::DOMErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdDescriptionResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdDescriptionResponse_ (::xercesc::DOMDocument& d,
                             const ::MDM::GetMdDescriptionResponse& s,
                             ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetMdDescriptionResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetMdDescriptionResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetMdDescriptionResponse_ (const ::MDM::GetMdDescriptionResponse& s,
                             const ::xml_schema::NamespaceInfomap& m,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetMdDescriptionResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetMdDescriptionResponse_ (*d, s, f);
    return d;
  }

  void
  GetMdState_ (::std::ostream& o,
               const ::MDM::GetMdState& s,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdState_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetMdState_ (::std::ostream& o,
               const ::MDM::GetMdState& s,
               ::xml_schema::ErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdState_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdState_ (::std::ostream& o,
               const ::MDM::GetMdState& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdState_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdState_ (::xercesc::XMLFormatTarget& t,
               const ::MDM::GetMdState& s,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdState_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetMdState_ (::xercesc::XMLFormatTarget& t,
               const ::MDM::GetMdState& s,
               ::xml_schema::ErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdState_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdState_ (::xercesc::XMLFormatTarget& t,
               const ::MDM::GetMdState& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::NamespaceInfomap& m,
               const ::std::string& e,
               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdState_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdState_ (::xercesc::DOMDocument& d,
               const ::MDM::GetMdState& s,
               ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetMdState" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetMdState",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetMdState_ (const ::MDM::GetMdState& s,
               const ::xml_schema::NamespaceInfomap& m,
               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetMdState",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetMdState_ (*d, s, f);
    return d;
  }

  void
  GetMdStateResponse_ (::std::ostream& o,
                       const ::MDM::GetMdStateResponse& s,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdStateResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetMdStateResponse_ (::std::ostream& o,
                       const ::MDM::GetMdStateResponse& s,
                       ::xml_schema::ErrorHandler& h,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdStateResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdStateResponse_ (::std::ostream& o,
                       const ::MDM::GetMdStateResponse& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdStateResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdStateResponse_ (::xercesc::XMLFormatTarget& t,
                       const ::MDM::GetMdStateResponse& s,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdStateResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetMdStateResponse_ (::xercesc::XMLFormatTarget& t,
                       const ::MDM::GetMdStateResponse& s,
                       ::xml_schema::ErrorHandler& h,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdStateResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdStateResponse_ (::xercesc::XMLFormatTarget& t,
                       const ::MDM::GetMdStateResponse& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetMdStateResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetMdStateResponse_ (::xercesc::DOMDocument& d,
                       const ::MDM::GetMdStateResponse& s,
                       ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetMdStateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetMdStateResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetMdStateResponse_ (const ::MDM::GetMdStateResponse& s,
                       const ::xml_schema::NamespaceInfomap& m,
                       ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetMdStateResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetMdStateResponse_ (*d, s, f);
    return d;
  }

  void
  GetContextStates_ (::std::ostream& o,
                     const ::MDM::GetContextStates& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStates_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetContextStates_ (::std::ostream& o,
                     const ::MDM::GetContextStates& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStates_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStates_ (::std::ostream& o,
                     const ::MDM::GetContextStates& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStates_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStates_ (::xercesc::XMLFormatTarget& t,
                     const ::MDM::GetContextStates& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStates_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetContextStates_ (::xercesc::XMLFormatTarget& t,
                     const ::MDM::GetContextStates& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStates_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStates_ (::xercesc::XMLFormatTarget& t,
                     const ::MDM::GetContextStates& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStates_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStates_ (::xercesc::DOMDocument& d,
                     const ::MDM::GetContextStates& s,
                     ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetContextStates" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetContextStates",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetContextStates_ (const ::MDM::GetContextStates& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetContextStates",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetContextStates_ (*d, s, f);
    return d;
  }

  void
  GetContextStatesResponse_ (::std::ostream& o,
                             const ::MDM::GetContextStatesResponse& s,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetContextStatesResponse_ (::std::ostream& o,
                             const ::MDM::GetContextStatesResponse& s,
                             ::xml_schema::ErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesResponse_ (::std::ostream& o,
                             const ::MDM::GetContextStatesResponse& s,
                             ::xercesc::DOMErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesResponse_ (::xercesc::XMLFormatTarget& t,
                             const ::MDM::GetContextStatesResponse& s,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetContextStatesResponse_ (::xercesc::XMLFormatTarget& t,
                             const ::MDM::GetContextStatesResponse& s,
                             ::xml_schema::ErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesResponse_ (::xercesc::XMLFormatTarget& t,
                             const ::MDM::GetContextStatesResponse& s,
                             ::xercesc::DOMErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesResponse_ (::xercesc::DOMDocument& d,
                             const ::MDM::GetContextStatesResponse& s,
                             ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetContextStatesResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetContextStatesResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetContextStatesResponse_ (const ::MDM::GetContextStatesResponse& s,
                             const ::xml_schema::NamespaceInfomap& m,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetContextStatesResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetContextStatesResponse_ (*d, s, f);
    return d;
  }

  void
  GetContextStatesByIdentification_ (::std::ostream& o,
                                     const ::MDM::GetContextStatesByIdentification& s,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByIdentification_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetContextStatesByIdentification_ (::std::ostream& o,
                                     const ::MDM::GetContextStatesByIdentification& s,
                                     ::xml_schema::ErrorHandler& h,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByIdentification_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesByIdentification_ (::std::ostream& o,
                                     const ::MDM::GetContextStatesByIdentification& s,
                                     ::xercesc::DOMErrorHandler& h,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByIdentification_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesByIdentification_ (::xercesc::XMLFormatTarget& t,
                                     const ::MDM::GetContextStatesByIdentification& s,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByIdentification_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetContextStatesByIdentification_ (::xercesc::XMLFormatTarget& t,
                                     const ::MDM::GetContextStatesByIdentification& s,
                                     ::xml_schema::ErrorHandler& h,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByIdentification_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesByIdentification_ (::xercesc::XMLFormatTarget& t,
                                     const ::MDM::GetContextStatesByIdentification& s,
                                     ::xercesc::DOMErrorHandler& h,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByIdentification_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesByIdentification_ (::xercesc::DOMDocument& d,
                                     const ::MDM::GetContextStatesByIdentification& s,
                                     ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetContextStatesByIdentification" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetContextStatesByIdentification",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetContextStatesByIdentification_ (const ::MDM::GetContextStatesByIdentification& s,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetContextStatesByIdentification",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetContextStatesByIdentification_ (*d, s, f);
    return d;
  }

  void
  GetContextStatesByIdentificationResponse_ (::std::ostream& o,
                                             const ::MDM::GetContextStatesByIdentificationResponse& s,
                                             const ::xml_schema::NamespaceInfomap& m,
                                             const ::std::string& e,
                                             ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByIdentificationResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetContextStatesByIdentificationResponse_ (::std::ostream& o,
                                             const ::MDM::GetContextStatesByIdentificationResponse& s,
                                             ::xml_schema::ErrorHandler& h,
                                             const ::xml_schema::NamespaceInfomap& m,
                                             const ::std::string& e,
                                             ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByIdentificationResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesByIdentificationResponse_ (::std::ostream& o,
                                             const ::MDM::GetContextStatesByIdentificationResponse& s,
                                             ::xercesc::DOMErrorHandler& h,
                                             const ::xml_schema::NamespaceInfomap& m,
                                             const ::std::string& e,
                                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByIdentificationResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesByIdentificationResponse_ (::xercesc::XMLFormatTarget& t,
                                             const ::MDM::GetContextStatesByIdentificationResponse& s,
                                             const ::xml_schema::NamespaceInfomap& m,
                                             const ::std::string& e,
                                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByIdentificationResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetContextStatesByIdentificationResponse_ (::xercesc::XMLFormatTarget& t,
                                             const ::MDM::GetContextStatesByIdentificationResponse& s,
                                             ::xml_schema::ErrorHandler& h,
                                             const ::xml_schema::NamespaceInfomap& m,
                                             const ::std::string& e,
                                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByIdentificationResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesByIdentificationResponse_ (::xercesc::XMLFormatTarget& t,
                                             const ::MDM::GetContextStatesByIdentificationResponse& s,
                                             ::xercesc::DOMErrorHandler& h,
                                             const ::xml_schema::NamespaceInfomap& m,
                                             const ::std::string& e,
                                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByIdentificationResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesByIdentificationResponse_ (::xercesc::DOMDocument& d,
                                             const ::MDM::GetContextStatesByIdentificationResponse& s,
                                             ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetContextStatesByIdentificationResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetContextStatesByIdentificationResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetContextStatesByIdentificationResponse_ (const ::MDM::GetContextStatesByIdentificationResponse& s,
                                             const ::xml_schema::NamespaceInfomap& m,
                                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetContextStatesByIdentificationResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetContextStatesByIdentificationResponse_ (*d, s, f);
    return d;
  }

  void
  GetContextStatesByFilter_ (::std::ostream& o,
                             const ::MDM::GetContextStatesByFilter& s,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByFilter_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetContextStatesByFilter_ (::std::ostream& o,
                             const ::MDM::GetContextStatesByFilter& s,
                             ::xml_schema::ErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByFilter_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesByFilter_ (::std::ostream& o,
                             const ::MDM::GetContextStatesByFilter& s,
                             ::xercesc::DOMErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByFilter_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesByFilter_ (::xercesc::XMLFormatTarget& t,
                             const ::MDM::GetContextStatesByFilter& s,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByFilter_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetContextStatesByFilter_ (::xercesc::XMLFormatTarget& t,
                             const ::MDM::GetContextStatesByFilter& s,
                             ::xml_schema::ErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByFilter_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesByFilter_ (::xercesc::XMLFormatTarget& t,
                             const ::MDM::GetContextStatesByFilter& s,
                             ::xercesc::DOMErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByFilter_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesByFilter_ (::xercesc::DOMDocument& d,
                             const ::MDM::GetContextStatesByFilter& s,
                             ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetContextStatesByFilter" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetContextStatesByFilter",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetContextStatesByFilter_ (const ::MDM::GetContextStatesByFilter& s,
                             const ::xml_schema::NamespaceInfomap& m,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetContextStatesByFilter",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetContextStatesByFilter_ (*d, s, f);
    return d;
  }

  void
  GetContextStatesByFilterResponse_ (::std::ostream& o,
                                     const ::MDM::GetContextStatesByFilterResponse& s,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByFilterResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetContextStatesByFilterResponse_ (::std::ostream& o,
                                     const ::MDM::GetContextStatesByFilterResponse& s,
                                     ::xml_schema::ErrorHandler& h,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByFilterResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesByFilterResponse_ (::std::ostream& o,
                                     const ::MDM::GetContextStatesByFilterResponse& s,
                                     ::xercesc::DOMErrorHandler& h,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByFilterResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesByFilterResponse_ (::xercesc::XMLFormatTarget& t,
                                     const ::MDM::GetContextStatesByFilterResponse& s,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByFilterResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetContextStatesByFilterResponse_ (::xercesc::XMLFormatTarget& t,
                                     const ::MDM::GetContextStatesByFilterResponse& s,
                                     ::xml_schema::ErrorHandler& h,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByFilterResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesByFilterResponse_ (::xercesc::XMLFormatTarget& t,
                                     const ::MDM::GetContextStatesByFilterResponse& s,
                                     ::xercesc::DOMErrorHandler& h,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     const ::std::string& e,
                                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContextStatesByFilterResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContextStatesByFilterResponse_ (::xercesc::DOMDocument& d,
                                     const ::MDM::GetContextStatesByFilterResponse& s,
                                     ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetContextStatesByFilterResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetContextStatesByFilterResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetContextStatesByFilterResponse_ (const ::MDM::GetContextStatesByFilterResponse& s,
                                     const ::xml_schema::NamespaceInfomap& m,
                                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetContextStatesByFilterResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetContextStatesByFilterResponse_ (*d, s, f);
    return d;
  }

  void
  SetContextState_ (::std::ostream& o,
                    const ::MDM::SetContextState& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetContextState_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetContextState_ (::std::ostream& o,
                    const ::MDM::SetContextState& s,
                    ::xml_schema::ErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetContextState_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetContextState_ (::std::ostream& o,
                    const ::MDM::SetContextState& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetContextState_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetContextState_ (::xercesc::XMLFormatTarget& t,
                    const ::MDM::SetContextState& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetContextState_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetContextState_ (::xercesc::XMLFormatTarget& t,
                    const ::MDM::SetContextState& s,
                    ::xml_schema::ErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetContextState_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetContextState_ (::xercesc::XMLFormatTarget& t,
                    const ::MDM::SetContextState& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetContextState_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetContextState_ (::xercesc::DOMDocument& d,
                    const ::MDM::SetContextState& s,
                    ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetContextState" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SetContextState",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  SetContextState_ (const ::MDM::SetContextState& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "SetContextState",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::SetContextState_ (*d, s, f);
    return d;
  }

  void
  SetContextStateResponse_ (::std::ostream& o,
                            const ::MDM::SetContextStateResponse& s,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetContextStateResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetContextStateResponse_ (::std::ostream& o,
                            const ::MDM::SetContextStateResponse& s,
                            ::xml_schema::ErrorHandler& h,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetContextStateResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetContextStateResponse_ (::std::ostream& o,
                            const ::MDM::SetContextStateResponse& s,
                            ::xercesc::DOMErrorHandler& h,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetContextStateResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetContextStateResponse_ (::xercesc::XMLFormatTarget& t,
                            const ::MDM::SetContextStateResponse& s,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetContextStateResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetContextStateResponse_ (::xercesc::XMLFormatTarget& t,
                            const ::MDM::SetContextStateResponse& s,
                            ::xml_schema::ErrorHandler& h,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetContextStateResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetContextStateResponse_ (::xercesc::XMLFormatTarget& t,
                            const ::MDM::SetContextStateResponse& s,
                            ::xercesc::DOMErrorHandler& h,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetContextStateResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetContextStateResponse_ (::xercesc::DOMDocument& d,
                            const ::MDM::SetContextStateResponse& s,
                            ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetContextStateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SetContextStateResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  SetContextStateResponse_ (const ::MDM::SetContextStateResponse& s,
                            const ::xml_schema::NamespaceInfomap& m,
                            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "SetContextStateResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::SetContextStateResponse_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const AbstractContextReport& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // ReportPart
    //
    for (AbstractContextReport::ReportPartConstIterator
         b (i.ReportPart ().begin ()), n (i.ReportPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReportPart",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractContextReport >
  _xsd_AbstractContextReport_type_serializer_init (
    "AbstractContextReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  PeriodicContextReport_ (::std::ostream& o,
                          const ::MDM::PeriodicContextReport& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicContextReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  PeriodicContextReport_ (::std::ostream& o,
                          const ::MDM::PeriodicContextReport& s,
                          ::xml_schema::ErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicContextReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicContextReport_ (::std::ostream& o,
                          const ::MDM::PeriodicContextReport& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicContextReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicContextReport_ (::xercesc::XMLFormatTarget& t,
                          const ::MDM::PeriodicContextReport& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicContextReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  PeriodicContextReport_ (::xercesc::XMLFormatTarget& t,
                          const ::MDM::PeriodicContextReport& s,
                          ::xml_schema::ErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicContextReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicContextReport_ (::xercesc::XMLFormatTarget& t,
                          const ::MDM::PeriodicContextReport& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicContextReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicContextReport_ (::xercesc::DOMDocument& d,
                          const ::MDM::PeriodicContextReport& s,
                          ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "PeriodicContextReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PeriodicContextReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  PeriodicContextReport_ (const ::MDM::PeriodicContextReport& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "PeriodicContextReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::PeriodicContextReport_ (*d, s, f);
    return d;
  }

  void
  EpisodicContextReport_ (::std::ostream& o,
                          const ::MDM::EpisodicContextReport& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicContextReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EpisodicContextReport_ (::std::ostream& o,
                          const ::MDM::EpisodicContextReport& s,
                          ::xml_schema::ErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicContextReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicContextReport_ (::std::ostream& o,
                          const ::MDM::EpisodicContextReport& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicContextReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicContextReport_ (::xercesc::XMLFormatTarget& t,
                          const ::MDM::EpisodicContextReport& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicContextReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EpisodicContextReport_ (::xercesc::XMLFormatTarget& t,
                          const ::MDM::EpisodicContextReport& s,
                          ::xml_schema::ErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicContextReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicContextReport_ (::xercesc::XMLFormatTarget& t,
                          const ::MDM::EpisodicContextReport& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicContextReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicContextReport_ (::xercesc::DOMDocument& d,
                          const ::MDM::EpisodicContextReport& s,
                          ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EpisodicContextReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EpisodicContextReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  EpisodicContextReport_ (const ::MDM::EpisodicContextReport& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "EpisodicContextReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::EpisodicContextReport_ (*d, s, f);
    return d;
  }

  void
  GetLocalizedText_ (::std::ostream& o,
                     const ::MDM::GetLocalizedText& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetLocalizedText_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetLocalizedText_ (::std::ostream& o,
                     const ::MDM::GetLocalizedText& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetLocalizedText_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetLocalizedText_ (::std::ostream& o,
                     const ::MDM::GetLocalizedText& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetLocalizedText_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetLocalizedText_ (::xercesc::XMLFormatTarget& t,
                     const ::MDM::GetLocalizedText& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetLocalizedText_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetLocalizedText_ (::xercesc::XMLFormatTarget& t,
                     const ::MDM::GetLocalizedText& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetLocalizedText_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetLocalizedText_ (::xercesc::XMLFormatTarget& t,
                     const ::MDM::GetLocalizedText& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetLocalizedText_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetLocalizedText_ (::xercesc::DOMDocument& d,
                     const ::MDM::GetLocalizedText& s,
                     ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetLocalizedText" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetLocalizedText",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetLocalizedText_ (const ::MDM::GetLocalizedText& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetLocalizedText",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetLocalizedText_ (*d, s, f);
    return d;
  }

  void
  GetLocalizedTextResponse_ (::std::ostream& o,
                             const ::MDM::GetLocalizedTextResponse& s,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetLocalizedTextResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetLocalizedTextResponse_ (::std::ostream& o,
                             const ::MDM::GetLocalizedTextResponse& s,
                             ::xml_schema::ErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetLocalizedTextResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetLocalizedTextResponse_ (::std::ostream& o,
                             const ::MDM::GetLocalizedTextResponse& s,
                             ::xercesc::DOMErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetLocalizedTextResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetLocalizedTextResponse_ (::xercesc::XMLFormatTarget& t,
                             const ::MDM::GetLocalizedTextResponse& s,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetLocalizedTextResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetLocalizedTextResponse_ (::xercesc::XMLFormatTarget& t,
                             const ::MDM::GetLocalizedTextResponse& s,
                             ::xml_schema::ErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetLocalizedTextResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetLocalizedTextResponse_ (::xercesc::XMLFormatTarget& t,
                             const ::MDM::GetLocalizedTextResponse& s,
                             ::xercesc::DOMErrorHandler& h,
                             const ::xml_schema::NamespaceInfomap& m,
                             const ::std::string& e,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetLocalizedTextResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetLocalizedTextResponse_ (::xercesc::DOMDocument& d,
                             const ::MDM::GetLocalizedTextResponse& s,
                             ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetLocalizedTextResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetLocalizedTextResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetLocalizedTextResponse_ (const ::MDM::GetLocalizedTextResponse& s,
                             const ::xml_schema::NamespaceInfomap& m,
                             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetLocalizedTextResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetLocalizedTextResponse_ (*d, s, f);
    return d;
  }

  void
  GetSupportedLanguages_ (::std::ostream& o,
                          const ::MDM::GetSupportedLanguages& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetSupportedLanguages_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetSupportedLanguages_ (::std::ostream& o,
                          const ::MDM::GetSupportedLanguages& s,
                          ::xml_schema::ErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetSupportedLanguages_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetSupportedLanguages_ (::std::ostream& o,
                          const ::MDM::GetSupportedLanguages& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetSupportedLanguages_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetSupportedLanguages_ (::xercesc::XMLFormatTarget& t,
                          const ::MDM::GetSupportedLanguages& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetSupportedLanguages_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetSupportedLanguages_ (::xercesc::XMLFormatTarget& t,
                          const ::MDM::GetSupportedLanguages& s,
                          ::xml_schema::ErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetSupportedLanguages_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetSupportedLanguages_ (::xercesc::XMLFormatTarget& t,
                          const ::MDM::GetSupportedLanguages& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetSupportedLanguages_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetSupportedLanguages_ (::xercesc::DOMDocument& d,
                          const ::MDM::GetSupportedLanguages& s,
                          ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetSupportedLanguages" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetSupportedLanguages",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetSupportedLanguages_ (const ::MDM::GetSupportedLanguages& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetSupportedLanguages",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetSupportedLanguages_ (*d, s, f);
    return d;
  }

  void
  GetSupportedLanguagesResponse_ (::std::ostream& o,
                                  const ::MDM::GetSupportedLanguagesResponse& s,
                                  const ::xml_schema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetSupportedLanguagesResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetSupportedLanguagesResponse_ (::std::ostream& o,
                                  const ::MDM::GetSupportedLanguagesResponse& s,
                                  ::xml_schema::ErrorHandler& h,
                                  const ::xml_schema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetSupportedLanguagesResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetSupportedLanguagesResponse_ (::std::ostream& o,
                                  const ::MDM::GetSupportedLanguagesResponse& s,
                                  ::xercesc::DOMErrorHandler& h,
                                  const ::xml_schema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetSupportedLanguagesResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetSupportedLanguagesResponse_ (::xercesc::XMLFormatTarget& t,
                                  const ::MDM::GetSupportedLanguagesResponse& s,
                                  const ::xml_schema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetSupportedLanguagesResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetSupportedLanguagesResponse_ (::xercesc::XMLFormatTarget& t,
                                  const ::MDM::GetSupportedLanguagesResponse& s,
                                  ::xml_schema::ErrorHandler& h,
                                  const ::xml_schema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetSupportedLanguagesResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetSupportedLanguagesResponse_ (::xercesc::XMLFormatTarget& t,
                                  const ::MDM::GetSupportedLanguagesResponse& s,
                                  ::xercesc::DOMErrorHandler& h,
                                  const ::xml_schema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetSupportedLanguagesResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetSupportedLanguagesResponse_ (::xercesc::DOMDocument& d,
                                  const ::MDM::GetSupportedLanguagesResponse& s,
                                  ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetSupportedLanguagesResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetSupportedLanguagesResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetSupportedLanguagesResponse_ (const ::MDM::GetSupportedLanguagesResponse& s,
                                  const ::xml_schema::NamespaceInfomap& m,
                                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetSupportedLanguagesResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetSupportedLanguagesResponse_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const VersionFrame& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Start
    //
    if (i.Start ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Start",
          e));

      a << *i.Start ();
    }

    // End
    //
    if (i.End ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "End",
          e));

      a << *i.End ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, VersionFrame >
  _xsd_VersionFrame_type_serializer_init (
    "VersionFrame",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const TimeFrame& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Start
    //
    if (i.Start ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Start",
          e));

      a << *i.Start ();
    }

    // End
    //
    if (i.End ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "End",
          e));

      a << *i.End ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TimeFrame >
  _xsd_TimeFrame_type_serializer_init (
    "TimeFrame",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  GetDescriptorsFromArchive_ (::std::ostream& o,
                              const ::MDM::GetDescriptorsFromArchive& s,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorsFromArchive_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetDescriptorsFromArchive_ (::std::ostream& o,
                              const ::MDM::GetDescriptorsFromArchive& s,
                              ::xml_schema::ErrorHandler& h,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorsFromArchive_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetDescriptorsFromArchive_ (::std::ostream& o,
                              const ::MDM::GetDescriptorsFromArchive& s,
                              ::xercesc::DOMErrorHandler& h,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorsFromArchive_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetDescriptorsFromArchive_ (::xercesc::XMLFormatTarget& t,
                              const ::MDM::GetDescriptorsFromArchive& s,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorsFromArchive_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetDescriptorsFromArchive_ (::xercesc::XMLFormatTarget& t,
                              const ::MDM::GetDescriptorsFromArchive& s,
                              ::xml_schema::ErrorHandler& h,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorsFromArchive_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetDescriptorsFromArchive_ (::xercesc::XMLFormatTarget& t,
                              const ::MDM::GetDescriptorsFromArchive& s,
                              ::xercesc::DOMErrorHandler& h,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorsFromArchive_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetDescriptorsFromArchive_ (::xercesc::DOMDocument& d,
                              const ::MDM::GetDescriptorsFromArchive& s,
                              ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetDescriptorsFromArchive" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetDescriptorsFromArchive",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetDescriptorsFromArchive_ (const ::MDM::GetDescriptorsFromArchive& s,
                              const ::xml_schema::NamespaceInfomap& m,
                              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetDescriptorsFromArchive",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetDescriptorsFromArchive_ (*d, s, f);
    return d;
  }

  void
  GetDescriptorsFromArchiveResponse_ (::std::ostream& o,
                                      const ::MDM::GetDescriptorsFromArchiveResponse& s,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorsFromArchiveResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetDescriptorsFromArchiveResponse_ (::std::ostream& o,
                                      const ::MDM::GetDescriptorsFromArchiveResponse& s,
                                      ::xml_schema::ErrorHandler& h,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorsFromArchiveResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetDescriptorsFromArchiveResponse_ (::std::ostream& o,
                                      const ::MDM::GetDescriptorsFromArchiveResponse& s,
                                      ::xercesc::DOMErrorHandler& h,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorsFromArchiveResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetDescriptorsFromArchiveResponse_ (::xercesc::XMLFormatTarget& t,
                                      const ::MDM::GetDescriptorsFromArchiveResponse& s,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorsFromArchiveResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetDescriptorsFromArchiveResponse_ (::xercesc::XMLFormatTarget& t,
                                      const ::MDM::GetDescriptorsFromArchiveResponse& s,
                                      ::xml_schema::ErrorHandler& h,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorsFromArchiveResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetDescriptorsFromArchiveResponse_ (::xercesc::XMLFormatTarget& t,
                                      const ::MDM::GetDescriptorsFromArchiveResponse& s,
                                      ::xercesc::DOMErrorHandler& h,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorsFromArchiveResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetDescriptorsFromArchiveResponse_ (::xercesc::DOMDocument& d,
                                      const ::MDM::GetDescriptorsFromArchiveResponse& s,
                                      ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetDescriptorsFromArchiveResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetDescriptorsFromArchiveResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetDescriptorsFromArchiveResponse_ (const ::MDM::GetDescriptorsFromArchiveResponse& s,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetDescriptorsFromArchiveResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetDescriptorsFromArchiveResponse_ (*d, s, f);
    return d;
  }

  void
  GetStatesFromArchive_ (::std::ostream& o,
                         const ::MDM::GetStatesFromArchive& s,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetStatesFromArchive_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetStatesFromArchive_ (::std::ostream& o,
                         const ::MDM::GetStatesFromArchive& s,
                         ::xml_schema::ErrorHandler& h,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetStatesFromArchive_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetStatesFromArchive_ (::std::ostream& o,
                         const ::MDM::GetStatesFromArchive& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetStatesFromArchive_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetStatesFromArchive_ (::xercesc::XMLFormatTarget& t,
                         const ::MDM::GetStatesFromArchive& s,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetStatesFromArchive_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetStatesFromArchive_ (::xercesc::XMLFormatTarget& t,
                         const ::MDM::GetStatesFromArchive& s,
                         ::xml_schema::ErrorHandler& h,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetStatesFromArchive_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetStatesFromArchive_ (::xercesc::XMLFormatTarget& t,
                         const ::MDM::GetStatesFromArchive& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetStatesFromArchive_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetStatesFromArchive_ (::xercesc::DOMDocument& d,
                         const ::MDM::GetStatesFromArchive& s,
                         ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetStatesFromArchive" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetStatesFromArchive",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetStatesFromArchive_ (const ::MDM::GetStatesFromArchive& s,
                         const ::xml_schema::NamespaceInfomap& m,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetStatesFromArchive",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetStatesFromArchive_ (*d, s, f);
    return d;
  }

  void
  GetStatesFromArchiveResponse_ (::std::ostream& o,
                                 const ::MDM::GetStatesFromArchiveResponse& s,
                                 const ::xml_schema::NamespaceInfomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetStatesFromArchiveResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetStatesFromArchiveResponse_ (::std::ostream& o,
                                 const ::MDM::GetStatesFromArchiveResponse& s,
                                 ::xml_schema::ErrorHandler& h,
                                 const ::xml_schema::NamespaceInfomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetStatesFromArchiveResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetStatesFromArchiveResponse_ (::std::ostream& o,
                                 const ::MDM::GetStatesFromArchiveResponse& s,
                                 ::xercesc::DOMErrorHandler& h,
                                 const ::xml_schema::NamespaceInfomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetStatesFromArchiveResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetStatesFromArchiveResponse_ (::xercesc::XMLFormatTarget& t,
                                 const ::MDM::GetStatesFromArchiveResponse& s,
                                 const ::xml_schema::NamespaceInfomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetStatesFromArchiveResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetStatesFromArchiveResponse_ (::xercesc::XMLFormatTarget& t,
                                 const ::MDM::GetStatesFromArchiveResponse& s,
                                 ::xml_schema::ErrorHandler& h,
                                 const ::xml_schema::NamespaceInfomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetStatesFromArchiveResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetStatesFromArchiveResponse_ (::xercesc::XMLFormatTarget& t,
                                 const ::MDM::GetStatesFromArchiveResponse& s,
                                 ::xercesc::DOMErrorHandler& h,
                                 const ::xml_schema::NamespaceInfomap& m,
                                 const ::std::string& e,
                                 ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetStatesFromArchiveResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetStatesFromArchiveResponse_ (::xercesc::DOMDocument& d,
                                 const ::MDM::GetStatesFromArchiveResponse& s,
                                 ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetStatesFromArchiveResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetStatesFromArchiveResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetStatesFromArchiveResponse_ (const ::MDM::GetStatesFromArchiveResponse& s,
                                 const ::xml_schema::NamespaceInfomap& m,
                                 ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetStatesFromArchiveResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetStatesFromArchiveResponse_ (*d, s, f);
    return d;
  }

  void
  SetValue_ (::std::ostream& o,
             const ::MDM::SetValue& s,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetValue_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetValue_ (::std::ostream& o,
             const ::MDM::SetValue& s,
             ::xml_schema::ErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetValue_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetValue_ (::std::ostream& o,
             const ::MDM::SetValue& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetValue_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetValue_ (::xercesc::XMLFormatTarget& t,
             const ::MDM::SetValue& s,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetValue_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetValue_ (::xercesc::XMLFormatTarget& t,
             const ::MDM::SetValue& s,
             ::xml_schema::ErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetValue_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetValue_ (::xercesc::XMLFormatTarget& t,
             const ::MDM::SetValue& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetValue_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetValue_ (::xercesc::DOMDocument& d,
             const ::MDM::SetValue& s,
             ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetValue" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SetValue",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  SetValue_ (const ::MDM::SetValue& s,
             const ::xml_schema::NamespaceInfomap& m,
             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "SetValue",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::SetValue_ (*d, s, f);
    return d;
  }

  void
  SetValueResponse_ (::std::ostream& o,
                     const ::MDM::SetValueResponse& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetValueResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetValueResponse_ (::std::ostream& o,
                     const ::MDM::SetValueResponse& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetValueResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetValueResponse_ (::std::ostream& o,
                     const ::MDM::SetValueResponse& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetValueResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetValueResponse_ (::xercesc::XMLFormatTarget& t,
                     const ::MDM::SetValueResponse& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetValueResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetValueResponse_ (::xercesc::XMLFormatTarget& t,
                     const ::MDM::SetValueResponse& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetValueResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetValueResponse_ (::xercesc::XMLFormatTarget& t,
                     const ::MDM::SetValueResponse& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetValueResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetValueResponse_ (::xercesc::DOMDocument& d,
                     const ::MDM::SetValueResponse& s,
                     ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetValueResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SetValueResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  SetValueResponse_ (const ::MDM::SetValueResponse& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "SetValueResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::SetValueResponse_ (*d, s, f);
    return d;
  }

  void
  SetString_ (::std::ostream& o,
              const ::MDM::SetString& s,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetString_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetString_ (::std::ostream& o,
              const ::MDM::SetString& s,
              ::xml_schema::ErrorHandler& h,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetString_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetString_ (::std::ostream& o,
              const ::MDM::SetString& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetString_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetString_ (::xercesc::XMLFormatTarget& t,
              const ::MDM::SetString& s,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetString_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetString_ (::xercesc::XMLFormatTarget& t,
              const ::MDM::SetString& s,
              ::xml_schema::ErrorHandler& h,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetString_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetString_ (::xercesc::XMLFormatTarget& t,
              const ::MDM::SetString& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetString_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetString_ (::xercesc::DOMDocument& d,
              const ::MDM::SetString& s,
              ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetString" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SetString",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  SetString_ (const ::MDM::SetString& s,
              const ::xml_schema::NamespaceInfomap& m,
              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "SetString",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::SetString_ (*d, s, f);
    return d;
  }

  void
  SetStringResponse_ (::std::ostream& o,
                      const ::MDM::SetStringResponse& s,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetStringResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetStringResponse_ (::std::ostream& o,
                      const ::MDM::SetStringResponse& s,
                      ::xml_schema::ErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetStringResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetStringResponse_ (::std::ostream& o,
                      const ::MDM::SetStringResponse& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetStringResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetStringResponse_ (::xercesc::XMLFormatTarget& t,
                      const ::MDM::SetStringResponse& s,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetStringResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetStringResponse_ (::xercesc::XMLFormatTarget& t,
                      const ::MDM::SetStringResponse& s,
                      ::xml_schema::ErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetStringResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetStringResponse_ (::xercesc::XMLFormatTarget& t,
                      const ::MDM::SetStringResponse& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetStringResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetStringResponse_ (::xercesc::DOMDocument& d,
                      const ::MDM::SetStringResponse& s,
                      ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetStringResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SetStringResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  SetStringResponse_ (const ::MDM::SetStringResponse& s,
                      const ::xml_schema::NamespaceInfomap& m,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "SetStringResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::SetStringResponse_ (*d, s, f);
    return d;
  }

  void
  Activate_ (::std::ostream& o,
             const ::MDM::Activate& s,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::Activate_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  Activate_ (::std::ostream& o,
             const ::MDM::Activate& s,
             ::xml_schema::ErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::Activate_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Activate_ (::std::ostream& o,
             const ::MDM::Activate& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::Activate_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Activate_ (::xercesc::XMLFormatTarget& t,
             const ::MDM::Activate& s,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::Activate_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  Activate_ (::xercesc::XMLFormatTarget& t,
             const ::MDM::Activate& s,
             ::xml_schema::ErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::Activate_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Activate_ (::xercesc::XMLFormatTarget& t,
             const ::MDM::Activate& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::Activate_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Activate_ (::xercesc::DOMDocument& d,
             const ::MDM::Activate& s,
             ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Activate" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Activate",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  Activate_ (const ::MDM::Activate& s,
             const ::xml_schema::NamespaceInfomap& m,
             ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "Activate",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::Activate_ (*d, s, f);
    return d;
  }

  void
  ActivateResponse_ (::std::ostream& o,
                     const ::MDM::ActivateResponse& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::ActivateResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ActivateResponse_ (::std::ostream& o,
                     const ::MDM::ActivateResponse& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::ActivateResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ActivateResponse_ (::std::ostream& o,
                     const ::MDM::ActivateResponse& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::ActivateResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ActivateResponse_ (::xercesc::XMLFormatTarget& t,
                     const ::MDM::ActivateResponse& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::ActivateResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ActivateResponse_ (::xercesc::XMLFormatTarget& t,
                     const ::MDM::ActivateResponse& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::ActivateResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ActivateResponse_ (::xercesc::XMLFormatTarget& t,
                     const ::MDM::ActivateResponse& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::ActivateResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ActivateResponse_ (::xercesc::DOMDocument& d,
                     const ::MDM::ActivateResponse& s,
                     ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ActivateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ActivateResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  ActivateResponse_ (const ::MDM::ActivateResponse& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "ActivateResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::ActivateResponse_ (*d, s, f);
    return d;
  }

  void
  SetAlertState_ (::std::ostream& o,
                  const ::MDM::SetAlertState& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetAlertState_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetAlertState_ (::std::ostream& o,
                  const ::MDM::SetAlertState& s,
                  ::xml_schema::ErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetAlertState_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetAlertState_ (::std::ostream& o,
                  const ::MDM::SetAlertState& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetAlertState_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetAlertState_ (::xercesc::XMLFormatTarget& t,
                  const ::MDM::SetAlertState& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetAlertState_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetAlertState_ (::xercesc::XMLFormatTarget& t,
                  const ::MDM::SetAlertState& s,
                  ::xml_schema::ErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetAlertState_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetAlertState_ (::xercesc::XMLFormatTarget& t,
                  const ::MDM::SetAlertState& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetAlertState_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetAlertState_ (::xercesc::DOMDocument& d,
                  const ::MDM::SetAlertState& s,
                  ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetAlertState" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SetAlertState",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  SetAlertState_ (const ::MDM::SetAlertState& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "SetAlertState",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::SetAlertState_ (*d, s, f);
    return d;
  }

  void
  SetAlertStateResponse_ (::std::ostream& o,
                          const ::MDM::SetAlertStateResponse& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetAlertStateResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetAlertStateResponse_ (::std::ostream& o,
                          const ::MDM::SetAlertStateResponse& s,
                          ::xml_schema::ErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetAlertStateResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetAlertStateResponse_ (::std::ostream& o,
                          const ::MDM::SetAlertStateResponse& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetAlertStateResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetAlertStateResponse_ (::xercesc::XMLFormatTarget& t,
                          const ::MDM::SetAlertStateResponse& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetAlertStateResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetAlertStateResponse_ (::xercesc::XMLFormatTarget& t,
                          const ::MDM::SetAlertStateResponse& s,
                          ::xml_schema::ErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetAlertStateResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetAlertStateResponse_ (::xercesc::XMLFormatTarget& t,
                          const ::MDM::SetAlertStateResponse& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetAlertStateResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetAlertStateResponse_ (::xercesc::DOMDocument& d,
                          const ::MDM::SetAlertStateResponse& s,
                          ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetAlertStateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SetAlertStateResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  SetAlertStateResponse_ (const ::MDM::SetAlertStateResponse& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "SetAlertStateResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::SetAlertStateResponse_ (*d, s, f);
    return d;
  }

  void
  SetComponentState_ (::std::ostream& o,
                      const ::MDM::SetComponentState& s,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetComponentState_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetComponentState_ (::std::ostream& o,
                      const ::MDM::SetComponentState& s,
                      ::xml_schema::ErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetComponentState_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetComponentState_ (::std::ostream& o,
                      const ::MDM::SetComponentState& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetComponentState_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetComponentState_ (::xercesc::XMLFormatTarget& t,
                      const ::MDM::SetComponentState& s,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetComponentState_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetComponentState_ (::xercesc::XMLFormatTarget& t,
                      const ::MDM::SetComponentState& s,
                      ::xml_schema::ErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetComponentState_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetComponentState_ (::xercesc::XMLFormatTarget& t,
                      const ::MDM::SetComponentState& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetComponentState_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetComponentState_ (::xercesc::DOMDocument& d,
                      const ::MDM::SetComponentState& s,
                      ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetComponentState" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SetComponentState",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  SetComponentState_ (const ::MDM::SetComponentState& s,
                      const ::xml_schema::NamespaceInfomap& m,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "SetComponentState",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::SetComponentState_ (*d, s, f);
    return d;
  }

  void
  SetComponentStateResponse_ (::std::ostream& o,
                              const ::MDM::SetComponentStateResponse& s,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetComponentStateResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetComponentStateResponse_ (::std::ostream& o,
                              const ::MDM::SetComponentStateResponse& s,
                              ::xml_schema::ErrorHandler& h,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetComponentStateResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetComponentStateResponse_ (::std::ostream& o,
                              const ::MDM::SetComponentStateResponse& s,
                              ::xercesc::DOMErrorHandler& h,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetComponentStateResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetComponentStateResponse_ (::xercesc::XMLFormatTarget& t,
                              const ::MDM::SetComponentStateResponse& s,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetComponentStateResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetComponentStateResponse_ (::xercesc::XMLFormatTarget& t,
                              const ::MDM::SetComponentStateResponse& s,
                              ::xml_schema::ErrorHandler& h,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetComponentStateResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetComponentStateResponse_ (::xercesc::XMLFormatTarget& t,
                              const ::MDM::SetComponentStateResponse& s,
                              ::xercesc::DOMErrorHandler& h,
                              const ::xml_schema::NamespaceInfomap& m,
                              const ::std::string& e,
                              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetComponentStateResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetComponentStateResponse_ (::xercesc::DOMDocument& d,
                              const ::MDM::SetComponentStateResponse& s,
                              ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetComponentStateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SetComponentStateResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  SetComponentStateResponse_ (const ::MDM::SetComponentStateResponse& s,
                              const ::xml_schema::NamespaceInfomap& m,
                              ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "SetComponentStateResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::SetComponentStateResponse_ (*d, s, f);
    return d;
  }

  void
  SetMetricState_ (::std::ostream& o,
                   const ::MDM::SetMetricState& s,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetMetricState_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetMetricState_ (::std::ostream& o,
                   const ::MDM::SetMetricState& s,
                   ::xml_schema::ErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetMetricState_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetMetricState_ (::std::ostream& o,
                   const ::MDM::SetMetricState& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetMetricState_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetMetricState_ (::xercesc::XMLFormatTarget& t,
                   const ::MDM::SetMetricState& s,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetMetricState_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetMetricState_ (::xercesc::XMLFormatTarget& t,
                   const ::MDM::SetMetricState& s,
                   ::xml_schema::ErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetMetricState_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetMetricState_ (::xercesc::XMLFormatTarget& t,
                   const ::MDM::SetMetricState& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetMetricState_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetMetricState_ (::xercesc::DOMDocument& d,
                   const ::MDM::SetMetricState& s,
                   ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetMetricState" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SetMetricState",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  SetMetricState_ (const ::MDM::SetMetricState& s,
                   const ::xml_schema::NamespaceInfomap& m,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "SetMetricState",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::SetMetricState_ (*d, s, f);
    return d;
  }

  void
  SetMetricStateResponse_ (::std::ostream& o,
                           const ::MDM::SetMetricStateResponse& s,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetMetricStateResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetMetricStateResponse_ (::std::ostream& o,
                           const ::MDM::SetMetricStateResponse& s,
                           ::xml_schema::ErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetMetricStateResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetMetricStateResponse_ (::std::ostream& o,
                           const ::MDM::SetMetricStateResponse& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetMetricStateResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetMetricStateResponse_ (::xercesc::XMLFormatTarget& t,
                           const ::MDM::SetMetricStateResponse& s,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetMetricStateResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SetMetricStateResponse_ (::xercesc::XMLFormatTarget& t,
                           const ::MDM::SetMetricStateResponse& s,
                           ::xml_schema::ErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetMetricStateResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetMetricStateResponse_ (::xercesc::XMLFormatTarget& t,
                           const ::MDM::SetMetricStateResponse& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SetMetricStateResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SetMetricStateResponse_ (::xercesc::DOMDocument& d,
                           const ::MDM::SetMetricStateResponse& s,
                           ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SetMetricStateResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SetMetricStateResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  SetMetricStateResponse_ (const ::MDM::SetMetricStateResponse& s,
                           const ::xml_schema::NamespaceInfomap& m,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "SetMetricStateResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::SetMetricStateResponse_ (*d, s, f);
    return d;
  }

  void
  OperationInvokedReport_ (::std::ostream& o,
                           const ::MDM::OperationInvokedReport& s,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::OperationInvokedReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  OperationInvokedReport_ (::std::ostream& o,
                           const ::MDM::OperationInvokedReport& s,
                           ::xml_schema::ErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::OperationInvokedReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  OperationInvokedReport_ (::std::ostream& o,
                           const ::MDM::OperationInvokedReport& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::OperationInvokedReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  OperationInvokedReport_ (::xercesc::XMLFormatTarget& t,
                           const ::MDM::OperationInvokedReport& s,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::OperationInvokedReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  OperationInvokedReport_ (::xercesc::XMLFormatTarget& t,
                           const ::MDM::OperationInvokedReport& s,
                           ::xml_schema::ErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::OperationInvokedReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  OperationInvokedReport_ (::xercesc::XMLFormatTarget& t,
                           const ::MDM::OperationInvokedReport& s,
                           ::xercesc::DOMErrorHandler& h,
                           const ::xml_schema::NamespaceInfomap& m,
                           const ::std::string& e,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::OperationInvokedReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  OperationInvokedReport_ (::xercesc::DOMDocument& d,
                           const ::MDM::OperationInvokedReport& s,
                           ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "OperationInvokedReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "OperationInvokedReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  OperationInvokedReport_ (const ::MDM::OperationInvokedReport& s,
                           const ::xml_schema::NamespaceInfomap& m,
                           ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "OperationInvokedReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::OperationInvokedReport_ (*d, s, f);
    return d;
  }

  void
  GetContainmentTree_ (::std::ostream& o,
                       const ::MDM::GetContainmentTree& s,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContainmentTree_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetContainmentTree_ (::std::ostream& o,
                       const ::MDM::GetContainmentTree& s,
                       ::xml_schema::ErrorHandler& h,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContainmentTree_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContainmentTree_ (::std::ostream& o,
                       const ::MDM::GetContainmentTree& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContainmentTree_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContainmentTree_ (::xercesc::XMLFormatTarget& t,
                       const ::MDM::GetContainmentTree& s,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContainmentTree_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetContainmentTree_ (::xercesc::XMLFormatTarget& t,
                       const ::MDM::GetContainmentTree& s,
                       ::xml_schema::ErrorHandler& h,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContainmentTree_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContainmentTree_ (::xercesc::XMLFormatTarget& t,
                       const ::MDM::GetContainmentTree& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::NamespaceInfomap& m,
                       const ::std::string& e,
                       ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContainmentTree_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContainmentTree_ (::xercesc::DOMDocument& d,
                       const ::MDM::GetContainmentTree& s,
                       ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetContainmentTree" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetContainmentTree",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetContainmentTree_ (const ::MDM::GetContainmentTree& s,
                       const ::xml_schema::NamespaceInfomap& m,
                       ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetContainmentTree",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetContainmentTree_ (*d, s, f);
    return d;
  }

  void
  GetContainmentTreeResponse_ (::std::ostream& o,
                               const ::MDM::GetContainmentTreeResponse& s,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContainmentTreeResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetContainmentTreeResponse_ (::std::ostream& o,
                               const ::MDM::GetContainmentTreeResponse& s,
                               ::xml_schema::ErrorHandler& h,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContainmentTreeResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContainmentTreeResponse_ (::std::ostream& o,
                               const ::MDM::GetContainmentTreeResponse& s,
                               ::xercesc::DOMErrorHandler& h,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContainmentTreeResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContainmentTreeResponse_ (::xercesc::XMLFormatTarget& t,
                               const ::MDM::GetContainmentTreeResponse& s,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContainmentTreeResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetContainmentTreeResponse_ (::xercesc::XMLFormatTarget& t,
                               const ::MDM::GetContainmentTreeResponse& s,
                               ::xml_schema::ErrorHandler& h,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContainmentTreeResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContainmentTreeResponse_ (::xercesc::XMLFormatTarget& t,
                               const ::MDM::GetContainmentTreeResponse& s,
                               ::xercesc::DOMErrorHandler& h,
                               const ::xml_schema::NamespaceInfomap& m,
                               const ::std::string& e,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetContainmentTreeResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetContainmentTreeResponse_ (::xercesc::DOMDocument& d,
                               const ::MDM::GetContainmentTreeResponse& s,
                               ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetContainmentTreeResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetContainmentTreeResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetContainmentTreeResponse_ (const ::MDM::GetContainmentTreeResponse& s,
                               const ::xml_schema::NamespaceInfomap& m,
                               ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetContainmentTreeResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetContainmentTreeResponse_ (*d, s, f);
    return d;
  }

  void
  GetDescriptor_ (::std::ostream& o,
                  const ::MDM::GetDescriptor& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptor_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetDescriptor_ (::std::ostream& o,
                  const ::MDM::GetDescriptor& s,
                  ::xml_schema::ErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptor_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetDescriptor_ (::std::ostream& o,
                  const ::MDM::GetDescriptor& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptor_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetDescriptor_ (::xercesc::XMLFormatTarget& t,
                  const ::MDM::GetDescriptor& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptor_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetDescriptor_ (::xercesc::XMLFormatTarget& t,
                  const ::MDM::GetDescriptor& s,
                  ::xml_schema::ErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptor_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetDescriptor_ (::xercesc::XMLFormatTarget& t,
                  const ::MDM::GetDescriptor& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptor_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetDescriptor_ (::xercesc::DOMDocument& d,
                  const ::MDM::GetDescriptor& s,
                  ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetDescriptor" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetDescriptor",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetDescriptor_ (const ::MDM::GetDescriptor& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetDescriptor",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetDescriptor_ (*d, s, f);
    return d;
  }

  void
  GetDescriptorResponse_ (::std::ostream& o,
                          const ::MDM::GetDescriptorResponse& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetDescriptorResponse_ (::std::ostream& o,
                          const ::MDM::GetDescriptorResponse& s,
                          ::xml_schema::ErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetDescriptorResponse_ (::std::ostream& o,
                          const ::MDM::GetDescriptorResponse& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorResponse_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetDescriptorResponse_ (::xercesc::XMLFormatTarget& t,
                          const ::MDM::GetDescriptorResponse& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorResponse_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GetDescriptorResponse_ (::xercesc::XMLFormatTarget& t,
                          const ::MDM::GetDescriptorResponse& s,
                          ::xml_schema::ErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetDescriptorResponse_ (::xercesc::XMLFormatTarget& t,
                          const ::MDM::GetDescriptorResponse& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::NamespaceInfomap& m,
                          const ::std::string& e,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::GetDescriptorResponse_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GetDescriptorResponse_ (::xercesc::DOMDocument& d,
                          const ::MDM::GetDescriptorResponse& s,
                          ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GetDescriptorResponse" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GetDescriptorResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  GetDescriptorResponse_ (const ::MDM::GetDescriptorResponse& s,
                          const ::xml_schema::NamespaceInfomap& m,
                          ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GetDescriptorResponse",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::GetDescriptorResponse_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const AbstractMetricReport& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // ReportPart
    //
    for (AbstractMetricReport::ReportPartConstIterator
         b (i.ReportPart ().begin ()), n (i.ReportPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReportPart",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractMetricReport >
  _xsd_AbstractMetricReport_type_serializer_init (
    "AbstractMetricReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  EpisodicMetricReport_ (::std::ostream& o,
                         const ::MDM::EpisodicMetricReport& s,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicMetricReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EpisodicMetricReport_ (::std::ostream& o,
                         const ::MDM::EpisodicMetricReport& s,
                         ::xml_schema::ErrorHandler& h,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicMetricReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicMetricReport_ (::std::ostream& o,
                         const ::MDM::EpisodicMetricReport& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicMetricReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicMetricReport_ (::xercesc::XMLFormatTarget& t,
                         const ::MDM::EpisodicMetricReport& s,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicMetricReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EpisodicMetricReport_ (::xercesc::XMLFormatTarget& t,
                         const ::MDM::EpisodicMetricReport& s,
                         ::xml_schema::ErrorHandler& h,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicMetricReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicMetricReport_ (::xercesc::XMLFormatTarget& t,
                         const ::MDM::EpisodicMetricReport& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicMetricReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicMetricReport_ (::xercesc::DOMDocument& d,
                         const ::MDM::EpisodicMetricReport& s,
                         ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EpisodicMetricReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EpisodicMetricReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  EpisodicMetricReport_ (const ::MDM::EpisodicMetricReport& s,
                         const ::xml_schema::NamespaceInfomap& m,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "EpisodicMetricReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::EpisodicMetricReport_ (*d, s, f);
    return d;
  }

  void
  PeriodicMetricReport_ (::std::ostream& o,
                         const ::MDM::PeriodicMetricReport& s,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicMetricReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  PeriodicMetricReport_ (::std::ostream& o,
                         const ::MDM::PeriodicMetricReport& s,
                         ::xml_schema::ErrorHandler& h,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicMetricReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicMetricReport_ (::std::ostream& o,
                         const ::MDM::PeriodicMetricReport& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicMetricReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicMetricReport_ (::xercesc::XMLFormatTarget& t,
                         const ::MDM::PeriodicMetricReport& s,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicMetricReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  PeriodicMetricReport_ (::xercesc::XMLFormatTarget& t,
                         const ::MDM::PeriodicMetricReport& s,
                         ::xml_schema::ErrorHandler& h,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicMetricReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicMetricReport_ (::xercesc::XMLFormatTarget& t,
                         const ::MDM::PeriodicMetricReport& s,
                         ::xercesc::DOMErrorHandler& h,
                         const ::xml_schema::NamespaceInfomap& m,
                         const ::std::string& e,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicMetricReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicMetricReport_ (::xercesc::DOMDocument& d,
                         const ::MDM::PeriodicMetricReport& s,
                         ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "PeriodicMetricReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PeriodicMetricReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  PeriodicMetricReport_ (const ::MDM::PeriodicMetricReport& s,
                         const ::xml_schema::NamespaceInfomap& m,
                         ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "PeriodicMetricReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::PeriodicMetricReport_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const AbstractComponentReport& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // ReportPart
    //
    for (AbstractComponentReport::ReportPartConstIterator
         b (i.ReportPart ().begin ()), n (i.ReportPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReportPart",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractComponentReport >
  _xsd_AbstractComponentReport_type_serializer_init (
    "AbstractComponentReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  EpisodicComponentReport_ (::std::ostream& o,
                            const ::MDM::EpisodicComponentReport& s,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicComponentReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EpisodicComponentReport_ (::std::ostream& o,
                            const ::MDM::EpisodicComponentReport& s,
                            ::xml_schema::ErrorHandler& h,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicComponentReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicComponentReport_ (::std::ostream& o,
                            const ::MDM::EpisodicComponentReport& s,
                            ::xercesc::DOMErrorHandler& h,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicComponentReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicComponentReport_ (::xercesc::XMLFormatTarget& t,
                            const ::MDM::EpisodicComponentReport& s,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicComponentReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EpisodicComponentReport_ (::xercesc::XMLFormatTarget& t,
                            const ::MDM::EpisodicComponentReport& s,
                            ::xml_schema::ErrorHandler& h,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicComponentReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicComponentReport_ (::xercesc::XMLFormatTarget& t,
                            const ::MDM::EpisodicComponentReport& s,
                            ::xercesc::DOMErrorHandler& h,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicComponentReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicComponentReport_ (::xercesc::DOMDocument& d,
                            const ::MDM::EpisodicComponentReport& s,
                            ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EpisodicComponentReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EpisodicComponentReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  EpisodicComponentReport_ (const ::MDM::EpisodicComponentReport& s,
                            const ::xml_schema::NamespaceInfomap& m,
                            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "EpisodicComponentReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::EpisodicComponentReport_ (*d, s, f);
    return d;
  }

  void
  PeriodicComponentReport_ (::std::ostream& o,
                            const ::MDM::PeriodicComponentReport& s,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicComponentReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  PeriodicComponentReport_ (::std::ostream& o,
                            const ::MDM::PeriodicComponentReport& s,
                            ::xml_schema::ErrorHandler& h,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicComponentReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicComponentReport_ (::std::ostream& o,
                            const ::MDM::PeriodicComponentReport& s,
                            ::xercesc::DOMErrorHandler& h,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicComponentReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicComponentReport_ (::xercesc::XMLFormatTarget& t,
                            const ::MDM::PeriodicComponentReport& s,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicComponentReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  PeriodicComponentReport_ (::xercesc::XMLFormatTarget& t,
                            const ::MDM::PeriodicComponentReport& s,
                            ::xml_schema::ErrorHandler& h,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicComponentReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicComponentReport_ (::xercesc::XMLFormatTarget& t,
                            const ::MDM::PeriodicComponentReport& s,
                            ::xercesc::DOMErrorHandler& h,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicComponentReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicComponentReport_ (::xercesc::DOMDocument& d,
                            const ::MDM::PeriodicComponentReport& s,
                            ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "PeriodicComponentReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PeriodicComponentReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  PeriodicComponentReport_ (const ::MDM::PeriodicComponentReport& s,
                            const ::xml_schema::NamespaceInfomap& m,
                            ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "PeriodicComponentReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::PeriodicComponentReport_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const AbstractAlertReport& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // ReportPart
    //
    for (AbstractAlertReport::ReportPartConstIterator
         b (i.ReportPart ().begin ()), n (i.ReportPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReportPart",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractAlertReport >
  _xsd_AbstractAlertReport_type_serializer_init (
    "AbstractAlertReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  EpisodicAlertReport_ (::std::ostream& o,
                        const ::MDM::EpisodicAlertReport& s,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicAlertReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EpisodicAlertReport_ (::std::ostream& o,
                        const ::MDM::EpisodicAlertReport& s,
                        ::xml_schema::ErrorHandler& h,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicAlertReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicAlertReport_ (::std::ostream& o,
                        const ::MDM::EpisodicAlertReport& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicAlertReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicAlertReport_ (::xercesc::XMLFormatTarget& t,
                        const ::MDM::EpisodicAlertReport& s,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicAlertReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EpisodicAlertReport_ (::xercesc::XMLFormatTarget& t,
                        const ::MDM::EpisodicAlertReport& s,
                        ::xml_schema::ErrorHandler& h,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicAlertReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicAlertReport_ (::xercesc::XMLFormatTarget& t,
                        const ::MDM::EpisodicAlertReport& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicAlertReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicAlertReport_ (::xercesc::DOMDocument& d,
                        const ::MDM::EpisodicAlertReport& s,
                        ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EpisodicAlertReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EpisodicAlertReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  EpisodicAlertReport_ (const ::MDM::EpisodicAlertReport& s,
                        const ::xml_schema::NamespaceInfomap& m,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "EpisodicAlertReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::EpisodicAlertReport_ (*d, s, f);
    return d;
  }

  void
  PeriodicAlertReport_ (::std::ostream& o,
                        const ::MDM::PeriodicAlertReport& s,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicAlertReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  PeriodicAlertReport_ (::std::ostream& o,
                        const ::MDM::PeriodicAlertReport& s,
                        ::xml_schema::ErrorHandler& h,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicAlertReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicAlertReport_ (::std::ostream& o,
                        const ::MDM::PeriodicAlertReport& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicAlertReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicAlertReport_ (::xercesc::XMLFormatTarget& t,
                        const ::MDM::PeriodicAlertReport& s,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicAlertReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  PeriodicAlertReport_ (::xercesc::XMLFormatTarget& t,
                        const ::MDM::PeriodicAlertReport& s,
                        ::xml_schema::ErrorHandler& h,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicAlertReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicAlertReport_ (::xercesc::XMLFormatTarget& t,
                        const ::MDM::PeriodicAlertReport& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicAlertReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicAlertReport_ (::xercesc::DOMDocument& d,
                        const ::MDM::PeriodicAlertReport& s,
                        ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "PeriodicAlertReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PeriodicAlertReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  PeriodicAlertReport_ (const ::MDM::PeriodicAlertReport& s,
                        const ::xml_schema::NamespaceInfomap& m,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "PeriodicAlertReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::PeriodicAlertReport_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const AbstractOperationalStateReport& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // ReportPart
    //
    for (AbstractOperationalStateReport::ReportPartConstIterator
         b (i.ReportPart ().begin ()), n (i.ReportPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReportPart",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AbstractOperationalStateReport >
  _xsd_AbstractOperationalStateReport_type_serializer_init (
    "AbstractOperationalStateReport",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  EpisodicOperationalStateReport_ (::std::ostream& o,
                                   const ::MDM::EpisodicOperationalStateReport& s,
                                   const ::xml_schema::NamespaceInfomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicOperationalStateReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EpisodicOperationalStateReport_ (::std::ostream& o,
                                   const ::MDM::EpisodicOperationalStateReport& s,
                                   ::xml_schema::ErrorHandler& h,
                                   const ::xml_schema::NamespaceInfomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicOperationalStateReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicOperationalStateReport_ (::std::ostream& o,
                                   const ::MDM::EpisodicOperationalStateReport& s,
                                   ::xercesc::DOMErrorHandler& h,
                                   const ::xml_schema::NamespaceInfomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicOperationalStateReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicOperationalStateReport_ (::xercesc::XMLFormatTarget& t,
                                   const ::MDM::EpisodicOperationalStateReport& s,
                                   const ::xml_schema::NamespaceInfomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicOperationalStateReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EpisodicOperationalStateReport_ (::xercesc::XMLFormatTarget& t,
                                   const ::MDM::EpisodicOperationalStateReport& s,
                                   ::xml_schema::ErrorHandler& h,
                                   const ::xml_schema::NamespaceInfomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicOperationalStateReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicOperationalStateReport_ (::xercesc::XMLFormatTarget& t,
                                   const ::MDM::EpisodicOperationalStateReport& s,
                                   ::xercesc::DOMErrorHandler& h,
                                   const ::xml_schema::NamespaceInfomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::EpisodicOperationalStateReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EpisodicOperationalStateReport_ (::xercesc::DOMDocument& d,
                                   const ::MDM::EpisodicOperationalStateReport& s,
                                   ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EpisodicOperationalStateReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EpisodicOperationalStateReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  EpisodicOperationalStateReport_ (const ::MDM::EpisodicOperationalStateReport& s,
                                   const ::xml_schema::NamespaceInfomap& m,
                                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "EpisodicOperationalStateReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::EpisodicOperationalStateReport_ (*d, s, f);
    return d;
  }

  void
  PeriodicOperationalStateReport_ (::std::ostream& o,
                                   const ::MDM::PeriodicOperationalStateReport& s,
                                   const ::xml_schema::NamespaceInfomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicOperationalStateReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  PeriodicOperationalStateReport_ (::std::ostream& o,
                                   const ::MDM::PeriodicOperationalStateReport& s,
                                   ::xml_schema::ErrorHandler& h,
                                   const ::xml_schema::NamespaceInfomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicOperationalStateReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicOperationalStateReport_ (::std::ostream& o,
                                   const ::MDM::PeriodicOperationalStateReport& s,
                                   ::xercesc::DOMErrorHandler& h,
                                   const ::xml_schema::NamespaceInfomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicOperationalStateReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicOperationalStateReport_ (::xercesc::XMLFormatTarget& t,
                                   const ::MDM::PeriodicOperationalStateReport& s,
                                   const ::xml_schema::NamespaceInfomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicOperationalStateReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  PeriodicOperationalStateReport_ (::xercesc::XMLFormatTarget& t,
                                   const ::MDM::PeriodicOperationalStateReport& s,
                                   ::xml_schema::ErrorHandler& h,
                                   const ::xml_schema::NamespaceInfomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicOperationalStateReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicOperationalStateReport_ (::xercesc::XMLFormatTarget& t,
                                   const ::MDM::PeriodicOperationalStateReport& s,
                                   ::xercesc::DOMErrorHandler& h,
                                   const ::xml_schema::NamespaceInfomap& m,
                                   const ::std::string& e,
                                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::PeriodicOperationalStateReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  PeriodicOperationalStateReport_ (::xercesc::DOMDocument& d,
                                   const ::MDM::PeriodicOperationalStateReport& s,
                                   ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "PeriodicOperationalStateReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PeriodicOperationalStateReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  PeriodicOperationalStateReport_ (const ::MDM::PeriodicOperationalStateReport& s,
                                   const ::xml_schema::NamespaceInfomap& m,
                                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "PeriodicOperationalStateReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::PeriodicOperationalStateReport_ (*d, s, f);
    return d;
  }

  void
  SystemErrorReport_ (::std::ostream& o,
                      const ::MDM::SystemErrorReport& s,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SystemErrorReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SystemErrorReport_ (::std::ostream& o,
                      const ::MDM::SystemErrorReport& s,
                      ::xml_schema::ErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SystemErrorReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SystemErrorReport_ (::std::ostream& o,
                      const ::MDM::SystemErrorReport& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SystemErrorReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SystemErrorReport_ (::xercesc::XMLFormatTarget& t,
                      const ::MDM::SystemErrorReport& s,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SystemErrorReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  SystemErrorReport_ (::xercesc::XMLFormatTarget& t,
                      const ::MDM::SystemErrorReport& s,
                      ::xml_schema::ErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SystemErrorReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SystemErrorReport_ (::xercesc::XMLFormatTarget& t,
                      const ::MDM::SystemErrorReport& s,
                      ::xercesc::DOMErrorHandler& h,
                      const ::xml_schema::NamespaceInfomap& m,
                      const ::std::string& e,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::SystemErrorReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  SystemErrorReport_ (::xercesc::DOMDocument& d,
                      const ::MDM::SystemErrorReport& s,
                      ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "SystemErrorReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SystemErrorReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  SystemErrorReport_ (const ::MDM::SystemErrorReport& s,
                      const ::xml_schema::NamespaceInfomap& m,
                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "SystemErrorReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::SystemErrorReport_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const DescriptionModificationType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DescriptionModificationType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const DescriptionModificationType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DescriptionModificationType >
  _xsd_DescriptionModificationType_type_serializer_init (
    "DescriptionModificationType",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  DescriptionModificationReport_ (::std::ostream& o,
                                  const ::MDM::DescriptionModificationReport& s,
                                  const ::xml_schema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::DescriptionModificationReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  DescriptionModificationReport_ (::std::ostream& o,
                                  const ::MDM::DescriptionModificationReport& s,
                                  ::xml_schema::ErrorHandler& h,
                                  const ::xml_schema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::DescriptionModificationReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  DescriptionModificationReport_ (::std::ostream& o,
                                  const ::MDM::DescriptionModificationReport& s,
                                  ::xercesc::DOMErrorHandler& h,
                                  const ::xml_schema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::DescriptionModificationReport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  DescriptionModificationReport_ (::xercesc::XMLFormatTarget& t,
                                  const ::MDM::DescriptionModificationReport& s,
                                  const ::xml_schema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::DescriptionModificationReport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  DescriptionModificationReport_ (::xercesc::XMLFormatTarget& t,
                                  const ::MDM::DescriptionModificationReport& s,
                                  ::xml_schema::ErrorHandler& h,
                                  const ::xml_schema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::DescriptionModificationReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  DescriptionModificationReport_ (::xercesc::XMLFormatTarget& t,
                                  const ::MDM::DescriptionModificationReport& s,
                                  ::xercesc::DOMErrorHandler& h,
                                  const ::xml_schema::NamespaceInfomap& m,
                                  const ::std::string& e,
                                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::DescriptionModificationReport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  DescriptionModificationReport_ (::xercesc::DOMDocument& d,
                                  const ::MDM::DescriptionModificationReport& s,
                                  ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DescriptionModificationReport" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "DescriptionModificationReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  DescriptionModificationReport_ (const ::MDM::DescriptionModificationReport& s,
                                  const ::xml_schema::NamespaceInfomap& m,
                                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "DescriptionModificationReport",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::DescriptionModificationReport_ (*d, s, f);
    return d;
  }

  void
  WaveformStream_ (::std::ostream& o,
                   const ::MDM::WaveformStream& s,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::WaveformStream_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  WaveformStream_ (::std::ostream& o,
                   const ::MDM::WaveformStream& s,
                   ::xml_schema::ErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::WaveformStream_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  WaveformStream_ (::std::ostream& o,
                   const ::MDM::WaveformStream& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::WaveformStream_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  WaveformStream_ (::xercesc::XMLFormatTarget& t,
                   const ::MDM::WaveformStream& s,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::WaveformStream_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  WaveformStream_ (::xercesc::XMLFormatTarget& t,
                   const ::MDM::WaveformStream& s,
                   ::xml_schema::ErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::WaveformStream_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  WaveformStream_ (::xercesc::XMLFormatTarget& t,
                   const ::MDM::WaveformStream& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::WaveformStream_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  WaveformStream_ (::xercesc::DOMDocument& d,
                   const ::MDM::WaveformStream& s,
                   ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "WaveformStream" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "WaveformStream",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  WaveformStream_ (const ::MDM::WaveformStream& s,
                   const ::xml_schema::NamespaceInfomap& m,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "WaveformStream",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::WaveformStream_ (*d, s, f);
    return d;
  }

  void
  ObservedValueStream_ (::std::ostream& o,
                        const ::MDM::ObservedValueStream& s,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::ObservedValueStream_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ObservedValueStream_ (::std::ostream& o,
                        const ::MDM::ObservedValueStream& s,
                        ::xml_schema::ErrorHandler& h,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::ObservedValueStream_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ObservedValueStream_ (::std::ostream& o,
                        const ::MDM::ObservedValueStream& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::ObservedValueStream_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ObservedValueStream_ (::xercesc::XMLFormatTarget& t,
                        const ::MDM::ObservedValueStream& s,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::ObservedValueStream_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ObservedValueStream_ (::xercesc::XMLFormatTarget& t,
                        const ::MDM::ObservedValueStream& s,
                        ::xml_schema::ErrorHandler& h,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::ObservedValueStream_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ObservedValueStream_ (::xercesc::XMLFormatTarget& t,
                        const ::MDM::ObservedValueStream& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::NamespaceInfomap& m,
                        const ::std::string& e,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::ObservedValueStream_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ObservedValueStream_ (::xercesc::DOMDocument& d,
                        const ::MDM::ObservedValueStream& s,
                        ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ObservedValueStream" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ObservedValueStream",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  ObservedValueStream_ (const ::MDM::ObservedValueStream& s,
                        const ::xml_schema::NamespaceInfomap& m,
                        ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "ObservedValueStream",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::ObservedValueStream_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const RetrievabilityMethod& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const RetrievabilityMethod& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const RetrievabilityMethod& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RetrievabilityMethod >
  _xsd_RetrievabilityMethod_type_serializer_init (
    "RetrievabilityMethod",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  operator<< (::xercesc::DOMElement& e, const RetrievabilityInfo& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const RetrievabilityInfo::ExtensionType& x (*i.Extension ());
        if (typeid (RetrievabilityInfo::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // Method
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Method",
          e));

      a << i.Method ();
    }

    // UpdatePeriod
    //
    if (i.UpdatePeriod ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "UpdatePeriod",
          e));

      a << *i.UpdatePeriod ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RetrievabilityInfo >
  _xsd_RetrievabilityInfo_type_serializer_init (
    "RetrievabilityInfo",
    "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");


  void
  Retrievability_ (::std::ostream& o,
                   const ::MDM::Retrievability& s,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::Retrievability_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  Retrievability_ (::std::ostream& o,
                   const ::MDM::Retrievability& s,
                   ::xml_schema::ErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::Retrievability_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Retrievability_ (::std::ostream& o,
                   const ::MDM::Retrievability& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::Retrievability_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Retrievability_ (::xercesc::XMLFormatTarget& t,
                   const ::MDM::Retrievability& s,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::Retrievability_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  Retrievability_ (::xercesc::XMLFormatTarget& t,
                   const ::MDM::Retrievability& s,
                   ::xml_schema::ErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::Retrievability_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Retrievability_ (::xercesc::XMLFormatTarget& t,
                   const ::MDM::Retrievability& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::NamespaceInfomap& m,
                   const ::std::string& e,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::MDM::Retrievability_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  Retrievability_ (::xercesc::DOMDocument& d,
                   const ::MDM::Retrievability& s,
                   ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "Retrievability" &&
        n.namespace_ () == "http://standards.ieee.org/downloads/11073/11073-10207-2017/message")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Retrievability",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  Retrievability_ (const ::MDM::Retrievability& s,
                   const ::xml_schema::NamespaceInfomap& m,
                   ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "Retrievability",
        "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
        m, f));

    ::MDM::Retrievability_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetMdib& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetMdibResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // Mdib
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const GetMdibResponse::MdibType& x (i.Mdib ());
      if (typeid (GetMdibResponse::MdibType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Mdib",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Mdib",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetMdDescription& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // HandleRef
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetMdDescription::HandleRefConstIterator
           b (i.HandleRef ().begin ()), n (i.HandleRef ().end ());
           b != n; ++b)
      {
        if (typeid (GetMdDescription::HandleRefType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "HandleRef",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetMdDescriptionResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // MdDescription
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const GetMdDescriptionResponse::MdDescriptionType& x (i.MdDescription ());
      if (typeid (GetMdDescriptionResponse::MdDescriptionType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MdDescription",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MdDescription",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetMdState& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // HandleRef
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetMdState::HandleRefConstIterator
           b (i.HandleRef ().begin ()), n (i.HandleRef ().end ());
           b != n; ++b)
      {
        if (typeid (GetMdState::HandleRefType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "HandleRef",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetMdStateResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // MdState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const GetMdStateResponse::MdStateType& x (i.MdState ());
      if (typeid (GetMdStateResponse::MdStateType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MdState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MdState",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetContextStates& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // HandleRef
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetContextStates::HandleRefConstIterator
           b (i.HandleRef ().begin ()), n (i.HandleRef ().end ());
           b != n; ++b)
      {
        if (typeid (GetContextStates::HandleRefType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "HandleRef",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetContextStatesResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // ContextState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetContextStatesResponse::ContextStateConstIterator
           b (i.ContextState ().begin ()), n (i.ContextState ().end ());
           b != n; ++b)
      {
        if (typeid (GetContextStatesResponse::ContextStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ContextState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetContextStatesByIdentification& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // Identification
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetContextStatesByIdentification::IdentificationConstIterator
           b (i.Identification ().begin ()), n (i.Identification ().end ());
           b != n; ++b)
      {
        if (typeid (GetContextStatesByIdentification::IdentificationType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Identification",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Identification",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }

    // ContextType
    //
    if (i.ContextType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ContextType",
          e));

      a << *i.ContextType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetContextStatesByIdentificationResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // ContextState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetContextStatesByIdentificationResponse::ContextStateConstIterator
           b (i.ContextState ().begin ()), n (i.ContextState ().end ());
           b != n; ++b)
      {
        if (typeid (GetContextStatesByIdentificationResponse::ContextStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ContextState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetContextStatesByFilter& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // Filter
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetContextStatesByFilter::FilterConstIterator
           b (i.Filter ().begin ()), n (i.Filter ().end ());
           b != n; ++b)
      {
        if (typeid (GetContextStatesByFilter::FilterType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Filter",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Filter",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }

    // ContextType
    //
    if (i.ContextType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ContextType",
          e));

      a << *i.ContextType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetContextStatesByFilterResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // ContextState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetContextStatesByFilterResponse::ContextStateConstIterator
           b (i.ContextState ().begin ()), n (i.ContextState ().end ());
           b != n; ++b)
      {
        if (typeid (GetContextStatesByFilterResponse::ContextStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ContextState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetContextState& i)
  {
    e << static_cast< const ::MDM::AbstractSet& > (i);

    // ProposedContextState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SetContextState::ProposedContextStateConstIterator
           b (i.ProposedContextState ().begin ()), n (i.ProposedContextState ().end ());
           b != n; ++b)
      {
        if (typeid (SetContextState::ProposedContextStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ProposedContextState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ProposedContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetContextStateResponse& i)
  {
    e << static_cast< const ::MDM::AbstractSetResponse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReportPart& i)
  {
    e << static_cast< const ::MDM::AbstractReportPart& > (i);

    // ContextState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ReportPart::ContextStateConstIterator
           b (i.ContextState ().begin ()), n (i.ContextState ().end ());
           b != n; ++b)
      {
        if (typeid (ReportPart::ContextStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ContextState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ContextState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PeriodicContextReport& i)
  {
    e << static_cast< const ::MDM::AbstractContextReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const EpisodicContextReport& i)
  {
    e << static_cast< const ::MDM::AbstractContextReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetLocalizedText& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // Ref
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetLocalizedText::RefConstIterator
           b (i.Ref ().begin ()), n (i.Ref ().end ());
           b != n; ++b)
      {
        if (typeid (GetLocalizedText::RefType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Ref",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Ref",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }

    // Version
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Version ())
      {
        const GetLocalizedText::VersionType& x (*i.Version ());
        if (typeid (GetLocalizedText::VersionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Version",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Version",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }

    // Lang
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetLocalizedText::LangConstIterator
           b (i.Lang ().begin ()), n (i.Lang ().end ());
           b != n; ++b)
      {
        if (typeid (GetLocalizedText::LangType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Lang",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Lang",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }

    // TextWidth
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetLocalizedText::TextWidthConstIterator
           b (i.TextWidth ().begin ()), n (i.TextWidth ().end ());
           b != n; ++b)
      {
        if (typeid (GetLocalizedText::TextWidthType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TextWidth",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "TextWidth",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }

    // NumberOfLines
    //
    for (GetLocalizedText::NumberOfLinesConstIterator
         b (i.NumberOfLines ().begin ()), n (i.NumberOfLines ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "NumberOfLines",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetLocalizedTextResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // Text
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetLocalizedTextResponse::TextConstIterator
           b (i.Text ().begin ()), n (i.Text ().end ());
           b != n; ++b)
      {
        if (typeid (GetLocalizedTextResponse::TextType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Text",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Text",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetSupportedLanguages& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetSupportedLanguagesResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // Lang
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetSupportedLanguagesResponse::LangConstIterator
           b (i.Lang ().begin ()), n (i.Lang ().end ());
           b != n; ++b)
      {
        if (typeid (GetSupportedLanguagesResponse::LangType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Lang",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Lang",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetDescriptorsFromArchive& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // DescriptorRevisions
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.DescriptorRevisions ())
      {
        const GetDescriptorsFromArchive::DescriptorRevisionsType& x (*i.DescriptorRevisions ());
        if (typeid (GetDescriptorsFromArchive::DescriptorRevisionsType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "DescriptorRevisions",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "DescriptorRevisions",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }

    // TimeFrame
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.TimeFrame ())
      {
        const GetDescriptorsFromArchive::TimeFrameType& x (*i.TimeFrame ());
        if (typeid (GetDescriptorsFromArchive::TimeFrameType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TimeFrame",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "TimeFrame",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }

    // Handle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetDescriptorsFromArchive::HandleConstIterator
           b (i.Handle ().begin ()), n (i.Handle ().end ());
           b != n; ++b)
      {
        if (typeid (GetDescriptorsFromArchive::HandleType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Handle",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Handle",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetDescriptorsFromArchiveResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // Descriptor
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetDescriptorsFromArchiveResponse::DescriptorConstIterator
           b (i.Descriptor ().begin ()), n (i.Descriptor ().end ());
           b != n; ++b)
      {
        if (typeid (GetDescriptorsFromArchiveResponse::DescriptorType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Descriptor",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Descriptor",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetStatesFromArchive& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // StateRevisions
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.StateRevisions ())
      {
        const GetStatesFromArchive::StateRevisionsType& x (*i.StateRevisions ());
        if (typeid (GetStatesFromArchive::StateRevisionsType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "StateRevisions",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "StateRevisions",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }

    // TimeFrame
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.TimeFrame ())
      {
        const GetStatesFromArchive::TimeFrameType& x (*i.TimeFrame ());
        if (typeid (GetStatesFromArchive::TimeFrameType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "TimeFrame",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "TimeFrame",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }

    // Handle
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetStatesFromArchive::HandleConstIterator
           b (i.Handle ().begin ()), n (i.Handle ().end ());
           b != n; ++b)
      {
        if (typeid (GetStatesFromArchive::HandleType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Handle",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Handle",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetStatesFromArchiveResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // State
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetStatesFromArchiveResponse::StateConstIterator
           b (i.State ().begin ()), n (i.State ().end ());
           b != n; ++b)
      {
        if (typeid (GetStatesFromArchiveResponse::StateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "State",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "State",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetValue& i)
  {
    e << static_cast< const ::MDM::AbstractSet& > (i);

    // RequestedNumericValue
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RequestedNumericValue",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << ::xml_schema::AsDecimal(i.RequestedNumericValue ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetValueResponse& i)
  {
    e << static_cast< const ::MDM::AbstractSetResponse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetString& i)
  {
    e << static_cast< const ::MDM::AbstractSet& > (i);

    // RequestedStringValue
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const SetString::RequestedStringValueType& x (i.RequestedStringValue ());
      if (typeid (SetString::RequestedStringValueType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RequestedStringValue",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "RequestedStringValue",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetStringResponse& i)
  {
    e << static_cast< const ::MDM::AbstractSetResponse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Activate& i)
  {
    e << static_cast< const ::MDM::AbstractSet& > (i);

    // Argument
    //
    for (Activate::ArgumentConstIterator
         b (i.Argument ().begin ()), n (i.Argument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Argument",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ActivateResponse& i)
  {
    e << static_cast< const ::MDM::AbstractSetResponse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetAlertState& i)
  {
    e << static_cast< const ::MDM::AbstractSet& > (i);

    // ProposedAlertState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const SetAlertState::ProposedAlertStateType& x (i.ProposedAlertState ());
      if (typeid (SetAlertState::ProposedAlertStateType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProposedAlertState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ProposedAlertState",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetAlertStateResponse& i)
  {
    e << static_cast< const ::MDM::AbstractSetResponse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetComponentState& i)
  {
    e << static_cast< const ::MDM::AbstractSet& > (i);

    // ProposedComponentState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SetComponentState::ProposedComponentStateConstIterator
           b (i.ProposedComponentState ().begin ()), n (i.ProposedComponentState ().end ());
           b != n; ++b)
      {
        if (typeid (SetComponentState::ProposedComponentStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ProposedComponentState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ProposedComponentState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetComponentStateResponse& i)
  {
    e << static_cast< const ::MDM::AbstractSetResponse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetMetricState& i)
  {
    e << static_cast< const ::MDM::AbstractSet& > (i);

    // ProposedMetricState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SetMetricState::ProposedMetricStateConstIterator
           b (i.ProposedMetricState ().begin ()), n (i.ProposedMetricState ().end ());
           b != n; ++b)
      {
        if (typeid (SetMetricState::ProposedMetricStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ProposedMetricState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ProposedMetricState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SetMetricStateResponse& i)
  {
    e << static_cast< const ::MDM::AbstractSetResponse& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const OperationInvokedReport& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // ReportPart
    //
    for (OperationInvokedReport::ReportPartConstIterator
         b (i.ReportPart ().begin ()), n (i.ReportPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReportPart",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetContainmentTree& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // HandleRef
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetContainmentTree::HandleRefConstIterator
           b (i.HandleRef ().begin ()), n (i.HandleRef ().end ());
           b != n; ++b)
      {
        if (typeid (GetContainmentTree::HandleRefType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "HandleRef",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetContainmentTreeResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // ContainmentTree
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const GetContainmentTreeResponse::ContainmentTreeType& x (i.ContainmentTree ());
      if (typeid (GetContainmentTreeResponse::ContainmentTreeType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ContainmentTree",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ContainmentTree",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetDescriptor& i)
  {
    e << static_cast< const ::MDM::AbstractGet& > (i);

    // HandleRef
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetDescriptor::HandleRefConstIterator
           b (i.HandleRef ().begin ()), n (i.HandleRef ().end ());
           b != n; ++b)
      {
        if (typeid (GetDescriptor::HandleRefType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "HandleRef",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "HandleRef",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GetDescriptorResponse& i)
  {
    e << static_cast< const ::MDM::AbstractGetResponse& > (i);

    // Descriptor
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (GetDescriptorResponse::DescriptorConstIterator
           b (i.Descriptor ().begin ()), n (i.Descriptor ().end ());
           b != n; ++b)
      {
        if (typeid (GetDescriptorResponse::DescriptorType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Descriptor",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Descriptor",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReportPart1& i)
  {
    e << static_cast< const ::MDM::AbstractReportPart& > (i);

    // MetricState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ReportPart1::MetricStateConstIterator
           b (i.MetricState ().begin ()), n (i.MetricState ().end ());
           b != n; ++b)
      {
        if (typeid (ReportPart1::MetricStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "MetricState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "MetricState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EpisodicMetricReport& i)
  {
    e << static_cast< const ::MDM::AbstractMetricReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const PeriodicMetricReport& i)
  {
    e << static_cast< const ::MDM::AbstractMetricReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReportPart2& i)
  {
    e << static_cast< const ::MDM::AbstractReportPart& > (i);

    // ComponentState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ReportPart2::ComponentStateConstIterator
           b (i.ComponentState ().begin ()), n (i.ComponentState ().end ());
           b != n; ++b)
      {
        if (typeid (ReportPart2::ComponentStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ComponentState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "ComponentState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EpisodicComponentReport& i)
  {
    e << static_cast< const ::MDM::AbstractComponentReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const PeriodicComponentReport& i)
  {
    e << static_cast< const ::MDM::AbstractComponentReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReportPart3& i)
  {
    e << static_cast< const ::MDM::AbstractReportPart& > (i);

    // AlertState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ReportPart3::AlertStateConstIterator
           b (i.AlertState ().begin ()), n (i.AlertState ().end ());
           b != n; ++b)
      {
        if (typeid (ReportPart3::AlertStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "AlertState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "AlertState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EpisodicAlertReport& i)
  {
    e << static_cast< const ::MDM::AbstractAlertReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const PeriodicAlertReport& i)
  {
    e << static_cast< const ::MDM::AbstractAlertReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReportPart4& i)
  {
    e << static_cast< const ::MDM::AbstractReportPart& > (i);

    // OperationState
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ReportPart4::OperationStateConstIterator
           b (i.OperationState ().begin ()), n (i.OperationState ().end ());
           b != n; ++b)
      {
        if (typeid (ReportPart4::OperationStateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "OperationState",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "OperationState",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EpisodicOperationalStateReport& i)
  {
    e << static_cast< const ::MDM::AbstractOperationalStateReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const PeriodicOperationalStateReport& i)
  {
    e << static_cast< const ::MDM::AbstractOperationalStateReport& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const SystemErrorReport& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // ReportPart
    //
    for (SystemErrorReport::ReportPartConstIterator
         b (i.ReportPart ().begin ()), n (i.ReportPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReportPart",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DescriptionModificationReport& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // ReportPart
    //
    for (DescriptionModificationReport::ReportPartConstIterator
         b (i.ReportPart ().begin ()), n (i.ReportPart ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReportPart",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const WaveformStream& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // State
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (WaveformStream::StateConstIterator
           b (i.State ().begin ()), n (i.State ().end ());
           b != n; ++b)
      {
        if (typeid (WaveformStream::StateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "State",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "State",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ObservedValueStream& i)
  {
    e << static_cast< const ::MDM::AbstractReport& > (i);

    // Value
    //
    for (ObservedValueStream::ValueConstIterator
         b (i.Value ().begin ()), n (i.Value ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Value",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Retrievability& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // By
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (Retrievability::ByConstIterator
           b (i.By ().begin ()), n (i.By ().end ());
           b != n; ++b)
      {
        if (typeid (Retrievability::ByType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "By",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "By",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Argument& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Extension
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Extension ())
      {
        const Argument::ExtensionType& x (*i.Extension ());
        if (typeid (Argument::ExtensionType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Extension",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Extension",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/extension",
            true, true, e, x);
      }
    }

    // ArgValue
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const Argument::ArgValueType& x (i.ArgValue ());
      if (typeid (Argument::ArgValueType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ArgValue",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ArgValue",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReportPart5& i)
  {
    e << static_cast< const ::MDM::AbstractReportPart& > (i);

    // InvocationInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ReportPart5::InvocationInfoType& x (i.InvocationInfo ());
      if (typeid (ReportPart5::InvocationInfoType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InvocationInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "InvocationInfo",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }

    // InvocationSource
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ReportPart5::InvocationSourceType& x (i.InvocationSource ());
      if (typeid (ReportPart5::InvocationSourceType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InvocationSource",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "InvocationSource",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }

    // OperationHandleRef
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "OperationHandleRef",
          e));

      a << i.OperationHandleRef ();
    }

    // OperationTarget
    //
    if (i.OperationTarget ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "OperationTarget",
          e));

      a << *i.OperationTarget ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReportPart6& i)
  {
    e << static_cast< const ::MDM::AbstractReportPart& > (i);

    // ErrorCode
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const ReportPart6::ErrorCodeType& x (i.ErrorCode ());
      if (typeid (ReportPart6::ErrorCodeType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ErrorCode",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ErrorCode",
          "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
          false, true, e, x);
    }

    // ErrorInfo
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.ErrorInfo ())
      {
        const ReportPart6::ErrorInfoType& x (*i.ErrorInfo ());
        if (typeid (ReportPart6::ErrorInfoType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ErrorInfo",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ErrorInfo",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReportPart7& i)
  {
    e << static_cast< const ::MDM::AbstractReportPart& > (i);

    // Descriptor
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ReportPart7::DescriptorConstIterator
           b (i.Descriptor ().begin ()), n (i.Descriptor ().end ());
           b != n; ++b)
      {
        if (typeid (ReportPart7::DescriptorType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Descriptor",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Descriptor",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }

    // State
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (ReportPart7::StateConstIterator
           b (i.State ().begin ()), n (i.State ().end ());
           b != n; ++b)
      {
        if (typeid (ReportPart7::StateType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "State",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "State",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, *b);
      }
    }

    // ParentDescriptor
    //
    if (i.ParentDescriptor ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ParentDescriptor",
          e));

      a << *i.ParentDescriptor ();
    }

    // ModificationType
    //
    if (i.ModificationType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "ModificationType",
          e));

      a << *i.ModificationType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Value& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Value
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.Value1 ())
      {
        const Value::Value1Type& x (*i.Value1 ());
        if (typeid (Value::Value1Type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Value",
              "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "Value",
            "http://standards.ieee.org/downloads/11073/11073-10207-2017/message",
            false, true, e, x);
      }
    }

    // Metric
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Metric",
          e));

      a << i.Metric ();
    }

    // StateVersion
    //
    if (i.StateVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "StateVersion",
          e));

      a << *i.StateVersion ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

