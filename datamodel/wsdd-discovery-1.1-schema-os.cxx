// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "wsdd-discovery-1.1-schema-os.hxx"

namespace WS
{
  namespace DISCOVERY
  {
    // HelloType
    // 

    const HelloType::EndpointReferenceType& HelloType::
    EndpointReference () const
    {
      return this->EndpointReference_.get ();
    }

    HelloType::EndpointReferenceType& HelloType::
    EndpointReference ()
    {
      return this->EndpointReference_.get ();
    }

    void HelloType::
    EndpointReference (const EndpointReferenceType& x)
    {
      this->EndpointReference_.set (x);
    }

    void HelloType::
    EndpointReference (::std::unique_ptr< EndpointReferenceType > x)
    {
      this->EndpointReference_.set (std::move (x));
    }

    const HelloType::TypesOptional& HelloType::
    Types () const
    {
      return this->Types_;
    }

    HelloType::TypesOptional& HelloType::
    Types ()
    {
      return this->Types_;
    }

    void HelloType::
    Types (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void HelloType::
    Types (const TypesOptional& x)
    {
      this->Types_ = x;
    }

    void HelloType::
    Types (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }

    const HelloType::ScopesOptional& HelloType::
    Scopes () const
    {
      return this->Scopes_;
    }

    HelloType::ScopesOptional& HelloType::
    Scopes ()
    {
      return this->Scopes_;
    }

    void HelloType::
    Scopes (const ScopesType& x)
    {
      this->Scopes_.set (x);
    }

    void HelloType::
    Scopes (const ScopesOptional& x)
    {
      this->Scopes_ = x;
    }

    void HelloType::
    Scopes (::std::unique_ptr< ScopesType > x)
    {
      this->Scopes_.set (std::move (x));
    }

    const HelloType::XAddrsOptional& HelloType::
    XAddrs () const
    {
      return this->XAddrs_;
    }

    HelloType::XAddrsOptional& HelloType::
    XAddrs ()
    {
      return this->XAddrs_;
    }

    void HelloType::
    XAddrs (const XAddrsType& x)
    {
      this->XAddrs_.set (x);
    }

    void HelloType::
    XAddrs (const XAddrsOptional& x)
    {
      this->XAddrs_ = x;
    }

    void HelloType::
    XAddrs (::std::unique_ptr< XAddrsType > x)
    {
      this->XAddrs_.set (std::move (x));
    }

    const HelloType::MetadataVersionType& HelloType::
    MetadataVersion () const
    {
      return this->MetadataVersion_.get ();
    }

    HelloType::MetadataVersionType& HelloType::
    MetadataVersion ()
    {
      return this->MetadataVersion_.get ();
    }

    void HelloType::
    MetadataVersion (const MetadataVersionType& x)
    {
      this->MetadataVersion_.set (x);
    }


    // ByeType
    // 

    const ByeType::EndpointReferenceType& ByeType::
    EndpointReference () const
    {
      return this->EndpointReference_.get ();
    }

    ByeType::EndpointReferenceType& ByeType::
    EndpointReference ()
    {
      return this->EndpointReference_.get ();
    }

    void ByeType::
    EndpointReference (const EndpointReferenceType& x)
    {
      this->EndpointReference_.set (x);
    }

    void ByeType::
    EndpointReference (::std::unique_ptr< EndpointReferenceType > x)
    {
      this->EndpointReference_.set (std::move (x));
    }

    const ByeType::TypesOptional& ByeType::
    Types () const
    {
      return this->Types_;
    }

    ByeType::TypesOptional& ByeType::
    Types ()
    {
      return this->Types_;
    }

    void ByeType::
    Types (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void ByeType::
    Types (const TypesOptional& x)
    {
      this->Types_ = x;
    }

    void ByeType::
    Types (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }

    const ByeType::ScopesOptional& ByeType::
    Scopes () const
    {
      return this->Scopes_;
    }

    ByeType::ScopesOptional& ByeType::
    Scopes ()
    {
      return this->Scopes_;
    }

    void ByeType::
    Scopes (const ScopesType& x)
    {
      this->Scopes_.set (x);
    }

    void ByeType::
    Scopes (const ScopesOptional& x)
    {
      this->Scopes_ = x;
    }

    void ByeType::
    Scopes (::std::unique_ptr< ScopesType > x)
    {
      this->Scopes_.set (std::move (x));
    }

    const ByeType::XAddrsOptional& ByeType::
    XAddrs () const
    {
      return this->XAddrs_;
    }

    ByeType::XAddrsOptional& ByeType::
    XAddrs ()
    {
      return this->XAddrs_;
    }

    void ByeType::
    XAddrs (const XAddrsType& x)
    {
      this->XAddrs_.set (x);
    }

    void ByeType::
    XAddrs (const XAddrsOptional& x)
    {
      this->XAddrs_ = x;
    }

    void ByeType::
    XAddrs (::std::unique_ptr< XAddrsType > x)
    {
      this->XAddrs_.set (std::move (x));
    }

    const ByeType::MetadataVersionOptional& ByeType::
    MetadataVersion () const
    {
      return this->MetadataVersion_;
    }

    ByeType::MetadataVersionOptional& ByeType::
    MetadataVersion ()
    {
      return this->MetadataVersion_;
    }

    void ByeType::
    MetadataVersion (const MetadataVersionType& x)
    {
      this->MetadataVersion_.set (x);
    }

    void ByeType::
    MetadataVersion (const MetadataVersionOptional& x)
    {
      this->MetadataVersion_ = x;
    }


    // ProbeType
    // 

    const ProbeType::TypesOptional& ProbeType::
    Types () const
    {
      return this->Types_;
    }

    ProbeType::TypesOptional& ProbeType::
    Types ()
    {
      return this->Types_;
    }

    void ProbeType::
    Types (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void ProbeType::
    Types (const TypesOptional& x)
    {
      this->Types_ = x;
    }

    void ProbeType::
    Types (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }

    const ProbeType::ScopesOptional& ProbeType::
    Scopes () const
    {
      return this->Scopes_;
    }

    ProbeType::ScopesOptional& ProbeType::
    Scopes ()
    {
      return this->Scopes_;
    }

    void ProbeType::
    Scopes (const ScopesType& x)
    {
      this->Scopes_.set (x);
    }

    void ProbeType::
    Scopes (const ScopesOptional& x)
    {
      this->Scopes_ = x;
    }

    void ProbeType::
    Scopes (::std::unique_ptr< ScopesType > x)
    {
      this->Scopes_.set (std::move (x));
    }


    // ProbeMatchesType
    // 

    const ProbeMatchesType::ProbeMatchSequence& ProbeMatchesType::
    ProbeMatch () const
    {
      return this->ProbeMatch_;
    }

    ProbeMatchesType::ProbeMatchSequence& ProbeMatchesType::
    ProbeMatch ()
    {
      return this->ProbeMatch_;
    }

    void ProbeMatchesType::
    ProbeMatch (const ProbeMatchSequence& s)
    {
      this->ProbeMatch_ = s;
    }


    // ProbeMatchType
    // 

    const ProbeMatchType::EndpointReferenceType& ProbeMatchType::
    EndpointReference () const
    {
      return this->EndpointReference_.get ();
    }

    ProbeMatchType::EndpointReferenceType& ProbeMatchType::
    EndpointReference ()
    {
      return this->EndpointReference_.get ();
    }

    void ProbeMatchType::
    EndpointReference (const EndpointReferenceType& x)
    {
      this->EndpointReference_.set (x);
    }

    void ProbeMatchType::
    EndpointReference (::std::unique_ptr< EndpointReferenceType > x)
    {
      this->EndpointReference_.set (std::move (x));
    }

    const ProbeMatchType::TypesOptional& ProbeMatchType::
    Types () const
    {
      return this->Types_;
    }

    ProbeMatchType::TypesOptional& ProbeMatchType::
    Types ()
    {
      return this->Types_;
    }

    void ProbeMatchType::
    Types (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void ProbeMatchType::
    Types (const TypesOptional& x)
    {
      this->Types_ = x;
    }

    void ProbeMatchType::
    Types (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }

    const ProbeMatchType::ScopesOptional& ProbeMatchType::
    Scopes () const
    {
      return this->Scopes_;
    }

    ProbeMatchType::ScopesOptional& ProbeMatchType::
    Scopes ()
    {
      return this->Scopes_;
    }

    void ProbeMatchType::
    Scopes (const ScopesType& x)
    {
      this->Scopes_.set (x);
    }

    void ProbeMatchType::
    Scopes (const ScopesOptional& x)
    {
      this->Scopes_ = x;
    }

    void ProbeMatchType::
    Scopes (::std::unique_ptr< ScopesType > x)
    {
      this->Scopes_.set (std::move (x));
    }

    const ProbeMatchType::XAddrsOptional& ProbeMatchType::
    XAddrs () const
    {
      return this->XAddrs_;
    }

    ProbeMatchType::XAddrsOptional& ProbeMatchType::
    XAddrs ()
    {
      return this->XAddrs_;
    }

    void ProbeMatchType::
    XAddrs (const XAddrsType& x)
    {
      this->XAddrs_.set (x);
    }

    void ProbeMatchType::
    XAddrs (const XAddrsOptional& x)
    {
      this->XAddrs_ = x;
    }

    void ProbeMatchType::
    XAddrs (::std::unique_ptr< XAddrsType > x)
    {
      this->XAddrs_.set (std::move (x));
    }

    const ProbeMatchType::MetadataVersionType& ProbeMatchType::
    MetadataVersion () const
    {
      return this->MetadataVersion_.get ();
    }

    ProbeMatchType::MetadataVersionType& ProbeMatchType::
    MetadataVersion ()
    {
      return this->MetadataVersion_.get ();
    }

    void ProbeMatchType::
    MetadataVersion (const MetadataVersionType& x)
    {
      this->MetadataVersion_.set (x);
    }


    // ResolveType
    // 

    const ResolveType::EndpointReferenceType& ResolveType::
    EndpointReference () const
    {
      return this->EndpointReference_.get ();
    }

    ResolveType::EndpointReferenceType& ResolveType::
    EndpointReference ()
    {
      return this->EndpointReference_.get ();
    }

    void ResolveType::
    EndpointReference (const EndpointReferenceType& x)
    {
      this->EndpointReference_.set (x);
    }

    void ResolveType::
    EndpointReference (::std::unique_ptr< EndpointReferenceType > x)
    {
      this->EndpointReference_.set (std::move (x));
    }


    // ResolveMatchesType
    // 

    const ResolveMatchesType::ResolveMatchOptional& ResolveMatchesType::
    ResolveMatch () const
    {
      return this->ResolveMatch_;
    }

    ResolveMatchesType::ResolveMatchOptional& ResolveMatchesType::
    ResolveMatch ()
    {
      return this->ResolveMatch_;
    }

    void ResolveMatchesType::
    ResolveMatch (const ResolveMatchType& x)
    {
      this->ResolveMatch_.set (x);
    }

    void ResolveMatchesType::
    ResolveMatch (const ResolveMatchOptional& x)
    {
      this->ResolveMatch_ = x;
    }

    void ResolveMatchesType::
    ResolveMatch (::std::unique_ptr< ResolveMatchType > x)
    {
      this->ResolveMatch_.set (std::move (x));
    }


    // ResolveMatchType
    // 

    const ResolveMatchType::EndpointReferenceType& ResolveMatchType::
    EndpointReference () const
    {
      return this->EndpointReference_.get ();
    }

    ResolveMatchType::EndpointReferenceType& ResolveMatchType::
    EndpointReference ()
    {
      return this->EndpointReference_.get ();
    }

    void ResolveMatchType::
    EndpointReference (const EndpointReferenceType& x)
    {
      this->EndpointReference_.set (x);
    }

    void ResolveMatchType::
    EndpointReference (::std::unique_ptr< EndpointReferenceType > x)
    {
      this->EndpointReference_.set (std::move (x));
    }

    const ResolveMatchType::TypesOptional& ResolveMatchType::
    Types () const
    {
      return this->Types_;
    }

    ResolveMatchType::TypesOptional& ResolveMatchType::
    Types ()
    {
      return this->Types_;
    }

    void ResolveMatchType::
    Types (const TypesType& x)
    {
      this->Types_.set (x);
    }

    void ResolveMatchType::
    Types (const TypesOptional& x)
    {
      this->Types_ = x;
    }

    void ResolveMatchType::
    Types (::std::unique_ptr< TypesType > x)
    {
      this->Types_.set (std::move (x));
    }

    const ResolveMatchType::ScopesOptional& ResolveMatchType::
    Scopes () const
    {
      return this->Scopes_;
    }

    ResolveMatchType::ScopesOptional& ResolveMatchType::
    Scopes ()
    {
      return this->Scopes_;
    }

    void ResolveMatchType::
    Scopes (const ScopesType& x)
    {
      this->Scopes_.set (x);
    }

    void ResolveMatchType::
    Scopes (const ScopesOptional& x)
    {
      this->Scopes_ = x;
    }

    void ResolveMatchType::
    Scopes (::std::unique_ptr< ScopesType > x)
    {
      this->Scopes_.set (std::move (x));
    }

    const ResolveMatchType::XAddrsOptional& ResolveMatchType::
    XAddrs () const
    {
      return this->XAddrs_;
    }

    ResolveMatchType::XAddrsOptional& ResolveMatchType::
    XAddrs ()
    {
      return this->XAddrs_;
    }

    void ResolveMatchType::
    XAddrs (const XAddrsType& x)
    {
      this->XAddrs_.set (x);
    }

    void ResolveMatchType::
    XAddrs (const XAddrsOptional& x)
    {
      this->XAddrs_ = x;
    }

    void ResolveMatchType::
    XAddrs (::std::unique_ptr< XAddrsType > x)
    {
      this->XAddrs_.set (std::move (x));
    }

    const ResolveMatchType::MetadataVersionType& ResolveMatchType::
    MetadataVersion () const
    {
      return this->MetadataVersion_.get ();
    }

    ResolveMatchType::MetadataVersionType& ResolveMatchType::
    MetadataVersion ()
    {
      return this->MetadataVersion_.get ();
    }

    void ResolveMatchType::
    MetadataVersion (const MetadataVersionType& x)
    {
      this->MetadataVersion_.set (x);
    }


    // QNameListType
    //

    QNameListType::
    QNameListType ()
    : ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (this)
    {
    }

    QNameListType::
    QNameListType (size_type n, const ::xml_schema::Qname& x)
    : ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (n, x, this)
    {
    }

    QNameListType::
    QNameListType (const QNameListType& o,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (o, f, this)
    {
    }

    // UriListType
    //

    UriListType::
    UriListType ()
    : ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (this)
    {
    }

    UriListType::
    UriListType (size_type n, const ::xml_schema::Uri& x)
    : ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (n, x, this)
    {
    }

    UriListType::
    UriListType (const UriListType& o,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (o, f, this)
    {
    }

    // ScopesType
    // 

    const ScopesType::MatchByOptional& ScopesType::
    MatchBy () const
    {
      return this->MatchBy_;
    }

    ScopesType::MatchByOptional& ScopesType::
    MatchBy ()
    {
      return this->MatchBy_;
    }

    void ScopesType::
    MatchBy (const MatchByType& x)
    {
      this->MatchBy_.set (x);
    }

    void ScopesType::
    MatchBy (const MatchByOptional& x)
    {
      this->MatchBy_ = x;
    }

    void ScopesType::
    MatchBy (::std::unique_ptr< MatchByType > x)
    {
      this->MatchBy_.set (std::move (x));
    }


    // FaultCodeType
    // 

    FaultCodeType::
    FaultCodeType (const ::xml_schema::Qname& v)
    : ::xml_schema::Qname (v)
    {
    }

    FaultCodeType::
    FaultCodeType (const FaultCodeType& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Qname (v, f, c)
    {
    }


    // FaultCodeOpenType
    //

    FaultCodeOpenType::
    FaultCodeOpenType (const char* s)
    : ::xml_schema::String (s)
    {
    }

    FaultCodeOpenType::
    FaultCodeOpenType (const ::std::string& s)
    : ::xml_schema::String (s)
    {
    }

    FaultCodeOpenType::
    FaultCodeOpenType (const FaultCodeOpenType& o,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (o, f, c)
    {
    }

    // SecurityType
    // 

    const SecurityType::SigOptional& SecurityType::
    Sig () const
    {
      return this->Sig_;
    }

    SecurityType::SigOptional& SecurityType::
    Sig ()
    {
      return this->Sig_;
    }

    void SecurityType::
    Sig (const SigType& x)
    {
      this->Sig_.set (x);
    }

    void SecurityType::
    Sig (const SigOptional& x)
    {
      this->Sig_ = x;
    }

    void SecurityType::
    Sig (::std::unique_ptr< SigType > x)
    {
      this->Sig_.set (std::move (x));
    }


    // SigType
    // 

    const SigType::SchemeType& SigType::
    Scheme () const
    {
      return this->Scheme_.get ();
    }

    SigType::SchemeType& SigType::
    Scheme ()
    {
      return this->Scheme_.get ();
    }

    void SigType::
    Scheme (const SchemeType& x)
    {
      this->Scheme_.set (x);
    }

    void SigType::
    Scheme (::std::unique_ptr< SchemeType > x)
    {
      this->Scheme_.set (std::move (x));
    }

    const SigType::KeyIdOptional& SigType::
    KeyId () const
    {
      return this->KeyId_;
    }

    SigType::KeyIdOptional& SigType::
    KeyId ()
    {
      return this->KeyId_;
    }

    void SigType::
    KeyId (const KeyIdType& x)
    {
      this->KeyId_.set (x);
    }

    void SigType::
    KeyId (const KeyIdOptional& x)
    {
      this->KeyId_ = x;
    }

    void SigType::
    KeyId (::std::unique_ptr< KeyIdType > x)
    {
      this->KeyId_.set (std::move (x));
    }

    const SigType::RefsType& SigType::
    Refs () const
    {
      return this->Refs_.get ();
    }

    SigType::RefsType& SigType::
    Refs ()
    {
      return this->Refs_.get ();
    }

    void SigType::
    Refs (const RefsType& x)
    {
      this->Refs_.set (x);
    }

    void SigType::
    Refs (::std::unique_ptr< RefsType > x)
    {
      this->Refs_.set (std::move (x));
    }

    const SigType::SigType1& SigType::
    Sig () const
    {
      return this->Sig_.get ();
    }

    SigType::SigType1& SigType::
    Sig ()
    {
      return this->Sig_.get ();
    }

    void SigType::
    Sig (const SigType1& x)
    {
      this->Sig_.set (x);
    }

    void SigType::
    Sig (::std::unique_ptr< SigType1 > x)
    {
      this->Sig_.set (std::move (x));
    }


    // AppSequenceType
    // 

    const AppSequenceType::InstanceIdType& AppSequenceType::
    InstanceId () const
    {
      return this->InstanceId_.get ();
    }

    AppSequenceType::InstanceIdType& AppSequenceType::
    InstanceId ()
    {
      return this->InstanceId_.get ();
    }

    void AppSequenceType::
    InstanceId (const InstanceIdType& x)
    {
      this->InstanceId_.set (x);
    }

    const AppSequenceType::SequenceIdOptional& AppSequenceType::
    SequenceId () const
    {
      return this->SequenceId_;
    }

    AppSequenceType::SequenceIdOptional& AppSequenceType::
    SequenceId ()
    {
      return this->SequenceId_;
    }

    void AppSequenceType::
    SequenceId (const SequenceIdType& x)
    {
      this->SequenceId_.set (x);
    }

    void AppSequenceType::
    SequenceId (const SequenceIdOptional& x)
    {
      this->SequenceId_ = x;
    }

    void AppSequenceType::
    SequenceId (::std::unique_ptr< SequenceIdType > x)
    {
      this->SequenceId_.set (std::move (x));
    }

    const AppSequenceType::MessageNumberType& AppSequenceType::
    MessageNumber () const
    {
      return this->MessageNumber_.get ();
    }

    AppSequenceType::MessageNumberType& AppSequenceType::
    MessageNumber ()
    {
      return this->MessageNumber_.get ();
    }

    void AppSequenceType::
    MessageNumber (const MessageNumberType& x)
    {
      this->MessageNumber_.set (x);
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace WS
{
  namespace DISCOVERY
  {
    // HelloType
    //

    HelloType::
    HelloType (const EndpointReferenceType& EndpointReference,
               const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (EndpointReference, this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    HelloType::
    HelloType (::std::unique_ptr< EndpointReferenceType > EndpointReference,
               const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (std::move (EndpointReference), this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    HelloType::
    HelloType (const HelloType& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this),
      Types_ (x.Types_, f, this),
      Scopes_ (x.Scopes_, f, this),
      XAddrs_ (x.XAddrs_, f, this),
      MetadataVersion_ (x.MetadataVersion_, f, this)
    {
    }

    HelloType::
    HelloType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void HelloType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EndpointReference_.present ())
            {
              ::std::unique_ptr< EndpointReferenceType > r (
                dynamic_cast< EndpointReferenceType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->EndpointReference_.set (::std::move (r));
              continue;
            }
          }
        }

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Types_)
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        // Scopes
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ScopesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Scopes_)
            {
              ::std::unique_ptr< ScopesType > r (
                dynamic_cast< ScopesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Scopes_.set (::std::move (r));
              continue;
            }
          }
        }

        // XAddrs
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< XAddrsType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->XAddrs_)
            {
              ::std::unique_ptr< XAddrsType > r (
                dynamic_cast< XAddrsType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->XAddrs_.set (::std::move (r));
              continue;
            }
          }
        }

        // MetadataVersion
        //
        if (n.name () == "MetadataVersion" && n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          if (!MetadataVersion_.present ())
          {
            this->MetadataVersion_.set (MetadataVersionTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!EndpointReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndpointReference",
          "http://www.w3.org/2005/08/addressing");
      }

      if (!MetadataVersion_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MetadataVersion",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
      }
    }

    HelloType* HelloType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class HelloType (*this, f, c);
    }

    HelloType& HelloType::
    operator= (const HelloType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
        this->Types_ = x.Types_;
        this->Scopes_ = x.Scopes_;
        this->XAddrs_ = x.XAddrs_;
        this->MetadataVersion_ = x.MetadataVersion_;
      }

      return *this;
    }

    HelloType::
    ~HelloType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, HelloType >
    _xsd_HelloType_type_factory_init (
      "HelloType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ByeType
    //

    ByeType::
    ByeType (const EndpointReferenceType& EndpointReference)
    : ::xml_schema::Type (),
      EndpointReference_ (EndpointReference, this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
    }

    ByeType::
    ByeType (::std::unique_ptr< EndpointReferenceType > EndpointReference)
    : ::xml_schema::Type (),
      EndpointReference_ (std::move (EndpointReference), this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
    }

    ByeType::
    ByeType (const ByeType& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this),
      Types_ (x.Types_, f, this),
      Scopes_ (x.Scopes_, f, this),
      XAddrs_ (x.XAddrs_, f, this),
      MetadataVersion_ (x.MetadataVersion_, f, this)
    {
    }

    ByeType::
    ByeType (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ByeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EndpointReference_.present ())
            {
              ::std::unique_ptr< EndpointReferenceType > r (
                dynamic_cast< EndpointReferenceType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->EndpointReference_.set (::std::move (r));
              continue;
            }
          }
        }

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Types_)
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        // Scopes
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ScopesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Scopes_)
            {
              ::std::unique_ptr< ScopesType > r (
                dynamic_cast< ScopesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Scopes_.set (::std::move (r));
              continue;
            }
          }
        }

        // XAddrs
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< XAddrsType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->XAddrs_)
            {
              ::std::unique_ptr< XAddrsType > r (
                dynamic_cast< XAddrsType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->XAddrs_.set (::std::move (r));
              continue;
            }
          }
        }

        // MetadataVersion
        //
        if (n.name () == "MetadataVersion" && n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          if (!this->MetadataVersion_)
          {
            this->MetadataVersion_.set (MetadataVersionTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!EndpointReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndpointReference",
          "http://www.w3.org/2005/08/addressing");
      }
    }

    ByeType* ByeType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ByeType (*this, f, c);
    }

    ByeType& ByeType::
    operator= (const ByeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
        this->Types_ = x.Types_;
        this->Scopes_ = x.Scopes_;
        this->XAddrs_ = x.XAddrs_;
        this->MetadataVersion_ = x.MetadataVersion_;
      }

      return *this;
    }

    ByeType::
    ~ByeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ByeType >
    _xsd_ByeType_type_factory_init (
      "ByeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ProbeType
    //

    ProbeType::
    ProbeType ()
    : ::xml_schema::Type (),
      Types_ (this),
      Scopes_ (this)
    {
    }

    ProbeType::
    ProbeType (const ProbeType& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Types_ (x.Types_, f, this),
      Scopes_ (x.Scopes_, f, this)
    {
    }

    ProbeType::
    ProbeType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Types_ (this),
      Scopes_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ProbeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Types_)
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        // Scopes
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ScopesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Scopes_)
            {
              ::std::unique_ptr< ScopesType > r (
                dynamic_cast< ScopesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Scopes_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    ProbeType* ProbeType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ProbeType (*this, f, c);
    }

    ProbeType& ProbeType::
    operator= (const ProbeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->Types_ = x.Types_;
        this->Scopes_ = x.Scopes_;
      }

      return *this;
    }

    ProbeType::
    ~ProbeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ProbeType >
    _xsd_ProbeType_type_factory_init (
      "ProbeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ProbeMatchesType
    //

    ProbeMatchesType::
    ProbeMatchesType ()
    : ::xml_schema::Type (),
      ProbeMatch_ (this)
    {
    }

    ProbeMatchesType::
    ProbeMatchesType (const ProbeMatchesType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      ProbeMatch_ (x.ProbeMatch_, f, this)
    {
    }

    ProbeMatchesType::
    ProbeMatchesType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      ProbeMatch_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ProbeMatchesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ProbeMatch
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ProbeMatch",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ProbeMatchType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ProbeMatchType > r (
              dynamic_cast< ProbeMatchType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ProbeMatch_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    ProbeMatchesType* ProbeMatchesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ProbeMatchesType (*this, f, c);
    }

    ProbeMatchesType& ProbeMatchesType::
    operator= (const ProbeMatchesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->ProbeMatch_ = x.ProbeMatch_;
      }

      return *this;
    }

    ProbeMatchesType::
    ~ProbeMatchesType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ProbeMatchesType >
    _xsd_ProbeMatchesType_type_factory_init (
      "ProbeMatchesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ProbeMatchType
    //

    ProbeMatchType::
    ProbeMatchType (const EndpointReferenceType& EndpointReference,
                    const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (EndpointReference, this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    ProbeMatchType::
    ProbeMatchType (::std::unique_ptr< EndpointReferenceType > EndpointReference,
                    const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (std::move (EndpointReference), this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    ProbeMatchType::
    ProbeMatchType (const ProbeMatchType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this),
      Types_ (x.Types_, f, this),
      Scopes_ (x.Scopes_, f, this),
      XAddrs_ (x.XAddrs_, f, this),
      MetadataVersion_ (x.MetadataVersion_, f, this)
    {
    }

    ProbeMatchType::
    ProbeMatchType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ProbeMatchType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EndpointReference_.present ())
            {
              ::std::unique_ptr< EndpointReferenceType > r (
                dynamic_cast< EndpointReferenceType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->EndpointReference_.set (::std::move (r));
              continue;
            }
          }
        }

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Types_)
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        // Scopes
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ScopesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Scopes_)
            {
              ::std::unique_ptr< ScopesType > r (
                dynamic_cast< ScopesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Scopes_.set (::std::move (r));
              continue;
            }
          }
        }

        // XAddrs
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< XAddrsType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->XAddrs_)
            {
              ::std::unique_ptr< XAddrsType > r (
                dynamic_cast< XAddrsType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->XAddrs_.set (::std::move (r));
              continue;
            }
          }
        }

        // MetadataVersion
        //
        if (n.name () == "MetadataVersion" && n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          if (!MetadataVersion_.present ())
          {
            this->MetadataVersion_.set (MetadataVersionTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!EndpointReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndpointReference",
          "http://www.w3.org/2005/08/addressing");
      }

      if (!MetadataVersion_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MetadataVersion",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
      }
    }

    ProbeMatchType* ProbeMatchType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ProbeMatchType (*this, f, c);
    }

    ProbeMatchType& ProbeMatchType::
    operator= (const ProbeMatchType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
        this->Types_ = x.Types_;
        this->Scopes_ = x.Scopes_;
        this->XAddrs_ = x.XAddrs_;
        this->MetadataVersion_ = x.MetadataVersion_;
      }

      return *this;
    }

    ProbeMatchType::
    ~ProbeMatchType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ProbeMatchType >
    _xsd_ProbeMatchType_type_factory_init (
      "ProbeMatchType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ResolveType
    //

    ResolveType::
    ResolveType (const EndpointReferenceType& EndpointReference)
    : ::xml_schema::Type (),
      EndpointReference_ (EndpointReference, this)
    {
    }

    ResolveType::
    ResolveType (::std::unique_ptr< EndpointReferenceType > EndpointReference)
    : ::xml_schema::Type (),
      EndpointReference_ (std::move (EndpointReference), this)
    {
    }

    ResolveType::
    ResolveType (const ResolveType& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this)
    {
    }

    ResolveType::
    ResolveType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ResolveType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EndpointReference_.present ())
            {
              ::std::unique_ptr< EndpointReferenceType > r (
                dynamic_cast< EndpointReferenceType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->EndpointReference_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!EndpointReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndpointReference",
          "http://www.w3.org/2005/08/addressing");
      }
    }

    ResolveType* ResolveType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ResolveType (*this, f, c);
    }

    ResolveType& ResolveType::
    operator= (const ResolveType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
      }

      return *this;
    }

    ResolveType::
    ~ResolveType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ResolveType >
    _xsd_ResolveType_type_factory_init (
      "ResolveType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ResolveMatchesType
    //

    ResolveMatchesType::
    ResolveMatchesType ()
    : ::xml_schema::Type (),
      ResolveMatch_ (this)
    {
    }

    ResolveMatchesType::
    ResolveMatchesType (const ResolveMatchesType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      ResolveMatch_ (x.ResolveMatch_, f, this)
    {
    }

    ResolveMatchesType::
    ResolveMatchesType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      ResolveMatch_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ResolveMatchesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ResolveMatch
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ResolveMatch",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ResolveMatchType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->ResolveMatch_)
            {
              ::std::unique_ptr< ResolveMatchType > r (
                dynamic_cast< ResolveMatchType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->ResolveMatch_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    ResolveMatchesType* ResolveMatchesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ResolveMatchesType (*this, f, c);
    }

    ResolveMatchesType& ResolveMatchesType::
    operator= (const ResolveMatchesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->ResolveMatch_ = x.ResolveMatch_;
      }

      return *this;
    }

    ResolveMatchesType::
    ~ResolveMatchesType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ResolveMatchesType >
    _xsd_ResolveMatchesType_type_factory_init (
      "ResolveMatchesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ResolveMatchType
    //

    ResolveMatchType::
    ResolveMatchType (const EndpointReferenceType& EndpointReference,
                      const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (EndpointReference, this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    ResolveMatchType::
    ResolveMatchType (::std::unique_ptr< EndpointReferenceType > EndpointReference,
                      const MetadataVersionType& MetadataVersion)
    : ::xml_schema::Type (),
      EndpointReference_ (std::move (EndpointReference), this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (MetadataVersion, this)
    {
    }

    ResolveMatchType::
    ResolveMatchType (const ResolveMatchType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      EndpointReference_ (x.EndpointReference_, f, this),
      Types_ (x.Types_, f, this),
      Scopes_ (x.Scopes_, f, this),
      XAddrs_ (x.XAddrs_, f, this),
      MetadataVersion_ (x.MetadataVersion_, f, this)
    {
    }

    ResolveMatchType::
    ResolveMatchType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      EndpointReference_ (this),
      Types_ (this),
      Scopes_ (this),
      XAddrs_ (this),
      MetadataVersion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ResolveMatchType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EndpointReference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              &::xsd::cxx::tree::factory_impl< EndpointReferenceType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EndpointReference_.present ())
            {
              ::std::unique_ptr< EndpointReferenceType > r (
                dynamic_cast< EndpointReferenceType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->EndpointReference_.set (::std::move (r));
              continue;
            }
          }
        }

        // Types
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< TypesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Types_)
            {
              ::std::unique_ptr< TypesType > r (
                dynamic_cast< TypesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Types_.set (::std::move (r));
              continue;
            }
          }
        }

        // Scopes
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< ScopesType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Scopes_)
            {
              ::std::unique_ptr< ScopesType > r (
                dynamic_cast< ScopesType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Scopes_.set (::std::move (r));
              continue;
            }
          }
        }

        // XAddrs
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< XAddrsType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->XAddrs_)
            {
              ::std::unique_ptr< XAddrsType > r (
                dynamic_cast< XAddrsType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->XAddrs_.set (::std::move (r));
              continue;
            }
          }
        }

        // MetadataVersion
        //
        if (n.name () == "MetadataVersion" && n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          if (!MetadataVersion_.present ())
          {
            this->MetadataVersion_.set (MetadataVersionTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!EndpointReference_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndpointReference",
          "http://www.w3.org/2005/08/addressing");
      }

      if (!MetadataVersion_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MetadataVersion",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
      }
    }

    ResolveMatchType* ResolveMatchType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ResolveMatchType (*this, f, c);
    }

    ResolveMatchType& ResolveMatchType::
    operator= (const ResolveMatchType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->EndpointReference_ = x.EndpointReference_;
        this->Types_ = x.Types_;
        this->Scopes_ = x.Scopes_;
        this->XAddrs_ = x.XAddrs_;
        this->MetadataVersion_ = x.MetadataVersion_;
      }

      return *this;
    }

    ResolveMatchType::
    ~ResolveMatchType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ResolveMatchType >
    _xsd_ResolveMatchType_type_factory_init (
      "ResolveMatchType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // QNameListType
    //

    QNameListType::
    QNameListType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (e, f, this)
    {
    }

    QNameListType::
    QNameListType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (a, f, this)
    {
    }

    QNameListType::
    QNameListType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Qname, char > (s, e, f, this)
    {
    }

    QNameListType* QNameListType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class QNameListType (*this, f, c);
    }

    QNameListType::
    ~QNameListType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, QNameListType >
    _xsd_QNameListType_type_factory_init (
      "QNameListType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // UriListType
    //

    UriListType::
    UriListType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (e, f, this)
    {
    }

    UriListType::
    UriListType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (a, f, this)
    {
    }

    UriListType::
    UriListType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::SimpleType (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::Uri, char > (s, e, f, this)
    {
    }

    UriListType* UriListType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class UriListType (*this, f, c);
    }

    UriListType::
    ~UriListType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, UriListType >
    _xsd_UriListType_type_factory_init (
      "UriListType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // ScopesType
    //

    ScopesType::
    ScopesType ()
    : ::WS::DISCOVERY::UriListType (),
      MatchBy_ (this)
    {
    }

    ScopesType::
    ScopesType (const ::WS::DISCOVERY::UriListType& _xsd_UriListType_base)
    : ::WS::DISCOVERY::UriListType (_xsd_UriListType_base),
      MatchBy_ (this)
    {
    }

    ScopesType::
    ScopesType (const ScopesType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::WS::DISCOVERY::UriListType (x, f, c),
      MatchBy_ (x.MatchBy_, f, this)
    {
    }

    ScopesType::
    ScopesType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::WS::DISCOVERY::UriListType (e, f | ::xml_schema::Flags::base, c),
      MatchBy_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ScopesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "MatchBy" && n.namespace_ ().empty ())
        {
          this->MatchBy_.set (MatchByTraits::create (i, f, this));
          continue;
        }
      }
    }

    ScopesType* ScopesType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ScopesType (*this, f, c);
    }

    ScopesType& ScopesType::
    operator= (const ScopesType& x)
    {
      if (this != &x)
      {
        static_cast< ::WS::DISCOVERY::UriListType& > (*this) = x;
        this->MatchBy_ = x.MatchBy_;
      }

      return *this;
    }

    ScopesType::
    ~ScopesType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ScopesType >
    _xsd_ScopesType_type_factory_init (
      "ScopesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // FaultCodeType
    //

    FaultCodeType::
    FaultCodeType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Qname (e, f, c)
    {
    }

    FaultCodeType::
    FaultCodeType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Qname (a, f, c)
    {
    }

    FaultCodeType::
    FaultCodeType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Qname (s, e, f, c)
    {
    }

    FaultCodeType* FaultCodeType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FaultCodeType (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, FaultCodeType >
    _xsd_FaultCodeType_type_factory_init (
      "FaultCodeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // FaultCodeOpenType
    //

    FaultCodeOpenType::
    FaultCodeOpenType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    FaultCodeOpenType::
    FaultCodeOpenType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    FaultCodeOpenType::
    FaultCodeOpenType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    FaultCodeOpenType* FaultCodeOpenType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FaultCodeOpenType (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, FaultCodeOpenType >
    _xsd_FaultCodeOpenType_type_factory_init (
      "FaultCodeOpenType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // SecurityType
    //

    SecurityType::
    SecurityType ()
    : ::xml_schema::Type (),
      Sig_ (this)
    {
    }

    SecurityType::
    SecurityType (const SecurityType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Sig_ (x.Sig_, f, this)
    {
    }

    SecurityType::
    SecurityType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Sig_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SecurityType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Sig
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Sig",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              &::xsd::cxx::tree::factory_impl< SigType >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Sig_)
            {
              ::std::unique_ptr< SigType > r (
                dynamic_cast< SigType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->Sig_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }
    }

    SecurityType* SecurityType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SecurityType (*this, f, c);
    }

    SecurityType& SecurityType::
    operator= (const SecurityType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->Sig_ = x.Sig_;
      }

      return *this;
    }

    SecurityType::
    ~SecurityType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SecurityType >
    _xsd_SecurityType_type_factory_init (
      "SecurityType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // SigType
    //

    SigType::
    SigType (const SchemeType& Scheme,
             const RefsType& Refs,
             const SigType1& Sig)
    : ::xml_schema::Type (),
      Scheme_ (Scheme, this),
      KeyId_ (this),
      Refs_ (Refs, this),
      Sig_ (Sig, this)
    {
    }

    SigType::
    SigType (const SigType& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      Scheme_ (x.Scheme_, f, this),
      KeyId_ (x.KeyId_, f, this),
      Refs_ (x.Refs_, f, this),
      Sig_ (x.Sig_, f, this)
    {
    }

    SigType::
    SigType (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      Scheme_ (this),
      KeyId_ (this),
      Refs_ (this),
      Sig_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SigType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "Scheme" && n.namespace_ ().empty ())
        {
          this->Scheme_.set (SchemeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "KeyId" && n.namespace_ ().empty ())
        {
          this->KeyId_.set (KeyIdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "Refs" && n.namespace_ ().empty ())
        {
          this->Refs_.set (RefsTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "Sig" && n.namespace_ ().empty ())
        {
          this->Sig_.set (SigTraits::create (i, f, this));
          continue;
        }
      }

      if (!Scheme_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "Scheme",
          "");
      }

      if (!Refs_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "Refs",
          "");
      }

      if (!Sig_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "Sig",
          "");
      }
    }

    SigType* SigType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SigType (*this, f, c);
    }

    SigType& SigType::
    operator= (const SigType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->Scheme_ = x.Scheme_;
        this->KeyId_ = x.KeyId_;
        this->Refs_ = x.Refs_;
        this->Sig_ = x.Sig_;
      }

      return *this;
    }

    SigType::
    ~SigType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SigType >
    _xsd_SigType_type_factory_init (
      "SigType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");

    // AppSequenceType
    //

    AppSequenceType::
    AppSequenceType (const InstanceIdType& InstanceId,
                     const MessageNumberType& MessageNumber)
    : ::xml_schema::Type (),
      InstanceId_ (InstanceId, this),
      SequenceId_ (this),
      MessageNumber_ (MessageNumber, this)
    {
    }

    AppSequenceType::
    AppSequenceType (const ::xml_schema::Type& _xsd_Type_base,
                     const InstanceIdType& InstanceId,
                     const MessageNumberType& MessageNumber)
    : ::xml_schema::Type (_xsd_Type_base),
      InstanceId_ (InstanceId, this),
      SequenceId_ (this),
      MessageNumber_ (MessageNumber, this)
    {
    }

    AppSequenceType::
    AppSequenceType (const AppSequenceType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      InstanceId_ (x.InstanceId_, f, this),
      SequenceId_ (x.SequenceId_, f, this),
      MessageNumber_ (x.MessageNumber_, f, this)
    {
    }

    AppSequenceType::
    AppSequenceType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      InstanceId_ (this),
      SequenceId_ (this),
      MessageNumber_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void AppSequenceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "InstanceId" && n.namespace_ ().empty ())
        {
          this->InstanceId_.set (InstanceIdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "SequenceId" && n.namespace_ ().empty ())
        {
          this->SequenceId_.set (SequenceIdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "MessageNumber" && n.namespace_ ().empty ())
        {
          this->MessageNumber_.set (MessageNumberTraits::create (i, f, this));
          continue;
        }
      }

      if (!InstanceId_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "InstanceId",
          "");
      }

      if (!MessageNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "MessageNumber",
          "");
      }
    }

    AppSequenceType* AppSequenceType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class AppSequenceType (*this, f, c);
    }

    AppSequenceType& AppSequenceType::
    operator= (const AppSequenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->InstanceId_ = x.InstanceId_;
        this->SequenceId_ = x.SequenceId_;
        this->MessageNumber_ = x.MessageNumber_;
      }

      return *this;
    }

    AppSequenceType::
    ~AppSequenceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, AppSequenceType >
    _xsd_AppSequenceType_type_factory_init (
      "AppSequenceType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace WS
{
  namespace DISCOVERY
  {
    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    Hello (const ::std::string& u,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::HelloType > (
        ::WS::DISCOVERY::Hello (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    Hello (const ::std::string& u,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::HelloType > (
        ::WS::DISCOVERY::Hello (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    Hello (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::HelloType > (
        ::WS::DISCOVERY::Hello (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    Hello (::std::istream& is,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Hello (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    Hello (::std::istream& is,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Hello (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    Hello (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Hello (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    Hello (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Hello (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    Hello (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Hello (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    Hello (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Hello (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    Hello (::xercesc::InputSource& i,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::HelloType > (
        ::WS::DISCOVERY::Hello (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    Hello (::xercesc::InputSource& i,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::HelloType > (
        ::WS::DISCOVERY::Hello (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    Hello (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::HelloType > (
        ::WS::DISCOVERY::Hello (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    Hello (const ::xercesc::DOMDocument& doc,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::HelloType > (
          ::WS::DISCOVERY::Hello (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Hello",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::HelloType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::HelloType > r (
          dynamic_cast< ::WS::DISCOVERY::HelloType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Hello",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::HelloType >
    Hello (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Hello",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::HelloType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::HelloType > r (
          dynamic_cast< ::WS::DISCOVERY::HelloType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Hello",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    Bye (const ::std::string& u,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ByeType > (
        ::WS::DISCOVERY::Bye (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    Bye (const ::std::string& u,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ByeType > (
        ::WS::DISCOVERY::Bye (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    Bye (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ByeType > (
        ::WS::DISCOVERY::Bye (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    Bye (::std::istream& is,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Bye (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    Bye (::std::istream& is,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Bye (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    Bye (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Bye (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    Bye (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Bye (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    Bye (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Bye (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    Bye (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Bye (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    Bye (::xercesc::InputSource& i,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ByeType > (
        ::WS::DISCOVERY::Bye (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    Bye (::xercesc::InputSource& i,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ByeType > (
        ::WS::DISCOVERY::Bye (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    Bye (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ByeType > (
        ::WS::DISCOVERY::Bye (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    Bye (const ::xercesc::DOMDocument& doc,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::ByeType > (
          ::WS::DISCOVERY::Bye (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Bye",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ByeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::ByeType > r (
          dynamic_cast< ::WS::DISCOVERY::ByeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Bye",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ByeType >
    Bye (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Bye",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ByeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::ByeType > r (
          dynamic_cast< ::WS::DISCOVERY::ByeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Bye",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    Probe (const ::std::string& u,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > (
        ::WS::DISCOVERY::Probe (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    Probe (const ::std::string& u,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > (
        ::WS::DISCOVERY::Probe (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    Probe (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > (
        ::WS::DISCOVERY::Probe (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    Probe (::std::istream& is,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Probe (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    Probe (::std::istream& is,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Probe (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    Probe (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Probe (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    Probe (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Probe (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    Probe (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Probe (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    Probe (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Probe (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    Probe (::xercesc::InputSource& i,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > (
        ::WS::DISCOVERY::Probe (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    Probe (::xercesc::InputSource& i,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > (
        ::WS::DISCOVERY::Probe (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    Probe (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > (
        ::WS::DISCOVERY::Probe (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    Probe (const ::xercesc::DOMDocument& doc,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > (
          ::WS::DISCOVERY::Probe (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Probe",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ProbeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > r (
          dynamic_cast< ::WS::DISCOVERY::ProbeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Probe",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeType >
    Probe (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Probe",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ProbeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::ProbeType > r (
          dynamic_cast< ::WS::DISCOVERY::ProbeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Probe",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    ProbeMatches (const ::std::string& u,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > (
        ::WS::DISCOVERY::ProbeMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    ProbeMatches (const ::std::string& u,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > (
        ::WS::DISCOVERY::ProbeMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    ProbeMatches (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > (
        ::WS::DISCOVERY::ProbeMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    ProbeMatches (::std::istream& is,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::ProbeMatches (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    ProbeMatches (::std::istream& is,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::ProbeMatches (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    ProbeMatches (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::ProbeMatches (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    ProbeMatches (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::ProbeMatches (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    ProbeMatches (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::ProbeMatches (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    ProbeMatches (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::ProbeMatches (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    ProbeMatches (::xercesc::InputSource& i,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > (
        ::WS::DISCOVERY::ProbeMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    ProbeMatches (::xercesc::InputSource& i,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > (
        ::WS::DISCOVERY::ProbeMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    ProbeMatches (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > (
        ::WS::DISCOVERY::ProbeMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    ProbeMatches (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > (
          ::WS::DISCOVERY::ProbeMatches (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ProbeMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ProbeMatchesType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > r (
          dynamic_cast< ::WS::DISCOVERY::ProbeMatchesType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ProbeMatches",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType >
    ProbeMatches (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ProbeMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ProbeMatchesType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::ProbeMatchesType > r (
          dynamic_cast< ::WS::DISCOVERY::ProbeMatchesType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ProbeMatches",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    Resolve (const ::std::string& u,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > (
        ::WS::DISCOVERY::Resolve (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    Resolve (const ::std::string& u,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > (
        ::WS::DISCOVERY::Resolve (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    Resolve (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > (
        ::WS::DISCOVERY::Resolve (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    Resolve (::std::istream& is,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Resolve (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    Resolve (::std::istream& is,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Resolve (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    Resolve (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Resolve (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    Resolve (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Resolve (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    Resolve (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Resolve (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    Resolve (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Resolve (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    Resolve (::xercesc::InputSource& i,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > (
        ::WS::DISCOVERY::Resolve (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    Resolve (::xercesc::InputSource& i,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > (
        ::WS::DISCOVERY::Resolve (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    Resolve (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > (
        ::WS::DISCOVERY::Resolve (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    Resolve (const ::xercesc::DOMDocument& doc,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > (
          ::WS::DISCOVERY::Resolve (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Resolve",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ResolveType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > r (
          dynamic_cast< ::WS::DISCOVERY::ResolveType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Resolve",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveType >
    Resolve (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Resolve",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ResolveType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::ResolveType > r (
          dynamic_cast< ::WS::DISCOVERY::ResolveType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Resolve",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    ResolveMatches (const ::std::string& u,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > (
        ::WS::DISCOVERY::ResolveMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    ResolveMatches (const ::std::string& u,
                    ::xml_schema::ErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > (
        ::WS::DISCOVERY::ResolveMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    ResolveMatches (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > (
        ::WS::DISCOVERY::ResolveMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    ResolveMatches (::std::istream& is,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::ResolveMatches (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    ResolveMatches (::std::istream& is,
                    ::xml_schema::ErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::ResolveMatches (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    ResolveMatches (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::ResolveMatches (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    ResolveMatches (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::ResolveMatches (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    ResolveMatches (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::ErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::ResolveMatches (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    ResolveMatches (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::ResolveMatches (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    ResolveMatches (::xercesc::InputSource& i,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > (
        ::WS::DISCOVERY::ResolveMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    ResolveMatches (::xercesc::InputSource& i,
                    ::xml_schema::ErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > (
        ::WS::DISCOVERY::ResolveMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    ResolveMatches (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > (
        ::WS::DISCOVERY::ResolveMatches (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    ResolveMatches (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > (
          ::WS::DISCOVERY::ResolveMatches (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ResolveMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ResolveMatchesType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > r (
          dynamic_cast< ::WS::DISCOVERY::ResolveMatchesType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ResolveMatches",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType >
    ResolveMatches (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::Flags f,
                    const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ResolveMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ResolveMatchesType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::ResolveMatchesType > r (
          dynamic_cast< ::WS::DISCOVERY::ResolveMatchesType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ResolveMatches",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    Types (const ::std::string& u,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > (
        ::WS::DISCOVERY::Types (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    Types (const ::std::string& u,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > (
        ::WS::DISCOVERY::Types (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    Types (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > (
        ::WS::DISCOVERY::Types (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    Types (::std::istream& is,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Types (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    Types (::std::istream& is,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Types (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    Types (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Types (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    Types (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Types (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    Types (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Types (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    Types (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Types (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    Types (::xercesc::InputSource& i,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > (
        ::WS::DISCOVERY::Types (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    Types (::xercesc::InputSource& i,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > (
        ::WS::DISCOVERY::Types (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    Types (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > (
        ::WS::DISCOVERY::Types (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    Types (const ::xercesc::DOMDocument& doc,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > (
          ::WS::DISCOVERY::Types (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Types",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::QNameListType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > r (
          dynamic_cast< ::WS::DISCOVERY::QNameListType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Types",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::QNameListType >
    Types (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Types",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::QNameListType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::QNameListType > r (
          dynamic_cast< ::WS::DISCOVERY::QNameListType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Types",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    Scopes (const ::std::string& u,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > (
        ::WS::DISCOVERY::Scopes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    Scopes (const ::std::string& u,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > (
        ::WS::DISCOVERY::Scopes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    Scopes (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > (
        ::WS::DISCOVERY::Scopes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    Scopes (::std::istream& is,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Scopes (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    Scopes (::std::istream& is,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Scopes (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    Scopes (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Scopes (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    Scopes (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Scopes (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    Scopes (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Scopes (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    Scopes (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Scopes (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    Scopes (::xercesc::InputSource& i,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > (
        ::WS::DISCOVERY::Scopes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    Scopes (::xercesc::InputSource& i,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > (
        ::WS::DISCOVERY::Scopes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    Scopes (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > (
        ::WS::DISCOVERY::Scopes (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    Scopes (const ::xercesc::DOMDocument& doc,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > (
          ::WS::DISCOVERY::Scopes (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Scopes",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ScopesType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > r (
          dynamic_cast< ::WS::DISCOVERY::ScopesType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Scopes",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::ScopesType >
    Scopes (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Scopes",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::ScopesType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::ScopesType > r (
          dynamic_cast< ::WS::DISCOVERY::ScopesType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Scopes",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    XAddrs (const ::std::string& u,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::XAddrs (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    XAddrs (const ::std::string& u,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::XAddrs (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    XAddrs (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::XAddrs (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    XAddrs (::std::istream& is,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::XAddrs (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    XAddrs (::std::istream& is,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::XAddrs (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    XAddrs (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::XAddrs (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    XAddrs (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::XAddrs (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    XAddrs (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::XAddrs (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    XAddrs (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::XAddrs (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    XAddrs (::xercesc::InputSource& i,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::XAddrs (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    XAddrs (::xercesc::InputSource& i,
            ::xml_schema::ErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::XAddrs (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    XAddrs (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::XAddrs (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    XAddrs (const ::xercesc::DOMDocument& doc,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
          ::WS::DISCOVERY::XAddrs (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "XAddrs",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::UriListType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::UriListType > r (
          dynamic_cast< ::WS::DISCOVERY::UriListType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "XAddrs",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    XAddrs (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::Flags f,
            const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "XAddrs",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::UriListType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::UriListType > r (
          dynamic_cast< ::WS::DISCOVERY::UriListType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "XAddrs",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    MetadataVersion (const ::std::string& u,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::xml_schema::UnsignedInt > (
        ::WS::DISCOVERY::MetadataVersion (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    MetadataVersion (const ::std::string& u,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::xml_schema::UnsignedInt > (
        ::WS::DISCOVERY::MetadataVersion (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    MetadataVersion (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::xml_schema::UnsignedInt > (
        ::WS::DISCOVERY::MetadataVersion (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    MetadataVersion (::std::istream& is,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::MetadataVersion (isrc, f, p);
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    MetadataVersion (::std::istream& is,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::MetadataVersion (isrc, h, f, p);
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    MetadataVersion (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::MetadataVersion (isrc, h, f, p);
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    MetadataVersion (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::MetadataVersion (isrc, f, p);
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    MetadataVersion (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::MetadataVersion (isrc, h, f, p);
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    MetadataVersion (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::MetadataVersion (isrc, h, f, p);
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    MetadataVersion (::xercesc::InputSource& i,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::xml_schema::UnsignedInt > (
        ::WS::DISCOVERY::MetadataVersion (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    MetadataVersion (::xercesc::InputSource& i,
                     ::xml_schema::ErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::xml_schema::UnsignedInt > (
        ::WS::DISCOVERY::MetadataVersion (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    MetadataVersion (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::xml_schema::UnsignedInt > (
        ::WS::DISCOVERY::MetadataVersion (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    MetadataVersion (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::xml_schema::UnsignedInt > (
          ::WS::DISCOVERY::MetadataVersion (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "MetadataVersion" &&
          n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
      {
        ::std::unique_ptr< ::xml_schema::UnsignedInt > r (
          new ::xml_schema::UnsignedInt (
            ::xsd::cxx::tree::traits< ::xml_schema::UnsignedInt, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "MetadataVersion",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::xml_schema::UnsignedInt >
    MetadataVersion (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::Flags f,
                     const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "MetadataVersion" &&
          n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
      {
        ::std::unique_ptr< ::xml_schema::UnsignedInt > r (
          new ::xml_schema::UnsignedInt (
            ::xsd::cxx::tree::traits< ::xml_schema::UnsignedInt, char >::create (
              e, f, 0)));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "MetadataVersion",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    SupportedMatchingRules (const ::std::string& u,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::SupportedMatchingRules (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    SupportedMatchingRules (const ::std::string& u,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::SupportedMatchingRules (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    SupportedMatchingRules (const ::std::string& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::SupportedMatchingRules (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    SupportedMatchingRules (::std::istream& is,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::SupportedMatchingRules (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    SupportedMatchingRules (::std::istream& is,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::SupportedMatchingRules (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    SupportedMatchingRules (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::SupportedMatchingRules (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    SupportedMatchingRules (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::SupportedMatchingRules (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    SupportedMatchingRules (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::SupportedMatchingRules (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    SupportedMatchingRules (::std::istream& is,
                            const ::std::string& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::SupportedMatchingRules (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    SupportedMatchingRules (::xercesc::InputSource& i,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::SupportedMatchingRules (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    SupportedMatchingRules (::xercesc::InputSource& i,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::SupportedMatchingRules (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    SupportedMatchingRules (::xercesc::InputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
        ::WS::DISCOVERY::SupportedMatchingRules (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    SupportedMatchingRules (const ::xercesc::DOMDocument& doc,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::UriListType > (
          ::WS::DISCOVERY::SupportedMatchingRules (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "SupportedMatchingRules",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::UriListType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::UriListType > r (
          dynamic_cast< ::WS::DISCOVERY::UriListType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SupportedMatchingRules",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::UriListType >
    SupportedMatchingRules (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "SupportedMatchingRules",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::UriListType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::UriListType > r (
          dynamic_cast< ::WS::DISCOVERY::UriListType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SupportedMatchingRules",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    Security (const ::std::string& u,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > (
        ::WS::DISCOVERY::Security (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    Security (const ::std::string& u,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > (
        ::WS::DISCOVERY::Security (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    Security (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > (
        ::WS::DISCOVERY::Security (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    Security (::std::istream& is,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Security (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    Security (::std::istream& is,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Security (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    Security (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Security (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    Security (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Security (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    Security (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Security (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    Security (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Security (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    Security (::xercesc::InputSource& i,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > (
        ::WS::DISCOVERY::Security (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    Security (::xercesc::InputSource& i,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > (
        ::WS::DISCOVERY::Security (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    Security (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > (
        ::WS::DISCOVERY::Security (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    Security (const ::xercesc::DOMDocument& doc,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > (
          ::WS::DISCOVERY::Security (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Security",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::SecurityType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > r (
          dynamic_cast< ::WS::DISCOVERY::SecurityType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Security",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SecurityType >
    Security (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Security",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::SecurityType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::SecurityType > r (
          dynamic_cast< ::WS::DISCOVERY::SecurityType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Security",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    Sig (const ::std::string& u,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SigType > (
        ::WS::DISCOVERY::Sig (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    Sig (const ::std::string& u,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SigType > (
        ::WS::DISCOVERY::Sig (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    Sig (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SigType > (
        ::WS::DISCOVERY::Sig (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    Sig (::std::istream& is,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Sig (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    Sig (::std::istream& is,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Sig (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    Sig (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::Sig (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    Sig (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Sig (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    Sig (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Sig (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    Sig (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::Sig (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    Sig (::xercesc::InputSource& i,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SigType > (
        ::WS::DISCOVERY::Sig (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    Sig (::xercesc::InputSource& i,
         ::xml_schema::ErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SigType > (
        ::WS::DISCOVERY::Sig (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    Sig (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::SigType > (
        ::WS::DISCOVERY::Sig (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    Sig (const ::xercesc::DOMDocument& doc,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::SigType > (
          ::WS::DISCOVERY::Sig (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Sig",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::SigType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::SigType > r (
          dynamic_cast< ::WS::DISCOVERY::SigType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Sig",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::SigType >
    Sig (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::Flags f,
         const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Sig",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::SigType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::SigType > r (
          dynamic_cast< ::WS::DISCOVERY::SigType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Sig",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    AppSequence (const ::std::string& u,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > (
        ::WS::DISCOVERY::AppSequence (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    AppSequence (const ::std::string& u,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > (
        ::WS::DISCOVERY::AppSequence (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    AppSequence (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > (
        ::WS::DISCOVERY::AppSequence (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    AppSequence (::std::istream& is,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::AppSequence (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    AppSequence (::std::istream& is,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::AppSequence (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    AppSequence (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::WS::DISCOVERY::AppSequence (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    AppSequence (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::AppSequence (isrc, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    AppSequence (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::AppSequence (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    AppSequence (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::WS::DISCOVERY::AppSequence (isrc, h, f, p);
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    AppSequence (::xercesc::InputSource& i,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > (
        ::WS::DISCOVERY::AppSequence (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    AppSequence (::xercesc::InputSource& i,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > (
        ::WS::DISCOVERY::AppSequence (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    AppSequence (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > (
        ::WS::DISCOVERY::AppSequence (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    AppSequence (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > (
          ::WS::DISCOVERY::AppSequence (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "AppSequence",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::AppSequenceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > r (
          dynamic_cast< ::WS::DISCOVERY::AppSequenceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AppSequence",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }

    ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType >
    AppSequence (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "AppSequence",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          &::xsd::cxx::tree::factory_impl< ::WS::DISCOVERY::AppSequenceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::unique_ptr< ::WS::DISCOVERY::AppSequenceType > r (
          dynamic_cast< ::WS::DISCOVERY::AppSequenceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AppSequence",
        "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace WS
{
  namespace DISCOVERY
  {
    void
    Hello (::std::ostream& o,
           const ::WS::DISCOVERY::HelloType& s,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Hello (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Hello (::std::ostream& o,
           const ::WS::DISCOVERY::HelloType& s,
           ::xml_schema::ErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Hello (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Hello (::std::ostream& o,
           const ::WS::DISCOVERY::HelloType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Hello (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Hello (::xercesc::XMLFormatTarget& t,
           const ::WS::DISCOVERY::HelloType& s,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Hello (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Hello (::xercesc::XMLFormatTarget& t,
           const ::WS::DISCOVERY::HelloType& s,
           ::xml_schema::ErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Hello (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Hello (::xercesc::XMLFormatTarget& t,
           const ::WS::DISCOVERY::HelloType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Hello (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Hello (::xercesc::DOMDocument& d,
           const ::WS::DISCOVERY::HelloType& s,
           ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::HelloType) == typeid (s))
      {
        if (n.name () == "Hello" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Hello",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Hello",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    Hello (const ::WS::DISCOVERY::HelloType& s,
           const ::xml_schema::NamespaceInfomap& m,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::HelloType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Hello",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Hello",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::Hello (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const HelloType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const HelloType::EndpointReferenceType& x (i.EndpointReference ());
        if (typeid (HelloType::EndpointReferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EndpointReference",
            "http://www.w3.org/2005/08/addressing",
            true, true, e, x);
      }

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.Types ())
        {
          const HelloType::TypesType& x (*i.Types ());
          if (typeid (HelloType::TypesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Types",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // Scopes
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.Scopes ())
        {
          const HelloType::ScopesType& x (*i.Scopes ());
          if (typeid (HelloType::ScopesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Scopes",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // XAddrs
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.XAddrs ())
        {
          const HelloType::XAddrsType& x (*i.XAddrs ());
          if (typeid (HelloType::XAddrsType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "XAddrs",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // MetadataVersion
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MetadataVersion",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
            e));

        s << i.MetadataVersion ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, HelloType >
    _xsd_HelloType_type_serializer_init (
      "HelloType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    Bye (::std::ostream& o,
         const ::WS::DISCOVERY::ByeType& s,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Bye (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Bye (::std::ostream& o,
         const ::WS::DISCOVERY::ByeType& s,
         ::xml_schema::ErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Bye (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Bye (::std::ostream& o,
         const ::WS::DISCOVERY::ByeType& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Bye (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Bye (::xercesc::XMLFormatTarget& t,
         const ::WS::DISCOVERY::ByeType& s,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Bye (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Bye (::xercesc::XMLFormatTarget& t,
         const ::WS::DISCOVERY::ByeType& s,
         ::xml_schema::ErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Bye (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Bye (::xercesc::XMLFormatTarget& t,
         const ::WS::DISCOVERY::ByeType& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Bye (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Bye (::xercesc::DOMDocument& d,
         const ::WS::DISCOVERY::ByeType& s,
         ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::ByeType) == typeid (s))
      {
        if (n.name () == "Bye" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Bye",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Bye",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    Bye (const ::WS::DISCOVERY::ByeType& s,
         const ::xml_schema::NamespaceInfomap& m,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::ByeType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Bye",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Bye",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::Bye (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const ByeType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ByeType::EndpointReferenceType& x (i.EndpointReference ());
        if (typeid (ByeType::EndpointReferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EndpointReference",
            "http://www.w3.org/2005/08/addressing",
            true, true, e, x);
      }

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.Types ())
        {
          const ByeType::TypesType& x (*i.Types ());
          if (typeid (ByeType::TypesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Types",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // Scopes
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.Scopes ())
        {
          const ByeType::ScopesType& x (*i.Scopes ());
          if (typeid (ByeType::ScopesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Scopes",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // XAddrs
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.XAddrs ())
        {
          const ByeType::XAddrsType& x (*i.XAddrs ());
          if (typeid (ByeType::XAddrsType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "XAddrs",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // MetadataVersion
      //
      if (i.MetadataVersion ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MetadataVersion",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
            e));

        s << *i.MetadataVersion ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ByeType >
    _xsd_ByeType_type_serializer_init (
      "ByeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    Probe (::std::ostream& o,
           const ::WS::DISCOVERY::ProbeType& s,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Probe (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Probe (::std::ostream& o,
           const ::WS::DISCOVERY::ProbeType& s,
           ::xml_schema::ErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Probe (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Probe (::std::ostream& o,
           const ::WS::DISCOVERY::ProbeType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Probe (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Probe (::xercesc::XMLFormatTarget& t,
           const ::WS::DISCOVERY::ProbeType& s,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Probe (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Probe (::xercesc::XMLFormatTarget& t,
           const ::WS::DISCOVERY::ProbeType& s,
           ::xml_schema::ErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Probe (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Probe (::xercesc::XMLFormatTarget& t,
           const ::WS::DISCOVERY::ProbeType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Probe (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Probe (::xercesc::DOMDocument& d,
           const ::WS::DISCOVERY::ProbeType& s,
           ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::ProbeType) == typeid (s))
      {
        if (n.name () == "Probe" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Probe",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Probe",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    Probe (const ::WS::DISCOVERY::ProbeType& s,
           const ::xml_schema::NamespaceInfomap& m,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::ProbeType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Probe",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Probe",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::Probe (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const ProbeType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.Types ())
        {
          const ProbeType::TypesType& x (*i.Types ());
          if (typeid (ProbeType::TypesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Types",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // Scopes
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.Scopes ())
        {
          const ProbeType::ScopesType& x (*i.Scopes ());
          if (typeid (ProbeType::ScopesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Scopes",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ProbeType >
    _xsd_ProbeType_type_serializer_init (
      "ProbeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    ProbeMatches (::std::ostream& o,
                  const ::WS::DISCOVERY::ProbeMatchesType& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::ProbeMatches (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ProbeMatches (::std::ostream& o,
                  const ::WS::DISCOVERY::ProbeMatchesType& s,
                  ::xml_schema::ErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::ProbeMatches (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ProbeMatches (::std::ostream& o,
                  const ::WS::DISCOVERY::ProbeMatchesType& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::ProbeMatches (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ProbeMatches (::xercesc::XMLFormatTarget& t,
                  const ::WS::DISCOVERY::ProbeMatchesType& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::ProbeMatches (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ProbeMatches (::xercesc::XMLFormatTarget& t,
                  const ::WS::DISCOVERY::ProbeMatchesType& s,
                  ::xml_schema::ErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::ProbeMatches (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ProbeMatches (::xercesc::XMLFormatTarget& t,
                  const ::WS::DISCOVERY::ProbeMatchesType& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::ProbeMatches (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ProbeMatches (::xercesc::DOMDocument& d,
                  const ::WS::DISCOVERY::ProbeMatchesType& s,
                  ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::ProbeMatchesType) == typeid (s))
      {
        if (n.name () == "ProbeMatches" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "ProbeMatches",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ProbeMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    ProbeMatches (const ::WS::DISCOVERY::ProbeMatchesType& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::ProbeMatchesType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "ProbeMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ProbeMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::ProbeMatches (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const ProbeMatchesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // ProbeMatch
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (ProbeMatchesType::ProbeMatchConstIterator
             b (i.ProbeMatch ().begin ()), n (i.ProbeMatch ().end ());
             b != n; ++b)
        {
          if (typeid (ProbeMatchesType::ProbeMatchType) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ProbeMatch",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "ProbeMatch",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              false, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ProbeMatchesType >
    _xsd_ProbeMatchesType_type_serializer_init (
      "ProbeMatchesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const ProbeMatchType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ProbeMatchType::EndpointReferenceType& x (i.EndpointReference ());
        if (typeid (ProbeMatchType::EndpointReferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EndpointReference",
            "http://www.w3.org/2005/08/addressing",
            true, true, e, x);
      }

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.Types ())
        {
          const ProbeMatchType::TypesType& x (*i.Types ());
          if (typeid (ProbeMatchType::TypesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Types",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // Scopes
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.Scopes ())
        {
          const ProbeMatchType::ScopesType& x (*i.Scopes ());
          if (typeid (ProbeMatchType::ScopesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Scopes",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // XAddrs
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.XAddrs ())
        {
          const ProbeMatchType::XAddrsType& x (*i.XAddrs ());
          if (typeid (ProbeMatchType::XAddrsType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "XAddrs",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // MetadataVersion
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MetadataVersion",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
            e));

        s << i.MetadataVersion ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ProbeMatchType >
    _xsd_ProbeMatchType_type_serializer_init (
      "ProbeMatchType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    Resolve (::std::ostream& o,
             const ::WS::DISCOVERY::ResolveType& s,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Resolve (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Resolve (::std::ostream& o,
             const ::WS::DISCOVERY::ResolveType& s,
             ::xml_schema::ErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Resolve (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Resolve (::std::ostream& o,
             const ::WS::DISCOVERY::ResolveType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Resolve (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Resolve (::xercesc::XMLFormatTarget& t,
             const ::WS::DISCOVERY::ResolveType& s,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Resolve (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Resolve (::xercesc::XMLFormatTarget& t,
             const ::WS::DISCOVERY::ResolveType& s,
             ::xml_schema::ErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Resolve (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Resolve (::xercesc::XMLFormatTarget& t,
             const ::WS::DISCOVERY::ResolveType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::NamespaceInfomap& m,
             const ::std::string& e,
             ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Resolve (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Resolve (::xercesc::DOMDocument& d,
             const ::WS::DISCOVERY::ResolveType& s,
             ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::ResolveType) == typeid (s))
      {
        if (n.name () == "Resolve" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Resolve",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Resolve",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    Resolve (const ::WS::DISCOVERY::ResolveType& s,
             const ::xml_schema::NamespaceInfomap& m,
             ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::ResolveType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Resolve",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Resolve",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::Resolve (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const ResolveType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ResolveType::EndpointReferenceType& x (i.EndpointReference ());
        if (typeid (ResolveType::EndpointReferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EndpointReference",
            "http://www.w3.org/2005/08/addressing",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ResolveType >
    _xsd_ResolveType_type_serializer_init (
      "ResolveType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    ResolveMatches (::std::ostream& o,
                    const ::WS::DISCOVERY::ResolveMatchesType& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::ResolveMatches (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ResolveMatches (::std::ostream& o,
                    const ::WS::DISCOVERY::ResolveMatchesType& s,
                    ::xml_schema::ErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::ResolveMatches (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ResolveMatches (::std::ostream& o,
                    const ::WS::DISCOVERY::ResolveMatchesType& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::ResolveMatches (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ResolveMatches (::xercesc::XMLFormatTarget& t,
                    const ::WS::DISCOVERY::ResolveMatchesType& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::ResolveMatches (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ResolveMatches (::xercesc::XMLFormatTarget& t,
                    const ::WS::DISCOVERY::ResolveMatchesType& s,
                    ::xml_schema::ErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::ResolveMatches (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ResolveMatches (::xercesc::XMLFormatTarget& t,
                    const ::WS::DISCOVERY::ResolveMatchesType& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::NamespaceInfomap& m,
                    const ::std::string& e,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::ResolveMatches (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ResolveMatches (::xercesc::DOMDocument& d,
                    const ::WS::DISCOVERY::ResolveMatchesType& s,
                    ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::ResolveMatchesType) == typeid (s))
      {
        if (n.name () == "ResolveMatches" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "ResolveMatches",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ResolveMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    ResolveMatches (const ::WS::DISCOVERY::ResolveMatchesType& s,
                    const ::xml_schema::NamespaceInfomap& m,
                    ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::ResolveMatchesType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "ResolveMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ResolveMatches",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::ResolveMatches (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const ResolveMatchesType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // ResolveMatch
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.ResolveMatch ())
        {
          const ResolveMatchesType::ResolveMatchType& x (*i.ResolveMatch ());
          if (typeid (ResolveMatchesType::ResolveMatchType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ResolveMatch",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "ResolveMatch",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              false, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ResolveMatchesType >
    _xsd_ResolveMatchesType_type_serializer_init (
      "ResolveMatchesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const ResolveMatchType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // EndpointReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const ResolveMatchType::EndpointReferenceType& x (i.EndpointReference ());
        if (typeid (ResolveMatchType::EndpointReferenceType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "EndpointReference",
              "http://www.w3.org/2005/08/addressing",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "EndpointReference",
            "http://www.w3.org/2005/08/addressing",
            true, true, e, x);
      }

      // Types
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.Types ())
        {
          const ResolveMatchType::TypesType& x (*i.Types ());
          if (typeid (ResolveMatchType::TypesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Types",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Types",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // Scopes
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.Scopes ())
        {
          const ResolveMatchType::ScopesType& x (*i.Scopes ());
          if (typeid (ResolveMatchType::ScopesType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Scopes",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Scopes",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // XAddrs
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.XAddrs ())
        {
          const ResolveMatchType::XAddrsType& x (*i.XAddrs ());
          if (typeid (ResolveMatchType::XAddrsType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "XAddrs",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "XAddrs",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }

      // MetadataVersion
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MetadataVersion",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
            e));

        s << i.MetadataVersion ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ResolveMatchType >
    _xsd_ResolveMatchType_type_serializer_init (
      "ResolveMatchType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    Types (::std::ostream& o,
           const ::WS::DISCOVERY::QNameListType& s,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Types (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Types (::std::ostream& o,
           const ::WS::DISCOVERY::QNameListType& s,
           ::xml_schema::ErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Types (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Types (::std::ostream& o,
           const ::WS::DISCOVERY::QNameListType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Types (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Types (::xercesc::XMLFormatTarget& t,
           const ::WS::DISCOVERY::QNameListType& s,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Types (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Types (::xercesc::XMLFormatTarget& t,
           const ::WS::DISCOVERY::QNameListType& s,
           ::xml_schema::ErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Types (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Types (::xercesc::XMLFormatTarget& t,
           const ::WS::DISCOVERY::QNameListType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Types (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Types (::xercesc::DOMDocument& d,
           const ::WS::DISCOVERY::QNameListType& s,
           ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::QNameListType) == typeid (s))
      {
        if (n.name () == "Types" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Types",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Types",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    Types (const ::WS::DISCOVERY::QNameListType& s,
           const ::xml_schema::NamespaceInfomap& m,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::QNameListType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Types",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Types",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::Types (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const QNameListType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Qname, char >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const QNameListType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Qname, char >& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const QNameListType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Qname, char >& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, QNameListType >
    _xsd_QNameListType_type_serializer_init (
      "QNameListType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    Scopes (::std::ostream& o,
            const ::WS::DISCOVERY::ScopesType& s,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Scopes (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Scopes (::std::ostream& o,
            const ::WS::DISCOVERY::ScopesType& s,
            ::xml_schema::ErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Scopes (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Scopes (::std::ostream& o,
            const ::WS::DISCOVERY::ScopesType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Scopes (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Scopes (::xercesc::XMLFormatTarget& t,
            const ::WS::DISCOVERY::ScopesType& s,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Scopes (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Scopes (::xercesc::XMLFormatTarget& t,
            const ::WS::DISCOVERY::ScopesType& s,
            ::xml_schema::ErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Scopes (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Scopes (::xercesc::XMLFormatTarget& t,
            const ::WS::DISCOVERY::ScopesType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Scopes (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Scopes (::xercesc::DOMDocument& d,
            const ::WS::DISCOVERY::ScopesType& s,
            ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::ScopesType) == typeid (s))
      {
        if (n.name () == "Scopes" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Scopes",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Scopes",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    Scopes (const ::WS::DISCOVERY::ScopesType& s,
            const ::xml_schema::NamespaceInfomap& m,
            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::ScopesType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Scopes",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Scopes",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::Scopes (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const UriListType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Uri, char >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const UriListType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Uri, char >& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const UriListType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Uri, char >& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, UriListType >
    _xsd_UriListType_type_serializer_init (
      "UriListType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const ScopesType& i)
    {
      e << static_cast< const ::WS::DISCOVERY::UriListType& > (i);

      // MatchBy
      //
      if (i.MatchBy ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "MatchBy",
            e));

        a << *i.MatchBy ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ScopesType >
    _xsd_ScopesType_type_serializer_init (
      "ScopesType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    XAddrs (::std::ostream& o,
            const ::WS::DISCOVERY::UriListType& s,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::XAddrs (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    XAddrs (::std::ostream& o,
            const ::WS::DISCOVERY::UriListType& s,
            ::xml_schema::ErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::XAddrs (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    XAddrs (::std::ostream& o,
            const ::WS::DISCOVERY::UriListType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::XAddrs (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    XAddrs (::xercesc::XMLFormatTarget& t,
            const ::WS::DISCOVERY::UriListType& s,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::XAddrs (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    XAddrs (::xercesc::XMLFormatTarget& t,
            const ::WS::DISCOVERY::UriListType& s,
            ::xml_schema::ErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::XAddrs (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    XAddrs (::xercesc::XMLFormatTarget& t,
            const ::WS::DISCOVERY::UriListType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::NamespaceInfomap& m,
            const ::std::string& e,
            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::XAddrs (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    XAddrs (::xercesc::DOMDocument& d,
            const ::WS::DISCOVERY::UriListType& s,
            ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::UriListType) == typeid (s))
      {
        if (n.name () == "XAddrs" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "XAddrs",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "XAddrs",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    XAddrs (const ::WS::DISCOVERY::UriListType& s,
            const ::xml_schema::NamespaceInfomap& m,
            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::UriListType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "XAddrs",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "XAddrs",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::XAddrs (*d, s, f);
      return d;
    }

    void
    MetadataVersion (::std::ostream& o,
                     const ::xml_schema::UnsignedInt& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::MetadataVersion (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    MetadataVersion (::std::ostream& o,
                     const ::xml_schema::UnsignedInt& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::MetadataVersion (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    MetadataVersion (::std::ostream& o,
                     const ::xml_schema::UnsignedInt& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::MetadataVersion (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    MetadataVersion (::xercesc::XMLFormatTarget& t,
                     const ::xml_schema::UnsignedInt& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::MetadataVersion (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    MetadataVersion (::xercesc::XMLFormatTarget& t,
                     const ::xml_schema::UnsignedInt& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::MetadataVersion (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    MetadataVersion (::xercesc::XMLFormatTarget& t,
                     const ::xml_schema::UnsignedInt& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::MetadataVersion (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    MetadataVersion (::xercesc::DOMDocument& d,
                     const ::xml_schema::UnsignedInt& s,
                     ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "MetadataVersion" &&
          n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "MetadataVersion",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    MetadataVersion (const ::xml_schema::UnsignedInt& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "MetadataVersion",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f));

      ::WS::DISCOVERY::MetadataVersion (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const FaultCodeType& i)
    {
      e << static_cast< const ::xml_schema::Qname& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const FaultCodeType& i)
    {
      a << static_cast< const ::xml_schema::Qname& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const FaultCodeType& i)
    {
      l << static_cast< const ::xml_schema::Qname& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FaultCodeType >
    _xsd_FaultCodeType_type_serializer_init (
      "FaultCodeType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    operator<< (::xercesc::DOMElement& e, const FaultCodeOpenType& i)
    {
      e << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const FaultCodeOpenType& i)
    {
      a << static_cast< const ::xml_schema::String& > (i);
    }

    void
    operator<< (::xml_schema::ListStream& l,
                const FaultCodeOpenType& i)
    {
      l << static_cast< const ::xml_schema::String& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FaultCodeOpenType >
    _xsd_FaultCodeOpenType_type_serializer_init (
      "FaultCodeOpenType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    SupportedMatchingRules (::std::ostream& o,
                            const ::WS::DISCOVERY::UriListType& s,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::SupportedMatchingRules (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    SupportedMatchingRules (::std::ostream& o,
                            const ::WS::DISCOVERY::UriListType& s,
                            ::xml_schema::ErrorHandler& h,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::SupportedMatchingRules (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    SupportedMatchingRules (::std::ostream& o,
                            const ::WS::DISCOVERY::UriListType& s,
                            ::xercesc::DOMErrorHandler& h,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::SupportedMatchingRules (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    SupportedMatchingRules (::xercesc::XMLFormatTarget& t,
                            const ::WS::DISCOVERY::UriListType& s,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::SupportedMatchingRules (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    SupportedMatchingRules (::xercesc::XMLFormatTarget& t,
                            const ::WS::DISCOVERY::UriListType& s,
                            ::xml_schema::ErrorHandler& h,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::SupportedMatchingRules (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    SupportedMatchingRules (::xercesc::XMLFormatTarget& t,
                            const ::WS::DISCOVERY::UriListType& s,
                            ::xercesc::DOMErrorHandler& h,
                            const ::xml_schema::NamespaceInfomap& m,
                            const ::std::string& e,
                            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::SupportedMatchingRules (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    SupportedMatchingRules (::xercesc::DOMDocument& d,
                            const ::WS::DISCOVERY::UriListType& s,
                            ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::UriListType) == typeid (s))
      {
        if (n.name () == "SupportedMatchingRules" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "SupportedMatchingRules",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "SupportedMatchingRules",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    SupportedMatchingRules (const ::WS::DISCOVERY::UriListType& s,
                            const ::xml_schema::NamespaceInfomap& m,
                            ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::UriListType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "SupportedMatchingRules",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "SupportedMatchingRules",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::SupportedMatchingRules (*d, s, f);
      return d;
    }

    void
    Security (::std::ostream& o,
              const ::WS::DISCOVERY::SecurityType& s,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Security (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Security (::std::ostream& o,
              const ::WS::DISCOVERY::SecurityType& s,
              ::xml_schema::ErrorHandler& h,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Security (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Security (::std::ostream& o,
              const ::WS::DISCOVERY::SecurityType& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Security (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Security (::xercesc::XMLFormatTarget& t,
              const ::WS::DISCOVERY::SecurityType& s,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Security (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Security (::xercesc::XMLFormatTarget& t,
              const ::WS::DISCOVERY::SecurityType& s,
              ::xml_schema::ErrorHandler& h,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Security (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Security (::xercesc::XMLFormatTarget& t,
              const ::WS::DISCOVERY::SecurityType& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::NamespaceInfomap& m,
              const ::std::string& e,
              ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Security (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Security (::xercesc::DOMDocument& d,
              const ::WS::DISCOVERY::SecurityType& s,
              ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::SecurityType) == typeid (s))
      {
        if (n.name () == "Security" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Security",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Security",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    Security (const ::WS::DISCOVERY::SecurityType& s,
              const ::xml_schema::NamespaceInfomap& m,
              ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::SecurityType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Security",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Security",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::Security (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const SecurityType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Sig
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        if (i.Sig ())
        {
          const SecurityType::SigType& x (*i.Sig ());
          if (typeid (SecurityType::SigType) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Sig",
                "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
                e));

            s << x;
          }
          else
            tsm.serialize (
              "Sig",
              "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
              true, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SecurityType >
    _xsd_SecurityType_type_serializer_init (
      "SecurityType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    Sig (::std::ostream& o,
         const ::WS::DISCOVERY::SigType& s,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Sig (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Sig (::std::ostream& o,
         const ::WS::DISCOVERY::SigType& s,
         ::xml_schema::ErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Sig (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Sig (::std::ostream& o,
         const ::WS::DISCOVERY::SigType& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Sig (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Sig (::xercesc::XMLFormatTarget& t,
         const ::WS::DISCOVERY::SigType& s,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Sig (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Sig (::xercesc::XMLFormatTarget& t,
         const ::WS::DISCOVERY::SigType& s,
         ::xml_schema::ErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Sig (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Sig (::xercesc::XMLFormatTarget& t,
         const ::WS::DISCOVERY::SigType& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::NamespaceInfomap& m,
         const ::std::string& e,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::Sig (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Sig (::xercesc::DOMDocument& d,
         const ::WS::DISCOVERY::SigType& s,
         ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::SigType) == typeid (s))
      {
        if (n.name () == "Sig" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Sig",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Sig",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    Sig (const ::WS::DISCOVERY::SigType& s,
         const ::xml_schema::NamespaceInfomap& m,
         ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::SigType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Sig",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Sig",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::Sig (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const SigType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // Scheme
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Scheme",
            e));

        a << i.Scheme ();
      }

      // KeyId
      //
      if (i.KeyId ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "KeyId",
            e));

        a << *i.KeyId ();
      }

      // Refs
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Refs",
            e));

        a << i.Refs ();
      }

      // Sig
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Sig",
            e));

        a << i.Sig ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SigType >
    _xsd_SigType_type_serializer_init (
      "SigType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");


    void
    AppSequence (::std::ostream& o,
                 const ::WS::DISCOVERY::AppSequenceType& s,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::AppSequence (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    AppSequence (::std::ostream& o,
                 const ::WS::DISCOVERY::AppSequenceType& s,
                 ::xml_schema::ErrorHandler& h,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::AppSequence (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    AppSequence (::std::ostream& o,
                 const ::WS::DISCOVERY::AppSequenceType& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::AppSequence (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    AppSequence (::xercesc::XMLFormatTarget& t,
                 const ::WS::DISCOVERY::AppSequenceType& s,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::AppSequence (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    AppSequence (::xercesc::XMLFormatTarget& t,
                 const ::WS::DISCOVERY::AppSequenceType& s,
                 ::xml_schema::ErrorHandler& h,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::AppSequence (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    AppSequence (::xercesc::XMLFormatTarget& t,
                 const ::WS::DISCOVERY::AppSequenceType& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::NamespaceInfomap& m,
                 const ::std::string& e,
                 ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::WS::DISCOVERY::AppSequence (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    AppSequence (::xercesc::DOMDocument& d,
                 const ::WS::DISCOVERY::AppSequenceType& s,
                 ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::WS::DISCOVERY::AppSequenceType) == typeid (s))
      {
        if (n.name () == "AppSequence" &&
            n.namespace_ () == "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "AppSequence",
            "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "AppSequence",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          e, n, s);
      }
    }

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
    AppSequence (const ::WS::DISCOVERY::AppSequenceType& s,
                 const ::xml_schema::NamespaceInfomap& m,
                 ::xml_schema::Flags f)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::WS::DISCOVERY::AppSequenceType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "AppSequence",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "AppSequence",
          "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01",
          m, s, f);
      }

      ::WS::DISCOVERY::AppSequence (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const AppSequenceType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // InstanceId
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "InstanceId",
            e));

        a << i.InstanceId ();
      }

      // SequenceId
      //
      if (i.SequenceId ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "SequenceId",
            e));

        a << *i.SequenceId ();
      }

      // MessageNumber
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "MessageNumber",
            e));

        a << i.MessageNumber ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AppSequenceType >
    _xsd_AppSequenceType_type_serializer_init (
      "AppSequenceType",
      "http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

