// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef BICEPS_DOMAIN_MODEL_HXX
#define BICEPS_DOMAIN_MODEL_HXX

#include "BICEPS_DomainModel-fwd.hxx"

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "ExtensionPoint.hxx"

namespace CDM
{
  class Handle: public ::xml_schema::String
  {
    public:
    // Constructors.
    //
    Handle ();

    Handle (const char*);

    Handle (const ::std::string&);

    Handle (const ::xml_schema::String&);

    Handle (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    Handle (const ::xercesc::DOMAttr& a,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    Handle (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    Handle (const Handle& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    virtual Handle*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~Handle ();
  };

  class HandleRef: public ::xml_schema::String
  {
    public:
    // Constructors.
    //
    HandleRef ();

    HandleRef (const char*);

    HandleRef (const ::std::string&);

    HandleRef (const ::xml_schema::String&);

    HandleRef (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    HandleRef (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    HandleRef (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    HandleRef (const HandleRef& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    virtual HandleRef*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~HandleRef ();
  };

  class Timestamp: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >
  {
    public:
    // Constructors.
    //
    Timestamp (const ::xml_schema::UnsignedLong&);

    Timestamp (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    Timestamp (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    Timestamp (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    Timestamp (const Timestamp& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    virtual Timestamp*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~Timestamp ();
  };

  class VersionCounter: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedLong, char, ::xml_schema::SimpleType >
  {
    public:
    // Constructors.
    //
    VersionCounter (const ::xml_schema::UnsignedLong&);

    VersionCounter (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    VersionCounter (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    VersionCounter (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    VersionCounter (const VersionCounter& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual VersionCounter*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~VersionCounter ();
  };

  class ReferencedVersion: public ::CDM::VersionCounter
  {
    public:
    // Constructors.
    //
    ReferencedVersion (const ::xml_schema::UnsignedLong&);

    ReferencedVersion (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    ReferencedVersion (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    ReferencedVersion (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    ReferencedVersion (const ReferencedVersion& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual ReferencedVersion*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~ReferencedVersion ();
  };

  class Activation: public ::xml_schema::String
  {
    public:
    enum Value
    {
      On,
      Off
    };

    Activation (Value v);

    Activation (const char* v);

    Activation (const ::std::string& v);

    Activation (const ::xml_schema::String& v);

    Activation (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    Activation (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    Activation (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    Activation (const Activation& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual Activation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Activation&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_Activation_convert ();
    }

    protected:
    Value
    _xsd_Activation_convert () const;

    public:
    static const char* const _xsd_Activation_literals_[2];
    static const Value _xsd_Activation_indexes_[2];
  };

  class CodeIdentifier: public ::xml_schema::String
  {
    public:
    // Constructors.
    //
    CodeIdentifier ();

    CodeIdentifier (const char*);

    CodeIdentifier (const ::std::string&);

    CodeIdentifier (const ::xml_schema::String&);

    CodeIdentifier (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    CodeIdentifier (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    CodeIdentifier (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    CodeIdentifier (const CodeIdentifier& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual CodeIdentifier*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~CodeIdentifier ();
  };

  class LocalizedTextRef: public ::xml_schema::String
  {
    public:
    // Constructors.
    //
    LocalizedTextRef ();

    LocalizedTextRef (const char*);

    LocalizedTextRef (const ::std::string&);

    LocalizedTextRef (const ::xml_schema::String&);

    LocalizedTextRef (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    LocalizedTextRef (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    LocalizedTextRef (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    LocalizedTextRef (const LocalizedTextRef& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual LocalizedTextRef*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~LocalizedTextRef ();
  };

  class LocalizedText: public ::xml_schema::String
  {
    public:
    // Lang
    //
    typedef ::xml_schema::Language LangType;
    typedef ::xsd::cxx::tree::optional< LangType > LangOptional;
    typedef ::xsd::cxx::tree::traits< LangType, char > LangTraits;

    const LangOptional&
    Lang () const;

    LangOptional&
    Lang ();

    void
    Lang (const LangType& x);

    void
    Lang (const LangOptional& x);

    void
    Lang (::std::unique_ptr< LangType > p);

    // Ref
    //
    typedef ::CDM::LocalizedTextRef RefType;
    typedef ::xsd::cxx::tree::optional< RefType > RefOptional;
    typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

    const RefOptional&
    Ref () const;

    RefOptional&
    Ref ();

    void
    Ref (const RefType& x);

    void
    Ref (const RefOptional& x);

    void
    Ref (::std::unique_ptr< RefType > p);

    // Version
    //
    typedef ::CDM::ReferencedVersion VersionType;
    typedef ::xsd::cxx::tree::optional< VersionType > VersionOptional;
    typedef ::xsd::cxx::tree::traits< VersionType, char > VersionTraits;

    const VersionOptional&
    Version () const;

    VersionOptional&
    Version ();

    void
    Version (const VersionType& x);

    void
    Version (const VersionOptional& x);

    void
    Version (::std::unique_ptr< VersionType > p);

    // Constructors.
    //
    LocalizedText ();

    LocalizedText (const char*);

    LocalizedText (const ::std::string&);

    LocalizedText (const ::xml_schema::String&);

    LocalizedText (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    LocalizedText (const LocalizedText& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual LocalizedText*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    LocalizedText&
    operator= (const LocalizedText& x);

    virtual 
    ~LocalizedText ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    LangOptional Lang_;
    RefOptional Ref_;
    VersionOptional Version_;
  };

  class InstanceIdentifier: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // IdentifierName
    //
    typedef ::CDM::LocalizedText IdentifierNameType;
    typedef ::xsd::cxx::tree::sequence< IdentifierNameType > IdentifierNameSequence;
    typedef IdentifierNameSequence::iterator IdentifierNameIterator;
    typedef IdentifierNameSequence::const_iterator IdentifierNameConstIterator;
    typedef ::xsd::cxx::tree::traits< IdentifierNameType, char > IdentifierNameTraits;

    const IdentifierNameSequence&
    IdentifierName () const;

    IdentifierNameSequence&
    IdentifierName ();

    void
    IdentifierName (const IdentifierNameSequence& s);

    // root
    //
    typedef ::xml_schema::Uri RootType;
    typedef ::xsd::cxx::tree::traits< RootType, char > RootTraits;

    const RootType&
    root () const;

    RootType&
    root ();

    void
    root (const RootType& x);

    void
    root (::std::unique_ptr< RootType > p);

    // extension
    //
    typedef ::xml_schema::String ExtensionType1;
    typedef ::xsd::cxx::tree::optional< ExtensionType1 > ExtensionOptional1;
    typedef ::xsd::cxx::tree::traits< ExtensionType1, char > ExtensionTraits1;

    const ExtensionOptional1&
    extension () const;

    ExtensionOptional1&
    extension ();

    void
    extension (const ExtensionType1& x);

    void
    extension (const ExtensionOptional1& x);

    void
    extension (::std::unique_ptr< ExtensionType1 > p);

    // Constructors.
    //
    InstanceIdentifier (const RootType&);

    InstanceIdentifier (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    InstanceIdentifier (const InstanceIdentifier& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual InstanceIdentifier*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    InstanceIdentifier&
    operator= (const InstanceIdentifier& x);

    virtual 
    ~InstanceIdentifier ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    IdentifierNameSequence IdentifierName_;
    ::xsd::cxx::tree::one< RootType > root_;
    ExtensionOptional1 extension_;
  };

  class CodedValue: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // CodingSystemId
    //
    typedef ::xml_schema::Uri CodingSystemIdType;
    typedef ::xsd::cxx::tree::optional< CodingSystemIdType > CodingSystemIdOptional;
    typedef ::xsd::cxx::tree::traits< CodingSystemIdType, char > CodingSystemIdTraits;

    const CodingSystemIdOptional&
    CodingSystemId () const;

    CodingSystemIdOptional&
    CodingSystemId ();

    void
    CodingSystemId (const CodingSystemIdType& x);

    void
    CodingSystemId (const CodingSystemIdOptional& x);

    void
    CodingSystemId (::std::unique_ptr< CodingSystemIdType > p);

    // CodingSystemName
    //
    typedef ::CDM::LocalizedText CodingSystemNameType;
    typedef ::xsd::cxx::tree::sequence< CodingSystemNameType > CodingSystemNameSequence;
    typedef CodingSystemNameSequence::iterator CodingSystemNameIterator;
    typedef CodingSystemNameSequence::const_iterator CodingSystemNameConstIterator;
    typedef ::xsd::cxx::tree::traits< CodingSystemNameType, char > CodingSystemNameTraits;

    const CodingSystemNameSequence&
    CodingSystemName () const;

    CodingSystemNameSequence&
    CodingSystemName ();

    void
    CodingSystemName (const CodingSystemNameSequence& s);

    // VersionId
    //
    typedef ::xml_schema::String VersionIdType;
    typedef ::xsd::cxx::tree::optional< VersionIdType > VersionIdOptional;
    typedef ::xsd::cxx::tree::traits< VersionIdType, char > VersionIdTraits;

    const VersionIdOptional&
    VersionId () const;

    VersionIdOptional&
    VersionId ();

    void
    VersionId (const VersionIdType& x);

    void
    VersionId (const VersionIdOptional& x);

    void
    VersionId (::std::unique_ptr< VersionIdType > p);

    // CodeId
    //
    typedef ::CDM::CodeIdentifier CodeIdType;
    typedef ::xsd::cxx::tree::traits< CodeIdType, char > CodeIdTraits;

    const CodeIdType&
    CodeId () const;

    CodeIdType&
    CodeId ();

    void
    CodeId (const CodeIdType& x);

    void
    CodeId (::std::unique_ptr< CodeIdType > p);

    // ConceptDescription
    //
    typedef ::CDM::LocalizedText ConceptDescriptionType;
    typedef ::xsd::cxx::tree::sequence< ConceptDescriptionType > ConceptDescriptionSequence;
    typedef ConceptDescriptionSequence::iterator ConceptDescriptionIterator;
    typedef ConceptDescriptionSequence::const_iterator ConceptDescriptionConstIterator;
    typedef ::xsd::cxx::tree::traits< ConceptDescriptionType, char > ConceptDescriptionTraits;

    const ConceptDescriptionSequence&
    ConceptDescription () const;

    ConceptDescriptionSequence&
    ConceptDescription ();

    void
    ConceptDescription (const ConceptDescriptionSequence& s);

    // Constructors.
    //
    CodedValue (const CodeIdType&);

    CodedValue (::std::unique_ptr< CodeIdType >);

    CodedValue (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    CodedValue (const CodedValue& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual CodedValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CodedValue&
    operator= (const CodedValue& x);

    virtual 
    ~CodedValue ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    CodingSystemIdOptional CodingSystemId_;
    CodingSystemNameSequence CodingSystemName_;
    VersionIdOptional VersionId_;
    ::xsd::cxx::tree::one< CodeIdType > CodeId_;
    ConceptDescriptionSequence ConceptDescription_;
  };

  class CodedWithTranslations: public ::CDM::CodedValue
  {
    public:
    // Translation
    //
    typedef ::CDM::CodedValue TranslationType;
    typedef ::xsd::cxx::tree::sequence< TranslationType > TranslationSequence;
    typedef TranslationSequence::iterator TranslationIterator;
    typedef TranslationSequence::const_iterator TranslationConstIterator;
    typedef ::xsd::cxx::tree::traits< TranslationType, char > TranslationTraits;

    const TranslationSequence&
    Translation () const;

    TranslationSequence&
    Translation ();

    void
    Translation (const TranslationSequence& s);

    // Constructors.
    //
    CodedWithTranslations (const CodeIdType&);

    CodedWithTranslations (::std::unique_ptr< CodeIdType >);

    CodedWithTranslations (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    CodedWithTranslations (const CodedWithTranslations& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual CodedWithTranslations*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CodedWithTranslations&
    operator= (const CodedWithTranslations& x);

    virtual 
    ~CodedWithTranslations ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TranslationSequence Translation_;
  };

  class CauseInfo: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Remedy
    //
    typedef ::CDM::RemedyInfo RemedyType;
    typedef ::xsd::cxx::tree::optional< RemedyType > RemedyOptional;
    typedef ::xsd::cxx::tree::traits< RemedyType, char > RemedyTraits;

    const RemedyOptional&
    Remedy () const;

    RemedyOptional&
    Remedy ();

    void
    Remedy (const RemedyType& x);

    void
    Remedy (const RemedyOptional& x);

    void
    Remedy (::std::unique_ptr< RemedyType > p);

    // Description
    //
    typedef ::CDM::LocalizedText DescriptionType;
    typedef ::xsd::cxx::tree::sequence< DescriptionType > DescriptionSequence;
    typedef DescriptionSequence::iterator DescriptionIterator;
    typedef DescriptionSequence::const_iterator DescriptionConstIterator;
    typedef ::xsd::cxx::tree::traits< DescriptionType, char > DescriptionTraits;

    const DescriptionSequence&
    Description () const;

    DescriptionSequence&
    Description ();

    void
    Description (const DescriptionSequence& s);

    // Constructors.
    //
    CauseInfo ();

    CauseInfo (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    CauseInfo (const CauseInfo& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    virtual CauseInfo*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CauseInfo&
    operator= (const CauseInfo& x);

    virtual 
    ~CauseInfo ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    RemedyOptional Remedy_;
    DescriptionSequence Description_;
  };

  class RemedyInfo: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Description
    //
    typedef ::CDM::LocalizedText DescriptionType;
    typedef ::xsd::cxx::tree::sequence< DescriptionType > DescriptionSequence;
    typedef DescriptionSequence::iterator DescriptionIterator;
    typedef DescriptionSequence::const_iterator DescriptionConstIterator;
    typedef ::xsd::cxx::tree::traits< DescriptionType, char > DescriptionTraits;

    const DescriptionSequence&
    Description () const;

    DescriptionSequence&
    Description ();

    void
    Description (const DescriptionSequence& s);

    // Constructors.
    //
    RemedyInfo ();

    RemedyInfo (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    RemedyInfo (const RemedyInfo& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual RemedyInfo*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    RemedyInfo&
    operator= (const RemedyInfo& x);

    virtual 
    ~RemedyInfo ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    DescriptionSequence Description_;
  };

  class Range: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Lower
    //
    typedef ::xml_schema::Decimal LowerType;
    typedef ::xsd::cxx::tree::optional< LowerType > LowerOptional;
    typedef ::xsd::cxx::tree::traits< LowerType, char, ::xsd::cxx::tree::schema_type::decimal > LowerTraits;

    const LowerOptional&
    Lower () const;

    LowerOptional&
    Lower ();

    void
    Lower (const LowerType& x);

    void
    Lower (const LowerOptional& x);

    // Upper
    //
    typedef ::xml_schema::Decimal UpperType;
    typedef ::xsd::cxx::tree::optional< UpperType > UpperOptional;
    typedef ::xsd::cxx::tree::traits< UpperType, char, ::xsd::cxx::tree::schema_type::decimal > UpperTraits;

    const UpperOptional&
    Upper () const;

    UpperOptional&
    Upper ();

    void
    Upper (const UpperType& x);

    void
    Upper (const UpperOptional& x);

    // StepWidth
    //
    typedef ::xml_schema::Decimal StepWidthType;
    typedef ::xsd::cxx::tree::optional< StepWidthType > StepWidthOptional;
    typedef ::xsd::cxx::tree::traits< StepWidthType, char, ::xsd::cxx::tree::schema_type::decimal > StepWidthTraits;

    const StepWidthOptional&
    StepWidth () const;

    StepWidthOptional&
    StepWidth ();

    void
    StepWidth (const StepWidthType& x);

    void
    StepWidth (const StepWidthOptional& x);

    // Constructors.
    //
    Range ();

    Range (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    Range (const Range& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    virtual Range*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Range&
    operator= (const Range& x);

    virtual 
    ~Range ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    LowerOptional Lower_;
    UpperOptional Upper_;
    StepWidthOptional StepWidth_;
  };

  class Measure: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // MeasurementUnit
    //
    typedef ::CDM::CodedValue MeasurementUnitType;
    typedef ::xsd::cxx::tree::traits< MeasurementUnitType, char > MeasurementUnitTraits;

    const MeasurementUnitType&
    MeasurementUnit () const;

    MeasurementUnitType&
    MeasurementUnit ();

    void
    MeasurementUnit (const MeasurementUnitType& x);

    void
    MeasurementUnit (::std::unique_ptr< MeasurementUnitType > p);

    // MeasuredValue
    //
    typedef ::xml_schema::Decimal MeasuredValueType;
    typedef ::xsd::cxx::tree::optional< MeasuredValueType > MeasuredValueOptional;
    typedef ::xsd::cxx::tree::traits< MeasuredValueType, char, ::xsd::cxx::tree::schema_type::decimal > MeasuredValueTraits;

    const MeasuredValueOptional&
    MeasuredValue () const;

    MeasuredValueOptional&
    MeasuredValue ();

    void
    MeasuredValue (const MeasuredValueType& x);

    void
    MeasuredValue (const MeasuredValueOptional& x);

    // Constructors.
    //
    Measure (const MeasurementUnitType&);

    Measure (::std::unique_ptr< MeasurementUnitType >);

    Measure (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    Measure (const Measure& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    virtual Measure*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Measure&
    operator= (const Measure& x);

    virtual 
    ~Measure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< MeasurementUnitType > MeasurementUnit_;
    MeasuredValueOptional MeasuredValue_;
  };

  class IntendedUse: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Inf,
      MedA,
      MedB,
      MedC
    };

    IntendedUse (Value v);

    IntendedUse (const char* v);

    IntendedUse (const ::std::string& v);

    IntendedUse (const ::xml_schema::String& v);

    IntendedUse (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    IntendedUse (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    IntendedUse (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    IntendedUse (const IntendedUse& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual IntendedUse*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    IntendedUse&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_IntendedUse_convert ();
    }

    protected:
    Value
    _xsd_IntendedUse_convert () const;

    public:
    static const char* const _xsd_IntendedUse_literals_[4];
    static const Value _xsd_IntendedUse_indexes_[4];
  };

  class AbstractDescriptor: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Type
    //
    typedef ::CDM::CodedValue TypeType;
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeOptional&
    Type () const;

    TypeOptional&
    Type ();

    void
    Type (const TypeType& x);

    void
    Type (const TypeOptional& x);

    void
    Type (::std::unique_ptr< TypeType > p);

    // Handle
    //
    typedef ::CDM::Handle HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    Handle () const;

    HandleType&
    Handle ();

    void
    Handle (const HandleType& x);

    void
    Handle (::std::unique_ptr< HandleType > p);

    // DescriptorVersion
    //
    typedef ::CDM::VersionCounter DescriptorVersionType;
    typedef ::xsd::cxx::tree::optional< DescriptorVersionType > DescriptorVersionOptional;
    typedef ::xsd::cxx::tree::traits< DescriptorVersionType, char > DescriptorVersionTraits;

    const DescriptorVersionOptional&
    DescriptorVersion () const;

    DescriptorVersionOptional&
    DescriptorVersion ();

    void
    DescriptorVersion (const DescriptorVersionType& x);

    void
    DescriptorVersion (const DescriptorVersionOptional& x);

    void
    DescriptorVersion (::std::unique_ptr< DescriptorVersionType > p);

    // IntendedUse
    //
    typedef ::CDM::IntendedUse IntendedUseType;
    typedef ::xsd::cxx::tree::optional< IntendedUseType > IntendedUseOptional;
    typedef ::xsd::cxx::tree::traits< IntendedUseType, char > IntendedUseTraits;

    const IntendedUseOptional&
    IntendedUse () const;

    IntendedUseOptional&
    IntendedUse ();

    void
    IntendedUse (const IntendedUseType& x);

    void
    IntendedUse (const IntendedUseOptional& x);

    void
    IntendedUse (::std::unique_ptr< IntendedUseType > p);

    // Constructors.
    //
    AbstractDescriptor (const HandleType&);

    AbstractDescriptor (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    AbstractDescriptor (const AbstractDescriptor& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual AbstractDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractDescriptor&
    operator= (const AbstractDescriptor& x);

    virtual 
    ~AbstractDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    TypeOptional Type_;
    ::xsd::cxx::tree::one< HandleType > Handle_;
    DescriptorVersionOptional DescriptorVersion_;
    IntendedUseOptional IntendedUse_;
  };

  class AbstractState: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Handle
    //
    typedef ::CDM::Handle HandleType;
    typedef ::xsd::cxx::tree::optional< HandleType > HandleOptional;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleOptional&
    Handle () const;

    HandleOptional&
    Handle ();

    void
    Handle (const HandleType& x);

    void
    Handle (const HandleOptional& x);

    void
    Handle (::std::unique_ptr< HandleType > p);

    // StateVersion
    //
    typedef ::CDM::VersionCounter StateVersionType;
    typedef ::xsd::cxx::tree::optional< StateVersionType > StateVersionOptional;
    typedef ::xsd::cxx::tree::traits< StateVersionType, char > StateVersionTraits;

    const StateVersionOptional&
    StateVersion () const;

    StateVersionOptional&
    StateVersion ();

    void
    StateVersion (const StateVersionType& x);

    void
    StateVersion (const StateVersionOptional& x);

    void
    StateVersion (::std::unique_ptr< StateVersionType > p);

    // DescriptorHandle
    //
    typedef ::CDM::HandleRef DescriptorHandleType;
    typedef ::xsd::cxx::tree::traits< DescriptorHandleType, char > DescriptorHandleTraits;

    const DescriptorHandleType&
    DescriptorHandle () const;

    DescriptorHandleType&
    DescriptorHandle ();

    void
    DescriptorHandle (const DescriptorHandleType& x);

    void
    DescriptorHandle (::std::unique_ptr< DescriptorHandleType > p);

    // DescriptorVersion
    //
    typedef ::CDM::ReferencedVersion DescriptorVersionType;
    typedef ::xsd::cxx::tree::optional< DescriptorVersionType > DescriptorVersionOptional;
    typedef ::xsd::cxx::tree::traits< DescriptorVersionType, char > DescriptorVersionTraits;

    const DescriptorVersionOptional&
    DescriptorVersion () const;

    DescriptorVersionOptional&
    DescriptorVersion ();

    void
    DescriptorVersion (const DescriptorVersionType& x);

    void
    DescriptorVersion (const DescriptorVersionOptional& x);

    void
    DescriptorVersion (::std::unique_ptr< DescriptorVersionType > p);

    // Constructors.
    //
    AbstractState (const DescriptorHandleType&);

    AbstractState (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    AbstractState (const AbstractState& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual AbstractState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractState&
    operator= (const AbstractState& x);

    virtual 
    ~AbstractState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    HandleOptional Handle_;
    StateVersionOptional StateVersion_;
    ::xsd::cxx::tree::one< DescriptorHandleType > DescriptorHandle_;
    DescriptorVersionOptional DescriptorVersion_;
  };

  class MDDescription: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // MDS
    //
    typedef ::CDM::AbstractMDSDescriptor MDSType;
    typedef ::xsd::cxx::tree::sequence< MDSType > MDSSequence;
    typedef MDSSequence::iterator MDSIterator;
    typedef MDSSequence::const_iterator MDSConstIterator;
    typedef ::xsd::cxx::tree::traits< MDSType, char > MDSTraits;

    const MDSSequence&
    MDS () const;

    MDSSequence&
    MDS ();

    void
    MDS (const MDSSequence& s);

    // DescriptionVersion
    //
    typedef ::CDM::VersionCounter DescriptionVersionType;
    typedef ::xsd::cxx::tree::optional< DescriptionVersionType > DescriptionVersionOptional;
    typedef ::xsd::cxx::tree::traits< DescriptionVersionType, char > DescriptionVersionTraits;

    const DescriptionVersionOptional&
    DescriptionVersion () const;

    DescriptionVersionOptional&
    DescriptionVersion ();

    void
    DescriptionVersion (const DescriptionVersionType& x);

    void
    DescriptionVersion (const DescriptionVersionOptional& x);

    void
    DescriptionVersion (::std::unique_ptr< DescriptionVersionType > p);

    // Constructors.
    //
    MDDescription ();

    MDDescription (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    MDDescription (const MDDescription& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual MDDescription*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MDDescription&
    operator= (const MDDescription& x);

    virtual 
    ~MDDescription ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    MDSSequence MDS_;
    DescriptionVersionOptional DescriptionVersion_;
  };

  class MDState: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // State
    //
    typedef ::CDM::AbstractState StateType;
    typedef ::xsd::cxx::tree::sequence< StateType > StateSequence;
    typedef StateSequence::iterator StateIterator;
    typedef StateSequence::const_iterator StateConstIterator;
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    const StateSequence&
    State () const;

    StateSequence&
    State ();

    void
    State (const StateSequence& s);

    // StateVersion
    //
    typedef ::CDM::VersionCounter StateVersionType;
    typedef ::xsd::cxx::tree::optional< StateVersionType > StateVersionOptional;
    typedef ::xsd::cxx::tree::traits< StateVersionType, char > StateVersionTraits;

    const StateVersionOptional&
    StateVersion () const;

    StateVersionOptional&
    StateVersion ();

    void
    StateVersion (const StateVersionType& x);

    void
    StateVersion (const StateVersionOptional& x);

    void
    StateVersion (::std::unique_ptr< StateVersionType > p);

    // Constructors.
    //
    MDState ();

    MDState (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    MDState (const MDState& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    virtual MDState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MDState&
    operator= (const MDState& x);

    virtual 
    ~MDState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    StateSequence State_;
    StateVersionOptional StateVersion_;
  };

  class MDIB: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // MDDescription
    //
    typedef ::CDM::MDDescription MDDescriptionType;
    typedef ::xsd::cxx::tree::traits< MDDescriptionType, char > MDDescriptionTraits;

    const MDDescriptionType&
    MDDescription () const;

    MDDescriptionType&
    MDDescription ();

    void
    MDDescription (const MDDescriptionType& x);

    void
    MDDescription (::std::unique_ptr< MDDescriptionType > p);

    // MDState
    //
    typedef ::CDM::MDState MDStateType;
    typedef ::xsd::cxx::tree::traits< MDStateType, char > MDStateTraits;

    const MDStateType&
    MDState () const;

    MDStateType&
    MDState ();

    void
    MDState (const MDStateType& x);

    void
    MDState (::std::unique_ptr< MDStateType > p);

    // MDIBVersion
    //
    typedef ::CDM::VersionCounter MDIBVersionType;
    typedef ::xsd::cxx::tree::traits< MDIBVersionType, char > MDIBVersionTraits;

    const MDIBVersionType&
    MDIBVersion () const;

    MDIBVersionType&
    MDIBVersion ();

    void
    MDIBVersion (const MDIBVersionType& x);

    void
    MDIBVersion (::std::unique_ptr< MDIBVersionType > p);

    // Constructors.
    //
    MDIB (const MDDescriptionType&,
          const MDStateType&,
          const MDIBVersionType&);

    MDIB (::std::unique_ptr< MDDescriptionType >,
          ::std::unique_ptr< MDStateType >,
          const MDIBVersionType&);

    MDIB (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    MDIB (const MDIB& x,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    virtual MDIB*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MDIB&
    operator= (const MDIB& x);

    virtual 
    ~MDIB ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< MDDescriptionType > MDDescription_;
    ::xsd::cxx::tree::one< MDStateType > MDState_;
    ::xsd::cxx::tree::one< MDIBVersionType > MDIBVersion_;
  };

  class ProductionSpecification: public ::xml_schema::Type
  {
    public:
    // specType
    //
    typedef ::CDM::CodedValue SpecTypeType;
    typedef ::xsd::cxx::tree::traits< SpecTypeType, char > SpecTypeTraits;

    const SpecTypeType&
    specType () const;

    SpecTypeType&
    specType ();

    void
    specType (const SpecTypeType& x);

    void
    specType (::std::unique_ptr< SpecTypeType > p);

    // productionSpec
    //
    typedef ::xml_schema::String ProductionSpecType;
    typedef ::xsd::cxx::tree::traits< ProductionSpecType, char > ProductionSpecTraits;

    const ProductionSpecType&
    productionSpec () const;

    ProductionSpecType&
    productionSpec ();

    void
    productionSpec (const ProductionSpecType& x);

    void
    productionSpec (::std::unique_ptr< ProductionSpecType > p);

    // componentId
    //
    typedef ::CDM::InstanceIdentifier ComponentIdType;
    typedef ::xsd::cxx::tree::optional< ComponentIdType > ComponentIdOptional;
    typedef ::xsd::cxx::tree::traits< ComponentIdType, char > ComponentIdTraits;

    const ComponentIdOptional&
    componentId () const;

    ComponentIdOptional&
    componentId ();

    void
    componentId (const ComponentIdType& x);

    void
    componentId (const ComponentIdOptional& x);

    void
    componentId (::std::unique_ptr< ComponentIdType > p);

    // Constructors.
    //
    ProductionSpecification (const SpecTypeType&,
                             const ProductionSpecType&);

    ProductionSpecification (::std::unique_ptr< SpecTypeType >,
                             const ProductionSpecType&);

    ProductionSpecification (::std::unique_ptr< SpecTypeType >,
                             ::std::unique_ptr< ProductionSpecType >);

    ProductionSpecification (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    ProductionSpecification (const ProductionSpecification& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual ProductionSpecification*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ProductionSpecification&
    operator= (const ProductionSpecification& x);

    virtual 
    ~ProductionSpecification ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< SpecTypeType > specType_;
    ::xsd::cxx::tree::one< ProductionSpecType > productionSpec_;
    ComponentIdOptional componentId_;
  };

  class SystemMetaData: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // UDI
    //
    typedef ::xml_schema::String UDIType;
    typedef ::xsd::cxx::tree::optional< UDIType > UDIOptional;
    typedef ::xsd::cxx::tree::traits< UDIType, char > UDITraits;

    const UDIOptional&
    UDI () const;

    UDIOptional&
    UDI ();

    void
    UDI (const UDIType& x);

    void
    UDI (const UDIOptional& x);

    void
    UDI (::std::unique_ptr< UDIType > p);

    // Manufacturer
    //
    typedef ::CDM::LocalizedText ManufacturerType;
    typedef ::xsd::cxx::tree::sequence< ManufacturerType > ManufacturerSequence;
    typedef ManufacturerSequence::iterator ManufacturerIterator;
    typedef ManufacturerSequence::const_iterator ManufacturerConstIterator;
    typedef ::xsd::cxx::tree::traits< ManufacturerType, char > ManufacturerTraits;

    const ManufacturerSequence&
    Manufacturer () const;

    ManufacturerSequence&
    Manufacturer ();

    void
    Manufacturer (const ManufacturerSequence& s);

    // ModelName
    //
    typedef ::CDM::LocalizedText ModelNameType;
    typedef ::xsd::cxx::tree::sequence< ModelNameType > ModelNameSequence;
    typedef ModelNameSequence::iterator ModelNameIterator;
    typedef ModelNameSequence::const_iterator ModelNameConstIterator;
    typedef ::xsd::cxx::tree::traits< ModelNameType, char > ModelNameTraits;

    const ModelNameSequence&
    ModelName () const;

    ModelNameSequence&
    ModelName ();

    void
    ModelName (const ModelNameSequence& s);

    // ModelNumber
    //
    typedef ::xml_schema::String ModelNumberType;
    typedef ::xsd::cxx::tree::sequence< ModelNumberType > ModelNumberSequence;
    typedef ModelNumberSequence::iterator ModelNumberIterator;
    typedef ModelNumberSequence::const_iterator ModelNumberConstIterator;
    typedef ::xsd::cxx::tree::traits< ModelNumberType, char > ModelNumberTraits;

    const ModelNumberSequence&
    ModelNumber () const;

    ModelNumberSequence&
    ModelNumber ();

    void
    ModelNumber (const ModelNumberSequence& s);

    // SerialNumber
    //
    typedef ::xml_schema::String SerialNumberType;
    typedef ::xsd::cxx::tree::sequence< SerialNumberType > SerialNumberSequence;
    typedef SerialNumberSequence::iterator SerialNumberIterator;
    typedef SerialNumberSequence::const_iterator SerialNumberConstIterator;
    typedef ::xsd::cxx::tree::traits< SerialNumberType, char > SerialNumberTraits;

    const SerialNumberSequence&
    SerialNumber () const;

    SerialNumberSequence&
    SerialNumber ();

    void
    SerialNumber (const SerialNumberSequence& s);

    // Constructors.
    //
    SystemMetaData ();

    SystemMetaData (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    SystemMetaData (const SystemMetaData& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual SystemMetaData*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SystemMetaData&
    operator= (const SystemMetaData& x);

    virtual 
    ~SystemMetaData ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    UDIOptional UDI_;
    ManufacturerSequence Manufacturer_;
    ModelNameSequence ModelName_;
    ModelNumberSequence ModelNumber_;
    SerialNumberSequence SerialNumber_;
  };

  class SystemContext: public ::CDM::AbstractDescriptor
  {
    public:
    // PatientContext
    //
    typedef ::CDM::PatientContextDescriptor PatientContextType;
    typedef ::xsd::cxx::tree::optional< PatientContextType > PatientContextOptional;
    typedef ::xsd::cxx::tree::traits< PatientContextType, char > PatientContextTraits;

    const PatientContextOptional&
    PatientContext () const;

    PatientContextOptional&
    PatientContext ();

    void
    PatientContext (const PatientContextType& x);

    void
    PatientContext (const PatientContextOptional& x);

    void
    PatientContext (::std::unique_ptr< PatientContextType > p);

    // LocationContext
    //
    typedef ::CDM::LocationContextDescriptor LocationContextType;
    typedef ::xsd::cxx::tree::optional< LocationContextType > LocationContextOptional;
    typedef ::xsd::cxx::tree::traits< LocationContextType, char > LocationContextTraits;

    const LocationContextOptional&
    LocationContext () const;

    LocationContextOptional&
    LocationContext ();

    void
    LocationContext (const LocationContextType& x);

    void
    LocationContext (const LocationContextOptional& x);

    void
    LocationContext (::std::unique_ptr< LocationContextType > p);

    // EnsembleContext
    //
    typedef ::CDM::EnsembleContextDescriptor EnsembleContextType;
    typedef ::xsd::cxx::tree::optional< EnsembleContextType > EnsembleContextOptional;
    typedef ::xsd::cxx::tree::traits< EnsembleContextType, char > EnsembleContextTraits;

    const EnsembleContextOptional&
    EnsembleContext () const;

    EnsembleContextOptional&
    EnsembleContext ();

    void
    EnsembleContext (const EnsembleContextType& x);

    void
    EnsembleContext (const EnsembleContextOptional& x);

    void
    EnsembleContext (::std::unique_ptr< EnsembleContextType > p);

    // OperatorContext
    //
    typedef ::CDM::OperatorContextDescriptor OperatorContextType;
    typedef ::xsd::cxx::tree::optional< OperatorContextType > OperatorContextOptional;
    typedef ::xsd::cxx::tree::traits< OperatorContextType, char > OperatorContextTraits;

    const OperatorContextOptional&
    OperatorContext () const;

    OperatorContextOptional&
    OperatorContext ();

    void
    OperatorContext (const OperatorContextType& x);

    void
    OperatorContext (const OperatorContextOptional& x);

    void
    OperatorContext (::std::unique_ptr< OperatorContextType > p);

    // WorkflowContext
    //
    typedef ::CDM::WorkflowContextDescriptor WorkflowContextType;
    typedef ::xsd::cxx::tree::optional< WorkflowContextType > WorkflowContextOptional;
    typedef ::xsd::cxx::tree::traits< WorkflowContextType, char > WorkflowContextTraits;

    const WorkflowContextOptional&
    WorkflowContext () const;

    WorkflowContextOptional&
    WorkflowContext ();

    void
    WorkflowContext (const WorkflowContextType& x);

    void
    WorkflowContext (const WorkflowContextOptional& x);

    void
    WorkflowContext (::std::unique_ptr< WorkflowContextType > p);

    // Constructors.
    //
    SystemContext (const HandleType&);

    SystemContext (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    SystemContext (const SystemContext& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual SystemContext*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SystemContext&
    operator= (const SystemContext& x);

    virtual 
    ~SystemContext ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    PatientContextOptional PatientContext_;
    LocationContextOptional LocationContext_;
    EnsembleContextOptional EnsembleContext_;
    OperatorContextOptional OperatorContext_;
    WorkflowContextOptional WorkflowContext_;
  };

  class AbstractDeviceComponent: public ::CDM::AbstractDescriptor
  {
    public:
    // ProductionSpecification
    //
    typedef ::CDM::ProductionSpecification ProductionSpecificationType;
    typedef ::xsd::cxx::tree::sequence< ProductionSpecificationType > ProductionSpecificationSequence;
    typedef ProductionSpecificationSequence::iterator ProductionSpecificationIterator;
    typedef ProductionSpecificationSequence::const_iterator ProductionSpecificationConstIterator;
    typedef ::xsd::cxx::tree::traits< ProductionSpecificationType, char > ProductionSpecificationTraits;

    const ProductionSpecificationSequence&
    ProductionSpecification () const;

    ProductionSpecificationSequence&
    ProductionSpecification ();

    void
    ProductionSpecification (const ProductionSpecificationSequence& s);

    // Constructors.
    //
    AbstractDeviceComponent (const HandleType&);

    AbstractDeviceComponent (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    AbstractDeviceComponent (const AbstractDeviceComponent& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual AbstractDeviceComponent*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractDeviceComponent&
    operator= (const AbstractDeviceComponent& x);

    virtual 
    ~AbstractDeviceComponent ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ProductionSpecificationSequence ProductionSpecification_;
  };

  class AbstractMDSDescriptor: public ::CDM::AbstractDeviceComponent
  {
    public:
    // MetaData
    //
    typedef ::CDM::SystemMetaData MetaDataType;
    typedef ::xsd::cxx::tree::optional< MetaDataType > MetaDataOptional;
    typedef ::xsd::cxx::tree::traits< MetaDataType, char > MetaDataTraits;

    const MetaDataOptional&
    MetaData () const;

    MetaDataOptional&
    MetaData ();

    void
    MetaData (const MetaDataType& x);

    void
    MetaData (const MetaDataOptional& x);

    void
    MetaData (::std::unique_ptr< MetaDataType > p);

    // Context
    //
    typedef ::CDM::SystemContext ContextType;
    typedef ::xsd::cxx::tree::traits< ContextType, char > ContextTraits;

    const ContextType&
    Context () const;

    ContextType&
    Context ();

    void
    Context (const ContextType& x);

    void
    Context (::std::unique_ptr< ContextType > p);

    // Clock
    //
    typedef ::CDM::ClockDescriptor ClockType;
    typedef ::xsd::cxx::tree::optional< ClockType > ClockOptional;
    typedef ::xsd::cxx::tree::traits< ClockType, char > ClockTraits;

    const ClockOptional&
    Clock () const;

    ClockOptional&
    Clock ();

    void
    Clock (const ClockType& x);

    void
    Clock (const ClockOptional& x);

    void
    Clock (::std::unique_ptr< ClockType > p);

    // Constructors.
    //
    AbstractMDSDescriptor (const HandleType&,
                           const ContextType&);

    AbstractMDSDescriptor (const HandleType&,
                           ::std::unique_ptr< ContextType >);

    AbstractMDSDescriptor (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    AbstractMDSDescriptor (const AbstractMDSDescriptor& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual AbstractMDSDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractMDSDescriptor&
    operator= (const AbstractMDSDescriptor& x);

    virtual 
    ~AbstractMDSDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MetaDataOptional MetaData_;
    ::xsd::cxx::tree::one< ContextType > Context_;
    ClockOptional Clock_;
  };

  class HydraMDSDescriptor: public ::CDM::AbstractMDSDescriptor
  {
    public:
    // SCO
    //
    typedef ::CDM::SCODescriptor SCOType;
    typedef ::xsd::cxx::tree::optional< SCOType > SCOOptional;
    typedef ::xsd::cxx::tree::traits< SCOType, char > SCOTraits;

    const SCOOptional&
    SCO () const;

    SCOOptional&
    SCO ();

    void
    SCO (const SCOType& x);

    void
    SCO (const SCOOptional& x);

    void
    SCO (::std::unique_ptr< SCOType > p);

    // AlertSystem
    //
    typedef ::CDM::AlertSystemDescriptor AlertSystemType;
    typedef ::xsd::cxx::tree::optional< AlertSystemType > AlertSystemOptional;
    typedef ::xsd::cxx::tree::traits< AlertSystemType, char > AlertSystemTraits;

    const AlertSystemOptional&
    AlertSystem () const;

    AlertSystemOptional&
    AlertSystem ();

    void
    AlertSystem (const AlertSystemType& x);

    void
    AlertSystem (const AlertSystemOptional& x);

    void
    AlertSystem (::std::unique_ptr< AlertSystemType > p);

    // VMD
    //
    typedef ::CDM::VMDDescriptor VMDType;
    typedef ::xsd::cxx::tree::sequence< VMDType > VMDSequence;
    typedef VMDSequence::iterator VMDIterator;
    typedef VMDSequence::const_iterator VMDConstIterator;
    typedef ::xsd::cxx::tree::traits< VMDType, char > VMDTraits;

    const VMDSequence&
    VMD () const;

    VMDSequence&
    VMD ();

    void
    VMD (const VMDSequence& s);

    // Constructors.
    //
    HydraMDSDescriptor (const HandleType&,
                        const ContextType&);

    HydraMDSDescriptor (const HandleType&,
                        ::std::unique_ptr< ContextType >);

    HydraMDSDescriptor (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    HydraMDSDescriptor (const HydraMDSDescriptor& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual HydraMDSDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    HydraMDSDescriptor&
    operator= (const HydraMDSDescriptor& x);

    virtual 
    ~HydraMDSDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SCOOptional SCO_;
    AlertSystemOptional AlertSystem_;
    VMDSequence VMD_;
  };

  class ComponentState: public ::CDM::AbstractState
  {
    public:
    // CalibrationInfo
    //
    typedef ::CDM::CalibrationInfo CalibrationInfoType;
    typedef ::xsd::cxx::tree::optional< CalibrationInfoType > CalibrationInfoOptional;
    typedef ::xsd::cxx::tree::traits< CalibrationInfoType, char > CalibrationInfoTraits;

    const CalibrationInfoOptional&
    CalibrationInfo () const;

    CalibrationInfoOptional&
    CalibrationInfo ();

    void
    CalibrationInfo (const CalibrationInfoType& x);

    void
    CalibrationInfo (const CalibrationInfoOptional& x);

    void
    CalibrationInfo (::std::unique_ptr< CalibrationInfoType > p);

    // ComponentActivationState
    //
    typedef ::CDM::ComponentActivation ComponentActivationStateType;
    typedef ::xsd::cxx::tree::optional< ComponentActivationStateType > ComponentActivationStateOptional;
    typedef ::xsd::cxx::tree::traits< ComponentActivationStateType, char > ComponentActivationStateTraits;

    const ComponentActivationStateOptional&
    ComponentActivationState () const;

    ComponentActivationStateOptional&
    ComponentActivationState ();

    void
    ComponentActivationState (const ComponentActivationStateType& x);

    void
    ComponentActivationState (const ComponentActivationStateOptional& x);

    void
    ComponentActivationState (::std::unique_ptr< ComponentActivationStateType > p);

    // OperatingHours
    //
    typedef ::xml_schema::Int OperatingHoursType;
    typedef ::xsd::cxx::tree::optional< OperatingHoursType > OperatingHoursOptional;
    typedef ::xsd::cxx::tree::traits< OperatingHoursType, char > OperatingHoursTraits;

    const OperatingHoursOptional&
    OperatingHours () const;

    OperatingHoursOptional&
    OperatingHours ();

    void
    OperatingHours (const OperatingHoursType& x);

    void
    OperatingHours (const OperatingHoursOptional& x);

    // OperatingCycles
    //
    typedef ::xml_schema::Int OperatingCyclesType;
    typedef ::xsd::cxx::tree::optional< OperatingCyclesType > OperatingCyclesOptional;
    typedef ::xsd::cxx::tree::traits< OperatingCyclesType, char > OperatingCyclesTraits;

    const OperatingCyclesOptional&
    OperatingCycles () const;

    OperatingCyclesOptional&
    OperatingCycles ();

    void
    OperatingCycles (const OperatingCyclesType& x);

    void
    OperatingCycles (const OperatingCyclesOptional& x);

    // Constructors.
    //
    ComponentState (const DescriptorHandleType&);

    ComponentState (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    ComponentState (const ComponentState& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual ComponentState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ComponentState&
    operator= (const ComponentState& x);

    virtual 
    ~ComponentState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CalibrationInfoOptional CalibrationInfo_;
    ComponentActivationStateOptional ComponentActivationState_;
    OperatingHoursOptional OperatingHours_;
    OperatingCyclesOptional OperatingCycles_;
  };

  class AbstractMDSState: public ::CDM::ComponentState
  {
    public:
    // Lang
    //
    typedef ::xml_schema::Language LangType;
    typedef ::xsd::cxx::tree::optional< LangType > LangOptional;
    typedef ::xsd::cxx::tree::traits< LangType, char > LangTraits;

    const LangOptional&
    Lang () const;

    LangOptional&
    Lang ();

    void
    Lang (const LangType& x);

    void
    Lang (const LangOptional& x);

    void
    Lang (::std::unique_ptr< LangType > p);

    // Constructors.
    //
    AbstractMDSState (const DescriptorHandleType&);

    AbstractMDSState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    AbstractMDSState (const AbstractMDSState& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual AbstractMDSState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractMDSState&
    operator= (const AbstractMDSState& x);

    virtual 
    ~AbstractMDSState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    LangOptional Lang_;
  };

  class HydraMDSState: public ::CDM::AbstractMDSState
  {
    public:
    // Constructors.
    //
    HydraMDSState (const DescriptorHandleType&);

    HydraMDSState (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    HydraMDSState (const HydraMDSState& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual HydraMDSState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~HydraMDSState ();
  };

  class AlertConditionKind: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Phy,
      Tec,
      Oth
    };

    AlertConditionKind (Value v);

    AlertConditionKind (const char* v);

    AlertConditionKind (const ::std::string& v);

    AlertConditionKind (const ::xml_schema::String& v);

    AlertConditionKind (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    AlertConditionKind (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    AlertConditionKind (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    AlertConditionKind (const AlertConditionKind& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual AlertConditionKind*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertConditionKind&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_AlertConditionKind_convert ();
    }

    protected:
    Value
    _xsd_AlertConditionKind_convert () const;

    public:
    static const char* const _xsd_AlertConditionKind_literals_[3];
    static const Value _xsd_AlertConditionKind_indexes_[3];
  };

  class AlertConditionPriority: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Lo,
      Me,
      Hi,
      None
    };

    AlertConditionPriority (Value v);

    AlertConditionPriority (const char* v);

    AlertConditionPriority (const ::std::string& v);

    AlertConditionPriority (const ::xml_schema::String& v);

    AlertConditionPriority (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    AlertConditionPriority (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    AlertConditionPriority (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    AlertConditionPriority (const AlertConditionPriority& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    virtual AlertConditionPriority*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertConditionPriority&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_AlertConditionPriority_convert ();
    }

    protected:
    Value
    _xsd_AlertConditionPriority_convert () const;

    public:
    static const char* const _xsd_AlertConditionPriority_literals_[4];
    static const Value _xsd_AlertConditionPriority_indexes_[4];
  };

  class AlertSignalManifestation: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Aud,
      Vis,
      Tan
    };

    AlertSignalManifestation (Value v);

    AlertSignalManifestation (const char* v);

    AlertSignalManifestation (const ::std::string& v);

    AlertSignalManifestation (const ::xml_schema::String& v);

    AlertSignalManifestation (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    AlertSignalManifestation (const ::xercesc::DOMAttr& a,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    AlertSignalManifestation (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    AlertSignalManifestation (const AlertSignalManifestation& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    virtual AlertSignalManifestation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertSignalManifestation&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_AlertSignalManifestation_convert ();
    }

    protected:
    Value
    _xsd_AlertSignalManifestation_convert () const;

    public:
    static const char* const _xsd_AlertSignalManifestation_literals_[3];
    static const Value _xsd_AlertSignalManifestation_indexes_[3];
  };

  class AbstractAlertDescriptor: public ::CDM::AbstractDescriptor
  {
    public:
    // Constructors.
    //
    AbstractAlertDescriptor (const HandleType&);

    AbstractAlertDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    AbstractAlertDescriptor (const AbstractAlertDescriptor& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual AbstractAlertDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~AbstractAlertDescriptor ();
  };

  class AlertSystemDescriptor: public ::CDM::AbstractAlertDescriptor
  {
    public:
    // AlertCondition
    //
    typedef ::CDM::AlertConditionDescriptor AlertConditionType;
    typedef ::xsd::cxx::tree::sequence< AlertConditionType > AlertConditionSequence;
    typedef AlertConditionSequence::iterator AlertConditionIterator;
    typedef AlertConditionSequence::const_iterator AlertConditionConstIterator;
    typedef ::xsd::cxx::tree::traits< AlertConditionType, char > AlertConditionTraits;

    const AlertConditionSequence&
    AlertCondition () const;

    AlertConditionSequence&
    AlertCondition ();

    void
    AlertCondition (const AlertConditionSequence& s);

    // AlertSignal
    //
    typedef ::CDM::AlertSignalDescriptor AlertSignalType;
    typedef ::xsd::cxx::tree::sequence< AlertSignalType > AlertSignalSequence;
    typedef AlertSignalSequence::iterator AlertSignalIterator;
    typedef AlertSignalSequence::const_iterator AlertSignalConstIterator;
    typedef ::xsd::cxx::tree::traits< AlertSignalType, char > AlertSignalTraits;

    const AlertSignalSequence&
    AlertSignal () const;

    AlertSignalSequence&
    AlertSignal ();

    void
    AlertSignal (const AlertSignalSequence& s);

    // MaxPhysiologicalAlarmListEntries
    //
    typedef ::xml_schema::Int MaxPhysiologicalAlarmListEntriesType;
    typedef ::xsd::cxx::tree::optional< MaxPhysiologicalAlarmListEntriesType > MaxPhysiologicalAlarmListEntriesOptional;
    typedef ::xsd::cxx::tree::traits< MaxPhysiologicalAlarmListEntriesType, char > MaxPhysiologicalAlarmListEntriesTraits;

    const MaxPhysiologicalAlarmListEntriesOptional&
    MaxPhysiologicalAlarmListEntries () const;

    MaxPhysiologicalAlarmListEntriesOptional&
    MaxPhysiologicalAlarmListEntries ();

    void
    MaxPhysiologicalAlarmListEntries (const MaxPhysiologicalAlarmListEntriesType& x);

    void
    MaxPhysiologicalAlarmListEntries (const MaxPhysiologicalAlarmListEntriesOptional& x);

    // MaxTechnicalAlarmListEntries
    //
    typedef ::xml_schema::Int MaxTechnicalAlarmListEntriesType;
    typedef ::xsd::cxx::tree::optional< MaxTechnicalAlarmListEntriesType > MaxTechnicalAlarmListEntriesOptional;
    typedef ::xsd::cxx::tree::traits< MaxTechnicalAlarmListEntriesType, char > MaxTechnicalAlarmListEntriesTraits;

    const MaxTechnicalAlarmListEntriesOptional&
    MaxTechnicalAlarmListEntries () const;

    MaxTechnicalAlarmListEntriesOptional&
    MaxTechnicalAlarmListEntries ();

    void
    MaxTechnicalAlarmListEntries (const MaxTechnicalAlarmListEntriesType& x);

    void
    MaxTechnicalAlarmListEntries (const MaxTechnicalAlarmListEntriesOptional& x);

    // SelfCheckPeriod
    //
    typedef ::xml_schema::Duration SelfCheckPeriodType;
    typedef ::xsd::cxx::tree::optional< SelfCheckPeriodType > SelfCheckPeriodOptional;
    typedef ::xsd::cxx::tree::traits< SelfCheckPeriodType, char > SelfCheckPeriodTraits;

    const SelfCheckPeriodOptional&
    SelfCheckPeriod () const;

    SelfCheckPeriodOptional&
    SelfCheckPeriod ();

    void
    SelfCheckPeriod (const SelfCheckPeriodType& x);

    void
    SelfCheckPeriod (const SelfCheckPeriodOptional& x);

    void
    SelfCheckPeriod (::std::unique_ptr< SelfCheckPeriodType > p);

    // Constructors.
    //
    AlertSystemDescriptor (const HandleType&);

    AlertSystemDescriptor (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    AlertSystemDescriptor (const AlertSystemDescriptor& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual AlertSystemDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertSystemDescriptor&
    operator= (const AlertSystemDescriptor& x);

    virtual 
    ~AlertSystemDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AlertConditionSequence AlertCondition_;
    AlertSignalSequence AlertSignal_;
    MaxPhysiologicalAlarmListEntriesOptional MaxPhysiologicalAlarmListEntries_;
    MaxTechnicalAlarmListEntriesOptional MaxTechnicalAlarmListEntries_;
    SelfCheckPeriodOptional SelfCheckPeriod_;
  };

  class AlertConditionDescriptor: public ::CDM::AbstractAlertDescriptor
  {
    public:
    // Kind
    //
    typedef ::CDM::AlertConditionKind KindType;
    typedef ::xsd::cxx::tree::traits< KindType, char > KindTraits;

    const KindType&
    Kind () const;

    KindType&
    Kind ();

    void
    Kind (const KindType& x);

    void
    Kind (::std::unique_ptr< KindType > p);

    // Source
    //
    typedef ::CDM::HandleRef SourceType;
    typedef ::xsd::cxx::tree::sequence< SourceType > SourceSequence;
    typedef SourceSequence::iterator SourceIterator;
    typedef SourceSequence::const_iterator SourceConstIterator;
    typedef ::xsd::cxx::tree::traits< SourceType, char > SourceTraits;

    const SourceSequence&
    Source () const;

    SourceSequence&
    Source ();

    void
    Source (const SourceSequence& s);

    // Priority
    //
    typedef ::CDM::AlertConditionPriority PriorityType;
    typedef ::xsd::cxx::tree::traits< PriorityType, char > PriorityTraits;

    const PriorityType&
    Priority () const;

    PriorityType&
    Priority ();

    void
    Priority (const PriorityType& x);

    void
    Priority (::std::unique_ptr< PriorityType > p);

    // CauseInfo
    //
    typedef ::CDM::CauseInfo CauseInfoType;
    typedef ::xsd::cxx::tree::sequence< CauseInfoType > CauseInfoSequence;
    typedef CauseInfoSequence::iterator CauseInfoIterator;
    typedef CauseInfoSequence::const_iterator CauseInfoConstIterator;
    typedef ::xsd::cxx::tree::traits< CauseInfoType, char > CauseInfoTraits;

    const CauseInfoSequence&
    CauseInfo () const;

    CauseInfoSequence&
    CauseInfo ();

    void
    CauseInfo (const CauseInfoSequence& s);

    // Constructors.
    //
    AlertConditionDescriptor (const HandleType&,
                              const KindType&,
                              const PriorityType&);

    AlertConditionDescriptor (const HandleType&,
                              ::std::unique_ptr< KindType >,
                              ::std::unique_ptr< PriorityType >);

    AlertConditionDescriptor (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    AlertConditionDescriptor (const AlertConditionDescriptor& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    virtual AlertConditionDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertConditionDescriptor&
    operator= (const AlertConditionDescriptor& x);

    virtual 
    ~AlertConditionDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< KindType > Kind_;
    SourceSequence Source_;
    ::xsd::cxx::tree::one< PriorityType > Priority_;
    CauseInfoSequence CauseInfo_;
  };

  class AlertSignalDescriptor: public ::CDM::AbstractAlertDescriptor
  {
    public:
    // ConditionSignaled
    //
    typedef ::CDM::HandleRef ConditionSignaledType;
    typedef ::xsd::cxx::tree::traits< ConditionSignaledType, char > ConditionSignaledTraits;

    const ConditionSignaledType&
    ConditionSignaled () const;

    ConditionSignaledType&
    ConditionSignaled ();

    void
    ConditionSignaled (const ConditionSignaledType& x);

    void
    ConditionSignaled (::std::unique_ptr< ConditionSignaledType > p);

    // Manifestation
    //
    typedef ::CDM::AlertSignalManifestation ManifestationType;
    typedef ::xsd::cxx::tree::traits< ManifestationType, char > ManifestationTraits;

    const ManifestationType&
    Manifestation () const;

    ManifestationType&
    Manifestation ();

    void
    Manifestation (const ManifestationType& x);

    void
    Manifestation (::std::unique_ptr< ManifestationType > p);

    // Latching
    //
    typedef ::xml_schema::Boolean LatchingType;
    typedef ::xsd::cxx::tree::traits< LatchingType, char > LatchingTraits;

    const LatchingType&
    Latching () const;

    LatchingType&
    Latching ();

    void
    Latching (const LatchingType& x);

    // DefaultSignalGenerationDelay
    //
    typedef ::xml_schema::Duration DefaultSignalGenerationDelayType;
    typedef ::xsd::cxx::tree::optional< DefaultSignalGenerationDelayType > DefaultSignalGenerationDelayOptional;
    typedef ::xsd::cxx::tree::traits< DefaultSignalGenerationDelayType, char > DefaultSignalGenerationDelayTraits;

    const DefaultSignalGenerationDelayOptional&
    DefaultSignalGenerationDelay () const;

    DefaultSignalGenerationDelayOptional&
    DefaultSignalGenerationDelay ();

    void
    DefaultSignalGenerationDelay (const DefaultSignalGenerationDelayType& x);

    void
    DefaultSignalGenerationDelay (const DefaultSignalGenerationDelayOptional& x);

    void
    DefaultSignalGenerationDelay (::std::unique_ptr< DefaultSignalGenerationDelayType > p);

    // SignalDelegationSupported
    //
    typedef ::xml_schema::Boolean SignalDelegationSupportedType;
    typedef ::xsd::cxx::tree::optional< SignalDelegationSupportedType > SignalDelegationSupportedOptional;
    typedef ::xsd::cxx::tree::traits< SignalDelegationSupportedType, char > SignalDelegationSupportedTraits;

    const SignalDelegationSupportedOptional&
    SignalDelegationSupported () const;

    SignalDelegationSupportedOptional&
    SignalDelegationSupported ();

    void
    SignalDelegationSupported (const SignalDelegationSupportedType& x);

    void
    SignalDelegationSupported (const SignalDelegationSupportedOptional& x);

    static SignalDelegationSupportedType
    SignalDelegationSupported_default_value ();

    // AcknowledgementSupported
    //
    typedef ::xml_schema::Boolean AcknowledgementSupportedType;
    typedef ::xsd::cxx::tree::optional< AcknowledgementSupportedType > AcknowledgementSupportedOptional;
    typedef ::xsd::cxx::tree::traits< AcknowledgementSupportedType, char > AcknowledgementSupportedTraits;

    const AcknowledgementSupportedOptional&
    AcknowledgementSupported () const;

    AcknowledgementSupportedOptional&
    AcknowledgementSupported ();

    void
    AcknowledgementSupported (const AcknowledgementSupportedType& x);

    void
    AcknowledgementSupported (const AcknowledgementSupportedOptional& x);

    // AcknowledgeTimeout
    //
    typedef ::xml_schema::Duration AcknowledgeTimeoutType;
    typedef ::xsd::cxx::tree::optional< AcknowledgeTimeoutType > AcknowledgeTimeoutOptional;
    typedef ::xsd::cxx::tree::traits< AcknowledgeTimeoutType, char > AcknowledgeTimeoutTraits;

    const AcknowledgeTimeoutOptional&
    AcknowledgeTimeout () const;

    AcknowledgeTimeoutOptional&
    AcknowledgeTimeout ();

    void
    AcknowledgeTimeout (const AcknowledgeTimeoutType& x);

    void
    AcknowledgeTimeout (const AcknowledgeTimeoutOptional& x);

    void
    AcknowledgeTimeout (::std::unique_ptr< AcknowledgeTimeoutType > p);

    // Constructors.
    //
    AlertSignalDescriptor (const HandleType&,
                           const ConditionSignaledType&,
                           const ManifestationType&,
                           const LatchingType&);

    AlertSignalDescriptor (const HandleType&,
                           ::std::unique_ptr< ConditionSignaledType >,
                           ::std::unique_ptr< ManifestationType >,
                           const LatchingType&);

    AlertSignalDescriptor (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    AlertSignalDescriptor (const AlertSignalDescriptor& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual AlertSignalDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertSignalDescriptor&
    operator= (const AlertSignalDescriptor& x);

    virtual 
    ~AlertSignalDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ConditionSignaledType > ConditionSignaled_;
    ::xsd::cxx::tree::one< ManifestationType > Manifestation_;
    ::xsd::cxx::tree::one< LatchingType > Latching_;
    DefaultSignalGenerationDelayOptional DefaultSignalGenerationDelay_;
    SignalDelegationSupportedOptional SignalDelegationSupported_;
    AcknowledgementSupportedOptional AcknowledgementSupported_;
    AcknowledgeTimeoutOptional AcknowledgeTimeout_;
  };

  class LimitAlertConditionDescriptor: public ::CDM::AlertConditionDescriptor
  {
    public:
    // MaxLimits
    //
    typedef ::CDM::Range MaxLimitsType;
    typedef ::xsd::cxx::tree::traits< MaxLimitsType, char > MaxLimitsTraits;

    const MaxLimitsType&
    MaxLimits () const;

    MaxLimitsType&
    MaxLimits ();

    void
    MaxLimits (const MaxLimitsType& x);

    void
    MaxLimits (::std::unique_ptr< MaxLimitsType > p);

    // AutoLimitSupported
    //
    typedef ::xml_schema::Boolean AutoLimitSupportedType;
    typedef ::xsd::cxx::tree::optional< AutoLimitSupportedType > AutoLimitSupportedOptional;
    typedef ::xsd::cxx::tree::traits< AutoLimitSupportedType, char > AutoLimitSupportedTraits;

    const AutoLimitSupportedOptional&
    AutoLimitSupported () const;

    AutoLimitSupportedOptional&
    AutoLimitSupported ();

    void
    AutoLimitSupported (const AutoLimitSupportedType& x);

    void
    AutoLimitSupported (const AutoLimitSupportedOptional& x);

    // Constructors.
    //
    LimitAlertConditionDescriptor (const HandleType&,
                                   const KindType&,
                                   const PriorityType&,
                                   const MaxLimitsType&);

    LimitAlertConditionDescriptor (const HandleType&,
                                   const KindType&,
                                   const PriorityType&,
                                   ::std::unique_ptr< MaxLimitsType >);

    LimitAlertConditionDescriptor (const HandleType&,
                                   ::std::unique_ptr< KindType >,
                                   ::std::unique_ptr< PriorityType >,
                                   ::std::unique_ptr< MaxLimitsType >);

    LimitAlertConditionDescriptor (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    LimitAlertConditionDescriptor (const LimitAlertConditionDescriptor& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    virtual LimitAlertConditionDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    LimitAlertConditionDescriptor&
    operator= (const LimitAlertConditionDescriptor& x);

    virtual 
    ~LimitAlertConditionDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< MaxLimitsType > MaxLimits_;
    AutoLimitSupportedOptional AutoLimitSupported_;
  };

  class PausableActivation: public ::xml_schema::String
  {
    public:
    enum Value
    {
      On,
      Off,
      Psd
    };

    PausableActivation (Value v);

    PausableActivation (const char* v);

    PausableActivation (const ::std::string& v);

    PausableActivation (const ::xml_schema::String& v);

    PausableActivation (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    PausableActivation (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    PausableActivation (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    PausableActivation (const PausableActivation& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual PausableActivation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    PausableActivation&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_PausableActivation_convert ();
    }

    protected:
    Value
    _xsd_PausableActivation_convert () const;

    public:
    static const char* const _xsd_PausableActivation_literals_[3];
    static const Value _xsd_PausableActivation_indexes_[3];
  };

  class SignalPresence: public ::xml_schema::String
  {
    public:
    enum Value
    {
      On,
      Off,
      Latch,
      Ack
    };

    SignalPresence (Value v);

    SignalPresence (const char* v);

    SignalPresence (const ::std::string& v);

    SignalPresence (const ::xml_schema::String& v);

    SignalPresence (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    SignalPresence (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    SignalPresence (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    SignalPresence (const SignalPresence& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual SignalPresence*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SignalPresence&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_SignalPresence_convert ();
    }

    protected:
    Value
    _xsd_SignalPresence_convert () const;

    public:
    static const char* const _xsd_SignalPresence_literals_[4];
    static const Value _xsd_SignalPresence_indexes_[4];
  };

  class PrimaryAlertSignalLocation: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Loc,
      Rem
    };

    PrimaryAlertSignalLocation (Value v);

    PrimaryAlertSignalLocation (const char* v);

    PrimaryAlertSignalLocation (const ::std::string& v);

    PrimaryAlertSignalLocation (const ::xml_schema::String& v);

    PrimaryAlertSignalLocation (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    PrimaryAlertSignalLocation (const ::xercesc::DOMAttr& a,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    PrimaryAlertSignalLocation (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    PrimaryAlertSignalLocation (const PrimaryAlertSignalLocation& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    virtual PrimaryAlertSignalLocation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    PrimaryAlertSignalLocation&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_PrimaryAlertSignalLocation_convert ();
    }

    protected:
    Value
    _xsd_PrimaryAlertSignalLocation_convert () const;

    public:
    static const char* const _xsd_PrimaryAlertSignalLocation_literals_[2];
    static const Value _xsd_PrimaryAlertSignalLocation_indexes_[2];
  };

  class MonitoredAlertLimits: public ::xml_schema::String
  {
    public:
    enum Value
    {
      All,
      LoOff,
      HiOff,
      None
    };

    MonitoredAlertLimits (Value v);

    MonitoredAlertLimits (const char* v);

    MonitoredAlertLimits (const ::std::string& v);

    MonitoredAlertLimits (const ::xml_schema::String& v);

    MonitoredAlertLimits (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    MonitoredAlertLimits (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    MonitoredAlertLimits (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    MonitoredAlertLimits (const MonitoredAlertLimits& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual MonitoredAlertLimits*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MonitoredAlertLimits&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_MonitoredAlertLimits_convert ();
    }

    protected:
    Value
    _xsd_MonitoredAlertLimits_convert () const;

    public:
    static const char* const _xsd_MonitoredAlertLimits_literals_[4];
    static const Value _xsd_MonitoredAlertLimits_indexes_[4];
  };

  class AbstractAlertState: public ::CDM::AbstractState
  {
    public:
    // Constructors.
    //
    AbstractAlertState (const DescriptorHandleType&);

    AbstractAlertState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    AbstractAlertState (const AbstractAlertState& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual AbstractAlertState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~AbstractAlertState ();
  };

  class AlertConditionState: public ::CDM::AbstractAlertState
  {
    public:
    // ActivationState
    //
    typedef ::CDM::PausableActivation ActivationStateType;
    typedef ::xsd::cxx::tree::traits< ActivationStateType, char > ActivationStateTraits;

    const ActivationStateType&
    ActivationState () const;

    ActivationStateType&
    ActivationState ();

    void
    ActivationState (const ActivationStateType& x);

    void
    ActivationState (::std::unique_ptr< ActivationStateType > p);

    // ActualPriority
    //
    typedef ::CDM::AlertConditionPriority ActualPriorityType;
    typedef ::xsd::cxx::tree::optional< ActualPriorityType > ActualPriorityOptional;
    typedef ::xsd::cxx::tree::traits< ActualPriorityType, char > ActualPriorityTraits;

    const ActualPriorityOptional&
    ActualPriority () const;

    ActualPriorityOptional&
    ActualPriority ();

    void
    ActualPriority (const ActualPriorityType& x);

    void
    ActualPriority (const ActualPriorityOptional& x);

    void
    ActualPriority (::std::unique_ptr< ActualPriorityType > p);

    // Rank
    //
    typedef ::xml_schema::Int RankType;
    typedef ::xsd::cxx::tree::optional< RankType > RankOptional;
    typedef ::xsd::cxx::tree::traits< RankType, char > RankTraits;

    const RankOptional&
    Rank () const;

    RankOptional&
    Rank ();

    void
    Rank (const RankType& x);

    void
    Rank (const RankOptional& x);

    // Presence
    //
    typedef ::xml_schema::Boolean PresenceType;
    typedef ::xsd::cxx::tree::traits< PresenceType, char > PresenceTraits;

    const PresenceType&
    Presence () const;

    PresenceType&
    Presence ();

    void
    Presence (const PresenceType& x);

    // ObservationTime
    //
    typedef ::CDM::Timestamp ObservationTimeType;
    typedef ::xsd::cxx::tree::optional< ObservationTimeType > ObservationTimeOptional;
    typedef ::xsd::cxx::tree::traits< ObservationTimeType, char > ObservationTimeTraits;

    const ObservationTimeOptional&
    ObservationTime () const;

    ObservationTimeOptional&
    ObservationTime ();

    void
    ObservationTime (const ObservationTimeType& x);

    void
    ObservationTime (const ObservationTimeOptional& x);

    void
    ObservationTime (::std::unique_ptr< ObservationTimeType > p);

    // Constructors.
    //
    AlertConditionState (const DescriptorHandleType&,
                         const ActivationStateType&,
                         const PresenceType&);

    AlertConditionState (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    AlertConditionState (const AlertConditionState& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual AlertConditionState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertConditionState&
    operator= (const AlertConditionState& x);

    virtual 
    ~AlertConditionState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ActivationStateType > ActivationState_;
    ActualPriorityOptional ActualPriority_;
    RankOptional Rank_;
    ::xsd::cxx::tree::one< PresenceType > Presence_;
    ObservationTimeOptional ObservationTime_;
  };

  class AlertSignalState: public ::CDM::AbstractAlertState
  {
    public:
    // ActivationState
    //
    typedef ::CDM::PausableActivation ActivationStateType;
    typedef ::xsd::cxx::tree::traits< ActivationStateType, char > ActivationStateTraits;

    const ActivationStateType&
    ActivationState () const;

    ActivationStateType&
    ActivationState ();

    void
    ActivationState (const ActivationStateType& x);

    void
    ActivationState (::std::unique_ptr< ActivationStateType > p);

    // Presence
    //
    typedef ::CDM::SignalPresence PresenceType;
    typedef ::xsd::cxx::tree::optional< PresenceType > PresenceOptional;
    typedef ::xsd::cxx::tree::traits< PresenceType, char > PresenceTraits;

    const PresenceOptional&
    Presence () const;

    PresenceOptional&
    Presence ();

    void
    Presence (const PresenceType& x);

    void
    Presence (const PresenceOptional& x);

    void
    Presence (::std::unique_ptr< PresenceType > p);

    // Location
    //
    typedef ::CDM::PrimaryAlertSignalLocation LocationType;
    typedef ::xsd::cxx::tree::optional< LocationType > LocationOptional;
    typedef ::xsd::cxx::tree::traits< LocationType, char > LocationTraits;

    const LocationOptional&
    Location () const;

    LocationOptional&
    Location ();

    void
    Location (const LocationType& x);

    void
    Location (const LocationOptional& x);

    void
    Location (::std::unique_ptr< LocationType > p);

    // Slot
    //
    typedef ::xml_schema::Int SlotType;
    typedef ::xsd::cxx::tree::optional< SlotType > SlotOptional;
    typedef ::xsd::cxx::tree::traits< SlotType, char > SlotTraits;

    const SlotOptional&
    Slot () const;

    SlotOptional&
    Slot ();

    void
    Slot (const SlotType& x);

    void
    Slot (const SlotOptional& x);

    // Constructors.
    //
    AlertSignalState (const DescriptorHandleType&,
                      const ActivationStateType&);

    AlertSignalState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    AlertSignalState (const AlertSignalState& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual AlertSignalState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertSignalState&
    operator= (const AlertSignalState& x);

    virtual 
    ~AlertSignalState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ActivationStateType > ActivationState_;
    PresenceOptional Presence_;
    LocationOptional Location_;
    SlotOptional Slot_;
  };

  class AlertSystemState: public ::CDM::AbstractAlertState
  {
    public:
    // ActivationState
    //
    typedef ::CDM::PausableActivation ActivationStateType;
    typedef ::xsd::cxx::tree::traits< ActivationStateType, char > ActivationStateTraits;

    const ActivationStateType&
    ActivationState () const;

    ActivationStateType&
    ActivationState ();

    void
    ActivationState (const ActivationStateType& x);

    void
    ActivationState (::std::unique_ptr< ActivationStateType > p);

    // LastSelfCheck
    //
    typedef ::CDM::Timestamp LastSelfCheckType;
    typedef ::xsd::cxx::tree::optional< LastSelfCheckType > LastSelfCheckOptional;
    typedef ::xsd::cxx::tree::traits< LastSelfCheckType, char > LastSelfCheckTraits;

    const LastSelfCheckOptional&
    LastSelfCheck () const;

    LastSelfCheckOptional&
    LastSelfCheck ();

    void
    LastSelfCheck (const LastSelfCheckType& x);

    void
    LastSelfCheck (const LastSelfCheckOptional& x);

    void
    LastSelfCheck (::std::unique_ptr< LastSelfCheckType > p);

    // SelfCheckCount
    //
    typedef ::xml_schema::Long SelfCheckCountType;
    typedef ::xsd::cxx::tree::optional< SelfCheckCountType > SelfCheckCountOptional;
    typedef ::xsd::cxx::tree::traits< SelfCheckCountType, char > SelfCheckCountTraits;

    const SelfCheckCountOptional&
    SelfCheckCount () const;

    SelfCheckCountOptional&
    SelfCheckCount ();

    void
    SelfCheckCount (const SelfCheckCountType& x);

    void
    SelfCheckCount (const SelfCheckCountOptional& x);

    // PresentPhysiologicalAlarmConditions
    //
    typedef ::CDM::AlertConditionReference PresentPhysiologicalAlarmConditionsType;
    typedef ::xsd::cxx::tree::optional< PresentPhysiologicalAlarmConditionsType > PresentPhysiologicalAlarmConditionsOptional;
    typedef ::xsd::cxx::tree::traits< PresentPhysiologicalAlarmConditionsType, char > PresentPhysiologicalAlarmConditionsTraits;

    const PresentPhysiologicalAlarmConditionsOptional&
    PresentPhysiologicalAlarmConditions () const;

    PresentPhysiologicalAlarmConditionsOptional&
    PresentPhysiologicalAlarmConditions ();

    void
    PresentPhysiologicalAlarmConditions (const PresentPhysiologicalAlarmConditionsType& x);

    void
    PresentPhysiologicalAlarmConditions (const PresentPhysiologicalAlarmConditionsOptional& x);

    void
    PresentPhysiologicalAlarmConditions (::std::unique_ptr< PresentPhysiologicalAlarmConditionsType > p);

    // PresentTechnicalAlarmConditions
    //
    typedef ::CDM::AlertConditionReference PresentTechnicalAlarmConditionsType;
    typedef ::xsd::cxx::tree::optional< PresentTechnicalAlarmConditionsType > PresentTechnicalAlarmConditionsOptional;
    typedef ::xsd::cxx::tree::traits< PresentTechnicalAlarmConditionsType, char > PresentTechnicalAlarmConditionsTraits;

    const PresentTechnicalAlarmConditionsOptional&
    PresentTechnicalAlarmConditions () const;

    PresentTechnicalAlarmConditionsOptional&
    PresentTechnicalAlarmConditions ();

    void
    PresentTechnicalAlarmConditions (const PresentTechnicalAlarmConditionsType& x);

    void
    PresentTechnicalAlarmConditions (const PresentTechnicalAlarmConditionsOptional& x);

    void
    PresentTechnicalAlarmConditions (::std::unique_ptr< PresentTechnicalAlarmConditionsType > p);

    // Constructors.
    //
    AlertSystemState (const DescriptorHandleType&,
                      const ActivationStateType&);

    AlertSystemState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    AlertSystemState (const AlertSystemState& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual AlertSystemState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AlertSystemState&
    operator= (const AlertSystemState& x);

    virtual 
    ~AlertSystemState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ActivationStateType > ActivationState_;
    LastSelfCheckOptional LastSelfCheck_;
    SelfCheckCountOptional SelfCheckCount_;
    PresentPhysiologicalAlarmConditionsOptional PresentPhysiologicalAlarmConditions_;
    PresentTechnicalAlarmConditionsOptional PresentTechnicalAlarmConditions_;
  };

  class AlertConditionReference: public ::xml_schema::SimpleType,
    public ::xsd::cxx::tree::list< ::CDM::HandleRef, char >
  {
    public:
    AlertConditionReference ();

    AlertConditionReference (size_type n, const ::CDM::HandleRef& x);

    template < typename I >
    AlertConditionReference (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::CDM::HandleRef, char > (begin, end, this)
    {
    }

    AlertConditionReference (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    AlertConditionReference (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    AlertConditionReference (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    AlertConditionReference (const AlertConditionReference& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual AlertConditionReference*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~AlertConditionReference ();
  };

  class LimitAlertConditionState: public ::CDM::AlertConditionState
  {
    public:
    // Limits
    //
    typedef ::CDM::Range LimitsType;
    typedef ::xsd::cxx::tree::optional< LimitsType > LimitsOptional;
    typedef ::xsd::cxx::tree::traits< LimitsType, char > LimitsTraits;

    const LimitsOptional&
    Limits () const;

    LimitsOptional&
    Limits ();

    void
    Limits (const LimitsType& x);

    void
    Limits (const LimitsOptional& x);

    void
    Limits (::std::unique_ptr< LimitsType > p);

    // MonitoredAlertLimits
    //
    typedef ::CDM::MonitoredAlertLimits MonitoredAlertLimitsType;
    typedef ::xsd::cxx::tree::traits< MonitoredAlertLimitsType, char > MonitoredAlertLimitsTraits;

    const MonitoredAlertLimitsType&
    MonitoredAlertLimits () const;

    MonitoredAlertLimitsType&
    MonitoredAlertLimits ();

    void
    MonitoredAlertLimits (const MonitoredAlertLimitsType& x);

    void
    MonitoredAlertLimits (::std::unique_ptr< MonitoredAlertLimitsType > p);

    // AutoLimitActivationState
    //
    typedef ::CDM::PausableActivation AutoLimitActivationStateType;
    typedef ::xsd::cxx::tree::optional< AutoLimitActivationStateType > AutoLimitActivationStateOptional;
    typedef ::xsd::cxx::tree::traits< AutoLimitActivationStateType, char > AutoLimitActivationStateTraits;

    const AutoLimitActivationStateOptional&
    AutoLimitActivationState () const;

    AutoLimitActivationStateOptional&
    AutoLimitActivationState ();

    void
    AutoLimitActivationState (const AutoLimitActivationStateType& x);

    void
    AutoLimitActivationState (const AutoLimitActivationStateOptional& x);

    void
    AutoLimitActivationState (::std::unique_ptr< AutoLimitActivationStateType > p);

    // Constructors.
    //
    LimitAlertConditionState (const DescriptorHandleType&,
                              const ActivationStateType&,
                              const PresenceType&,
                              const MonitoredAlertLimitsType&);

    LimitAlertConditionState (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    LimitAlertConditionState (const LimitAlertConditionState& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    virtual LimitAlertConditionState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    LimitAlertConditionState&
    operator= (const LimitAlertConditionState& x);

    virtual 
    ~LimitAlertConditionState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    LimitsOptional Limits_;
    ::xsd::cxx::tree::one< MonitoredAlertLimitsType > MonitoredAlertLimits_;
    AutoLimitActivationStateOptional AutoLimitActivationState_;
  };

  class MetricCategory: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Unspec,
      Msrmt,
      Clc,
      Set,
      Preset,
      Rcmm
    };

    MetricCategory (Value v);

    MetricCategory (const char* v);

    MetricCategory (const ::std::string& v);

    MetricCategory (const ::xml_schema::String& v);

    MetricCategory (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    MetricCategory (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    MetricCategory (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    MetricCategory (const MetricCategory& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual MetricCategory*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MetricCategory&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_MetricCategory_convert ();
    }

    protected:
    Value
    _xsd_MetricCategory_convert () const;

    public:
    static const char* const _xsd_MetricCategory_literals_[6];
    static const Value _xsd_MetricCategory_indexes_[6];
  };

  class MetricAvailability: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Intr,
      Cont
    };

    MetricAvailability (Value v);

    MetricAvailability (const char* v);

    MetricAvailability (const ::std::string& v);

    MetricAvailability (const ::xml_schema::String& v);

    MetricAvailability (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    MetricAvailability (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    MetricAvailability (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    MetricAvailability (const MetricAvailability& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual MetricAvailability*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MetricAvailability&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_MetricAvailability_convert ();
    }

    protected:
    Value
    _xsd_MetricAvailability_convert () const;

    public:
    static const char* const _xsd_MetricAvailability_literals_[2];
    static const Value _xsd_MetricAvailability_indexes_[2];
  };

  class VMDDescriptor: public ::CDM::AbstractDeviceComponent
  {
    public:
    // Channel
    //
    typedef ::CDM::ChannelDescriptor ChannelType;
    typedef ::xsd::cxx::tree::sequence< ChannelType > ChannelSequence;
    typedef ChannelSequence::iterator ChannelIterator;
    typedef ChannelSequence::const_iterator ChannelConstIterator;
    typedef ::xsd::cxx::tree::traits< ChannelType, char > ChannelTraits;

    const ChannelSequence&
    Channel () const;

    ChannelSequence&
    Channel ();

    void
    Channel (const ChannelSequence& s);

    // AlertSystem
    //
    typedef ::CDM::AlertSystemDescriptor AlertSystemType;
    typedef ::xsd::cxx::tree::optional< AlertSystemType > AlertSystemOptional;
    typedef ::xsd::cxx::tree::traits< AlertSystemType, char > AlertSystemTraits;

    const AlertSystemOptional&
    AlertSystem () const;

    AlertSystemOptional&
    AlertSystem ();

    void
    AlertSystem (const AlertSystemType& x);

    void
    AlertSystem (const AlertSystemOptional& x);

    void
    AlertSystem (::std::unique_ptr< AlertSystemType > p);

    // Constructors.
    //
    VMDDescriptor (const HandleType&);

    VMDDescriptor (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    VMDDescriptor (const VMDDescriptor& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual VMDDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    VMDDescriptor&
    operator= (const VMDDescriptor& x);

    virtual 
    ~VMDDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ChannelSequence Channel_;
    AlertSystemOptional AlertSystem_;
  };

  class ChannelDescriptor: public ::CDM::AbstractDeviceComponent
  {
    public:
    // Metric
    //
    typedef ::CDM::AbstractMetricDescriptor MetricType;
    typedef ::xsd::cxx::tree::sequence< MetricType > MetricSequence;
    typedef MetricSequence::iterator MetricIterator;
    typedef MetricSequence::const_iterator MetricConstIterator;
    typedef ::xsd::cxx::tree::traits< MetricType, char > MetricTraits;

    const MetricSequence&
    Metric () const;

    MetricSequence&
    Metric ();

    void
    Metric (const MetricSequence& s);

    // AlertSystem
    //
    typedef ::CDM::AlertSystemDescriptor AlertSystemType;
    typedef ::xsd::cxx::tree::optional< AlertSystemType > AlertSystemOptional;
    typedef ::xsd::cxx::tree::traits< AlertSystemType, char > AlertSystemTraits;

    const AlertSystemOptional&
    AlertSystem () const;

    AlertSystemOptional&
    AlertSystem ();

    void
    AlertSystem (const AlertSystemType& x);

    void
    AlertSystem (const AlertSystemOptional& x);

    void
    AlertSystem (::std::unique_ptr< AlertSystemType > p);

    // Constructors.
    //
    ChannelDescriptor (const HandleType&);

    ChannelDescriptor (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    ChannelDescriptor (const ChannelDescriptor& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual ChannelDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ChannelDescriptor&
    operator= (const ChannelDescriptor& x);

    virtual 
    ~ChannelDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MetricSequence Metric_;
    AlertSystemOptional AlertSystem_;
  };

  class AbstractMetricDescriptor: public ::CDM::AbstractDescriptor
  {
    public:
    // Unit
    //
    typedef ::CDM::CodedValue UnitType;
    typedef ::xsd::cxx::tree::traits< UnitType, char > UnitTraits;

    const UnitType&
    Unit () const;

    UnitType&
    Unit ();

    void
    Unit (const UnitType& x);

    void
    Unit (::std::unique_ptr< UnitType > p);

    // BodySite
    //
    typedef ::CDM::CodedValue BodySiteType;
    typedef ::xsd::cxx::tree::sequence< BodySiteType > BodySiteSequence;
    typedef BodySiteSequence::iterator BodySiteIterator;
    typedef BodySiteSequence::const_iterator BodySiteConstIterator;
    typedef ::xsd::cxx::tree::traits< BodySiteType, char > BodySiteTraits;

    const BodySiteSequence&
    BodySite () const;

    BodySiteSequence&
    BodySite ();

    void
    BodySite (const BodySiteSequence& s);

    // MetricCategory
    //
    typedef ::CDM::MetricCategory MetricCategoryType;
    typedef ::xsd::cxx::tree::traits< MetricCategoryType, char > MetricCategoryTraits;

    const MetricCategoryType&
    MetricCategory () const;

    MetricCategoryType&
    MetricCategory ();

    void
    MetricCategory (const MetricCategoryType& x);

    void
    MetricCategory (::std::unique_ptr< MetricCategoryType > p);

    // Availability
    //
    typedef ::CDM::MetricAvailability AvailabilityType;
    typedef ::xsd::cxx::tree::traits< AvailabilityType, char > AvailabilityTraits;

    const AvailabilityType&
    Availability () const;

    AvailabilityType&
    Availability ();

    void
    Availability (const AvailabilityType& x);

    void
    Availability (::std::unique_ptr< AvailabilityType > p);

    // MaxDelayTime
    //
    typedef ::xml_schema::Duration MaxDelayTimeType;
    typedef ::xsd::cxx::tree::optional< MaxDelayTimeType > MaxDelayTimeOptional;
    typedef ::xsd::cxx::tree::traits< MaxDelayTimeType, char > MaxDelayTimeTraits;

    const MaxDelayTimeOptional&
    MaxDelayTime () const;

    MaxDelayTimeOptional&
    MaxDelayTime ();

    void
    MaxDelayTime (const MaxDelayTimeType& x);

    void
    MaxDelayTime (const MaxDelayTimeOptional& x);

    void
    MaxDelayTime (::std::unique_ptr< MaxDelayTimeType > p);

    // Constructors.
    //
    AbstractMetricDescriptor (const HandleType&,
                              const UnitType&,
                              const MetricCategoryType&,
                              const AvailabilityType&);

    AbstractMetricDescriptor (const HandleType&,
                              ::std::unique_ptr< UnitType >,
                              const MetricCategoryType&,
                              const AvailabilityType&);

    AbstractMetricDescriptor (const HandleType&,
                              ::std::unique_ptr< UnitType >,
                              ::std::unique_ptr< MetricCategoryType >,
                              ::std::unique_ptr< AvailabilityType >);

    AbstractMetricDescriptor (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    AbstractMetricDescriptor (const AbstractMetricDescriptor& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    virtual AbstractMetricDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractMetricDescriptor&
    operator= (const AbstractMetricDescriptor& x);

    virtual 
    ~AbstractMetricDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< UnitType > Unit_;
    BodySiteSequence BodySite_;
    ::xsd::cxx::tree::one< MetricCategoryType > MetricCategory_;
    ::xsd::cxx::tree::one< AvailabilityType > Availability_;
    MaxDelayTimeOptional MaxDelayTime_;
  };

  class NumericMetricDescriptor: public ::CDM::AbstractMetricDescriptor
  {
    public:
    // Resolution
    //
    typedef ::xml_schema::Decimal ResolutionType;
    typedef ::xsd::cxx::tree::traits< ResolutionType, char, ::xsd::cxx::tree::schema_type::decimal > ResolutionTraits;

    const ResolutionType&
    Resolution () const;

    ResolutionType&
    Resolution ();

    void
    Resolution (const ResolutionType& x);

    // MeasurePeriod
    //
    typedef ::xml_schema::Duration MeasurePeriodType;
    typedef ::xsd::cxx::tree::optional< MeasurePeriodType > MeasurePeriodOptional;
    typedef ::xsd::cxx::tree::traits< MeasurePeriodType, char > MeasurePeriodTraits;

    const MeasurePeriodOptional&
    MeasurePeriod () const;

    MeasurePeriodOptional&
    MeasurePeriod ();

    void
    MeasurePeriod (const MeasurePeriodType& x);

    void
    MeasurePeriod (const MeasurePeriodOptional& x);

    void
    MeasurePeriod (::std::unique_ptr< MeasurePeriodType > p);

    // AveragingPeriod
    //
    typedef ::xml_schema::Duration AveragingPeriodType;
    typedef ::xsd::cxx::tree::optional< AveragingPeriodType > AveragingPeriodOptional;
    typedef ::xsd::cxx::tree::traits< AveragingPeriodType, char > AveragingPeriodTraits;

    const AveragingPeriodOptional&
    AveragingPeriod () const;

    AveragingPeriodOptional&
    AveragingPeriod ();

    void
    AveragingPeriod (const AveragingPeriodType& x);

    void
    AveragingPeriod (const AveragingPeriodOptional& x);

    void
    AveragingPeriod (::std::unique_ptr< AveragingPeriodType > p);

    // TechnicalRange
    //
    typedef ::CDM::Range TechnicalRangeType;
    typedef ::xsd::cxx::tree::sequence< TechnicalRangeType > TechnicalRangeSequence;
    typedef TechnicalRangeSequence::iterator TechnicalRangeIterator;
    typedef TechnicalRangeSequence::const_iterator TechnicalRangeConstIterator;
    typedef ::xsd::cxx::tree::traits< TechnicalRangeType, char > TechnicalRangeTraits;

    const TechnicalRangeSequence&
    TechnicalRange () const;

    TechnicalRangeSequence&
    TechnicalRange ();

    void
    TechnicalRange (const TechnicalRangeSequence& s);

    // Constructors.
    //
    NumericMetricDescriptor (const HandleType&,
                             const UnitType&,
                             const MetricCategoryType&,
                             const AvailabilityType&,
                             const ResolutionType&);

    NumericMetricDescriptor (const HandleType&,
                             ::std::unique_ptr< UnitType >,
                             const MetricCategoryType&,
                             const AvailabilityType&,
                             const ResolutionType&);

    NumericMetricDescriptor (const HandleType&,
                             ::std::unique_ptr< UnitType >,
                             ::std::unique_ptr< MetricCategoryType >,
                             ::std::unique_ptr< AvailabilityType >,
                             const ResolutionType&);

    NumericMetricDescriptor (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    NumericMetricDescriptor (const NumericMetricDescriptor& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual NumericMetricDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    NumericMetricDescriptor&
    operator= (const NumericMetricDescriptor& x);

    virtual 
    ~NumericMetricDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResolutionType > Resolution_;
    MeasurePeriodOptional MeasurePeriod_;
    AveragingPeriodOptional AveragingPeriod_;
    TechnicalRangeSequence TechnicalRange_;
  };

  class StringMetricDescriptor: public ::CDM::AbstractMetricDescriptor
  {
    public:
    // Constructors.
    //
    StringMetricDescriptor (const HandleType&,
                            const UnitType&,
                            const MetricCategoryType&,
                            const AvailabilityType&);

    StringMetricDescriptor (const HandleType&,
                            ::std::unique_ptr< UnitType >,
                            const MetricCategoryType&,
                            const AvailabilityType&);

    StringMetricDescriptor (const HandleType&,
                            ::std::unique_ptr< UnitType >,
                            ::std::unique_ptr< MetricCategoryType >,
                            ::std::unique_ptr< AvailabilityType >);

    StringMetricDescriptor (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    StringMetricDescriptor (const StringMetricDescriptor& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    virtual StringMetricDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~StringMetricDescriptor ();
  };

  class EnumNomenRef: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Code
    //
    typedef ::CDM::CodedValue CodeType;
    typedef ::xsd::cxx::tree::traits< CodeType, char > CodeTraits;

    const CodeType&
    Code () const;

    CodeType&
    Code ();

    void
    Code (const CodeType& x);

    void
    Code (::std::unique_ptr< CodeType > p);

    // EnumIndex
    //
    typedef ::CDM::SampleIndex EnumIndexType;
    typedef ::xsd::cxx::tree::optional< EnumIndexType > EnumIndexOptional;
    typedef ::xsd::cxx::tree::traits< EnumIndexType, char > EnumIndexTraits;

    const EnumIndexOptional&
    EnumIndex () const;

    EnumIndexOptional&
    EnumIndex ();

    void
    EnumIndex (const EnumIndexType& x);

    void
    EnumIndex (const EnumIndexOptional& x);

    void
    EnumIndex (::std::unique_ptr< EnumIndexType > p);

    // Constructors.
    //
    EnumNomenRef (const CodeType&);

    EnumNomenRef (::std::unique_ptr< CodeType >);

    EnumNomenRef (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    EnumNomenRef (const EnumNomenRef& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual EnumNomenRef*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    EnumNomenRef&
    operator= (const EnumNomenRef& x);

    virtual 
    ~EnumNomenRef ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< CodeType > Code_;
    EnumIndexOptional EnumIndex_;
  };

  class EnumStringMetricDescriptor: public ::CDM::StringMetricDescriptor
  {
    public:
    // AllowedValue
    //
    typedef ::xml_schema::String AllowedValueType;
    typedef ::xsd::cxx::tree::sequence< AllowedValueType > AllowedValueSequence;
    typedef AllowedValueSequence::iterator AllowedValueIterator;
    typedef AllowedValueSequence::const_iterator AllowedValueConstIterator;
    typedef ::xsd::cxx::tree::traits< AllowedValueType, char > AllowedValueTraits;

    const AllowedValueSequence&
    AllowedValue () const;

    AllowedValueSequence&
    AllowedValue ();

    void
    AllowedValue (const AllowedValueSequence& s);

    // EnumCodes
    //
    typedef ::CDM::EnumNomenRef EnumCodesType;
    typedef ::xsd::cxx::tree::sequence< EnumCodesType > EnumCodesSequence;
    typedef EnumCodesSequence::iterator EnumCodesIterator;
    typedef EnumCodesSequence::const_iterator EnumCodesConstIterator;
    typedef ::xsd::cxx::tree::traits< EnumCodesType, char > EnumCodesTraits;

    const EnumCodesSequence&
    EnumCodes () const;

    EnumCodesSequence&
    EnumCodes ();

    void
    EnumCodes (const EnumCodesSequence& s);

    // Constructors.
    //
    EnumStringMetricDescriptor (const HandleType&,
                                const UnitType&,
                                const MetricCategoryType&,
                                const AvailabilityType&);

    EnumStringMetricDescriptor (const HandleType&,
                                ::std::unique_ptr< UnitType >,
                                const MetricCategoryType&,
                                const AvailabilityType&);

    EnumStringMetricDescriptor (const HandleType&,
                                ::std::unique_ptr< UnitType >,
                                ::std::unique_ptr< MetricCategoryType >,
                                ::std::unique_ptr< AvailabilityType >);

    EnumStringMetricDescriptor (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    EnumStringMetricDescriptor (const EnumStringMetricDescriptor& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    virtual EnumStringMetricDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    EnumStringMetricDescriptor&
    operator= (const EnumStringMetricDescriptor& x);

    virtual 
    ~EnumStringMetricDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AllowedValueSequence AllowedValue_;
    EnumCodesSequence EnumCodes_;
  };

  class RealTimeSampleArrayMetricDescriptor: public ::CDM::AbstractMetricDescriptor
  {
    public:
    // SamplePeriod
    //
    typedef ::xml_schema::Duration SamplePeriodType;
    typedef ::xsd::cxx::tree::traits< SamplePeriodType, char > SamplePeriodTraits;

    const SamplePeriodType&
    SamplePeriod () const;

    SamplePeriodType&
    SamplePeriod ();

    void
    SamplePeriod (const SamplePeriodType& x);

    void
    SamplePeriod (::std::unique_ptr< SamplePeriodType > p);

    // Resolution
    //
    typedef ::xml_schema::Decimal ResolutionType;
    typedef ::xsd::cxx::tree::traits< ResolutionType, char, ::xsd::cxx::tree::schema_type::decimal > ResolutionTraits;

    const ResolutionType&
    Resolution () const;

    ResolutionType&
    Resolution ();

    void
    Resolution (const ResolutionType& x);

    // TechnicalRange
    //
    typedef ::CDM::Range TechnicalRangeType;
    typedef ::xsd::cxx::tree::sequence< TechnicalRangeType > TechnicalRangeSequence;
    typedef TechnicalRangeSequence::iterator TechnicalRangeIterator;
    typedef TechnicalRangeSequence::const_iterator TechnicalRangeConstIterator;
    typedef ::xsd::cxx::tree::traits< TechnicalRangeType, char > TechnicalRangeTraits;

    const TechnicalRangeSequence&
    TechnicalRange () const;

    TechnicalRangeSequence&
    TechnicalRange ();

    void
    TechnicalRange (const TechnicalRangeSequence& s);

    // Constructors.
    //
    RealTimeSampleArrayMetricDescriptor (const HandleType&,
                                         const UnitType&,
                                         const MetricCategoryType&,
                                         const AvailabilityType&,
                                         const SamplePeriodType&,
                                         const ResolutionType&);

    RealTimeSampleArrayMetricDescriptor (const HandleType&,
                                         ::std::unique_ptr< UnitType >,
                                         const MetricCategoryType&,
                                         const AvailabilityType&,
                                         const SamplePeriodType&,
                                         const ResolutionType&);

    RealTimeSampleArrayMetricDescriptor (const HandleType&,
                                         ::std::unique_ptr< UnitType >,
                                         ::std::unique_ptr< MetricCategoryType >,
                                         ::std::unique_ptr< AvailabilityType >,
                                         ::std::unique_ptr< SamplePeriodType >,
                                         const ResolutionType&);

    RealTimeSampleArrayMetricDescriptor (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    RealTimeSampleArrayMetricDescriptor (const RealTimeSampleArrayMetricDescriptor& x,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    virtual RealTimeSampleArrayMetricDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    RealTimeSampleArrayMetricDescriptor&
    operator= (const RealTimeSampleArrayMetricDescriptor& x);

    virtual 
    ~RealTimeSampleArrayMetricDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< SamplePeriodType > SamplePeriod_;
    ::xsd::cxx::tree::one< ResolutionType > Resolution_;
    TechnicalRangeSequence TechnicalRange_;
  };

  class CalibrationState: public ::xml_schema::String
  {
    public:
    enum Value
    {
      No,
      Req,
      Cal
    };

    CalibrationState (Value v);

    CalibrationState (const char* v);

    CalibrationState (const ::std::string& v);

    CalibrationState (const ::xml_schema::String& v);

    CalibrationState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    CalibrationState (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    CalibrationState (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    CalibrationState (const CalibrationState& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual CalibrationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CalibrationState&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_CalibrationState_convert ();
    }

    protected:
    Value
    _xsd_CalibrationState_convert () const;

    public:
    static const char* const _xsd_CalibrationState_literals_[3];
    static const Value _xsd_CalibrationState_indexes_[3];
  };

  class ComponentActivation: public ::xml_schema::String
  {
    public:
    enum Value
    {
      On,
      NotRdy,
      StndBy,
      Off,
      Shtdn
    };

    ComponentActivation (Value v);

    ComponentActivation (const char* v);

    ComponentActivation (const ::std::string& v);

    ComponentActivation (const ::xml_schema::String& v);

    ComponentActivation (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    ComponentActivation (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    ComponentActivation (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    ComponentActivation (const ComponentActivation& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual ComponentActivation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ComponentActivation&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_ComponentActivation_convert ();
    }

    protected:
    Value
    _xsd_ComponentActivation_convert () const;

    public:
    static const char* const _xsd_ComponentActivation_literals_[5];
    static const Value _xsd_ComponentActivation_indexes_[5];
  };

  class MetricMeasurementValidity: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Vld,
      Vldated,
      Qst,
      Calib,
      Inv,
      Oflw,
      Uflw
    };

    MetricMeasurementValidity (Value v);

    MetricMeasurementValidity (const char* v);

    MetricMeasurementValidity (const ::std::string& v);

    MetricMeasurementValidity (const ::xml_schema::String& v);

    MetricMeasurementValidity (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    MetricMeasurementValidity (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    MetricMeasurementValidity (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    MetricMeasurementValidity (const MetricMeasurementValidity& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    virtual MetricMeasurementValidity*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MetricMeasurementValidity&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_MetricMeasurementValidity_convert ();
    }

    protected:
    Value
    _xsd_MetricMeasurementValidity_convert () const;

    public:
    static const char* const _xsd_MetricMeasurementValidity_literals_[7];
    static const Value _xsd_MetricMeasurementValidity_indexes_[7];
  };

  class GenerationMode: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Real,
      Test,
      Demo
    };

    GenerationMode (Value v);

    GenerationMode (const char* v);

    GenerationMode (const ::std::string& v);

    GenerationMode (const ::xml_schema::String& v);

    GenerationMode (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    GenerationMode (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    GenerationMode (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    GenerationMode (const GenerationMode& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual GenerationMode*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    GenerationMode&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_GenerationMode_convert ();
    }

    protected:
    Value
    _xsd_GenerationMode_convert () const;

    public:
    static const char* const _xsd_GenerationMode_literals_[3];
    static const Value _xsd_GenerationMode_indexes_[3];
  };

  class CalibrationInfo: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // ComponentCalibrationState
    //
    typedef ::CDM::CalibrationState ComponentCalibrationStateType;
    typedef ::xsd::cxx::tree::optional< ComponentCalibrationStateType > ComponentCalibrationStateOptional;
    typedef ::xsd::cxx::tree::traits< ComponentCalibrationStateType, char > ComponentCalibrationStateTraits;

    const ComponentCalibrationStateOptional&
    ComponentCalibrationState () const;

    ComponentCalibrationStateOptional&
    ComponentCalibrationState ();

    void
    ComponentCalibrationState (const ComponentCalibrationStateType& x);

    void
    ComponentCalibrationState (const ComponentCalibrationStateOptional& x);

    void
    ComponentCalibrationState (::std::unique_ptr< ComponentCalibrationStateType > p);

    // Constructors.
    //
    CalibrationInfo ();

    CalibrationInfo (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    CalibrationInfo (const CalibrationInfo& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual CalibrationInfo*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CalibrationInfo&
    operator= (const CalibrationInfo& x);

    virtual 
    ~CalibrationInfo ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ComponentCalibrationStateOptional ComponentCalibrationState_;
  };

  class AbstractMetricState: public ::CDM::ComponentState
  {
    public:
    // MeasurementPeriod
    //
    typedef ::xml_schema::Duration MeasurementPeriodType;
    typedef ::xsd::cxx::tree::optional< MeasurementPeriodType > MeasurementPeriodOptional;
    typedef ::xsd::cxx::tree::traits< MeasurementPeriodType, char > MeasurementPeriodTraits;

    const MeasurementPeriodOptional&
    MeasurementPeriod () const;

    MeasurementPeriodOptional&
    MeasurementPeriod ();

    void
    MeasurementPeriod (const MeasurementPeriodType& x);

    void
    MeasurementPeriod (const MeasurementPeriodOptional& x);

    void
    MeasurementPeriod (::std::unique_ptr< MeasurementPeriodType > p);

    // AveragingPeriod
    //
    typedef ::xml_schema::Duration AveragingPeriodType;
    typedef ::xsd::cxx::tree::optional< AveragingPeriodType > AveragingPeriodOptional;
    typedef ::xsd::cxx::tree::traits< AveragingPeriodType, char > AveragingPeriodTraits;

    const AveragingPeriodOptional&
    AveragingPeriod () const;

    AveragingPeriodOptional&
    AveragingPeriod ();

    void
    AveragingPeriod (const AveragingPeriodType& x);

    void
    AveragingPeriod (const AveragingPeriodOptional& x);

    void
    AveragingPeriod (::std::unique_ptr< AveragingPeriodType > p);

    // BodySite
    //
    typedef ::CDM::CodedValue BodySiteType;
    typedef ::xsd::cxx::tree::sequence< BodySiteType > BodySiteSequence;
    typedef BodySiteSequence::iterator BodySiteIterator;
    typedef BodySiteSequence::const_iterator BodySiteConstIterator;
    typedef ::xsd::cxx::tree::traits< BodySiteType, char > BodySiteTraits;

    const BodySiteSequence&
    BodySite () const;

    BodySiteSequence&
    BodySite ();

    void
    BodySite (const BodySiteSequence& s);

    // Constructors.
    //
    AbstractMetricState (const DescriptorHandleType&);

    AbstractMetricState (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    AbstractMetricState (const AbstractMetricState& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual AbstractMetricState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractMetricState&
    operator= (const AbstractMetricState& x);

    virtual 
    ~AbstractMetricState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MeasurementPeriodOptional MeasurementPeriod_;
    AveragingPeriodOptional AveragingPeriod_;
    BodySiteSequence BodySite_;
  };

  class NumericMetricState: public ::CDM::AbstractMetricState
  {
    public:
    // ObservedValue
    //
    typedef ::CDM::NumericMetricValue ObservedValueType;
    typedef ::xsd::cxx::tree::optional< ObservedValueType > ObservedValueOptional;
    typedef ::xsd::cxx::tree::traits< ObservedValueType, char > ObservedValueTraits;

    const ObservedValueOptional&
    ObservedValue () const;

    ObservedValueOptional&
    ObservedValue ();

    void
    ObservedValue (const ObservedValueType& x);

    void
    ObservedValue (const ObservedValueOptional& x);

    void
    ObservedValue (::std::unique_ptr< ObservedValueType > p);

    // PhysiologicalRange
    //
    typedef ::CDM::Range PhysiologicalRangeType;
    typedef ::xsd::cxx::tree::sequence< PhysiologicalRangeType > PhysiologicalRangeSequence;
    typedef PhysiologicalRangeSequence::iterator PhysiologicalRangeIterator;
    typedef PhysiologicalRangeSequence::const_iterator PhysiologicalRangeConstIterator;
    typedef ::xsd::cxx::tree::traits< PhysiologicalRangeType, char > PhysiologicalRangeTraits;

    const PhysiologicalRangeSequence&
    PhysiologicalRange () const;

    PhysiologicalRangeSequence&
    PhysiologicalRange ();

    void
    PhysiologicalRange (const PhysiologicalRangeSequence& s);

    // Constructors.
    //
    NumericMetricState (const DescriptorHandleType&);

    NumericMetricState (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    NumericMetricState (const NumericMetricState& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual NumericMetricState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    NumericMetricState&
    operator= (const NumericMetricState& x);

    virtual 
    ~NumericMetricState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ObservedValueOptional ObservedValue_;
    PhysiologicalRangeSequence PhysiologicalRange_;
  };

  class RealTimeSampleArrayMetricState: public ::CDM::AbstractMetricState
  {
    public:
    // ObservedValue
    //
    typedef ::CDM::RealTimeSampleArrayValue ObservedValueType;
    typedef ::xsd::cxx::tree::optional< ObservedValueType > ObservedValueOptional;
    typedef ::xsd::cxx::tree::traits< ObservedValueType, char > ObservedValueTraits;

    const ObservedValueOptional&
    ObservedValue () const;

    ObservedValueOptional&
    ObservedValue ();

    void
    ObservedValue (const ObservedValueType& x);

    void
    ObservedValue (const ObservedValueOptional& x);

    void
    ObservedValue (::std::unique_ptr< ObservedValueType > p);

    // Constructors.
    //
    RealTimeSampleArrayMetricState (const DescriptorHandleType&);

    RealTimeSampleArrayMetricState (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    RealTimeSampleArrayMetricState (const RealTimeSampleArrayMetricState& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    virtual RealTimeSampleArrayMetricState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    RealTimeSampleArrayMetricState&
    operator= (const RealTimeSampleArrayMetricState& x);

    virtual 
    ~RealTimeSampleArrayMetricState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ObservedValueOptional ObservedValue_;
  };

  class StringMetricState: public ::CDM::AbstractMetricState
  {
    public:
    // ObservedValue
    //
    typedef ::CDM::StringMetricValue ObservedValueType;
    typedef ::xsd::cxx::tree::optional< ObservedValueType > ObservedValueOptional;
    typedef ::xsd::cxx::tree::traits< ObservedValueType, char > ObservedValueTraits;

    const ObservedValueOptional&
    ObservedValue () const;

    ObservedValueOptional&
    ObservedValue ();

    void
    ObservedValue (const ObservedValueType& x);

    void
    ObservedValue (const ObservedValueOptional& x);

    void
    ObservedValue (::std::unique_ptr< ObservedValueType > p);

    // Constructors.
    //
    StringMetricState (const DescriptorHandleType&);

    StringMetricState (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    StringMetricState (const StringMetricState& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual StringMetricState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    StringMetricState&
    operator= (const StringMetricState& x);

    virtual 
    ~StringMetricState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ObservedValueOptional ObservedValue_;
  };

  class EnumStringMetricState: public ::CDM::StringMetricState
  {
    public:
    // Constructors.
    //
    EnumStringMetricState (const DescriptorHandleType&);

    EnumStringMetricState (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    EnumStringMetricState (const EnumStringMetricState& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual EnumStringMetricState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~EnumStringMetricState ();
  };

  class QualityIndicator: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >
  {
    public:
    // Constructors.
    //
    QualityIndicator (const ::xml_schema::Decimal&);

    QualityIndicator (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    QualityIndicator (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    QualityIndicator (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    QualityIndicator (const QualityIndicator& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual QualityIndicator*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~QualityIndicator ();
  };

  class MeasurementState: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Validity
    //
    typedef ::CDM::MetricMeasurementValidity ValidityType;
    typedef ::xsd::cxx::tree::traits< ValidityType, char > ValidityTraits;

    const ValidityType&
    Validity () const;

    ValidityType&
    Validity ();

    void
    Validity (const ValidityType& x);

    void
    Validity (::std::unique_ptr< ValidityType > p);

    // Mode
    //
    typedef ::CDM::GenerationMode ModeType;
    typedef ::xsd::cxx::tree::optional< ModeType > ModeOptional;
    typedef ::xsd::cxx::tree::traits< ModeType, char > ModeTraits;

    const ModeOptional&
    Mode () const;

    ModeOptional&
    Mode ();

    void
    Mode (const ModeType& x);

    void
    Mode (const ModeOptional& x);

    void
    Mode (::std::unique_ptr< ModeType > p);

    // QI
    //
    typedef ::CDM::QualityIndicator QIType;
    typedef ::xsd::cxx::tree::optional< QIType > QIOptional;
    typedef ::xsd::cxx::tree::traits< QIType, char > QITraits;

    const QIOptional&
    QI () const;

    QIOptional&
    QI ();

    void
    QI (const QIType& x);

    void
    QI (const QIOptional& x);

    void
    QI (::std::unique_ptr< QIType > p);

    // Constructors.
    //
    MeasurementState (const ValidityType&);

    MeasurementState (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    MeasurementState (const MeasurementState& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual MeasurementState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MeasurementState&
    operator= (const MeasurementState& x);

    virtual 
    ~MeasurementState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< ValidityType > Validity_;
    ModeOptional Mode_;
    QIOptional QI_;
  };

  class SampleIndex: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::UnsignedInt, char, ::xml_schema::SimpleType >
  {
    public:
    // Constructors.
    //
    SampleIndex (const ::xml_schema::UnsignedInt&);

    SampleIndex (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    SampleIndex (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    SampleIndex (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    SampleIndex (const SampleIndex& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual SampleIndex*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~SampleIndex ();
  };

  class Annotation: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Code
    //
    typedef ::CDM::CodedValue CodeType;
    typedef ::xsd::cxx::tree::traits< CodeType, char > CodeTraits;

    const CodeType&
    Code () const;

    CodeType&
    Code ();

    void
    Code (const CodeType& x);

    void
    Code (::std::unique_ptr< CodeType > p);

    // SampleIndex
    //
    typedef ::CDM::SampleIndex SampleIndexType;
    typedef ::xsd::cxx::tree::optional< SampleIndexType > SampleIndexOptional;
    typedef ::xsd::cxx::tree::traits< SampleIndexType, char > SampleIndexTraits;

    const SampleIndexOptional&
    SampleIndex () const;

    SampleIndexOptional&
    SampleIndex ();

    void
    SampleIndex (const SampleIndexType& x);

    void
    SampleIndex (const SampleIndexOptional& x);

    void
    SampleIndex (::std::unique_ptr< SampleIndexType > p);

    // Constructors.
    //
    Annotation (const CodeType&);

    Annotation (::std::unique_ptr< CodeType >);

    Annotation (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    Annotation (const Annotation& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual Annotation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Annotation&
    operator= (const Annotation& x);

    virtual 
    ~Annotation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< CodeType > Code_;
    SampleIndexOptional SampleIndex_;
  };

  class AbstractMetricValue: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // MeasurementState
    //
    typedef ::CDM::MeasurementState MeasurementStateType;
    typedef ::xsd::cxx::tree::traits< MeasurementStateType, char > MeasurementStateTraits;

    const MeasurementStateType&
    MeasurementState () const;

    MeasurementStateType&
    MeasurementState ();

    void
    MeasurementState (const MeasurementStateType& x);

    void
    MeasurementState (::std::unique_ptr< MeasurementStateType > p);

    // Start-Time
    //
    typedef ::CDM::Timestamp Start_TimeType;
    typedef ::xsd::cxx::tree::optional< Start_TimeType > Start_TimeOptional;
    typedef ::xsd::cxx::tree::traits< Start_TimeType, char > Start_TimeTraits;

    const Start_TimeOptional&
    Start_Time () const;

    Start_TimeOptional&
    Start_Time ();

    void
    Start_Time (const Start_TimeType& x);

    void
    Start_Time (const Start_TimeOptional& x);

    void
    Start_Time (::std::unique_ptr< Start_TimeType > p);

    // Stop-Time
    //
    typedef ::CDM::Timestamp Stop_TimeType;
    typedef ::xsd::cxx::tree::optional< Stop_TimeType > Stop_TimeOptional;
    typedef ::xsd::cxx::tree::traits< Stop_TimeType, char > Stop_TimeTraits;

    const Stop_TimeOptional&
    Stop_Time () const;

    Stop_TimeOptional&
    Stop_Time ();

    void
    Stop_Time (const Stop_TimeType& x);

    void
    Stop_Time (const Stop_TimeOptional& x);

    void
    Stop_Time (::std::unique_ptr< Stop_TimeType > p);

    // ObservationTime
    //
    typedef ::CDM::Timestamp ObservationTimeType;
    typedef ::xsd::cxx::tree::optional< ObservationTimeType > ObservationTimeOptional;
    typedef ::xsd::cxx::tree::traits< ObservationTimeType, char > ObservationTimeTraits;

    const ObservationTimeOptional&
    ObservationTime () const;

    ObservationTimeOptional&
    ObservationTime ();

    void
    ObservationTime (const ObservationTimeType& x);

    void
    ObservationTime (const ObservationTimeOptional& x);

    void
    ObservationTime (::std::unique_ptr< ObservationTimeType > p);

    // Constructors.
    //
    AbstractMetricValue (const MeasurementStateType&);

    AbstractMetricValue (::std::unique_ptr< MeasurementStateType >);

    AbstractMetricValue (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    AbstractMetricValue (const AbstractMetricValue& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual AbstractMetricValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractMetricValue&
    operator= (const AbstractMetricValue& x);

    virtual 
    ~AbstractMetricValue ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< MeasurementStateType > MeasurementState_;
    Start_TimeOptional Start_Time_;
    Stop_TimeOptional Stop_Time_;
    ObservationTimeOptional ObservationTime_;
  };

  class NumericMetricValue: public ::CDM::AbstractMetricValue
  {
    public:
    // Value
    //
    typedef ::xml_schema::Decimal ValueType;
    typedef ::xsd::cxx::tree::optional< ValueType > ValueOptional;
    typedef ::xsd::cxx::tree::traits< ValueType, char, ::xsd::cxx::tree::schema_type::decimal > ValueTraits;

    const ValueOptional&
    Value () const;

    ValueOptional&
    Value ();

    void
    Value (const ValueType& x);

    void
    Value (const ValueOptional& x);

    // Constructors.
    //
    NumericMetricValue (const MeasurementStateType&);

    NumericMetricValue (::std::unique_ptr< MeasurementStateType >);

    NumericMetricValue (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    NumericMetricValue (const NumericMetricValue& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual NumericMetricValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    NumericMetricValue&
    operator= (const NumericMetricValue& x);

    virtual 
    ~NumericMetricValue ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ValueOptional Value_;
  };

  class RealTimeSampleArrayValue: public ::CDM::AbstractMetricValue
  {
    public:
    // Annotation
    //
    typedef ::CDM::Annotation AnnotationType;
    typedef ::xsd::cxx::tree::sequence< AnnotationType > AnnotationSequence;
    typedef AnnotationSequence::iterator AnnotationIterator;
    typedef AnnotationSequence::const_iterator AnnotationConstIterator;
    typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

    const AnnotationSequence&
    Annotation () const;

    AnnotationSequence&
    Annotation ();

    void
    Annotation (const AnnotationSequence& s);

    // Samples
    //
    typedef ::CDM::RTValueType SamplesType;
    typedef ::xsd::cxx::tree::optional< SamplesType > SamplesOptional;
    typedef ::xsd::cxx::tree::traits< SamplesType, char > SamplesTraits;

    const SamplesOptional&
    Samples () const;

    SamplesOptional&
    Samples ();

    void
    Samples (const SamplesType& x);

    void
    Samples (const SamplesOptional& x);

    void
    Samples (::std::unique_ptr< SamplesType > p);

    // Constructors.
    //
    RealTimeSampleArrayValue (const MeasurementStateType&);

    RealTimeSampleArrayValue (::std::unique_ptr< MeasurementStateType >);

    RealTimeSampleArrayValue (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    RealTimeSampleArrayValue (const RealTimeSampleArrayValue& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    virtual RealTimeSampleArrayValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    RealTimeSampleArrayValue&
    operator= (const RealTimeSampleArrayValue& x);

    virtual 
    ~RealTimeSampleArrayValue ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AnnotationSequence Annotation_;
    SamplesOptional Samples_;
  };

  class RTValueType: public ::xml_schema::SimpleType,
    public ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal >
  {
    public:
    RTValueType ();

    RTValueType (size_type n, const ::xml_schema::Decimal& x);

    template < typename I >
    RTValueType (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::Decimal, char, ::xsd::cxx::tree::schema_type::decimal > (begin, end, this)
    {
    }

    RTValueType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    RTValueType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    RTValueType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    RTValueType (const RTValueType& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual RTValueType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~RTValueType ();
  };

  class StringMetricValue: public ::CDM::AbstractMetricValue
  {
    public:
    // Value
    //
    typedef ::xml_schema::String ValueType;
    typedef ::xsd::cxx::tree::optional< ValueType > ValueOptional;
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    const ValueOptional&
    Value () const;

    ValueOptional&
    Value ();

    void
    Value (const ValueType& x);

    void
    Value (const ValueOptional& x);

    void
    Value (::std::unique_ptr< ValueType > p);

    // Constructors.
    //
    StringMetricValue (const MeasurementStateType&);

    StringMetricValue (::std::unique_ptr< MeasurementStateType >);

    StringMetricValue (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    StringMetricValue (const StringMetricValue& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual StringMetricValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    StringMetricValue&
    operator= (const StringMetricValue& x);

    virtual 
    ~StringMetricValue ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ValueOptional Value_;
  };

  class ArgumentDescriptorType: public ::CDM::AbstractDescriptor
  {
    public:
    // ArgName
    //
    typedef ::CDM::CodedValue ArgNameType;
    typedef ::xsd::cxx::tree::traits< ArgNameType, char > ArgNameTraits;

    const ArgNameType&
    ArgName () const;

    ArgNameType&
    ArgName ();

    void
    ArgName (const ArgNameType& x);

    void
    ArgName (::std::unique_ptr< ArgNameType > p);

    // ArgType
    //
    typedef ::xml_schema::Qname ArgTypeType;
    typedef ::xsd::cxx::tree::traits< ArgTypeType, char > ArgTypeTraits;

    const ArgTypeType&
    ArgType () const;

    ArgTypeType&
    ArgType ();

    void
    ArgType (const ArgTypeType& x);

    void
    ArgType (::std::unique_ptr< ArgTypeType > p);

    // Constructors.
    //
    ArgumentDescriptorType (const HandleType&,
                            const ArgNameType&,
                            const ArgTypeType&);

    ArgumentDescriptorType (const HandleType&,
                            ::std::unique_ptr< ArgNameType >,
                            const ArgTypeType&);

    ArgumentDescriptorType (const HandleType&,
                            ::std::unique_ptr< ArgNameType >,
                            ::std::unique_ptr< ArgTypeType >);

    ArgumentDescriptorType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    ArgumentDescriptorType (const ArgumentDescriptorType& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    virtual ArgumentDescriptorType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ArgumentDescriptorType&
    operator= (const ArgumentDescriptorType& x);

    virtual 
    ~ArgumentDescriptorType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ArgNameType > ArgName_;
    ::xsd::cxx::tree::one< ArgTypeType > ArgType_;
  };

  class SCODescriptor: public ::CDM::AbstractDeviceComponent
  {
    public:
    // Operation
    //
    typedef ::CDM::AbstractOperationDescriptor OperationType;
    typedef ::xsd::cxx::tree::sequence< OperationType > OperationSequence;
    typedef OperationSequence::iterator OperationIterator;
    typedef OperationSequence::const_iterator OperationConstIterator;
    typedef ::xsd::cxx::tree::traits< OperationType, char > OperationTraits;

    const OperationSequence&
    Operation () const;

    OperationSequence&
    Operation ();

    void
    Operation (const OperationSequence& s);

    // Constructors.
    //
    SCODescriptor (const HandleType&);

    SCODescriptor (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    SCODescriptor (const SCODescriptor& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual SCODescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SCODescriptor&
    operator= (const SCODescriptor& x);

    virtual 
    ~SCODescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    OperationSequence Operation_;
  };

  class AbstractOperationDescriptor: public ::CDM::AbstractDescriptor
  {
    public:
    // ModifiableElement
    //
    typedef ::CDM::CodedValue ModifiableElementType;
    typedef ::xsd::cxx::tree::sequence< ModifiableElementType > ModifiableElementSequence;
    typedef ModifiableElementSequence::iterator ModifiableElementIterator;
    typedef ModifiableElementSequence::const_iterator ModifiableElementConstIterator;
    typedef ::xsd::cxx::tree::traits< ModifiableElementType, char > ModifiableElementTraits;

    const ModifiableElementSequence&
    ModifiableElement () const;

    ModifiableElementSequence&
    ModifiableElement ();

    void
    ModifiableElement (const ModifiableElementSequence& s);

    // OperationTarget
    //
    typedef ::CDM::HandleRef OperationTargetType;
    typedef ::xsd::cxx::tree::traits< OperationTargetType, char > OperationTargetTraits;

    const OperationTargetType&
    OperationTarget () const;

    OperationTargetType&
    OperationTarget ();

    void
    OperationTarget (const OperationTargetType& x);

    void
    OperationTarget (::std::unique_ptr< OperationTargetType > p);

    // Constructors.
    //
    AbstractOperationDescriptor (const HandleType&,
                                 const OperationTargetType&);

    AbstractOperationDescriptor (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    AbstractOperationDescriptor (const AbstractOperationDescriptor& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    virtual AbstractOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractOperationDescriptor&
    operator= (const AbstractOperationDescriptor& x);

    virtual 
    ~AbstractOperationDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ModifiableElementSequence ModifiableElement_;
    ::xsd::cxx::tree::one< OperationTargetType > OperationTarget_;
  };

  class SetValueOperationDescriptor: public ::CDM::AbstractOperationDescriptor
  {
    public:
    // Constructors.
    //
    SetValueOperationDescriptor (const HandleType&,
                                 const OperationTargetType&);

    SetValueOperationDescriptor (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    SetValueOperationDescriptor (const SetValueOperationDescriptor& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    virtual SetValueOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~SetValueOperationDescriptor ();
  };

  class SetStringOperationDescriptor: public ::CDM::AbstractOperationDescriptor
  {
    public:
    // Constructors.
    //
    SetStringOperationDescriptor (const HandleType&,
                                  const OperationTargetType&);

    SetStringOperationDescriptor (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    SetStringOperationDescriptor (const SetStringOperationDescriptor& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    virtual SetStringOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~SetStringOperationDescriptor ();
  };

  class ActivateOperationDescriptor: public ::CDM::AbstractOperationDescriptor
  {
    public:
    // Argument
    //
    typedef ::CDM::ArgumentDescriptorType ArgumentType;
    typedef ::xsd::cxx::tree::sequence< ArgumentType > ArgumentSequence;
    typedef ArgumentSequence::iterator ArgumentIterator;
    typedef ArgumentSequence::const_iterator ArgumentConstIterator;
    typedef ::xsd::cxx::tree::traits< ArgumentType, char > ArgumentTraits;

    const ArgumentSequence&
    Argument () const;

    ArgumentSequence&
    Argument ();

    void
    Argument (const ArgumentSequence& s);

    // ActivationDuration
    //
    typedef ::xml_schema::Duration ActivationDurationType;
    typedef ::xsd::cxx::tree::optional< ActivationDurationType > ActivationDurationOptional;
    typedef ::xsd::cxx::tree::traits< ActivationDurationType, char > ActivationDurationTraits;

    const ActivationDurationOptional&
    ActivationDuration () const;

    ActivationDurationOptional&
    ActivationDuration ();

    void
    ActivationDuration (const ActivationDurationType& x);

    void
    ActivationDuration (const ActivationDurationOptional& x);

    void
    ActivationDuration (::std::unique_ptr< ActivationDurationType > p);

    // Constructors.
    //
    ActivateOperationDescriptor (const HandleType&,
                                 const OperationTargetType&);

    ActivateOperationDescriptor (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    ActivateOperationDescriptor (const ActivateOperationDescriptor& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    virtual ActivateOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ActivateOperationDescriptor&
    operator= (const ActivateOperationDescriptor& x);

    virtual 
    ~ActivateOperationDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ArgumentSequence Argument_;
    ActivationDurationOptional ActivationDuration_;
  };

  class NonGenericOperationDescriptor: public ::CDM::AbstractOperationDescriptor
  {
    public:
    // Constructors.
    //
    NonGenericOperationDescriptor (const HandleType&,
                                   const OperationTargetType&);

    NonGenericOperationDescriptor (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    NonGenericOperationDescriptor (const NonGenericOperationDescriptor& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    virtual NonGenericOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~NonGenericOperationDescriptor ();
  };

  class SetAlertStateOperationDescriptor: public ::CDM::AbstractOperationDescriptor
  {
    public:
    // Constructors.
    //
    SetAlertStateOperationDescriptor (const HandleType&,
                                      const OperationTargetType&);

    SetAlertStateOperationDescriptor (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    SetAlertStateOperationDescriptor (const SetAlertStateOperationDescriptor& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    virtual SetAlertStateOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~SetAlertStateOperationDescriptor ();
  };

  class SetRangeOperationDescriptor: public ::CDM::AbstractOperationDescriptor
  {
    public:
    // AllowedMaxRange
    //
    typedef ::CDM::Range AllowedMaxRangeType;
    typedef ::xsd::cxx::tree::traits< AllowedMaxRangeType, char > AllowedMaxRangeTraits;

    const AllowedMaxRangeType&
    AllowedMaxRange () const;

    AllowedMaxRangeType&
    AllowedMaxRange ();

    void
    AllowedMaxRange (const AllowedMaxRangeType& x);

    void
    AllowedMaxRange (::std::unique_ptr< AllowedMaxRangeType > p);

    // Constructors.
    //
    SetRangeOperationDescriptor (const HandleType&,
                                 const OperationTargetType&,
                                 const AllowedMaxRangeType&);

    SetRangeOperationDescriptor (const HandleType&,
                                 const OperationTargetType&,
                                 ::std::unique_ptr< AllowedMaxRangeType >);

    SetRangeOperationDescriptor (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    SetRangeOperationDescriptor (const SetRangeOperationDescriptor& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    virtual SetRangeOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SetRangeOperationDescriptor&
    operator= (const SetRangeOperationDescriptor& x);

    virtual 
    ~SetRangeOperationDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< AllowedMaxRangeType > AllowedMaxRange_;
  };

  class SetContextOperationDescriptor: public ::CDM::AbstractOperationDescriptor
  {
    public:
    // Constructors.
    //
    SetContextOperationDescriptor (const HandleType&,
                                   const OperationTargetType&);

    SetContextOperationDescriptor (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    SetContextOperationDescriptor (const SetContextOperationDescriptor& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    virtual SetContextOperationDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~SetContextOperationDescriptor ();
  };

  class OperatingMode: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Dis,
      En,
      NA
    };

    OperatingMode (Value v);

    OperatingMode (const char* v);

    OperatingMode (const ::std::string& v);

    OperatingMode (const ::xml_schema::String& v);

    OperatingMode (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    OperatingMode (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    OperatingMode (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    OperatingMode (const OperatingMode& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual OperatingMode*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    OperatingMode&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_OperatingMode_convert ();
    }

    protected:
    Value
    _xsd_OperatingMode_convert () const;

    public:
    static const char* const _xsd_OperatingMode_literals_[3];
    static const Value _xsd_OperatingMode_indexes_[3];
  };

  class OperationState: public ::CDM::AbstractState
  {
    public:
    // OperatingMode
    //
    typedef ::CDM::OperatingMode OperatingModeType;
    typedef ::xsd::cxx::tree::traits< OperatingModeType, char > OperatingModeTraits;

    const OperatingModeType&
    OperatingMode () const;

    OperatingModeType&
    OperatingMode ();

    void
    OperatingMode (const OperatingModeType& x);

    void
    OperatingMode (::std::unique_ptr< OperatingModeType > p);

    // Constructors.
    //
    OperationState (const DescriptorHandleType&,
                    const OperatingModeType&);

    OperationState (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    OperationState (const OperationState& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual OperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    OperationState&
    operator= (const OperationState& x);

    virtual 
    ~OperationState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< OperatingModeType > OperatingMode_;
  };

  class SetValueOperationState: public ::CDM::OperationState
  {
    public:
    // allowedRange
    //
    typedef ::CDM::Range AllowedRangeType;
    typedef ::xsd::cxx::tree::sequence< AllowedRangeType > AllowedRangeSequence;
    typedef AllowedRangeSequence::iterator AllowedRangeIterator;
    typedef AllowedRangeSequence::const_iterator AllowedRangeConstIterator;
    typedef ::xsd::cxx::tree::traits< AllowedRangeType, char > AllowedRangeTraits;

    const AllowedRangeSequence&
    allowedRange () const;

    AllowedRangeSequence&
    allowedRange ();

    void
    allowedRange (const AllowedRangeSequence& s);

    // Constructors.
    //
    SetValueOperationState (const DescriptorHandleType&,
                            const OperatingModeType&);

    SetValueOperationState (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    SetValueOperationState (const SetValueOperationState& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    virtual SetValueOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SetValueOperationState&
    operator= (const SetValueOperationState& x);

    virtual 
    ~SetValueOperationState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AllowedRangeSequence allowedRange_;
  };

  class SetRangeOperationState: public ::CDM::OperationState
  {
    public:
    // allowedRange
    //
    typedef ::CDM::Range AllowedRangeType;
    typedef ::xsd::cxx::tree::sequence< AllowedRangeType > AllowedRangeSequence;
    typedef AllowedRangeSequence::iterator AllowedRangeIterator;
    typedef AllowedRangeSequence::const_iterator AllowedRangeConstIterator;
    typedef ::xsd::cxx::tree::traits< AllowedRangeType, char > AllowedRangeTraits;

    const AllowedRangeSequence&
    allowedRange () const;

    AllowedRangeSequence&
    allowedRange ();

    void
    allowedRange (const AllowedRangeSequence& s);

    // Constructors.
    //
    SetRangeOperationState (const DescriptorHandleType&,
                            const OperatingModeType&);

    SetRangeOperationState (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    SetRangeOperationState (const SetRangeOperationState& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    virtual SetRangeOperationState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SetRangeOperationState&
    operator= (const SetRangeOperationState& x);

    virtual 
    ~SetRangeOperationState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AllowedRangeSequence allowedRange_;
  };

  class TimeZone: public ::xml_schema::String
  {
    public:
    // Constructors.
    //
    TimeZone ();

    TimeZone (const char*);

    TimeZone (const ::std::string&);

    TimeZone (const ::xml_schema::String&);

    TimeZone (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    TimeZone (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    TimeZone (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    TimeZone (const TimeZone& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    virtual TimeZone*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~TimeZone ();
  };

  class ClockDescriptor: public ::CDM::AbstractDescriptor
  {
    public:
    // TimeProtocol
    //
    typedef ::CDM::CodedValue TimeProtocolType;
    typedef ::xsd::cxx::tree::sequence< TimeProtocolType > TimeProtocolSequence;
    typedef TimeProtocolSequence::iterator TimeProtocolIterator;
    typedef TimeProtocolSequence::const_iterator TimeProtocolConstIterator;
    typedef ::xsd::cxx::tree::traits< TimeProtocolType, char > TimeProtocolTraits;

    const TimeProtocolSequence&
    TimeProtocol () const;

    TimeProtocolSequence&
    TimeProtocol ();

    void
    TimeProtocol (const TimeProtocolSequence& s);

    // Resolution
    //
    typedef ::xml_schema::Duration ResolutionType;
    typedef ::xsd::cxx::tree::optional< ResolutionType > ResolutionOptional;
    typedef ::xsd::cxx::tree::traits< ResolutionType, char > ResolutionTraits;

    const ResolutionOptional&
    Resolution () const;

    ResolutionOptional&
    Resolution ();

    void
    Resolution (const ResolutionType& x);

    void
    Resolution (const ResolutionOptional& x);

    void
    Resolution (::std::unique_ptr< ResolutionType > p);

    // Constructors.
    //
    ClockDescriptor (const HandleType&);

    ClockDescriptor (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    ClockDescriptor (const ClockDescriptor& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual ClockDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ClockDescriptor&
    operator= (const ClockDescriptor& x);

    virtual 
    ~ClockDescriptor ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TimeProtocolSequence TimeProtocol_;
    ResolutionOptional Resolution_;
  };

  class ClockState: public ::CDM::AbstractState
  {
    public:
    // ActiveSyncProtocol
    //
    typedef ::CDM::CodedValue ActiveSyncProtocolType;
    typedef ::xsd::cxx::tree::optional< ActiveSyncProtocolType > ActiveSyncProtocolOptional;
    typedef ::xsd::cxx::tree::traits< ActiveSyncProtocolType, char > ActiveSyncProtocolTraits;

    const ActiveSyncProtocolOptional&
    ActiveSyncProtocol () const;

    ActiveSyncProtocolOptional&
    ActiveSyncProtocol ();

    void
    ActiveSyncProtocol (const ActiveSyncProtocolType& x);

    void
    ActiveSyncProtocol (const ActiveSyncProtocolOptional& x);

    void
    ActiveSyncProtocol (::std::unique_ptr< ActiveSyncProtocolType > p);

    // DateAndTime
    //
    typedef ::CDM::Timestamp DateAndTimeType;
    typedef ::xsd::cxx::tree::optional< DateAndTimeType > DateAndTimeOptional;
    typedef ::xsd::cxx::tree::traits< DateAndTimeType, char > DateAndTimeTraits;

    const DateAndTimeOptional&
    DateAndTime () const;

    DateAndTimeOptional&
    DateAndTime ();

    void
    DateAndTime (const DateAndTimeType& x);

    void
    DateAndTime (const DateAndTimeOptional& x);

    void
    DateAndTime (::std::unique_ptr< DateAndTimeType > p);

    // RemoteSync
    //
    typedef ::xml_schema::Boolean RemoteSyncType;
    typedef ::xsd::cxx::tree::traits< RemoteSyncType, char > RemoteSyncTraits;

    const RemoteSyncType&
    RemoteSync () const;

    RemoteSyncType&
    RemoteSync ();

    void
    RemoteSync (const RemoteSyncType& x);

    // ReferenceSource
    //
    typedef ::xml_schema::Uri ReferenceSourceType;
    typedef ::xsd::cxx::tree::optional< ReferenceSourceType > ReferenceSourceOptional;
    typedef ::xsd::cxx::tree::traits< ReferenceSourceType, char > ReferenceSourceTraits;

    const ReferenceSourceOptional&
    ReferenceSource () const;

    ReferenceSourceOptional&
    ReferenceSource ();

    void
    ReferenceSource (const ReferenceSourceType& x);

    void
    ReferenceSource (const ReferenceSourceOptional& x);

    void
    ReferenceSource (::std::unique_ptr< ReferenceSourceType > p);

    // Accuracy
    //
    typedef ::xml_schema::Decimal AccuracyType;
    typedef ::xsd::cxx::tree::optional< AccuracyType > AccuracyOptional;
    typedef ::xsd::cxx::tree::traits< AccuracyType, char, ::xsd::cxx::tree::schema_type::decimal > AccuracyTraits;

    const AccuracyOptional&
    Accuracy () const;

    AccuracyOptional&
    Accuracy ();

    void
    Accuracy (const AccuracyType& x);

    void
    Accuracy (const AccuracyOptional& x);

    // LastSet
    //
    typedef ::CDM::Timestamp LastSetType;
    typedef ::xsd::cxx::tree::optional< LastSetType > LastSetOptional;
    typedef ::xsd::cxx::tree::traits< LastSetType, char > LastSetTraits;

    const LastSetOptional&
    LastSet () const;

    LastSetOptional&
    LastSet ();

    void
    LastSet (const LastSetType& x);

    void
    LastSet (const LastSetOptional& x);

    void
    LastSet (::std::unique_ptr< LastSetType > p);

    // TimeZone
    //
    typedef ::CDM::TimeZone TimeZoneType;
    typedef ::xsd::cxx::tree::optional< TimeZoneType > TimeZoneOptional;
    typedef ::xsd::cxx::tree::traits< TimeZoneType, char > TimeZoneTraits;

    const TimeZoneOptional&
    TimeZone () const;

    TimeZoneOptional&
    TimeZone ();

    void
    TimeZone (const TimeZoneType& x);

    void
    TimeZone (const TimeZoneOptional& x);

    void
    TimeZone (::std::unique_ptr< TimeZoneType > p);

    // CriticalUse
    //
    typedef ::xml_schema::Boolean CriticalUseType;
    typedef ::xsd::cxx::tree::optional< CriticalUseType > CriticalUseOptional;
    typedef ::xsd::cxx::tree::traits< CriticalUseType, char > CriticalUseTraits;

    const CriticalUseOptional&
    CriticalUse () const;

    CriticalUseOptional&
    CriticalUse ();

    void
    CriticalUse (const CriticalUseType& x);

    void
    CriticalUse (const CriticalUseOptional& x);

    // Constructors.
    //
    ClockState (const DescriptorHandleType&,
                const RemoteSyncType&);

    ClockState (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    ClockState (const ClockState& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual ClockState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ClockState&
    operator= (const ClockState& x);

    virtual 
    ~ClockState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ActiveSyncProtocolOptional ActiveSyncProtocol_;
    DateAndTimeOptional DateAndTime_;
    ::xsd::cxx::tree::one< RemoteSyncType > RemoteSync_;
    ReferenceSourceOptional ReferenceSource_;
    AccuracyOptional Accuracy_;
    LastSetOptional LastSet_;
    TimeZoneOptional TimeZone_;
    CriticalUseOptional CriticalUse_;
  };

  class AbstractContextDescriptor: public ::CDM::AbstractDescriptor
  {
    public:
    // Constructors.
    //
    AbstractContextDescriptor (const HandleType&);

    AbstractContextDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    AbstractContextDescriptor (const AbstractContextDescriptor& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    virtual AbstractContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~AbstractContextDescriptor ();
  };

  class LocationContextDescriptor: public ::CDM::AbstractContextDescriptor
  {
    public:
    // Constructors.
    //
    LocationContextDescriptor (const HandleType&);

    LocationContextDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    LocationContextDescriptor (const LocationContextDescriptor& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    virtual LocationContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~LocationContextDescriptor ();
  };

  class EnsembleContextDescriptor: public ::CDM::AbstractContextDescriptor
  {
    public:
    // Constructors.
    //
    EnsembleContextDescriptor (const HandleType&);

    EnsembleContextDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    EnsembleContextDescriptor (const EnsembleContextDescriptor& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    virtual EnsembleContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~EnsembleContextDescriptor ();
  };

  class OperatorContextDescriptor: public ::CDM::AbstractContextDescriptor
  {
    public:
    // Constructors.
    //
    OperatorContextDescriptor (const HandleType&);

    OperatorContextDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    OperatorContextDescriptor (const OperatorContextDescriptor& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    virtual OperatorContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~OperatorContextDescriptor ();
  };

  class WorkflowContextDescriptor: public ::CDM::AbstractContextDescriptor
  {
    public:
    // Constructors.
    //
    WorkflowContextDescriptor (const HandleType&);

    WorkflowContextDescriptor (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    WorkflowContextDescriptor (const WorkflowContextDescriptor& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    virtual WorkflowContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~WorkflowContextDescriptor ();
  };

  class AbstractContextState: public ::CDM::AbstractState
  {
    public:
    // Validator
    //
    typedef ::CDM::InstanceIdentifier ValidatorType;
    typedef ::xsd::cxx::tree::sequence< ValidatorType > ValidatorSequence;
    typedef ValidatorSequence::iterator ValidatorIterator;
    typedef ValidatorSequence::const_iterator ValidatorConstIterator;
    typedef ::xsd::cxx::tree::traits< ValidatorType, char > ValidatorTraits;

    const ValidatorSequence&
    Validator () const;

    ValidatorSequence&
    Validator ();

    void
    Validator (const ValidatorSequence& s);

    // ContextAssociation
    //
    typedef ::CDM::ContextAssociation ContextAssociationType;
    typedef ::xsd::cxx::tree::optional< ContextAssociationType > ContextAssociationOptional;
    typedef ::xsd::cxx::tree::traits< ContextAssociationType, char > ContextAssociationTraits;

    const ContextAssociationOptional&
    ContextAssociation () const;

    ContextAssociationOptional&
    ContextAssociation ();

    void
    ContextAssociation (const ContextAssociationType& x);

    void
    ContextAssociation (const ContextAssociationOptional& x);

    void
    ContextAssociation (::std::unique_ptr< ContextAssociationType > p);

    // BindingMDIBVersion
    //
    typedef ::CDM::ReferencedVersion BindingMDIBVersionType;
    typedef ::xsd::cxx::tree::traits< BindingMDIBVersionType, char > BindingMDIBVersionTraits;

    const BindingMDIBVersionType&
    BindingMDIBVersion () const;

    BindingMDIBVersionType&
    BindingMDIBVersion ();

    void
    BindingMDIBVersion (const BindingMDIBVersionType& x);

    void
    BindingMDIBVersion (::std::unique_ptr< BindingMDIBVersionType > p);

    // UnbindingMDIBVersion
    //
    typedef ::CDM::ReferencedVersion UnbindingMDIBVersionType;
    typedef ::xsd::cxx::tree::optional< UnbindingMDIBVersionType > UnbindingMDIBVersionOptional;
    typedef ::xsd::cxx::tree::traits< UnbindingMDIBVersionType, char > UnbindingMDIBVersionTraits;

    const UnbindingMDIBVersionOptional&
    UnbindingMDIBVersion () const;

    UnbindingMDIBVersionOptional&
    UnbindingMDIBVersion ();

    void
    UnbindingMDIBVersion (const UnbindingMDIBVersionType& x);

    void
    UnbindingMDIBVersion (const UnbindingMDIBVersionOptional& x);

    void
    UnbindingMDIBVersion (::std::unique_ptr< UnbindingMDIBVersionType > p);

    // BindingStartTime
    //
    typedef ::CDM::Timestamp BindingStartTimeType;
    typedef ::xsd::cxx::tree::optional< BindingStartTimeType > BindingStartTimeOptional;
    typedef ::xsd::cxx::tree::traits< BindingStartTimeType, char > BindingStartTimeTraits;

    const BindingStartTimeOptional&
    BindingStartTime () const;

    BindingStartTimeOptional&
    BindingStartTime ();

    void
    BindingStartTime (const BindingStartTimeType& x);

    void
    BindingStartTime (const BindingStartTimeOptional& x);

    void
    BindingStartTime (::std::unique_ptr< BindingStartTimeType > p);

    // BindingEndTime
    //
    typedef ::CDM::Timestamp BindingEndTimeType;
    typedef ::xsd::cxx::tree::optional< BindingEndTimeType > BindingEndTimeOptional;
    typedef ::xsd::cxx::tree::traits< BindingEndTimeType, char > BindingEndTimeTraits;

    const BindingEndTimeOptional&
    BindingEndTime () const;

    BindingEndTimeOptional&
    BindingEndTime ();

    void
    BindingEndTime (const BindingEndTimeType& x);

    void
    BindingEndTime (const BindingEndTimeOptional& x);

    void
    BindingEndTime (::std::unique_ptr< BindingEndTimeType > p);

    // Constructors.
    //
    AbstractContextState (const DescriptorHandleType&,
                          const BindingMDIBVersionType&);

    AbstractContextState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    AbstractContextState (const AbstractContextState& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual AbstractContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractContextState&
    operator= (const AbstractContextState& x);

    virtual 
    ~AbstractContextState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ValidatorSequence Validator_;
    ContextAssociationOptional ContextAssociation_;
    ::xsd::cxx::tree::one< BindingMDIBVersionType > BindingMDIBVersion_;
    UnbindingMDIBVersionOptional UnbindingMDIBVersion_;
    BindingStartTimeOptional BindingStartTime_;
    BindingEndTimeOptional BindingEndTime_;
  };

  class AbstractIdentifiableContextState: public ::CDM::AbstractContextState
  {
    public:
    // Identification
    //
    typedef ::CDM::InstanceIdentifier IdentificationType;
    typedef ::xsd::cxx::tree::sequence< IdentificationType > IdentificationSequence;
    typedef IdentificationSequence::iterator IdentificationIterator;
    typedef IdentificationSequence::const_iterator IdentificationConstIterator;
    typedef ::xsd::cxx::tree::traits< IdentificationType, char > IdentificationTraits;

    const IdentificationSequence&
    Identification () const;

    IdentificationSequence&
    Identification ();

    void
    Identification (const IdentificationSequence& s);

    // Constructors.
    //
    AbstractIdentifiableContextState (const DescriptorHandleType&,
                                      const BindingMDIBVersionType&);

    AbstractIdentifiableContextState (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    AbstractIdentifiableContextState (const AbstractIdentifiableContextState& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    virtual AbstractIdentifiableContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    AbstractIdentifiableContextState&
    operator= (const AbstractIdentifiableContextState& x);

    virtual 
    ~AbstractIdentifiableContextState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    IdentificationSequence Identification_;
  };

  class LocationContextState: public ::CDM::AbstractIdentifiableContextState
  {
    public:
    // Constructors.
    //
    LocationContextState (const DescriptorHandleType&,
                          const BindingMDIBVersionType&);

    LocationContextState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    LocationContextState (const LocationContextState& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual LocationContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~LocationContextState ();
  };

  class EnsembleContextState: public ::CDM::AbstractIdentifiableContextState
  {
    public:
    // Constructors.
    //
    EnsembleContextState (const DescriptorHandleType&,
                          const BindingMDIBVersionType&);

    EnsembleContextState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    EnsembleContextState (const EnsembleContextState& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual EnsembleContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~EnsembleContextState ();
  };

  class WorkflowContextState: public ::CDM::AbstractIdentifiableContextState
  {
    public:
    // OrderDetail
    //
    typedef ::CDM::Order OrderDetailType;
    typedef ::xsd::cxx::tree::optional< OrderDetailType > OrderDetailOptional;
    typedef ::xsd::cxx::tree::traits< OrderDetailType, char > OrderDetailTraits;

    const OrderDetailOptional&
    OrderDetail () const;

    OrderDetailOptional&
    OrderDetail ();

    void
    OrderDetail (const OrderDetailType& x);

    void
    OrderDetail (const OrderDetailOptional& x);

    void
    OrderDetail (::std::unique_ptr< OrderDetailType > p);

    // Constructors.
    //
    WorkflowContextState (const DescriptorHandleType&,
                          const BindingMDIBVersionType&);

    WorkflowContextState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    WorkflowContextState (const WorkflowContextState& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual WorkflowContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    WorkflowContextState&
    operator= (const WorkflowContextState& x);

    virtual 
    ~WorkflowContextState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    OrderDetailOptional OrderDetail_;
  };

  class OperatorContextState: public ::CDM::AbstractIdentifiableContextState
  {
    public:
    // Constructors.
    //
    OperatorContextState (const DescriptorHandleType&,
                          const BindingMDIBVersionType&);

    OperatorContextState (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    OperatorContextState (const OperatorContextState& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual OperatorContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~OperatorContextState ();
  };

  class ContextAssociation: public ::xml_schema::String
  {
    public:
    enum Value
    {
      No,
      Pre,
      Assoc,
      Dis
    };

    ContextAssociation (Value v);

    ContextAssociation (const char* v);

    ContextAssociation (const ::std::string& v);

    ContextAssociation (const ::xml_schema::String& v);

    ContextAssociation (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    ContextAssociation (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    ContextAssociation (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    ContextAssociation (const ContextAssociation& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual ContextAssociation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ContextAssociation&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_ContextAssociation_convert ();
    }

    protected:
    Value
    _xsd_ContextAssociation_convert () const;

    public:
    static const char* const _xsd_ContextAssociation_literals_[4];
    static const Value _xsd_ContextAssociation_indexes_[4];
  };

  class PatientContextDescriptor: public ::CDM::AbstractContextDescriptor
  {
    public:
    // Constructors.
    //
    PatientContextDescriptor (const HandleType&);

    PatientContextDescriptor (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    PatientContextDescriptor (const PatientContextDescriptor& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    virtual PatientContextDescriptor*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~PatientContextDescriptor ();
  };

  class BaseDemographics: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Givenname
    //
    typedef ::xml_schema::String GivennameType;
    typedef ::xsd::cxx::tree::optional< GivennameType > GivennameOptional;
    typedef ::xsd::cxx::tree::traits< GivennameType, char > GivennameTraits;

    const GivennameOptional&
    Givenname () const;

    GivennameOptional&
    Givenname ();

    void
    Givenname (const GivennameType& x);

    void
    Givenname (const GivennameOptional& x);

    void
    Givenname (::std::unique_ptr< GivennameType > p);

    // Middlename
    //
    typedef ::xml_schema::String MiddlenameType;
    typedef ::xsd::cxx::tree::sequence< MiddlenameType > MiddlenameSequence;
    typedef MiddlenameSequence::iterator MiddlenameIterator;
    typedef MiddlenameSequence::const_iterator MiddlenameConstIterator;
    typedef ::xsd::cxx::tree::traits< MiddlenameType, char > MiddlenameTraits;

    const MiddlenameSequence&
    Middlename () const;

    MiddlenameSequence&
    Middlename ();

    void
    Middlename (const MiddlenameSequence& s);

    // Familyname
    //
    typedef ::xml_schema::String FamilynameType;
    typedef ::xsd::cxx::tree::optional< FamilynameType > FamilynameOptional;
    typedef ::xsd::cxx::tree::traits< FamilynameType, char > FamilynameTraits;

    const FamilynameOptional&
    Familyname () const;

    FamilynameOptional&
    Familyname ();

    void
    Familyname (const FamilynameType& x);

    void
    Familyname (const FamilynameOptional& x);

    void
    Familyname (::std::unique_ptr< FamilynameType > p);

    // Birthname
    //
    typedef ::xml_schema::String BirthnameType;
    typedef ::xsd::cxx::tree::optional< BirthnameType > BirthnameOptional;
    typedef ::xsd::cxx::tree::traits< BirthnameType, char > BirthnameTraits;

    const BirthnameOptional&
    Birthname () const;

    BirthnameOptional&
    Birthname ();

    void
    Birthname (const BirthnameType& x);

    void
    Birthname (const BirthnameOptional& x);

    void
    Birthname (::std::unique_ptr< BirthnameType > p);

    // Title
    //
    typedef ::xml_schema::String TitleType;
    typedef ::xsd::cxx::tree::optional< TitleType > TitleOptional;
    typedef ::xsd::cxx::tree::traits< TitleType, char > TitleTraits;

    const TitleOptional&
    Title () const;

    TitleOptional&
    Title ();

    void
    Title (const TitleType& x);

    void
    Title (const TitleOptional& x);

    void
    Title (::std::unique_ptr< TitleType > p);

    // Constructors.
    //
    BaseDemographics ();

    BaseDemographics (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    BaseDemographics (const BaseDemographics& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual BaseDemographics*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    BaseDemographics&
    operator= (const BaseDemographics& x);

    virtual 
    ~BaseDemographics ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    GivennameOptional Givenname_;
    MiddlenameSequence Middlename_;
    FamilynameOptional Familyname_;
    BirthnameOptional Birthname_;
    TitleOptional Title_;
  };

  class PatientDemographicsCoreData: public ::CDM::BaseDemographics
  {
    public:
    // Sex
    //
    typedef ::CDM::Sex SexType;
    typedef ::xsd::cxx::tree::optional< SexType > SexOptional;
    typedef ::xsd::cxx::tree::traits< SexType, char > SexTraits;

    const SexOptional&
    Sex () const;

    SexOptional&
    Sex ();

    void
    Sex (const SexType& x);

    void
    Sex (const SexOptional& x);

    void
    Sex (::std::unique_ptr< SexType > p);

    // PatientType
    //
    typedef ::CDM::PatientType PatientTypeType;
    typedef ::xsd::cxx::tree::optional< PatientTypeType > PatientTypeOptional;
    typedef ::xsd::cxx::tree::traits< PatientTypeType, char > PatientTypeTraits;

    const PatientTypeOptional&
    PatientType () const;

    PatientTypeOptional&
    PatientType ();

    void
    PatientType (const PatientTypeType& x);

    void
    PatientType (const PatientTypeOptional& x);

    void
    PatientType (::std::unique_ptr< PatientTypeType > p);

    // DateOfBirth
    //
    typedef ::xml_schema::DateTime DateOfBirthType;
    typedef ::xsd::cxx::tree::optional< DateOfBirthType > DateOfBirthOptional;
    typedef ::xsd::cxx::tree::traits< DateOfBirthType, char > DateOfBirthTraits;

    const DateOfBirthOptional&
    DateOfBirth () const;

    DateOfBirthOptional&
    DateOfBirth ();

    void
    DateOfBirth (const DateOfBirthType& x);

    void
    DateOfBirth (const DateOfBirthOptional& x);

    void
    DateOfBirth (::std::unique_ptr< DateOfBirthType > p);

    // Height
    //
    typedef ::CDM::Measure HeightType;
    typedef ::xsd::cxx::tree::optional< HeightType > HeightOptional;
    typedef ::xsd::cxx::tree::traits< HeightType, char > HeightTraits;

    const HeightOptional&
    Height () const;

    HeightOptional&
    Height ();

    void
    Height (const HeightType& x);

    void
    Height (const HeightOptional& x);

    void
    Height (::std::unique_ptr< HeightType > p);

    // Weight
    //
    typedef ::CDM::Measure WeightType;
    typedef ::xsd::cxx::tree::optional< WeightType > WeightOptional;
    typedef ::xsd::cxx::tree::traits< WeightType, char > WeightTraits;

    const WeightOptional&
    Weight () const;

    WeightOptional&
    Weight ();

    void
    Weight (const WeightType& x);

    void
    Weight (const WeightOptional& x);

    void
    Weight (::std::unique_ptr< WeightType > p);

    // Race
    //
    typedef ::CDM::CodedValue RaceType;
    typedef ::xsd::cxx::tree::optional< RaceType > RaceOptional;
    typedef ::xsd::cxx::tree::traits< RaceType, char > RaceTraits;

    const RaceOptional&
    Race () const;

    RaceOptional&
    Race ();

    void
    Race (const RaceType& x);

    void
    Race (const RaceOptional& x);

    void
    Race (::std::unique_ptr< RaceType > p);

    // Constructors.
    //
    PatientDemographicsCoreData ();

    PatientDemographicsCoreData (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    PatientDemographicsCoreData (const PatientDemographicsCoreData& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    virtual PatientDemographicsCoreData*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    PatientDemographicsCoreData&
    operator= (const PatientDemographicsCoreData& x);

    virtual 
    ~PatientDemographicsCoreData ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SexOptional Sex_;
    PatientTypeOptional PatientType_;
    DateOfBirthOptional DateOfBirth_;
    HeightOptional Height_;
    WeightOptional Weight_;
    RaceOptional Race_;
  };

  class PersonReference: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Identification
    //
    typedef ::CDM::InstanceIdentifier IdentificationType;
    typedef ::xsd::cxx::tree::sequence< IdentificationType > IdentificationSequence;
    typedef IdentificationSequence::iterator IdentificationIterator;
    typedef IdentificationSequence::const_iterator IdentificationConstIterator;
    typedef ::xsd::cxx::tree::traits< IdentificationType, char > IdentificationTraits;

    const IdentificationSequence&
    Identification () const;

    IdentificationSequence&
    Identification ();

    void
    Identification (const IdentificationSequence& s);

    // Name
    //
    typedef ::CDM::BaseDemographics NameType;
    typedef ::xsd::cxx::tree::sequence< NameType > NameSequence;
    typedef NameSequence::iterator NameIterator;
    typedef NameSequence::const_iterator NameConstIterator;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameSequence&
    Name () const;

    NameSequence&
    Name ();

    void
    Name (const NameSequence& s);

    // Constructors.
    //
    PersonReference ();

    PersonReference (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    PersonReference (const PersonReference& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual PersonReference*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    PersonReference&
    operator= (const PersonReference& x);

    virtual 
    ~PersonReference ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    IdentificationSequence Identification_;
    NameSequence Name_;
  };

  class PersonParticipation: public ::CDM::PersonReference
  {
    public:
    // Role
    //
    typedef ::CDM::CodedValue RoleType;
    typedef ::xsd::cxx::tree::sequence< RoleType > RoleSequence;
    typedef RoleSequence::iterator RoleIterator;
    typedef RoleSequence::const_iterator RoleConstIterator;
    typedef ::xsd::cxx::tree::traits< RoleType, char > RoleTraits;

    const RoleSequence&
    Role () const;

    RoleSequence&
    Role ();

    void
    Role (const RoleSequence& s);

    // Constructors.
    //
    PersonParticipation ();

    PersonParticipation (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    PersonParticipation (const PersonParticipation& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual PersonParticipation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    PersonParticipation&
    operator= (const PersonParticipation& x);

    virtual 
    ~PersonParticipation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    RoleSequence Role_;
  };

  class NeonatalPatientDemographicsCoreData: public ::CDM::PatientDemographicsCoreData
  {
    public:
    // Gestational-Age
    //
    typedef ::CDM::Measure Gestational_AgeType;
    typedef ::xsd::cxx::tree::optional< Gestational_AgeType > Gestational_AgeOptional;
    typedef ::xsd::cxx::tree::traits< Gestational_AgeType, char > Gestational_AgeTraits;

    const Gestational_AgeOptional&
    Gestational_Age () const;

    Gestational_AgeOptional&
    Gestational_Age ();

    void
    Gestational_Age (const Gestational_AgeType& x);

    void
    Gestational_Age (const Gestational_AgeOptional& x);

    void
    Gestational_Age (::std::unique_ptr< Gestational_AgeType > p);

    // BirthLength
    //
    typedef ::CDM::Measure BirthLengthType;
    typedef ::xsd::cxx::tree::optional< BirthLengthType > BirthLengthOptional;
    typedef ::xsd::cxx::tree::traits< BirthLengthType, char > BirthLengthTraits;

    const BirthLengthOptional&
    BirthLength () const;

    BirthLengthOptional&
    BirthLength ();

    void
    BirthLength (const BirthLengthType& x);

    void
    BirthLength (const BirthLengthOptional& x);

    void
    BirthLength (::std::unique_ptr< BirthLengthType > p);

    // BirthWeight
    //
    typedef ::CDM::Measure BirthWeightType;
    typedef ::xsd::cxx::tree::optional< BirthWeightType > BirthWeightOptional;
    typedef ::xsd::cxx::tree::traits< BirthWeightType, char > BirthWeightTraits;

    const BirthWeightOptional&
    BirthWeight () const;

    BirthWeightOptional&
    BirthWeight ();

    void
    BirthWeight (const BirthWeightType& x);

    void
    BirthWeight (const BirthWeightOptional& x);

    void
    BirthWeight (::std::unique_ptr< BirthWeightType > p);

    // HeadCircumference
    //
    typedef ::CDM::Measure HeadCircumferenceType;
    typedef ::xsd::cxx::tree::optional< HeadCircumferenceType > HeadCircumferenceOptional;
    typedef ::xsd::cxx::tree::traits< HeadCircumferenceType, char > HeadCircumferenceTraits;

    const HeadCircumferenceOptional&
    HeadCircumference () const;

    HeadCircumferenceOptional&
    HeadCircumference ();

    void
    HeadCircumference (const HeadCircumferenceType& x);

    void
    HeadCircumference (const HeadCircumferenceOptional& x);

    void
    HeadCircumference (::std::unique_ptr< HeadCircumferenceType > p);

    // Mother
    //
    typedef ::CDM::PersonReference MotherType;
    typedef ::xsd::cxx::tree::optional< MotherType > MotherOptional;
    typedef ::xsd::cxx::tree::traits< MotherType, char > MotherTraits;

    const MotherOptional&
    Mother () const;

    MotherOptional&
    Mother ();

    void
    Mother (const MotherType& x);

    void
    Mother (const MotherOptional& x);

    void
    Mother (::std::unique_ptr< MotherType > p);

    // Constructors.
    //
    NeonatalPatientDemographicsCoreData ();

    NeonatalPatientDemographicsCoreData (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    NeonatalPatientDemographicsCoreData (const NeonatalPatientDemographicsCoreData& x,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    virtual NeonatalPatientDemographicsCoreData*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    NeonatalPatientDemographicsCoreData&
    operator= (const NeonatalPatientDemographicsCoreData& x);

    virtual 
    ~NeonatalPatientDemographicsCoreData ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Gestational_AgeOptional Gestational_Age_;
    BirthLengthOptional BirthLength_;
    BirthWeightOptional BirthWeight_;
    HeadCircumferenceOptional HeadCircumference_;
    MotherOptional Mother_;
  };

  class PatientContextState: public ::CDM::AbstractIdentifiableContextState
  {
    public:
    // CoreData
    //
    typedef ::CDM::PatientDemographicsCoreData CoreDataType;
    typedef ::xsd::cxx::tree::optional< CoreDataType > CoreDataOptional;
    typedef ::xsd::cxx::tree::traits< CoreDataType, char > CoreDataTraits;

    const CoreDataOptional&
    CoreData () const;

    CoreDataOptional&
    CoreData ();

    void
    CoreData (const CoreDataType& x);

    void
    CoreData (const CoreDataOptional& x);

    void
    CoreData (::std::unique_ptr< CoreDataType > p);

    // Constructors.
    //
    PatientContextState (const DescriptorHandleType&,
                         const BindingMDIBVersionType&);

    PatientContextState (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    PatientContextState (const PatientContextState& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual PatientContextState*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    PatientContextState&
    operator= (const PatientContextState& x);

    virtual 
    ~PatientContextState ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CoreDataOptional CoreData_;
  };

  class Sex: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Unspec,
      M,
      F,
      Unkn
    };

    Sex (Value v);

    Sex (const char* v);

    Sex (const ::std::string& v);

    Sex (const ::xml_schema::String& v);

    Sex (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    Sex (const ::xercesc::DOMAttr& a,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    Sex (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    Sex (const Sex& x,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    virtual Sex*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Sex&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_Sex_convert ();
    }

    protected:
    Value
    _xsd_Sex_convert () const;

    public:
    static const char* const _xsd_Sex_literals_[4];
    static const Value _xsd_Sex_indexes_[4];
  };

  class PatientType: public ::xml_schema::String
  {
    public:
    enum Value
    {
      Unspec,
      Ad,
      Ped,
      Neo
    };

    PatientType (Value v);

    PatientType (const char* v);

    PatientType (const ::std::string& v);

    PatientType (const ::xml_schema::String& v);

    PatientType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    PatientType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    PatientType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    PatientType (const PatientType& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual PatientType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    PatientType&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_PatientType_convert ();
    }

    protected:
    Value
    _xsd_PatientType_convert () const;

    public:
    static const char* const _xsd_PatientType_literals_[4];
    static const Value _xsd_PatientType_indexes_[4];
  };

  class ContainmentTree: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Entry
    //
    typedef ::CDM::ContainmentTreeEntry EntryType;
    typedef ::xsd::cxx::tree::sequence< EntryType > EntrySequence;
    typedef EntrySequence::iterator EntryIterator;
    typedef EntrySequence::const_iterator EntryConstIterator;
    typedef ::xsd::cxx::tree::traits< EntryType, char > EntryTraits;

    const EntrySequence&
    Entry () const;

    EntrySequence&
    Entry ();

    void
    Entry (const EntrySequence& s);

    // HandleRef
    //
    typedef ::CDM::HandleRef HandleRefType;
    typedef ::xsd::cxx::tree::optional< HandleRefType > HandleRefOptional;
    typedef ::xsd::cxx::tree::traits< HandleRefType, char > HandleRefTraits;

    const HandleRefOptional&
    HandleRef () const;

    HandleRefOptional&
    HandleRef ();

    void
    HandleRef (const HandleRefType& x);

    void
    HandleRef (const HandleRefOptional& x);

    void
    HandleRef (::std::unique_ptr< HandleRefType > p);

    // ParentHandleRef
    //
    typedef ::CDM::HandleRef ParentHandleRefType;
    typedef ::xsd::cxx::tree::optional< ParentHandleRefType > ParentHandleRefOptional;
    typedef ::xsd::cxx::tree::traits< ParentHandleRefType, char > ParentHandleRefTraits;

    const ParentHandleRefOptional&
    ParentHandleRef () const;

    ParentHandleRefOptional&
    ParentHandleRef ();

    void
    ParentHandleRef (const ParentHandleRefType& x);

    void
    ParentHandleRef (const ParentHandleRefOptional& x);

    void
    ParentHandleRef (::std::unique_ptr< ParentHandleRefType > p);

    // EntryType
    //
    typedef ::xml_schema::Qname EntryTypeType;
    typedef ::xsd::cxx::tree::optional< EntryTypeType > EntryTypeOptional;
    typedef ::xsd::cxx::tree::traits< EntryTypeType, char > EntryTypeTraits;

    const EntryTypeOptional&
    EntryType1 () const;

    EntryTypeOptional&
    EntryType1 ();

    void
    EntryType1 (const EntryTypeType& x);

    void
    EntryType1 (const EntryTypeOptional& x);

    void
    EntryType1 (::std::unique_ptr< EntryTypeType > p);

    // ChildrenCount
    //
    typedef ::xml_schema::Int ChildrenCountType;
    typedef ::xsd::cxx::tree::optional< ChildrenCountType > ChildrenCountOptional;
    typedef ::xsd::cxx::tree::traits< ChildrenCountType, char > ChildrenCountTraits;

    const ChildrenCountOptional&
    ChildrenCount () const;

    ChildrenCountOptional&
    ChildrenCount ();

    void
    ChildrenCount (const ChildrenCountType& x);

    void
    ChildrenCount (const ChildrenCountOptional& x);

    // Constructors.
    //
    ContainmentTree ();

    ContainmentTree (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    ContainmentTree (const ContainmentTree& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual ContainmentTree*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ContainmentTree&
    operator= (const ContainmentTree& x);

    virtual 
    ~ContainmentTree ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    EntrySequence Entry_;
    HandleRefOptional HandleRef_;
    ParentHandleRefOptional ParentHandleRef_;
    EntryTypeOptional EntryType_;
    ChildrenCountOptional ChildrenCount_;
  };

  class ContainmentTreeEntry: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Type
    //
    typedef ::CDM::CodedValue TypeType;
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeOptional&
    Type () const;

    TypeOptional&
    Type ();

    void
    Type (const TypeType& x);

    void
    Type (const TypeOptional& x);

    void
    Type (::std::unique_ptr< TypeType > p);

    // HandleRef
    //
    typedef ::CDM::HandleRef HandleRefType;
    typedef ::xsd::cxx::tree::optional< HandleRefType > HandleRefOptional;
    typedef ::xsd::cxx::tree::traits< HandleRefType, char > HandleRefTraits;

    const HandleRefOptional&
    HandleRef () const;

    HandleRefOptional&
    HandleRef ();

    void
    HandleRef (const HandleRefType& x);

    void
    HandleRef (const HandleRefOptional& x);

    void
    HandleRef (::std::unique_ptr< HandleRefType > p);

    // ParentHandleRef
    //
    typedef ::CDM::HandleRef ParentHandleRefType;
    typedef ::xsd::cxx::tree::optional< ParentHandleRefType > ParentHandleRefOptional;
    typedef ::xsd::cxx::tree::traits< ParentHandleRefType, char > ParentHandleRefTraits;

    const ParentHandleRefOptional&
    ParentHandleRef () const;

    ParentHandleRefOptional&
    ParentHandleRef ();

    void
    ParentHandleRef (const ParentHandleRefType& x);

    void
    ParentHandleRef (const ParentHandleRefOptional& x);

    void
    ParentHandleRef (::std::unique_ptr< ParentHandleRefType > p);

    // EntryType
    //
    typedef ::xml_schema::Qname EntryTypeType;
    typedef ::xsd::cxx::tree::optional< EntryTypeType > EntryTypeOptional;
    typedef ::xsd::cxx::tree::traits< EntryTypeType, char > EntryTypeTraits;

    const EntryTypeOptional&
    EntryType () const;

    EntryTypeOptional&
    EntryType ();

    void
    EntryType (const EntryTypeType& x);

    void
    EntryType (const EntryTypeOptional& x);

    void
    EntryType (::std::unique_ptr< EntryTypeType > p);

    // ChildrenCount
    //
    typedef ::xml_schema::Int ChildrenCountType;
    typedef ::xsd::cxx::tree::optional< ChildrenCountType > ChildrenCountOptional;
    typedef ::xsd::cxx::tree::traits< ChildrenCountType, char > ChildrenCountTraits;

    const ChildrenCountOptional&
    ChildrenCount () const;

    ChildrenCountOptional&
    ChildrenCount ();

    void
    ChildrenCount (const ChildrenCountType& x);

    void
    ChildrenCount (const ChildrenCountOptional& x);

    // Constructors.
    //
    ContainmentTreeEntry ();

    ContainmentTreeEntry (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    ContainmentTreeEntry (const ContainmentTreeEntry& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual ContainmentTreeEntry*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ContainmentTreeEntry&
    operator= (const ContainmentTreeEntry& x);

    virtual 
    ~ContainmentTreeEntry ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    TypeOptional Type_;
    HandleRefOptional HandleRef_;
    ParentHandleRefOptional ParentHandleRef_;
    EntryTypeOptional EntryType_;
    ChildrenCountOptional ChildrenCount_;
  };

  class ClinicalInfo: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Type
    //
    typedef ::CDM::CodedValue TypeType;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeType&
    Type () const;

    TypeType&
    Type ();

    void
    Type (const TypeType& x);

    void
    Type (::std::unique_ptr< TypeType > p);

    // RelatedMeasurement
    //
    typedef ::CDM::Measure RelatedMeasurementType;
    typedef ::xsd::cxx::tree::sequence< RelatedMeasurementType > RelatedMeasurementSequence;
    typedef RelatedMeasurementSequence::iterator RelatedMeasurementIterator;
    typedef RelatedMeasurementSequence::const_iterator RelatedMeasurementConstIterator;
    typedef ::xsd::cxx::tree::traits< RelatedMeasurementType, char > RelatedMeasurementTraits;

    const RelatedMeasurementSequence&
    RelatedMeasurement () const;

    RelatedMeasurementSequence&
    RelatedMeasurement ();

    void
    RelatedMeasurement (const RelatedMeasurementSequence& s);

    // MeasuredValue
    //
    typedef ::xml_schema::Decimal MeasuredValueType;
    typedef ::xsd::cxx::tree::optional< MeasuredValueType > MeasuredValueOptional;
    typedef ::xsd::cxx::tree::traits< MeasuredValueType, char, ::xsd::cxx::tree::schema_type::decimal > MeasuredValueTraits;

    const MeasuredValueOptional&
    MeasuredValue () const;

    MeasuredValueOptional&
    MeasuredValue ();

    void
    MeasuredValue (const MeasuredValueType& x);

    void
    MeasuredValue (const MeasuredValueOptional& x);

    // Constructors.
    //
    ClinicalInfo (const TypeType&);

    ClinicalInfo (::std::unique_ptr< TypeType >);

    ClinicalInfo (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    ClinicalInfo (const ClinicalInfo& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual ClinicalInfo*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ClinicalInfo&
    operator= (const ClinicalInfo& x);

    virtual 
    ~ClinicalInfo ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< TypeType > Type_;
    RelatedMeasurementSequence RelatedMeasurement_;
    MeasuredValueOptional MeasuredValue_;
  };

  class Order: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // VisitNumber
    //
    typedef ::CDM::InstanceIdentifier VisitNumberType;
    typedef ::xsd::cxx::tree::optional< VisitNumberType > VisitNumberOptional;
    typedef ::xsd::cxx::tree::traits< VisitNumberType, char > VisitNumberTraits;

    const VisitNumberOptional&
    VisitNumber () const;

    VisitNumberOptional&
    VisitNumber ();

    void
    VisitNumber (const VisitNumberType& x);

    void
    VisitNumber (const VisitNumberOptional& x);

    void
    VisitNumber (::std::unique_ptr< VisitNumberType > p);

    // PlacerOrderNumber
    //
    typedef ::CDM::InstanceIdentifier PlacerOrderNumberType;
    typedef ::xsd::cxx::tree::traits< PlacerOrderNumberType, char > PlacerOrderNumberTraits;

    const PlacerOrderNumberType&
    PlacerOrderNumber () const;

    PlacerOrderNumberType&
    PlacerOrderNumber ();

    void
    PlacerOrderNumber (const PlacerOrderNumberType& x);

    void
    PlacerOrderNumber (::std::unique_ptr< PlacerOrderNumberType > p);

    // FillerOrderNumber
    //
    typedef ::CDM::InstanceIdentifier FillerOrderNumberType;
    typedef ::xsd::cxx::tree::optional< FillerOrderNumberType > FillerOrderNumberOptional;
    typedef ::xsd::cxx::tree::traits< FillerOrderNumberType, char > FillerOrderNumberTraits;

    const FillerOrderNumberOptional&
    FillerOrderNumber () const;

    FillerOrderNumberOptional&
    FillerOrderNumber ();

    void
    FillerOrderNumber (const FillerOrderNumberType& x);

    void
    FillerOrderNumber (const FillerOrderNumberOptional& x);

    void
    FillerOrderNumber (::std::unique_ptr< FillerOrderNumberType > p);

    // Patient
    //
    typedef ::CDM::PersonReference PatientType;
    typedef ::xsd::cxx::tree::traits< PatientType, char > PatientTraits;

    const PatientType&
    Patient () const;

    PatientType&
    Patient ();

    void
    Patient (const PatientType& x);

    void
    Patient (::std::unique_ptr< PatientType > p);

    // ReferringPhysician
    //
    typedef ::CDM::PersonReference ReferringPhysicianType;
    typedef ::xsd::cxx::tree::optional< ReferringPhysicianType > ReferringPhysicianOptional;
    typedef ::xsd::cxx::tree::traits< ReferringPhysicianType, char > ReferringPhysicianTraits;

    const ReferringPhysicianOptional&
    ReferringPhysician () const;

    ReferringPhysicianOptional&
    ReferringPhysician ();

    void
    ReferringPhysician (const ReferringPhysicianType& x);

    void
    ReferringPhysician (const ReferringPhysicianOptional& x);

    void
    ReferringPhysician (::std::unique_ptr< ReferringPhysicianType > p);

    // RequestingPhysician
    //
    typedef ::CDM::PersonReference RequestingPhysicianType;
    typedef ::xsd::cxx::tree::optional< RequestingPhysicianType > RequestingPhysicianOptional;
    typedef ::xsd::cxx::tree::traits< RequestingPhysicianType, char > RequestingPhysicianTraits;

    const RequestingPhysicianOptional&
    RequestingPhysician () const;

    RequestingPhysicianOptional&
    RequestingPhysician ();

    void
    RequestingPhysician (const RequestingPhysicianType& x);

    void
    RequestingPhysician (const RequestingPhysicianOptional& x);

    void
    RequestingPhysician (::std::unique_ptr< RequestingPhysicianType > p);

    // Reason
    //
    typedef ::CDM::ClinicalInfo ReasonType;
    typedef ::xsd::cxx::tree::sequence< ReasonType > ReasonSequence;
    typedef ReasonSequence::iterator ReasonIterator;
    typedef ReasonSequence::const_iterator ReasonConstIterator;
    typedef ::xsd::cxx::tree::traits< ReasonType, char > ReasonTraits;

    const ReasonSequence&
    Reason () const;

    ReasonSequence&
    Reason ();

    void
    Reason (const ReasonSequence& s);

    // DangerCode
    //
    typedef ::CDM::CodedValue DangerCodeType;
    typedef ::xsd::cxx::tree::sequence< DangerCodeType > DangerCodeSequence;
    typedef DangerCodeSequence::iterator DangerCodeIterator;
    typedef DangerCodeSequence::const_iterator DangerCodeConstIterator;
    typedef ::xsd::cxx::tree::traits< DangerCodeType, char > DangerCodeTraits;

    const DangerCodeSequence&
    DangerCode () const;

    DangerCodeSequence&
    DangerCode ();

    void
    DangerCode (const DangerCodeSequence& s);

    // RelevantClinicalInfo
    //
    typedef ::CDM::ClinicalInfo RelevantClinicalInfoType;
    typedef ::xsd::cxx::tree::sequence< RelevantClinicalInfoType > RelevantClinicalInfoSequence;
    typedef RelevantClinicalInfoSequence::iterator RelevantClinicalInfoIterator;
    typedef RelevantClinicalInfoSequence::const_iterator RelevantClinicalInfoConstIterator;
    typedef ::xsd::cxx::tree::traits< RelevantClinicalInfoType, char > RelevantClinicalInfoTraits;

    const RelevantClinicalInfoSequence&
    RelevantClinicalInfo () const;

    RelevantClinicalInfoSequence&
    RelevantClinicalInfo ();

    void
    RelevantClinicalInfo (const RelevantClinicalInfoSequence& s);

    // ImagingProcedure
    //
    typedef ::CDM::ImagingProcedure ImagingProcedureType;
    typedef ::xsd::cxx::tree::sequence< ImagingProcedureType > ImagingProcedureSequence;
    typedef ImagingProcedureSequence::iterator ImagingProcedureIterator;
    typedef ImagingProcedureSequence::const_iterator ImagingProcedureConstIterator;
    typedef ::xsd::cxx::tree::traits< ImagingProcedureType, char > ImagingProcedureTraits;

    const ImagingProcedureSequence&
    ImagingProcedure () const;

    ImagingProcedureSequence&
    ImagingProcedure ();

    void
    ImagingProcedure (const ImagingProcedureSequence& s);

    // RequestedOrderDetail
    //
    typedef ::CDM::OrderDetail RequestedOrderDetailType;
    typedef ::xsd::cxx::tree::optional< RequestedOrderDetailType > RequestedOrderDetailOptional;
    typedef ::xsd::cxx::tree::traits< RequestedOrderDetailType, char > RequestedOrderDetailTraits;

    const RequestedOrderDetailOptional&
    RequestedOrderDetail () const;

    RequestedOrderDetailOptional&
    RequestedOrderDetail ();

    void
    RequestedOrderDetail (const RequestedOrderDetailType& x);

    void
    RequestedOrderDetail (const RequestedOrderDetailOptional& x);

    void
    RequestedOrderDetail (::std::unique_ptr< RequestedOrderDetailType > p);

    // PerformedOrderDetail
    //
    typedef ::CDM::OrderDetail PerformedOrderDetailType;
    typedef ::xsd::cxx::tree::optional< PerformedOrderDetailType > PerformedOrderDetailOptional;
    typedef ::xsd::cxx::tree::traits< PerformedOrderDetailType, char > PerformedOrderDetailTraits;

    const PerformedOrderDetailOptional&
    PerformedOrderDetail () const;

    PerformedOrderDetailOptional&
    PerformedOrderDetail ();

    void
    PerformedOrderDetail (const PerformedOrderDetailType& x);

    void
    PerformedOrderDetail (const PerformedOrderDetailOptional& x);

    void
    PerformedOrderDetail (::std::unique_ptr< PerformedOrderDetailType > p);

    // Constructors.
    //
    Order (const PlacerOrderNumberType&,
           const PatientType&);

    Order (::std::unique_ptr< PlacerOrderNumberType >,
           ::std::unique_ptr< PatientType >);

    Order (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    Order (const Order& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    virtual Order*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Order&
    operator= (const Order& x);

    virtual 
    ~Order ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    VisitNumberOptional VisitNumber_;
    ::xsd::cxx::tree::one< PlacerOrderNumberType > PlacerOrderNumber_;
    FillerOrderNumberOptional FillerOrderNumber_;
    ::xsd::cxx::tree::one< PatientType > Patient_;
    ReferringPhysicianOptional ReferringPhysician_;
    RequestingPhysicianOptional RequestingPhysician_;
    ReasonSequence Reason_;
    DangerCodeSequence DangerCode_;
    RelevantClinicalInfoSequence RelevantClinicalInfo_;
    ImagingProcedureSequence ImagingProcedure_;
    RequestedOrderDetailOptional RequestedOrderDetail_;
    PerformedOrderDetailOptional PerformedOrderDetail_;
  };

  class OrderDetail: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // Start
    //
    typedef ::xml_schema::DateTime StartType;
    typedef ::xsd::cxx::tree::optional< StartType > StartOptional;
    typedef ::xsd::cxx::tree::traits< StartType, char > StartTraits;

    const StartOptional&
    Start () const;

    StartOptional&
    Start ();

    void
    Start (const StartType& x);

    void
    Start (const StartOptional& x);

    void
    Start (::std::unique_ptr< StartType > p);

    // End
    //
    typedef ::xml_schema::DateTime EndType;
    typedef ::xsd::cxx::tree::optional< EndType > EndOptional;
    typedef ::xsd::cxx::tree::traits< EndType, char > EndTraits;

    const EndOptional&
    End () const;

    EndOptional&
    End ();

    void
    End (const EndType& x);

    void
    End (const EndOptional& x);

    void
    End (::std::unique_ptr< EndType > p);

    // Performer
    //
    typedef ::CDM::PersonParticipation PerformerType;
    typedef ::xsd::cxx::tree::sequence< PerformerType > PerformerSequence;
    typedef PerformerSequence::iterator PerformerIterator;
    typedef PerformerSequence::const_iterator PerformerConstIterator;
    typedef ::xsd::cxx::tree::traits< PerformerType, char > PerformerTraits;

    const PerformerSequence&
    Performer () const;

    PerformerSequence&
    Performer ();

    void
    Performer (const PerformerSequence& s);

    // Service
    //
    typedef ::CDM::CodedValue ServiceType;
    typedef ::xsd::cxx::tree::sequence< ServiceType > ServiceSequence;
    typedef ServiceSequence::iterator ServiceIterator;
    typedef ServiceSequence::const_iterator ServiceConstIterator;
    typedef ::xsd::cxx::tree::traits< ServiceType, char > ServiceTraits;

    const ServiceSequence&
    Service () const;

    ServiceSequence&
    Service ();

    void
    Service (const ServiceSequence& s);

    // Constructors.
    //
    OrderDetail ();

    OrderDetail (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    OrderDetail (const OrderDetail& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual OrderDetail*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    OrderDetail&
    operator= (const OrderDetail& x);

    virtual 
    ~OrderDetail ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    StartOptional Start_;
    EndOptional End_;
    PerformerSequence Performer_;
    ServiceSequence Service_;
  };

  class ImagingProcedure: public ::xml_schema::Type
  {
    public:
    // Extension
    //
    typedef ::CDM::Extension ExtensionType;
    typedef ::xsd::cxx::tree::optional< ExtensionType > ExtensionOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionType, char > ExtensionTraits;

    const ExtensionOptional&
    Extension () const;

    ExtensionOptional&
    Extension ();

    void
    Extension (const ExtensionType& x);

    void
    Extension (const ExtensionOptional& x);

    void
    Extension (::std::unique_ptr< ExtensionType > p);

    // AccessionIdentifier
    //
    typedef ::CDM::InstanceIdentifier AccessionIdentifierType;
    typedef ::xsd::cxx::tree::traits< AccessionIdentifierType, char > AccessionIdentifierTraits;

    const AccessionIdentifierType&
    AccessionIdentifier () const;

    AccessionIdentifierType&
    AccessionIdentifier ();

    void
    AccessionIdentifier (const AccessionIdentifierType& x);

    void
    AccessionIdentifier (::std::unique_ptr< AccessionIdentifierType > p);

    // RequestedProcedureID
    //
    typedef ::CDM::InstanceIdentifier RequestedProcedureIDType;
    typedef ::xsd::cxx::tree::traits< RequestedProcedureIDType, char > RequestedProcedureIDTraits;

    const RequestedProcedureIDType&
    RequestedProcedureID () const;

    RequestedProcedureIDType&
    RequestedProcedureID ();

    void
    RequestedProcedureID (const RequestedProcedureIDType& x);

    void
    RequestedProcedureID (::std::unique_ptr< RequestedProcedureIDType > p);

    // StudyInstanceUID
    //
    typedef ::CDM::InstanceIdentifier StudyInstanceUIDType;
    typedef ::xsd::cxx::tree::traits< StudyInstanceUIDType, char > StudyInstanceUIDTraits;

    const StudyInstanceUIDType&
    StudyInstanceUID () const;

    StudyInstanceUIDType&
    StudyInstanceUID ();

    void
    StudyInstanceUID (const StudyInstanceUIDType& x);

    void
    StudyInstanceUID (::std::unique_ptr< StudyInstanceUIDType > p);

    // ScheduledProcedureStepID
    //
    typedef ::CDM::InstanceIdentifier ScheduledProcedureStepIDType;
    typedef ::xsd::cxx::tree::traits< ScheduledProcedureStepIDType, char > ScheduledProcedureStepIDTraits;

    const ScheduledProcedureStepIDType&
    ScheduledProcedureStepID () const;

    ScheduledProcedureStepIDType&
    ScheduledProcedureStepID ();

    void
    ScheduledProcedureStepID (const ScheduledProcedureStepIDType& x);

    void
    ScheduledProcedureStepID (::std::unique_ptr< ScheduledProcedureStepIDType > p);

    // Modality
    //
    typedef ::CDM::CodedValue ModalityType;
    typedef ::xsd::cxx::tree::optional< ModalityType > ModalityOptional;
    typedef ::xsd::cxx::tree::traits< ModalityType, char > ModalityTraits;

    const ModalityOptional&
    Modality () const;

    ModalityOptional&
    Modality ();

    void
    Modality (const ModalityType& x);

    void
    Modality (const ModalityOptional& x);

    void
    Modality (::std::unique_ptr< ModalityType > p);

    // ProtocolCode
    //
    typedef ::CDM::CodedValue ProtocolCodeType;
    typedef ::xsd::cxx::tree::optional< ProtocolCodeType > ProtocolCodeOptional;
    typedef ::xsd::cxx::tree::traits< ProtocolCodeType, char > ProtocolCodeTraits;

    const ProtocolCodeOptional&
    ProtocolCode () const;

    ProtocolCodeOptional&
    ProtocolCode ();

    void
    ProtocolCode (const ProtocolCodeType& x);

    void
    ProtocolCode (const ProtocolCodeOptional& x);

    void
    ProtocolCode (::std::unique_ptr< ProtocolCodeType > p);

    // Constructors.
    //
    ImagingProcedure (const AccessionIdentifierType&,
                      const RequestedProcedureIDType&,
                      const StudyInstanceUIDType&,
                      const ScheduledProcedureStepIDType&);

    ImagingProcedure (::std::unique_ptr< AccessionIdentifierType >,
                      ::std::unique_ptr< RequestedProcedureIDType >,
                      ::std::unique_ptr< StudyInstanceUIDType >,
                      ::std::unique_ptr< ScheduledProcedureStepIDType >);

    ImagingProcedure (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    ImagingProcedure (const ImagingProcedure& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual ImagingProcedure*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ImagingProcedure&
    operator= (const ImagingProcedure& x);

    virtual 
    ~ImagingProcedure ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ExtensionOptional Extension_;
    ::xsd::cxx::tree::one< AccessionIdentifierType > AccessionIdentifier_;
    ::xsd::cxx::tree::one< RequestedProcedureIDType > RequestedProcedureID_;
    ::xsd::cxx::tree::one< StudyInstanceUIDType > StudyInstanceUID_;
    ::xsd::cxx::tree::one< ScheduledProcedureStepIDType > ScheduledProcedureStepID_;
    ModalityOptional Modality_;
    ProtocolCodeOptional ProtocolCode_;
  };

  class MDIBContainmentTree: public ::CDM::ContainmentTree
  {
    public:
    // Constructors.
    //
    MDIBContainmentTree ();

    MDIBContainmentTree (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    MDIBContainmentTree (const MDIBContainmentTree& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual MDIBContainmentTree*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~MDIBContainmentTree ();
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace CDM
{
  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (const ::std::string& uri,
                  ::xml_schema::Flags f = 0,
                  const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (const ::std::string& uri,
                  ::xml_schema::ErrorHandler& eh,
                  ::xml_schema::Flags f = 0,
                  const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (const ::std::string& uri,
                  ::xercesc::DOMErrorHandler& eh,
                  ::xml_schema::Flags f = 0,
                  const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::std::istream& is,
                  ::xml_schema::Flags f = 0,
                  const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::std::istream& is,
                  ::xml_schema::ErrorHandler& eh,
                  ::xml_schema::Flags f = 0,
                  const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::std::istream& is,
                  ::xercesc::DOMErrorHandler& eh,
                  ::xml_schema::Flags f = 0,
                  const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::std::istream& is,
                  const ::std::string& id,
                  ::xml_schema::Flags f = 0,
                  const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::std::istream& is,
                  const ::std::string& id,
                  ::xml_schema::ErrorHandler& eh,
                  ::xml_schema::Flags f = 0,
                  const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::std::istream& is,
                  const ::std::string& id,
                  ::xercesc::DOMErrorHandler& eh,
                  ::xml_schema::Flags f = 0,
                  const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::xercesc::InputSource& is,
                  ::xml_schema::Flags f = 0,
                  const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::xercesc::InputSource& is,
                  ::xml_schema::ErrorHandler& eh,
                  ::xml_schema::Flags f = 0,
                  const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::xercesc::InputSource& is,
                  ::xercesc::DOMErrorHandler& eh,
                  ::xml_schema::Flags f = 0,
                  const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (const ::xercesc::DOMDocument& d,
                  ::xml_schema::Flags f = 0,
                  const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Uri >
  CodingSystemId (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::Flags f = 0,
                  const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (const ::std::string& uri,
                    ::xml_schema::Flags f = 0,
                    const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (const ::std::string& uri,
                    ::xml_schema::ErrorHandler& eh,
                    ::xml_schema::Flags f = 0,
                    const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (const ::std::string& uri,
                    ::xercesc::DOMErrorHandler& eh,
                    ::xml_schema::Flags f = 0,
                    const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::std::istream& is,
                    ::xml_schema::Flags f = 0,
                    const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::std::istream& is,
                    ::xml_schema::ErrorHandler& eh,
                    ::xml_schema::Flags f = 0,
                    const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::std::istream& is,
                    ::xercesc::DOMErrorHandler& eh,
                    ::xml_schema::Flags f = 0,
                    const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::std::istream& is,
                    const ::std::string& id,
                    ::xml_schema::Flags f = 0,
                    const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::std::istream& is,
                    const ::std::string& id,
                    ::xml_schema::ErrorHandler& eh,
                    ::xml_schema::Flags f = 0,
                    const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::std::istream& is,
                    const ::std::string& id,
                    ::xercesc::DOMErrorHandler& eh,
                    ::xml_schema::Flags f = 0,
                    const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::xercesc::InputSource& is,
                    ::xml_schema::Flags f = 0,
                    const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::xercesc::InputSource& is,
                    ::xml_schema::ErrorHandler& eh,
                    ::xml_schema::Flags f = 0,
                    const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::xercesc::InputSource& is,
                    ::xercesc::DOMErrorHandler& eh,
                    ::xml_schema::Flags f = 0,
                    const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (const ::xercesc::DOMDocument& d,
                    ::xml_schema::Flags f = 0,
                    const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::LocalizedText >
  CodingSystemName (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::Flags f = 0,
                    const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (const ::std::string& uri,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (const ::std::string& uri,
             ::xml_schema::ErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (const ::std::string& uri,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::std::istream& is,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::std::istream& is,
             ::xml_schema::ErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::std::istream& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::ErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::std::istream& is,
             const ::std::string& id,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::xercesc::InputSource& is,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::xercesc::InputSource& is,
             ::xml_schema::ErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::xercesc::InputSource& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (const ::xercesc::DOMDocument& d,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::String >
  VersionId (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (const ::std::string& uri,
          ::xml_schema::Flags f = 0,
          const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (const ::std::string& uri,
          ::xml_schema::ErrorHandler& eh,
          ::xml_schema::Flags f = 0,
          const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (const ::std::string& uri,
          ::xercesc::DOMErrorHandler& eh,
          ::xml_schema::Flags f = 0,
          const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::std::istream& is,
          ::xml_schema::Flags f = 0,
          const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::std::istream& is,
          ::xml_schema::ErrorHandler& eh,
          ::xml_schema::Flags f = 0,
          const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::std::istream& is,
          ::xercesc::DOMErrorHandler& eh,
          ::xml_schema::Flags f = 0,
          const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::std::istream& is,
          const ::std::string& id,
          ::xml_schema::Flags f = 0,
          const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::std::istream& is,
          const ::std::string& id,
          ::xml_schema::ErrorHandler& eh,
          ::xml_schema::Flags f = 0,
          const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::std::istream& is,
          const ::std::string& id,
          ::xercesc::DOMErrorHandler& eh,
          ::xml_schema::Flags f = 0,
          const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::xercesc::InputSource& is,
          ::xml_schema::Flags f = 0,
          const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::xercesc::InputSource& is,
          ::xml_schema::ErrorHandler& eh,
          ::xml_schema::Flags f = 0,
          const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::xercesc::InputSource& is,
          ::xercesc::DOMErrorHandler& eh,
          ::xml_schema::Flags f = 0,
          const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (const ::xercesc::DOMDocument& d,
          ::xml_schema::Flags f = 0,
          const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodeIdentifier >
  CodeId (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::Flags f = 0,
          const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (const ::std::string& uri,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (const ::std::string& uri,
        ::xml_schema::ErrorHandler& eh,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (const ::std::string& uri,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::std::istream& is,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::std::istream& is,
        ::xml_schema::ErrorHandler& eh,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::std::istream& is,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::std::istream& is,
        const ::std::string& id,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::std::istream& is,
        const ::std::string& id,
        ::xml_schema::ErrorHandler& eh,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::std::istream& is,
        const ::std::string& id,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::xercesc::InputSource& is,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::xercesc::InputSource& is,
        ::xml_schema::ErrorHandler& eh,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::xercesc::InputSource& is,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (const ::xercesc::DOMDocument& d,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Type (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (const ::std::string& uri,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (const ::std::string& uri,
        ::xml_schema::ErrorHandler& eh,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (const ::std::string& uri,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::std::istream& is,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::std::istream& is,
        ::xml_schema::ErrorHandler& eh,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::std::istream& is,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::std::istream& is,
        const ::std::string& id,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::std::istream& is,
        const ::std::string& id,
        ::xml_schema::ErrorHandler& eh,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::std::istream& is,
        const ::std::string& id,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::xercesc::InputSource& is,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::xercesc::InputSource& is,
        ::xml_schema::ErrorHandler& eh,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::xercesc::InputSource& is,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (const ::xercesc::DOMDocument& d,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  Unit (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::Flags f = 0,
        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (const ::std::string& uri,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (const ::std::string& uri,
            ::xml_schema::ErrorHandler& eh,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (const ::std::string& uri,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::std::istream& is,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::std::istream& is,
            ::xml_schema::ErrorHandler& eh,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::std::istream& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::ErrorHandler& eh,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::std::istream& is,
            const ::std::string& id,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::xercesc::InputSource& is,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::xercesc::InputSource& is,
            ::xml_schema::ErrorHandler& eh,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::xercesc::InputSource& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (const ::xercesc::DOMDocument& d,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::CodedValue >
  BodySite (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::Flags f = 0,
            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (const ::std::string& uri,
              ::xml_schema::Flags f = 0,
              const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (const ::std::string& uri,
              ::xml_schema::ErrorHandler& eh,
              ::xml_schema::Flags f = 0,
              const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (const ::std::string& uri,
              ::xercesc::DOMErrorHandler& eh,
              ::xml_schema::Flags f = 0,
              const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::std::istream& is,
              ::xml_schema::Flags f = 0,
              const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::std::istream& is,
              ::xml_schema::ErrorHandler& eh,
              ::xml_schema::Flags f = 0,
              const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::std::istream& is,
              ::xercesc::DOMErrorHandler& eh,
              ::xml_schema::Flags f = 0,
              const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::std::istream& is,
              const ::std::string& id,
              ::xml_schema::Flags f = 0,
              const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::std::istream& is,
              const ::std::string& id,
              ::xml_schema::ErrorHandler& eh,
              ::xml_schema::Flags f = 0,
              const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::std::istream& is,
              const ::std::string& id,
              ::xercesc::DOMErrorHandler& eh,
              ::xml_schema::Flags f = 0,
              const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::xercesc::InputSource& is,
              ::xml_schema::Flags f = 0,
              const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::xercesc::InputSource& is,
              ::xml_schema::ErrorHandler& eh,
              ::xml_schema::Flags f = 0,
              const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::xercesc::InputSource& is,
              ::xercesc::DOMErrorHandler& eh,
              ::xml_schema::Flags f = 0,
              const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (const ::xercesc::DOMDocument& d,
              ::xml_schema::Flags f = 0,
              const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::xml_schema::Decimal >
  Resolution (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::Flags f = 0,
              const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (const ::std::string& uri,
                   ::xml_schema::Flags f = 0,
                   const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (const ::std::string& uri,
                   ::xml_schema::ErrorHandler& eh,
                   ::xml_schema::Flags f = 0,
                   const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (const ::std::string& uri,
                   ::xercesc::DOMErrorHandler& eh,
                   ::xml_schema::Flags f = 0,
                   const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::std::istream& is,
                   ::xml_schema::Flags f = 0,
                   const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::std::istream& is,
                   ::xml_schema::ErrorHandler& eh,
                   ::xml_schema::Flags f = 0,
                   const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& eh,
                   ::xml_schema::Flags f = 0,
                   const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::std::istream& is,
                   const ::std::string& id,
                   ::xml_schema::Flags f = 0,
                   const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::std::istream& is,
                   const ::std::string& id,
                   ::xml_schema::ErrorHandler& eh,
                   ::xml_schema::Flags f = 0,
                   const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::std::istream& is,
                   const ::std::string& id,
                   ::xercesc::DOMErrorHandler& eh,
                   ::xml_schema::Flags f = 0,
                   const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::xercesc::InputSource& is,
                   ::xml_schema::Flags f = 0,
                   const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::xercesc::InputSource& is,
                   ::xml_schema::ErrorHandler& eh,
                   ::xml_schema::Flags f = 0,
                   const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::xercesc::InputSource& is,
                   ::xercesc::DOMErrorHandler& eh,
                   ::xml_schema::Flags f = 0,
                   const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (const ::xercesc::DOMDocument& d,
                   ::xml_schema::Flags f = 0,
                   const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricCategory >
  MetricCategory_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::Flags f = 0,
                   const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (const ::std::string& uri,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (const ::std::string& uri,
                ::xml_schema::ErrorHandler& eh,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (const ::std::string& uri,
                ::xercesc::DOMErrorHandler& eh,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::std::istream& is,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::std::istream& is,
                ::xml_schema::ErrorHandler& eh,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::std::istream& is,
                ::xercesc::DOMErrorHandler& eh,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::std::istream& is,
                const ::std::string& id,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::std::istream& is,
                const ::std::string& id,
                ::xml_schema::ErrorHandler& eh,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::std::istream& is,
                const ::std::string& id,
                ::xercesc::DOMErrorHandler& eh,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::xercesc::InputSource& is,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::xercesc::InputSource& is,
                ::xml_schema::ErrorHandler& eh,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::xercesc::InputSource& is,
                ::xercesc::DOMErrorHandler& eh,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (const ::xercesc::DOMDocument& d,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MetricAvailability >
  Availability (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (const ::std::string& uri,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (const ::std::string& uri,
                        ::xml_schema::ErrorHandler& eh,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (const ::std::string& uri,
                        ::xercesc::DOMErrorHandler& eh,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::std::istream& is,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::std::istream& is,
                        ::xml_schema::ErrorHandler& eh,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::std::istream& is,
                        ::xercesc::DOMErrorHandler& eh,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::std::istream& is,
                        const ::std::string& id,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::std::istream& is,
                        const ::std::string& id,
                        ::xml_schema::ErrorHandler& eh,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::std::istream& is,
                        const ::std::string& id,
                        ::xercesc::DOMErrorHandler& eh,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::xercesc::InputSource& is,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::xercesc::InputSource& is,
                        ::xml_schema::ErrorHandler& eh,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::xercesc::InputSource& is,
                        ::xercesc::DOMErrorHandler& eh,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (const ::xercesc::DOMDocument& d,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIBContainmentTree >
  MDIBContainmentTree_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (const ::std::string& uri,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (const ::std::string& uri,
                 ::xml_schema::ErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (const ::std::string& uri,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::std::istream& is,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::std::istream& is,
                 ::xml_schema::ErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::std::istream& is,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::std::istream& is,
                 const ::std::string& id,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::std::istream& is,
                 const ::std::string& id,
                 ::xml_schema::ErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::std::istream& is,
                 const ::std::string& id,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::xercesc::InputSource& is,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::xercesc::InputSource& is,
                 ::xml_schema::ErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::xercesc::InputSource& is,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (const ::xercesc::DOMDocument& d,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::CDM::MDIB >
  MDIBContainer (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace CDM
{
  void
  operator<< (::xercesc::DOMElement&, const Handle&);

  void
  operator<< (::xercesc::DOMAttr&, const Handle&);

  void
  operator<< (::xml_schema::ListStream&,
              const Handle&);

  void
  operator<< (::xercesc::DOMElement&, const HandleRef&);

  void
  operator<< (::xercesc::DOMAttr&, const HandleRef&);

  void
  operator<< (::xml_schema::ListStream&,
              const HandleRef&);

  void
  operator<< (::xercesc::DOMElement&, const Timestamp&);

  void
  operator<< (::xercesc::DOMAttr&, const Timestamp&);

  void
  operator<< (::xml_schema::ListStream&,
              const Timestamp&);

  void
  operator<< (::xercesc::DOMElement&, const VersionCounter&);

  void
  operator<< (::xercesc::DOMAttr&, const VersionCounter&);

  void
  operator<< (::xml_schema::ListStream&,
              const VersionCounter&);

  void
  operator<< (::xercesc::DOMElement&, const ReferencedVersion&);

  void
  operator<< (::xercesc::DOMAttr&, const ReferencedVersion&);

  void
  operator<< (::xml_schema::ListStream&,
              const ReferencedVersion&);

  void
  operator<< (::xercesc::DOMElement&, const Activation&);

  void
  operator<< (::xercesc::DOMAttr&, const Activation&);

  void
  operator<< (::xml_schema::ListStream&,
              const Activation&);

  void
  operator<< (::xercesc::DOMElement&, const CodeIdentifier&);

  void
  operator<< (::xercesc::DOMAttr&, const CodeIdentifier&);

  void
  operator<< (::xml_schema::ListStream&,
              const CodeIdentifier&);

  void
  operator<< (::xercesc::DOMElement&, const LocalizedTextRef&);

  void
  operator<< (::xercesc::DOMAttr&, const LocalizedTextRef&);

  void
  operator<< (::xml_schema::ListStream&,
              const LocalizedTextRef&);

  void
  operator<< (::xercesc::DOMElement&, const LocalizedText&);

  // Serialize to std::ostream.
  //

  void
  CodingSystemId (::std::ostream& os,
                  const ::xml_schema::Uri& x, 
                  const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                  const ::std::string& e = "UTF-8",
                  ::xml_schema::Flags f = 0);

  void
  CodingSystemId (::std::ostream& os,
                  const ::xml_schema::Uri& x, 
                  ::xml_schema::ErrorHandler& eh,
                  const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                  const ::std::string& e = "UTF-8",
                  ::xml_schema::Flags f = 0);

  void
  CodingSystemId (::std::ostream& os,
                  const ::xml_schema::Uri& x, 
                  ::xercesc::DOMErrorHandler& eh,
                  const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                  const ::std::string& e = "UTF-8",
                  ::xml_schema::Flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  CodingSystemId (::xercesc::XMLFormatTarget& ft,
                  const ::xml_schema::Uri& x, 
                  const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                  const ::std::string& e = "UTF-8",
                  ::xml_schema::Flags f = 0);

  void
  CodingSystemId (::xercesc::XMLFormatTarget& ft,
                  const ::xml_schema::Uri& x, 
                  ::xml_schema::ErrorHandler& eh,
                  const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                  const ::std::string& e = "UTF-8",
                  ::xml_schema::Flags f = 0);

  void
  CodingSystemId (::xercesc::XMLFormatTarget& ft,
                  const ::xml_schema::Uri& x, 
                  ::xercesc::DOMErrorHandler& eh,
                  const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                  const ::std::string& e = "UTF-8",
                  ::xml_schema::Flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  CodingSystemId (::xercesc::DOMDocument& d,
                  const ::xml_schema::Uri& x,
                  ::xml_schema::Flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  CodingSystemId (const ::xml_schema::Uri& x, 
                  const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                  ::xml_schema::Flags f = 0);

  // Serialize to std::ostream.
  //

  void
  CodingSystemName (::std::ostream& os,
                    const ::CDM::LocalizedText& x, 
                    const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                    const ::std::string& e = "UTF-8",
                    ::xml_schema::Flags f = 0);

  void
  CodingSystemName (::std::ostream& os,
                    const ::CDM::LocalizedText& x, 
                    ::xml_schema::ErrorHandler& eh,
                    const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                    const ::std::string& e = "UTF-8",
                    ::xml_schema::Flags f = 0);

  void
  CodingSystemName (::std::ostream& os,
                    const ::CDM::LocalizedText& x, 
                    ::xercesc::DOMErrorHandler& eh,
                    const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                    const ::std::string& e = "UTF-8",
                    ::xml_schema::Flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  CodingSystemName (::xercesc::XMLFormatTarget& ft,
                    const ::CDM::LocalizedText& x, 
                    const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                    const ::std::string& e = "UTF-8",
                    ::xml_schema::Flags f = 0);

  void
  CodingSystemName (::xercesc::XMLFormatTarget& ft,
                    const ::CDM::LocalizedText& x, 
                    ::xml_schema::ErrorHandler& eh,
                    const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                    const ::std::string& e = "UTF-8",
                    ::xml_schema::Flags f = 0);

  void
  CodingSystemName (::xercesc::XMLFormatTarget& ft,
                    const ::CDM::LocalizedText& x, 
                    ::xercesc::DOMErrorHandler& eh,
                    const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                    const ::std::string& e = "UTF-8",
                    ::xml_schema::Flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  CodingSystemName (::xercesc::DOMDocument& d,
                    const ::CDM::LocalizedText& x,
                    ::xml_schema::Flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  CodingSystemName (const ::CDM::LocalizedText& x, 
                    const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                    ::xml_schema::Flags f = 0);

  // Serialize to std::ostream.
  //

  void
  VersionId (::std::ostream& os,
             const ::xml_schema::String& x, 
             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::Flags f = 0);

  void
  VersionId (::std::ostream& os,
             const ::xml_schema::String& x, 
             ::xml_schema::ErrorHandler& eh,
             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::Flags f = 0);

  void
  VersionId (::std::ostream& os,
             const ::xml_schema::String& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::Flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  VersionId (::xercesc::XMLFormatTarget& ft,
             const ::xml_schema::String& x, 
             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::Flags f = 0);

  void
  VersionId (::xercesc::XMLFormatTarget& ft,
             const ::xml_schema::String& x, 
             ::xml_schema::ErrorHandler& eh,
             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::Flags f = 0);

  void
  VersionId (::xercesc::XMLFormatTarget& ft,
             const ::xml_schema::String& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
             const ::std::string& e = "UTF-8",
             ::xml_schema::Flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  VersionId (::xercesc::DOMDocument& d,
             const ::xml_schema::String& x,
             ::xml_schema::Flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  VersionId (const ::xml_schema::String& x, 
             const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
             ::xml_schema::Flags f = 0);

  // Serialize to std::ostream.
  //

  void
  CodeId (::std::ostream& os,
          const ::CDM::CodeIdentifier& x, 
          const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
          const ::std::string& e = "UTF-8",
          ::xml_schema::Flags f = 0);

  void
  CodeId (::std::ostream& os,
          const ::CDM::CodeIdentifier& x, 
          ::xml_schema::ErrorHandler& eh,
          const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
          const ::std::string& e = "UTF-8",
          ::xml_schema::Flags f = 0);

  void
  CodeId (::std::ostream& os,
          const ::CDM::CodeIdentifier& x, 
          ::xercesc::DOMErrorHandler& eh,
          const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
          const ::std::string& e = "UTF-8",
          ::xml_schema::Flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  CodeId (::xercesc::XMLFormatTarget& ft,
          const ::CDM::CodeIdentifier& x, 
          const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
          const ::std::string& e = "UTF-8",
          ::xml_schema::Flags f = 0);

  void
  CodeId (::xercesc::XMLFormatTarget& ft,
          const ::CDM::CodeIdentifier& x, 
          ::xml_schema::ErrorHandler& eh,
          const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
          const ::std::string& e = "UTF-8",
          ::xml_schema::Flags f = 0);

  void
  CodeId (::xercesc::XMLFormatTarget& ft,
          const ::CDM::CodeIdentifier& x, 
          ::xercesc::DOMErrorHandler& eh,
          const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
          const ::std::string& e = "UTF-8",
          ::xml_schema::Flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  CodeId (::xercesc::DOMDocument& d,
          const ::CDM::CodeIdentifier& x,
          ::xml_schema::Flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  CodeId (const ::CDM::CodeIdentifier& x, 
          const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
          ::xml_schema::Flags f = 0);

  void
  operator<< (::xercesc::DOMElement&, const InstanceIdentifier&);

  void
  operator<< (::xercesc::DOMElement&, const CodedValue&);

  void
  operator<< (::xercesc::DOMElement&, const CodedWithTranslations&);

  void
  operator<< (::xercesc::DOMElement&, const CauseInfo&);

  void
  operator<< (::xercesc::DOMElement&, const RemedyInfo&);

  void
  operator<< (::xercesc::DOMElement&, const Range&);

  void
  operator<< (::xercesc::DOMElement&, const Measure&);

  void
  operator<< (::xercesc::DOMElement&, const IntendedUse&);

  void
  operator<< (::xercesc::DOMAttr&, const IntendedUse&);

  void
  operator<< (::xml_schema::ListStream&,
              const IntendedUse&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractState&);

  void
  operator<< (::xercesc::DOMElement&, const MDDescription&);

  void
  operator<< (::xercesc::DOMElement&, const MDState&);

  void
  operator<< (::xercesc::DOMElement&, const MDIB&);

  void
  operator<< (::xercesc::DOMElement&, const ProductionSpecification&);

  void
  operator<< (::xercesc::DOMElement&, const SystemMetaData&);

  void
  operator<< (::xercesc::DOMElement&, const SystemContext&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractDeviceComponent&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractMDSDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const HydraMDSDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const ComponentState&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractMDSState&);

  void
  operator<< (::xercesc::DOMElement&, const HydraMDSState&);

  void
  operator<< (::xercesc::DOMElement&, const AlertConditionKind&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertConditionKind&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertConditionKind&);

  void
  operator<< (::xercesc::DOMElement&, const AlertConditionPriority&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertConditionPriority&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertConditionPriority&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSignalManifestation&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertSignalManifestation&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertSignalManifestation&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractAlertDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSystemDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AlertConditionDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSignalDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const LimitAlertConditionDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const PausableActivation&);

  void
  operator<< (::xercesc::DOMAttr&, const PausableActivation&);

  void
  operator<< (::xml_schema::ListStream&,
              const PausableActivation&);

  void
  operator<< (::xercesc::DOMElement&, const SignalPresence&);

  void
  operator<< (::xercesc::DOMAttr&, const SignalPresence&);

  void
  operator<< (::xml_schema::ListStream&,
              const SignalPresence&);

  void
  operator<< (::xercesc::DOMElement&, const PrimaryAlertSignalLocation&);

  void
  operator<< (::xercesc::DOMAttr&, const PrimaryAlertSignalLocation&);

  void
  operator<< (::xml_schema::ListStream&,
              const PrimaryAlertSignalLocation&);

  void
  operator<< (::xercesc::DOMElement&, const MonitoredAlertLimits&);

  void
  operator<< (::xercesc::DOMAttr&, const MonitoredAlertLimits&);

  void
  operator<< (::xml_schema::ListStream&,
              const MonitoredAlertLimits&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractAlertState&);

  void
  operator<< (::xercesc::DOMElement&, const AlertConditionState&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSignalState&);

  void
  operator<< (::xercesc::DOMElement&, const AlertSystemState&);

  void
  operator<< (::xercesc::DOMElement&, const AlertConditionReference&);

  void
  operator<< (::xercesc::DOMAttr&, const AlertConditionReference&);

  void
  operator<< (::xml_schema::ListStream&,
              const AlertConditionReference&);

  void
  operator<< (::xercesc::DOMElement&, const LimitAlertConditionState&);

  void
  operator<< (::xercesc::DOMElement&, const MetricCategory&);

  void
  operator<< (::xercesc::DOMAttr&, const MetricCategory&);

  void
  operator<< (::xml_schema::ListStream&,
              const MetricCategory&);

  void
  operator<< (::xercesc::DOMElement&, const MetricAvailability&);

  void
  operator<< (::xercesc::DOMAttr&, const MetricAvailability&);

  void
  operator<< (::xml_schema::ListStream&,
              const MetricAvailability&);

  // Serialize to std::ostream.
  //

  void
  Type (::std::ostream& os,
        const ::CDM::CodedValue& x, 
        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::Flags f = 0);

  void
  Type (::std::ostream& os,
        const ::CDM::CodedValue& x, 
        ::xml_schema::ErrorHandler& eh,
        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::Flags f = 0);

  void
  Type (::std::ostream& os,
        const ::CDM::CodedValue& x, 
        ::xercesc::DOMErrorHandler& eh,
        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::Flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  Type (::xercesc::XMLFormatTarget& ft,
        const ::CDM::CodedValue& x, 
        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::Flags f = 0);

  void
  Type (::xercesc::XMLFormatTarget& ft,
        const ::CDM::CodedValue& x, 
        ::xml_schema::ErrorHandler& eh,
        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::Flags f = 0);

  void
  Type (::xercesc::XMLFormatTarget& ft,
        const ::CDM::CodedValue& x, 
        ::xercesc::DOMErrorHandler& eh,
        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::Flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  Type (::xercesc::DOMDocument& d,
        const ::CDM::CodedValue& x,
        ::xml_schema::Flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  Type (const ::CDM::CodedValue& x, 
        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
        ::xml_schema::Flags f = 0);

  void
  operator<< (::xercesc::DOMElement&, const VMDDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const ChannelDescriptor&);

  // Serialize to std::ostream.
  //

  void
  Unit (::std::ostream& os,
        const ::CDM::CodedValue& x, 
        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::Flags f = 0);

  void
  Unit (::std::ostream& os,
        const ::CDM::CodedValue& x, 
        ::xml_schema::ErrorHandler& eh,
        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::Flags f = 0);

  void
  Unit (::std::ostream& os,
        const ::CDM::CodedValue& x, 
        ::xercesc::DOMErrorHandler& eh,
        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::Flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  Unit (::xercesc::XMLFormatTarget& ft,
        const ::CDM::CodedValue& x, 
        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::Flags f = 0);

  void
  Unit (::xercesc::XMLFormatTarget& ft,
        const ::CDM::CodedValue& x, 
        ::xml_schema::ErrorHandler& eh,
        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::Flags f = 0);

  void
  Unit (::xercesc::XMLFormatTarget& ft,
        const ::CDM::CodedValue& x, 
        ::xercesc::DOMErrorHandler& eh,
        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::Flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  Unit (::xercesc::DOMDocument& d,
        const ::CDM::CodedValue& x,
        ::xml_schema::Flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  Unit (const ::CDM::CodedValue& x, 
        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
        ::xml_schema::Flags f = 0);

  // Serialize to std::ostream.
  //

  void
  BodySite (::std::ostream& os,
            const ::CDM::CodedValue& x, 
            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::Flags f = 0);

  void
  BodySite (::std::ostream& os,
            const ::CDM::CodedValue& x, 
            ::xml_schema::ErrorHandler& eh,
            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::Flags f = 0);

  void
  BodySite (::std::ostream& os,
            const ::CDM::CodedValue& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::Flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  BodySite (::xercesc::XMLFormatTarget& ft,
            const ::CDM::CodedValue& x, 
            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::Flags f = 0);

  void
  BodySite (::xercesc::XMLFormatTarget& ft,
            const ::CDM::CodedValue& x, 
            ::xml_schema::ErrorHandler& eh,
            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::Flags f = 0);

  void
  BodySite (::xercesc::XMLFormatTarget& ft,
            const ::CDM::CodedValue& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
            const ::std::string& e = "UTF-8",
            ::xml_schema::Flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  BodySite (::xercesc::DOMDocument& d,
            const ::CDM::CodedValue& x,
            ::xml_schema::Flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  BodySite (const ::CDM::CodedValue& x, 
            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
            ::xml_schema::Flags f = 0);

  void
  operator<< (::xercesc::DOMElement&, const AbstractMetricDescriptor&);

  // Serialize to std::ostream.
  //

  void
  Resolution (::std::ostream& os,
              const ::xml_schema::Decimal& x, 
              const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::Flags f = 0);

  void
  Resolution (::std::ostream& os,
              const ::xml_schema::Decimal& x, 
              ::xml_schema::ErrorHandler& eh,
              const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::Flags f = 0);

  void
  Resolution (::std::ostream& os,
              const ::xml_schema::Decimal& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::Flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  Resolution (::xercesc::XMLFormatTarget& ft,
              const ::xml_schema::Decimal& x, 
              const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::Flags f = 0);

  void
  Resolution (::xercesc::XMLFormatTarget& ft,
              const ::xml_schema::Decimal& x, 
              ::xml_schema::ErrorHandler& eh,
              const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::Flags f = 0);

  void
  Resolution (::xercesc::XMLFormatTarget& ft,
              const ::xml_schema::Decimal& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::Flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  Resolution (::xercesc::DOMDocument& d,
              const ::xml_schema::Decimal& x,
              ::xml_schema::Flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  Resolution (const ::xml_schema::Decimal& x, 
              const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
              ::xml_schema::Flags f = 0);

  void
  operator<< (::xercesc::DOMElement&, const NumericMetricDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const StringMetricDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const EnumNomenRef&);

  void
  operator<< (::xercesc::DOMElement&, const EnumStringMetricDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const RealTimeSampleArrayMetricDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const CalibrationState&);

  void
  operator<< (::xercesc::DOMAttr&, const CalibrationState&);

  void
  operator<< (::xml_schema::ListStream&,
              const CalibrationState&);

  void
  operator<< (::xercesc::DOMElement&, const ComponentActivation&);

  void
  operator<< (::xercesc::DOMAttr&, const ComponentActivation&);

  void
  operator<< (::xml_schema::ListStream&,
              const ComponentActivation&);

  void
  operator<< (::xercesc::DOMElement&, const MetricMeasurementValidity&);

  void
  operator<< (::xercesc::DOMAttr&, const MetricMeasurementValidity&);

  void
  operator<< (::xml_schema::ListStream&,
              const MetricMeasurementValidity&);

  void
  operator<< (::xercesc::DOMElement&, const GenerationMode&);

  void
  operator<< (::xercesc::DOMAttr&, const GenerationMode&);

  void
  operator<< (::xml_schema::ListStream&,
              const GenerationMode&);

  void
  operator<< (::xercesc::DOMElement&, const CalibrationInfo&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractMetricState&);

  void
  operator<< (::xercesc::DOMElement&, const NumericMetricState&);

  void
  operator<< (::xercesc::DOMElement&, const RealTimeSampleArrayMetricState&);

  void
  operator<< (::xercesc::DOMElement&, const StringMetricState&);

  void
  operator<< (::xercesc::DOMElement&, const EnumStringMetricState&);

  void
  operator<< (::xercesc::DOMElement&, const QualityIndicator&);

  void
  operator<< (::xercesc::DOMAttr&, const QualityIndicator&);

  void
  operator<< (::xml_schema::ListStream&,
              const QualityIndicator&);

  void
  operator<< (::xercesc::DOMElement&, const MeasurementState&);

  void
  operator<< (::xercesc::DOMElement&, const SampleIndex&);

  void
  operator<< (::xercesc::DOMAttr&, const SampleIndex&);

  void
  operator<< (::xml_schema::ListStream&,
              const SampleIndex&);

  void
  operator<< (::xercesc::DOMElement&, const Annotation&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractMetricValue&);

  void
  operator<< (::xercesc::DOMElement&, const NumericMetricValue&);

  void
  operator<< (::xercesc::DOMElement&, const RealTimeSampleArrayValue&);

  void
  operator<< (::xercesc::DOMElement&, const RTValueType&);

  void
  operator<< (::xercesc::DOMAttr&, const RTValueType&);

  void
  operator<< (::xml_schema::ListStream&,
              const RTValueType&);

  void
  operator<< (::xercesc::DOMElement&, const StringMetricValue&);

  void
  operator<< (::xercesc::DOMElement&, const ArgumentDescriptorType&);

  void
  operator<< (::xercesc::DOMElement&, const SCODescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SetValueOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SetStringOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const ActivateOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const NonGenericOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SetAlertStateOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SetRangeOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const SetContextOperationDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const OperatingMode&);

  void
  operator<< (::xercesc::DOMAttr&, const OperatingMode&);

  void
  operator<< (::xml_schema::ListStream&,
              const OperatingMode&);

  void
  operator<< (::xercesc::DOMElement&, const OperationState&);

  void
  operator<< (::xercesc::DOMElement&, const SetValueOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const SetRangeOperationState&);

  void
  operator<< (::xercesc::DOMElement&, const TimeZone&);

  void
  operator<< (::xercesc::DOMAttr&, const TimeZone&);

  void
  operator<< (::xml_schema::ListStream&,
              const TimeZone&);

  void
  operator<< (::xercesc::DOMElement&, const ClockDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const ClockState&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const LocationContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const EnsembleContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const OperatorContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const WorkflowContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractContextState&);

  void
  operator<< (::xercesc::DOMElement&, const AbstractIdentifiableContextState&);

  void
  operator<< (::xercesc::DOMElement&, const LocationContextState&);

  void
  operator<< (::xercesc::DOMElement&, const EnsembleContextState&);

  void
  operator<< (::xercesc::DOMElement&, const WorkflowContextState&);

  void
  operator<< (::xercesc::DOMElement&, const OperatorContextState&);

  void
  operator<< (::xercesc::DOMElement&, const ContextAssociation&);

  void
  operator<< (::xercesc::DOMAttr&, const ContextAssociation&);

  void
  operator<< (::xml_schema::ListStream&,
              const ContextAssociation&);

  void
  operator<< (::xercesc::DOMElement&, const PatientContextDescriptor&);

  void
  operator<< (::xercesc::DOMElement&, const BaseDemographics&);

  void
  operator<< (::xercesc::DOMElement&, const PatientDemographicsCoreData&);

  void
  operator<< (::xercesc::DOMElement&, const PersonReference&);

  void
  operator<< (::xercesc::DOMElement&, const PersonParticipation&);

  void
  operator<< (::xercesc::DOMElement&, const NeonatalPatientDemographicsCoreData&);

  void
  operator<< (::xercesc::DOMElement&, const PatientContextState&);

  void
  operator<< (::xercesc::DOMElement&, const Sex&);

  void
  operator<< (::xercesc::DOMAttr&, const Sex&);

  void
  operator<< (::xml_schema::ListStream&,
              const Sex&);

  void
  operator<< (::xercesc::DOMElement&, const PatientType&);

  void
  operator<< (::xercesc::DOMAttr&, const PatientType&);

  void
  operator<< (::xml_schema::ListStream&,
              const PatientType&);

  // Serialize to std::ostream.
  //

  void
  MetricCategory_ (::std::ostream& os,
                   const ::CDM::MetricCategory& x, 
                   const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                   const ::std::string& e = "UTF-8",
                   ::xml_schema::Flags f = 0);

  void
  MetricCategory_ (::std::ostream& os,
                   const ::CDM::MetricCategory& x, 
                   ::xml_schema::ErrorHandler& eh,
                   const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                   const ::std::string& e = "UTF-8",
                   ::xml_schema::Flags f = 0);

  void
  MetricCategory_ (::std::ostream& os,
                   const ::CDM::MetricCategory& x, 
                   ::xercesc::DOMErrorHandler& eh,
                   const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                   const ::std::string& e = "UTF-8",
                   ::xml_schema::Flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  MetricCategory_ (::xercesc::XMLFormatTarget& ft,
                   const ::CDM::MetricCategory& x, 
                   const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                   const ::std::string& e = "UTF-8",
                   ::xml_schema::Flags f = 0);

  void
  MetricCategory_ (::xercesc::XMLFormatTarget& ft,
                   const ::CDM::MetricCategory& x, 
                   ::xml_schema::ErrorHandler& eh,
                   const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                   const ::std::string& e = "UTF-8",
                   ::xml_schema::Flags f = 0);

  void
  MetricCategory_ (::xercesc::XMLFormatTarget& ft,
                   const ::CDM::MetricCategory& x, 
                   ::xercesc::DOMErrorHandler& eh,
                   const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                   const ::std::string& e = "UTF-8",
                   ::xml_schema::Flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  MetricCategory_ (::xercesc::DOMDocument& d,
                   const ::CDM::MetricCategory& x,
                   ::xml_schema::Flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  MetricCategory_ (const ::CDM::MetricCategory& x, 
                   const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                   ::xml_schema::Flags f = 0);

  // Serialize to std::ostream.
  //

  void
  Availability (::std::ostream& os,
                const ::CDM::MetricAvailability& x, 
                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                const ::std::string& e = "UTF-8",
                ::xml_schema::Flags f = 0);

  void
  Availability (::std::ostream& os,
                const ::CDM::MetricAvailability& x, 
                ::xml_schema::ErrorHandler& eh,
                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                const ::std::string& e = "UTF-8",
                ::xml_schema::Flags f = 0);

  void
  Availability (::std::ostream& os,
                const ::CDM::MetricAvailability& x, 
                ::xercesc::DOMErrorHandler& eh,
                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                const ::std::string& e = "UTF-8",
                ::xml_schema::Flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  Availability (::xercesc::XMLFormatTarget& ft,
                const ::CDM::MetricAvailability& x, 
                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                const ::std::string& e = "UTF-8",
                ::xml_schema::Flags f = 0);

  void
  Availability (::xercesc::XMLFormatTarget& ft,
                const ::CDM::MetricAvailability& x, 
                ::xml_schema::ErrorHandler& eh,
                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                const ::std::string& e = "UTF-8",
                ::xml_schema::Flags f = 0);

  void
  Availability (::xercesc::XMLFormatTarget& ft,
                const ::CDM::MetricAvailability& x, 
                ::xercesc::DOMErrorHandler& eh,
                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                const ::std::string& e = "UTF-8",
                ::xml_schema::Flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  Availability (::xercesc::DOMDocument& d,
                const ::CDM::MetricAvailability& x,
                ::xml_schema::Flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  Availability (const ::CDM::MetricAvailability& x, 
                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                ::xml_schema::Flags f = 0);

  void
  operator<< (::xercesc::DOMElement&, const ContainmentTree&);

  // Serialize to std::ostream.
  //

  void
  MDIBContainmentTree_ (::std::ostream& os,
                        const ::CDM::MDIBContainmentTree& x, 
                        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::Flags f = 0);

  void
  MDIBContainmentTree_ (::std::ostream& os,
                        const ::CDM::MDIBContainmentTree& x, 
                        ::xml_schema::ErrorHandler& eh,
                        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::Flags f = 0);

  void
  MDIBContainmentTree_ (::std::ostream& os,
                        const ::CDM::MDIBContainmentTree& x, 
                        ::xercesc::DOMErrorHandler& eh,
                        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::Flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  MDIBContainmentTree_ (::xercesc::XMLFormatTarget& ft,
                        const ::CDM::MDIBContainmentTree& x, 
                        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::Flags f = 0);

  void
  MDIBContainmentTree_ (::xercesc::XMLFormatTarget& ft,
                        const ::CDM::MDIBContainmentTree& x, 
                        ::xml_schema::ErrorHandler& eh,
                        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::Flags f = 0);

  void
  MDIBContainmentTree_ (::xercesc::XMLFormatTarget& ft,
                        const ::CDM::MDIBContainmentTree& x, 
                        ::xercesc::DOMErrorHandler& eh,
                        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                        const ::std::string& e = "UTF-8",
                        ::xml_schema::Flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  MDIBContainmentTree_ (::xercesc::DOMDocument& d,
                        const ::CDM::MDIBContainmentTree& x,
                        ::xml_schema::Flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  MDIBContainmentTree_ (const ::CDM::MDIBContainmentTree& x, 
                        const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                        ::xml_schema::Flags f = 0);

  void
  operator<< (::xercesc::DOMElement&, const ContainmentTreeEntry&);

  void
  operator<< (::xercesc::DOMElement&, const ClinicalInfo&);

  void
  operator<< (::xercesc::DOMElement&, const Order&);

  void
  operator<< (::xercesc::DOMElement&, const OrderDetail&);

  void
  operator<< (::xercesc::DOMElement&, const ImagingProcedure&);

  // Serialize to std::ostream.
  //

  void
  MDIBContainer (::std::ostream& os,
                 const ::CDM::MDIB& x, 
                 const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::Flags f = 0);

  void
  MDIBContainer (::std::ostream& os,
                 const ::CDM::MDIB& x, 
                 ::xml_schema::ErrorHandler& eh,
                 const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::Flags f = 0);

  void
  MDIBContainer (::std::ostream& os,
                 const ::CDM::MDIB& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::Flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  MDIBContainer (::xercesc::XMLFormatTarget& ft,
                 const ::CDM::MDIB& x, 
                 const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::Flags f = 0);

  void
  MDIBContainer (::xercesc::XMLFormatTarget& ft,
                 const ::CDM::MDIB& x, 
                 ::xml_schema::ErrorHandler& eh,
                 const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::Flags f = 0);

  void
  MDIBContainer (::xercesc::XMLFormatTarget& ft,
                 const ::CDM::MDIB& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::Flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  MDIBContainer (::xercesc::DOMDocument& d,
                 const ::CDM::MDIB& x,
                 ::xml_schema::Flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  MDIBContainer (const ::CDM::MDIB& x, 
                 const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                 ::xml_schema::Flags f = 0);

  void
  operator<< (::xercesc::DOMElement&, const MDIBContainmentTree&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // BICEPS_DOMAIN_MODEL_HXX
